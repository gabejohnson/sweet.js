define("sweet", [], function() { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(1);
	module.exports = __webpack_require__(77);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.compile = exports.parse = exports.expand = undefined;

	var _shiftReader = __webpack_require__(3);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _immutable = __webpack_require__(11);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _env = __webpack_require__(30);

	var _env2 = _interopRequireDefault(_env);

	var _shiftReducer = __webpack_require__(32);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _parseReducer = __webpack_require__(36);

	var _parseReducer2 = _interopRequireDefault(_parseReducer);

	var _shiftCodegen = __webpack_require__(37);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	var _scope = __webpack_require__(43);

	var _bindingMap = __webpack_require__(14);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _modules = __webpack_require__(45);

	var _babelCore = __webpack_require__(74);

	var _nodeModuleResolver = __webpack_require__(75);

	var _nodeModuleResolver2 = _interopRequireDefault(_nodeModuleResolver);

	var _nodeModuleLoader = __webpack_require__(76);

	var _nodeModuleLoader2 = _interopRequireDefault(_nodeModuleLoader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function expand_758(source_761) {
	  let options_762 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  let bindings_763 = new _bindingMap2.default();
	  let modules_764 = new _modules.Modules({ bindings: bindings_763, cwd: options_762.cwd || process.cwd(), filename: options_762.filename, transform: options_762.transform || _babelCore.transform || function (c_767) {
	      return { code: c_767 };
	    }, moduleResolver: options_762.moduleResolver || _nodeModuleResolver2.default, moduleLoader: options_762.moduleLoader || _nodeModuleLoader2.default });
	  let compiledMod_765 = modules_764.compileEntrypoint(source_761, options_762.filename, options_762.enforcePragma);
	  let nativeImports_766 = compiledMod_765.importEntries.filter(imp_768 => !modules_764.has(imp_768.moduleSpecifier.val()));
	  return new _terms2.default("Module", { directives: (0, _immutable.List)(), items: nativeImports_766.concat(compiledMod_765.body).concat(compiledMod_765.exportEntries.interpose(new _terms2.default("EmptyStatement", {}))) });
	}
	function parse_759(source_769, options_770) {
	  let includeImports_771 = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

	  return (0, _shiftReducer2.default)(new _parseReducer2.default({ phase: 0 }), expand_758(source_769, options_770).gen({ includeImports: includeImports_771 }));
	}
	function compile_760(source_772) {
	  let options_773 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  let ast_774 = parse_759(source_772, options_773, options_773.includeImports);
	  let gen_775 = (0, _shiftCodegen2.default)(ast_774, new _shiftCodegen.FormattedCodeGen());
	  return options_773.transform && !options_773.noBabel ? options_773.transform(gen_775, { babelrc: true, filename: options_773.filename }) : { code: gen_775 };
	}
	exports.expand = expand_758;
	exports.parse = parse_759;
	exports.compile = compile_760;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N3ZWV0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBQ0EsU0FBUyxVQUFULENBQW9CLFVBQXBCLEVBQWtEO0FBQUEsTUFBbEIsV0FBa0IseURBQUosRUFBSTs7QUFDaEQsTUFBSSxlQUFlLDBCQUFuQjtBQUNBLE1BQUksY0FBYyxxQkFBWSxFQUFDLFVBQVUsWUFBWCxFQUF5QixLQUFLLFlBQVksR0FBWixJQUFtQixRQUFRLEdBQVIsRUFBakQsRUFBZ0UsVUFBVSxZQUFZLFFBQXRGLEVBQWdHLFdBQVcsWUFBWSxTQUFaLDRCQUEyQyxVQUFVLEtBQVYsRUFBaUI7QUFDbk0sYUFBTyxFQUFDLE1BQU0sS0FBUCxFQUFQO0FBQ0QsS0FGNkIsRUFFM0IsZ0JBQWdCLFlBQVksY0FBWixnQ0FGVyxFQUVpQyxjQUFjLFlBQVksWUFBWiw4QkFGL0MsRUFBWixDQUFsQjtBQUdBLE1BQUksa0JBQWtCLFlBQVksaUJBQVosQ0FBOEIsVUFBOUIsRUFBMEMsWUFBWSxRQUF0RCxFQUFnRSxZQUFZLGFBQTVFLENBQXRCO0FBQ0EsTUFBSSxvQkFBb0IsZ0JBQWdCLGFBQWhCLENBQThCLE1BQTlCLENBQXFDLFdBQVcsQ0FBQyxZQUFZLEdBQVosQ0FBZ0IsUUFBUSxlQUFSLENBQXdCLEdBQXhCLEVBQWhCLENBQWpELENBQXhCO0FBQ0EsU0FBTyxvQkFBUyxRQUFULEVBQW1CLEVBQUMsWUFBWSxzQkFBYixFQUFxQixPQUFPLGtCQUFrQixNQUFsQixDQUF5QixnQkFBZ0IsSUFBekMsRUFBK0MsTUFBL0MsQ0FBc0QsZ0JBQWdCLGFBQWhCLENBQThCLFNBQTlCLENBQXdDLG9CQUFTLGdCQUFULEVBQTJCLEVBQTNCLENBQXhDLENBQXRELENBQTVCLEVBQW5CLENBQVA7QUFDRDtBQUNELFNBQVMsU0FBVCxDQUFtQixVQUFuQixFQUErQixXQUEvQixFQUF1RTtBQUFBLE1BQTNCLGtCQUEyQix5REFBTixJQUFNOztBQUNyRSxTQUFPLDRCQUFPLDJCQUFpQixFQUFDLE9BQU8sQ0FBUixFQUFqQixDQUFQLEVBQXFDLFdBQVcsVUFBWCxFQUF1QixXQUF2QixFQUFvQyxHQUFwQyxDQUF3QyxFQUFDLGdCQUFnQixrQkFBakIsRUFBeEMsQ0FBckMsQ0FBUDtBQUNEO0FBQ0QsU0FBUyxXQUFULENBQXFCLFVBQXJCLEVBQW1EO0FBQUEsTUFBbEIsV0FBa0IseURBQUosRUFBSTs7QUFDakQsTUFBSSxVQUFVLFVBQVUsVUFBVixFQUFzQixXQUF0QixFQUFtQyxZQUFZLGNBQS9DLENBQWQ7QUFDQSxNQUFJLFVBQVUsNEJBQVEsT0FBUixFQUFpQixvQ0FBakIsQ0FBZDtBQUNBLFNBQU8sWUFBWSxTQUFaLElBQXlCLENBQUMsWUFBWSxPQUF0QyxHQUFnRCxZQUFZLFNBQVosQ0FBc0IsT0FBdEIsRUFBK0IsRUFBQyxTQUFTLElBQVYsRUFBZ0IsVUFBVSxZQUFZLFFBQXRDLEVBQS9CLENBQWhELEdBQWtJLEVBQUMsTUFBTSxPQUFQLEVBQXpJO0FBQ0Q7UUFDcUIsTSxHQUFkLFU7UUFDYSxLLEdBQWIsUztRQUNlLE8sR0FBZixXIiwiZmlsZSI6InN3ZWV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWRlciBmcm9tIFwiLi9zaGlmdC1yZWFkZXJcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IFN5bnRheCBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCBFbnYgZnJvbSBcIi4vZW52XCI7XG5pbXBvcnQgcmVkdWNlIGZyb20gXCJzaGlmdC1yZWR1Y2VyXCI7XG5pbXBvcnQgUGFyc2VSZWR1Y2VyIGZyb20gXCIuL3BhcnNlLXJlZHVjZXJcIjtcbmltcG9ydCBjb2RlZ2VuLCB7Rm9ybWF0dGVkQ29kZUdlbn0gZnJvbSBcInNoaWZ0LWNvZGVnZW5cIjtcbmltcG9ydCB7U2NvcGUsIGZyZXNoU2NvcGV9IGZyb20gXCIuL3Njb3BlXCI7XG5pbXBvcnQgQmluZGluZ01hcCBmcm9tIFwiLi9iaW5kaW5nLW1hcC5qc1wiO1xuaW1wb3J0IFRlcm0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7TW9kdWxlc30gZnJvbSBcIi4vbW9kdWxlc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm0gYXMgYmFiZWxUcmFuc2Zvcm19IGZyb20gXCJiYWJlbC1jb3JlXCI7XG5pbXBvcnQgbm9kZVJlc29sdmVyIGZyb20gXCIuL25vZGUtbW9kdWxlLXJlc29sdmVyXCI7XG5pbXBvcnQgbm9kZUxvYWRlciBmcm9tIFwiLi9ub2RlLW1vZHVsZS1sb2FkZXJcIjtcbmZ1bmN0aW9uIGV4cGFuZF83NTgoc291cmNlXzc2MSwgb3B0aW9uc183NjIgPSB7fSkge1xuICBsZXQgYmluZGluZ3NfNzYzID0gbmV3IEJpbmRpbmdNYXA7XG4gIGxldCBtb2R1bGVzXzc2NCA9IG5ldyBNb2R1bGVzKHtiaW5kaW5nczogYmluZGluZ3NfNzYzLCBjd2Q6IG9wdGlvbnNfNzYyLmN3ZCB8fCBwcm9jZXNzLmN3ZCgpLCBmaWxlbmFtZTogb3B0aW9uc183NjIuZmlsZW5hbWUsIHRyYW5zZm9ybTogb3B0aW9uc183NjIudHJhbnNmb3JtIHx8IGJhYmVsVHJhbnNmb3JtIHx8IGZ1bmN0aW9uIChjXzc2Nykge1xuICAgIHJldHVybiB7Y29kZTogY183Njd9O1xuICB9LCBtb2R1bGVSZXNvbHZlcjogb3B0aW9uc183NjIubW9kdWxlUmVzb2x2ZXIgfHwgbm9kZVJlc29sdmVyLCBtb2R1bGVMb2FkZXI6IG9wdGlvbnNfNzYyLm1vZHVsZUxvYWRlciB8fCBub2RlTG9hZGVyfSk7XG4gIGxldCBjb21waWxlZE1vZF83NjUgPSBtb2R1bGVzXzc2NC5jb21waWxlRW50cnlwb2ludChzb3VyY2VfNzYxLCBvcHRpb25zXzc2Mi5maWxlbmFtZSwgb3B0aW9uc183NjIuZW5mb3JjZVByYWdtYSk7XG4gIGxldCBuYXRpdmVJbXBvcnRzXzc2NiA9IGNvbXBpbGVkTW9kXzc2NS5pbXBvcnRFbnRyaWVzLmZpbHRlcihpbXBfNzY4ID0+ICFtb2R1bGVzXzc2NC5oYXMoaW1wXzc2OC5tb2R1bGVTcGVjaWZpZXIudmFsKCkpKTtcbiAgcmV0dXJuIG5ldyBUZXJtKFwiTW9kdWxlXCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIGl0ZW1zOiBuYXRpdmVJbXBvcnRzXzc2Ni5jb25jYXQoY29tcGlsZWRNb2RfNzY1LmJvZHkpLmNvbmNhdChjb21waWxlZE1vZF83NjUuZXhwb3J0RW50cmllcy5pbnRlcnBvc2UobmV3IFRlcm0oXCJFbXB0eVN0YXRlbWVudFwiLCB7fSkpKX0pO1xufVxuZnVuY3Rpb24gcGFyc2VfNzU5KHNvdXJjZV83NjksIG9wdGlvbnNfNzcwLCBpbmNsdWRlSW1wb3J0c183NzEgPSB0cnVlKSB7XG4gIHJldHVybiByZWR1Y2UobmV3IFBhcnNlUmVkdWNlcih7cGhhc2U6IDB9KSwgZXhwYW5kXzc1OChzb3VyY2VfNzY5LCBvcHRpb25zXzc3MCkuZ2VuKHtpbmNsdWRlSW1wb3J0czogaW5jbHVkZUltcG9ydHNfNzcxfSkpO1xufVxuZnVuY3Rpb24gY29tcGlsZV83NjAoc291cmNlXzc3Miwgb3B0aW9uc183NzMgPSB7fSkge1xuICBsZXQgYXN0Xzc3NCA9IHBhcnNlXzc1OShzb3VyY2VfNzcyLCBvcHRpb25zXzc3Mywgb3B0aW9uc183NzMuaW5jbHVkZUltcG9ydHMpO1xuICBsZXQgZ2VuXzc3NSA9IGNvZGVnZW4oYXN0Xzc3NCwgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICByZXR1cm4gb3B0aW9uc183NzMudHJhbnNmb3JtICYmICFvcHRpb25zXzc3My5ub0JhYmVsID8gb3B0aW9uc183NzMudHJhbnNmb3JtKGdlbl83NzUsIHtiYWJlbHJjOiB0cnVlLCBmaWxlbmFtZTogb3B0aW9uc183NzMuZmlsZW5hbWV9KSA6IHtjb2RlOiBnZW5fNzc1fTtcbn1cbmV4cG9ydCB7ZXhwYW5kXzc1OCBhcyBleHBhbmR9O1xuZXhwb3J0IHtwYXJzZV83NTkgYXMgcGFyc2V9O1xuZXhwb3J0IHtjb21waWxlXzc2MCBhcyBjb21waWxlfSJdfQ==
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _tokenizer = __webpack_require__(4);

	var _tokenizer2 = _interopRequireDefault(_tokenizer);

	var _immutable = __webpack_require__(11);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramdaFantasy = __webpack_require__(15);

	var _errors = __webpack_require__(13);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _ramda = __webpack_require__(27);

	var R = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const Just_623 = _ramdaFantasy.Maybe.Just;
	const Nothing_624 = _ramdaFantasy.Maybe.Nothing;
	const LSYNTAX_625 = { name: "left-syntax" };
	const RSYNTAX_626 = { name: "right-syntax" };
	const AT_627 = { klass: _tokenizer.TokenClass.Punctuator, name: "@" };
	const literalKeywords_628 = ["this", "null", "true", "false"];
	const isLeftBracket_629 = R.whereEq({ type: _tokenizer.TokenType.LBRACK });
	const isLeftBrace_630 = R.whereEq({ type: _tokenizer.TokenType.LBRACE });
	const isLeftParen_631 = R.whereEq({ type: _tokenizer.TokenType.LPAREN });
	const isRightBracket_632 = R.whereEq({ type: _tokenizer.TokenType.RBRACK });
	const isRightBrace_633 = R.whereEq({ type: _tokenizer.TokenType.RBRACE });
	const isRightParen_634 = R.whereEq({ type: _tokenizer.TokenType.RPAREN });
	const isEOS_635 = R.whereEq({ type: _tokenizer.TokenType.EOS });
	const isHash_636 = R.whereEq({ type: _tokenizer.TokenType.IDENTIFIER, value: "#" });
	const isLeftSyntax_637 = R.whereEq({ type: LSYNTAX_625 });
	const isRightSyntax_638 = R.whereEq({ type: RSYNTAX_626 });
	const isLeftDelimiter_639 = R.anyPass([isLeftBracket_629, isLeftBrace_630, isLeftParen_631, isLeftSyntax_637]);
	const isRightDelimiter_640 = R.anyPass([isRightBracket_632, isRightBrace_633, isRightParen_634, isRightSyntax_638]);
	const isMatchingDelimiters_641 = R.cond([[isLeftBracket_629, (__682, b_683) => isRightBracket_632(b_683)], [isLeftBrace_630, (__684, b_685) => isRightBrace_633(b_685)], [isLeftParen_631, (__686, b_687) => isRightParen_634(b_687)], [isLeftSyntax_637, (__688, b_689) => isRightSyntax_638(b_689)], [R.T, R.F]]);
	const assignOps_642 = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","];
	const binaryOps_643 = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"];
	const unaryOps_644 = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"];
	const isEmpty_645 = R.whereEq({ size: 0 });
	const isPunctuator_646 = s_690 => s_690.match("punctuator");
	const isKeyword_647 = s_691 => s_691.match("keyword");
	const isDelimiter_648 = s_692 => s_692.match("delimiter");
	const isParens_649 = s_693 => s_693.match("parens");
	const isBraces_650 = s_694 => s_694.match("braces");
	const isBrackets_651 = s_695 => s_695.match("brackets");
	const isIdentifier_652 = s_696 => s_696.match("identifier");
	const val_653 = s_697 => s_697.val();
	const isVal_654 = R.curry((v_698, s_699) => s_699.val() === v_698);
	const isDot_655 = R.allPass([isPunctuator_646, isVal_654(".")]);
	const isColon_656 = R.allPass([isPunctuator_646, isVal_654(":")]);
	const isFunctionKeyword_657 = R.allPass([isKeyword_647, isVal_654("function")]);
	const isOperator_658 = s_700 => (s_700.match("punctuator") || s_700.match("keyword")) && R.any(R.equals(s_700.val()), assignOps_642.concat(binaryOps_643).concat(unaryOps_644));
	const isNonLiteralKeyword_659 = R.allPass([isKeyword_647, s_701 => R.none(R.equals(s_701.val()), literalKeywords_628)]);
	const isKeywordExprPrefix_660 = R.allPass([isKeyword_647, s_702 => R.any(R.equals(s_702.val()), ["instanceof", "typeof", "delete", "void", "yield", "throw", "new", "case"])]);
	let last_661 = p_703 => p_703.last();
	let safeLast_662 = R.pipe(R.cond([[isEmpty_645, R.always(Nothing_624())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last_661)]]));
	let stuffTrue_663 = R.curry((p_704, b_705) => b_705 ? Just_623(p_704) : Nothing_624());
	let stuffFalse_664 = R.curry((p_706, b_707) => !b_707 ? Just_623(p_706) : Nothing_624());
	let isTopColon_665 = R.pipe(safeLast_662, R.map(isColon_656), _ramdaFantasy.Maybe.maybe(false, R.identity));
	let isTopPunctuator_666 = R.pipe(safeLast_662, R.map(isPunctuator_646), _ramdaFantasy.Maybe.maybe(false, R.identity));
	let isExprReturn_667 = R.curry((l_708, p_709) => {
	  let retKwd_710 = safeLast_662(p_709);
	  let maybeDot_711 = pop_678(p_709).chain(safeLast_662);
	  if (maybeDot_711.map(isDot_655).getOrElse(false)) {
	    return true;
	  }
	  return retKwd_710.map(s_712 => {
	    return s_712.match("keyword") && s_712.val() === "return" && s_712.lineNumber() === l_708;
	  }).getOrElse(false);
	});
	const isTopOperator_668 = R.pipe(safeLast_662, R.map(isOperator_658), _ramdaFantasy.Maybe.maybe(false, R.identity));
	const isTopKeywordExprPrefix_669 = R.pipe(safeLast_662, R.map(isKeywordExprPrefix_660), _ramdaFantasy.Maybe.maybe(false, R.identity));
	let isExprPrefix_670 = R.curry((l_713, b_714) => R.cond([[isEmpty_645, R.always(b_714)], [isTopColon_665, R.always(b_714)], [isTopKeywordExprPrefix_669, R.T], [isTopOperator_668, R.T], [isTopPunctuator_666, R.always(b_714)], [isExprReturn_667(l_713), R.T], [R.T, R.F]]));
	let curly_671 = p_715 => safeLast_662(p_715).map(isBraces_650).chain(stuffTrue_663(p_715));
	let paren_672 = p_716 => safeLast_662(p_716).map(isParens_649).chain(stuffTrue_663(p_716));
	let func_673 = p_717 => safeLast_662(p_717).map(isFunctionKeyword_657).chain(stuffTrue_663(p_717));
	let ident_674 = p_718 => safeLast_662(p_718).map(isIdentifier_652).chain(stuffTrue_663(p_718));
	let nonLiteralKeyword_675 = p_719 => safeLast_662(p_719).map(isNonLiteralKeyword_659).chain(stuffTrue_663(p_719));
	let opt_676 = R.curry((a_720, b_721, p_722) => {
	  let result_723 = R.pipeK(a_720, b_721)(_ramdaFantasy.Maybe.of(p_722));
	  return _ramdaFantasy.Maybe.isJust(result_723) ? result_723 : _ramdaFantasy.Maybe.of(p_722);
	});
	let notDot_677 = R.ifElse(R.whereEq({ size: 0 }), Just_623, p_724 => safeLast_662(p_724).map(s_725 => !(s_725.match("punctuator") && s_725.val() === ".")).chain(stuffTrue_663(p_724)));
	let pop_678 = R.compose(Just_623, p_726 => p_726.pop());
	const functionPrefix_679 = R.pipeK(curly_671, pop_678, paren_672, pop_678, opt_676(ident_674, pop_678), func_673);
	const isRegexPrefix_680 = b_727 => R.anyPass([isEmpty_645, isTopPunctuator_666, R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword_675, pop_678, notDot_677), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren_672, pop_678, nonLiteralKeyword_675, pop_678, notDot_677), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, functionPrefix_679, R.chain(p_728 => {
	  return safeLast_662(p_728).map(s_729 => s_729.lineNumber()).chain(fnLine_730 => {
	    return pop_678(p_728).map(isExprPrefix_670(fnLine_730, b_727));
	  }).chain(stuffFalse_664(p_728));
	}), _ramdaFantasy.Maybe.isJust), p_731 => {
	  let isCurly_732 = _ramdaFantasy.Maybe.isJust(safeLast_662(p_731).map(isBraces_650));
	  let alreadyCheckedFunction_733 = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix_679, _ramdaFantasy.Maybe.isJust)(p_731);
	  if (alreadyCheckedFunction_733) {
	    return false;
	  }
	  return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly_671), R.chain(p_734 => {
	    return safeLast_662(p_734).map(s_735 => s_735.lineNumber()).chain(curlyLine_736 => {
	      return pop_678(p_734).map(isExprPrefix_670(curlyLine_736, b_727));
	    }).chain(stuffFalse_664(p_734));
	  }), _ramdaFantasy.Maybe.isJust)(p_731);
	}]);
	function lastEl_681(l_737) {
	  return l_737[l_737.length - 1];
	}
	class Reader extends _tokenizer2.default {
	  constructor(strings_738, context_739, replacements_740) {
	    super(Array.isArray(strings_738) ? strings_738.join("") : strings_738);
	    this.delimStack = new Map();
	    this.insideSyntaxTemplate = [false];
	    this.context = context_739;
	    if (Array.isArray(strings_738)) {
	      let totalIndex = 0;
	      this.replacementIndex = R.reduce((acc_741, strRep_742) => {
	        acc_741.push({ index: totalIndex + strRep_742[0].length, replacement: strRep_742[1] });
	        totalIndex += strRep_742[0].length;
	        return acc_741;
	      }, [], R.zip(strings_738, replacements_740));
	    }
	  }
	  read() {
	    let stack_743 = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    let b_744 = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    let singleDelimiter_745 = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	    let prefix_746 = (0, _immutable.List)();
	    while (true) {
	      let tok = this.advance(prefix_746, b_744);
	      if (tok instanceof _syntax2.default || tok instanceof _terms2.default) {
	        stack_743.push(tok);
	        continue;
	      }
	      if (Array.isArray(tok)) {
	        Array.prototype.push.apply(stack_743, tok);
	        continue;
	      }
	      if (_immutable.List.isList(tok)) {
	        Array.prototype.push.apply(stack_743, tok.toArray());
	        continue;
	      }
	      if (isEOS_635(tok)) {
	        if (stack_743[0] && isLeftDelimiter_639(stack_743[0].token)) {
	          throw this.createUnexpected(tok);
	        }
	        break;
	      }
	      if (isLeftDelimiter_639(tok)) {
	        if (isLeftSyntax_637(tok)) {
	          this.insideSyntaxTemplate.push(true);
	        }
	        let line = tok.slice.startLocation.line;
	        let innerB = isLeftBrace_630(tok) ? isExprPrefix_670(line, b_744)(prefix_746) : true;
	        let inner = this.read([new _syntax2.default(tok, this.context)], innerB, false);
	        let stx = new _syntax2.default(inner, this.context);
	        prefix_746 = prefix_746.concat(stx);
	        stack_743.push(stx);
	        if (singleDelimiter_745) {
	          break;
	        }
	      } else if (isRightDelimiter_640(tok)) {
	        if (stack_743[0] && !isMatchingDelimiters_641(stack_743[0].token, tok)) {
	          throw this.createUnexpected(tok);
	        }
	        let stx = new _syntax2.default(tok, this.context);
	        stack_743.push(stx);
	        if (lastEl_681(this.insideSyntaxTemplate) && isRightSyntax_638(tok)) {
	          this.insideSyntaxTemplate.pop();
	        }
	        break;
	      } else {
	        let stx = new _syntax2.default(tok, this.context);
	        prefix_746 = prefix_746.concat(stx);
	        stack_743.push(stx);
	      }
	    }
	    return (0, _immutable.List)(stack_743);
	  }
	  advance(prefix_747, b_748) {
	    let startLocation_749 = this.getLocation();
	    this.lastIndex = this.index;
	    this.lastLine = this.line;
	    this.lastLineStart = this.lineStart;
	    this.skipComment();
	    this.startIndex = this.index;
	    this.startLine = this.line;
	    this.startLineStart = this.lineStart;
	    if (this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
	      let rep = this.replacementIndex[0].replacement;
	      this.replacementIndex.shift();
	      return rep;
	    }
	    let charCode_750 = this.source.charCodeAt(this.index);
	    if (charCode_750 === 96) {
	      let element,
	          items = [];
	      let startLocation_749 = this.getLocation();
	      let start = this.index;
	      this.index++;
	      if (lastEl_681(this.insideSyntaxTemplate)) {
	        let slice = this.getSlice(start, startLocation_749);
	        return { type: RSYNTAX_626, value: "`", slice: slice };
	      }
	      do {
	        element = this.scanTemplateElement();
	        items.push(element);
	        if (element.interp) {
	          element = this.read([], false, true);
	          (0, _errors.assert)(element.size === 1, "should only have read a single delimiter inside a template");
	          items.push(element.get(0));
	        }
	      } while (!element.tail);
	      return { type: _tokenizer.TokenType.TEMPLATE, items: (0, _immutable.List)(items) };
	    } else if (charCode_750 === 35) {
	      let startLocation_749 = this.getLocation();
	      let start = this.index;
	      let slice = this.getSlice(start, startLocation_749);
	      this.index++;
	      if (this.source.charCodeAt(this.index) === 96) {
	        this.index++;
	        return { type: LSYNTAX_625, value: "#`", slice: slice };
	      }
	      return { type: _tokenizer.TokenType.IDENTIFIER, value: "#", slice: slice };
	    } else if (charCode_750 === 64) {
	      let startLocation_749 = this.getLocation();
	      let start = this.index;
	      let slice = this.getSlice(start, startLocation_749);
	      this.index++;
	      return { type: AT_627, value: "@", slice: slice };
	    }
	    let lookahead_751 = super.advance();
	    if (lookahead_751.type === _tokenizer.TokenType.DIV && isRegexPrefix_680(b_748)(prefix_747)) {
	      return super.scanRegExp("/");
	    }
	    return lookahead_751;
	  }
	  scanTemplateElement() {
	    let startLocation_752 = this.getLocation();
	    let start_753 = this.index;
	    while (this.index < this.source.length) {
	      let ch = this.source.charCodeAt(this.index);
	      switch (ch) {
	        case 96:
	          let slice = this.getSlice(start_753, startLocation_752);
	          this.index++;
	          return { type: _tokenizer.TokenType.TEMPLATE, tail: true, interp: false, slice: slice };
	        case 36:
	          if (this.source.charCodeAt(this.index + 1) === 123) {
	            let slice = this.getSlice(start_753, startLocation_752);
	            this.index += 1;
	            return { type: _tokenizer.TokenType.TEMPLATE, tail: false, interp: true, slice: slice };
	          }
	          this.index++;
	          break;
	        case 92:
	          {
	            let octal = this.scanStringEscape("", null)[1];
	            if (octal != null) {
	              throw this.createILLEGAL();
	            }
	            break;
	          }
	        default:
	          this.index++;
	      }
	    }
	    throw this.createILLEGAL();
	  }
	}
	exports.default = Reader;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3NoaWZ0LXJlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDYixNQUFNLFdBQVcsb0JBQU0sSUFBdkI7QUFDQSxNQUFNLGNBQWMsb0JBQU0sT0FBMUI7QUFDQSxNQUFNLGNBQWMsRUFBQyxNQUFNLGFBQVAsRUFBcEI7QUFDQSxNQUFNLGNBQWMsRUFBQyxNQUFNLGNBQVAsRUFBcEI7QUFDQSxNQUFNLFNBQVMsRUFBQyxPQUFPLHNCQUFXLFVBQW5CLEVBQStCLE1BQU0sR0FBckMsRUFBZjtBQUNBLE1BQU0sc0JBQXNCLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUIsT0FBekIsQ0FBNUI7QUFDQSxNQUFNLG9CQUFvQixFQUFFLE9BQUYsQ0FBVSxFQUFDLE1BQU0scUJBQVUsTUFBakIsRUFBVixDQUExQjtBQUNBLE1BQU0sa0JBQWtCLEVBQUUsT0FBRixDQUFVLEVBQUMsTUFBTSxxQkFBVSxNQUFqQixFQUFWLENBQXhCO0FBQ0EsTUFBTSxrQkFBa0IsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLE1BQWpCLEVBQVYsQ0FBeEI7QUFDQSxNQUFNLHFCQUFxQixFQUFFLE9BQUYsQ0FBVSxFQUFDLE1BQU0scUJBQVUsTUFBakIsRUFBVixDQUEzQjtBQUNBLE1BQU0sbUJBQW1CLEVBQUUsT0FBRixDQUFVLEVBQUMsTUFBTSxxQkFBVSxNQUFqQixFQUFWLENBQXpCO0FBQ0EsTUFBTSxtQkFBbUIsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLE1BQWpCLEVBQVYsQ0FBekI7QUFDQSxNQUFNLFlBQVksRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLEdBQWpCLEVBQVYsQ0FBbEI7QUFDQSxNQUFNLGFBQWEsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLFVBQWpCLEVB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LEVBQUw7QUFDRTtBQUNFLGdCQUFJLFFBQVEsS0FBSyxnQkFBTCxDQUFzQixFQUF0QixFQUEwQixJQUExQixFQUFnQyxDQUFoQyxDQUFaO0FBQ0EsZ0JBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLG9CQUFNLEtBQUssYUFBTCxFQUFOO0FBQ0Q7QUFDRDtBQUNEO0FBQ0g7QUFDRSxlQUFLLEtBQUw7QUF0Qko7QUF3QkQ7QUFDRCxVQUFNLEtBQUssYUFBTCxFQUFOO0FBQ0Q7QUE1SjJDO2tCQUF6QixNIiwiZmlsZSI6InNoaWZ0LXJlYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUb2tlbml6ZXIgZnJvbSBcInNoaWZ0LXBhcnNlci9kaXN0L3Rva2VuaXplclwiO1xuaW1wb3J0IHtUb2tlbkNsYXNzLCBUb2tlblR5cGV9IGZyb20gXCJzaGlmdC1wYXJzZXIvZGlzdC90b2tlbml6ZXJcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IFN5bnRheCBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7TWF5YmV9IGZyb20gXCJyYW1kYS1mYW50YXN5XCI7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgVGVybSBmcm9tIFwiLi90ZXJtc1wiO1xuaW1wb3J0ICAqIGFzIFIgZnJvbSBcInJhbWRhXCI7XG5jb25zdCBKdXN0XzYyMyA9IE1heWJlLkp1c3Q7XG5jb25zdCBOb3RoaW5nXzYyNCA9IE1heWJlLk5vdGhpbmc7XG5jb25zdCBMU1lOVEFYXzYyNSA9IHtuYW1lOiBcImxlZnQtc3ludGF4XCJ9O1xuY29uc3QgUlNZTlRBWF82MjYgPSB7bmFtZTogXCJyaWdodC1zeW50YXhcIn07XG5jb25zdCBBVF82MjcgPSB7a2xhc3M6IFRva2VuQ2xhc3MuUHVuY3R1YXRvciwgbmFtZTogXCJAXCJ9O1xuY29uc3QgbGl0ZXJhbEtleXdvcmRzXzYyOCA9IFtcInRoaXNcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCJdO1xuY29uc3QgaXNMZWZ0QnJhY2tldF82MjkgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5MQlJBQ0t9KTtcbmNvbnN0IGlzTGVmdEJyYWNlXzYzMCA9IFIud2hlcmVFcSh7dHlwZTogVG9rZW5UeXBlLkxCUkFDRX0pO1xuY29uc3QgaXNMZWZ0UGFyZW5fNjMxID0gUi53aGVyZUVxKHt0eXBlOiBUb2tlblR5cGUuTFBBUkVOfSk7XG5jb25zdCBpc1JpZ2h0QnJhY2tldF82MzIgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5SQlJBQ0t9KTtcbmNvbnN0IGlzUmlnaHRCcmFjZV82MzMgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5SQlJBQ0V9KTtcbmNvbnN0IGlzUmlnaHRQYXJlbl82MzQgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5SUEFSRU59KTtcbmNvbnN0IGlzRU9TXzYzNSA9IFIud2hlcmVFcSh7dHlwZTogVG9rZW5UeXBlLkVPU30pO1xuY29uc3QgaXNIYXNoXzYzNiA9IFIud2hlcmVFcSh7dHlwZTogVG9rZW5UeXBlLklERU5USUZJRVIsIHZhbHVlOiBcIiNcIn0pO1xuY29uc3QgaXNMZWZ0U3ludGF4XzYzNyA9IFIud2hlcmVFcSh7dHlwZTogTFNZTlRBWF82MjV9KTtcbmNvbnN0IGlzUmlnaHRTeW50YXhfNjM4ID0gUi53aGVyZUVxKHt0eXBlOiBSU1lOVEFYXzYyNn0pO1xuY29uc3QgaXNMZWZ0RGVsaW1pdGVyXzYzOSA9IFIuYW55UGFzcyhbaXNMZWZ0QnJhY2tldF82MjksIGlzTGVmdEJyYWNlXzYzMCwgaXNMZWZ0UGFyZW5fNjMxLCBpc0xlZnRTeW50YXhfNjM3XSk7XG5jb25zdCBpc1JpZ2h0RGVsaW1pdGVyXzY0MCA9IFIuYW55UGFzcyhbaXNSaWdodEJyYWNrZXRfNjMyLCBpc1JpZ2h0QnJhY2VfNjMzLCBpc1JpZ2h0UGFyZW5fNjM0LCBpc1JpZ2h0U3ludGF4XzYzOF0pO1xuY29uc3QgaXNNYXRjaGluZ0RlbGltaXRlcnNfNjQxID0gUi5jb25kKFtbaXNMZWZ0QnJhY2tldF82MjksIChfXzY4MiwgYl82ODMpID0+IGlzUmlnaHRCcmFja2V0XzYzMihiXzY4MyldLCBbaXNMZWZ0QnJhY2VfNjMwLCAoX182ODQsIGJfNjg1KSA9PiBpc1JpZ2h0QnJhY2VfNjMzKGJfNjg1KV0sIFtpc0xlZnRQYXJlbl82MzEsIChfXzY4NiwgYl82ODcpID0+IGlzUmlnaHRQYXJlbl82MzQoYl82ODcpXSwgW2lzTGVmdFN5bnRheF82MzcsIChfXzY4OCwgYl82ODkpID0+IGlzUmlnaHRTeW50YXhfNjM4KGJfNjg5KV0sIFtSLlQsIFIuRl1dKTtcbmNvbnN0IGFzc2lnbk9wc182NDIgPSBbXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIio9XCIsIFwiLz1cIiwgXCIlPVwiLCBcIjw8PVwiLCBcIj4+PVwiLCBcIj4+Pj1cIiwgXCImPVwiLCBcInw9XCIsIFwiXj1cIiwgXCIsXCJdO1xuY29uc3QgYmluYXJ5T3BzXzY0MyA9IFtcIitcIiwgXCItXCIsIFwiKlwiLCBcIi9cIiwgXCIlXCIsIFwiPDxcIiwgXCI+PlwiLCBcIj4+PlwiLCBcIiZcIiwgXCJ8XCIsIFwiXlwiLCBcIiYmXCIsIFwifHxcIiwgXCI/XCIsIFwiOlwiLCBcIj09PVwiLCBcIj09XCIsIFwiPj1cIiwgXCI8PVwiLCBcIjxcIiwgXCI+XCIsIFwiIT1cIiwgXCIhPT1cIiwgXCJpbnN0YW5jZW9mXCJdO1xuY29uc3QgdW5hcnlPcHNfNjQ0ID0gW1wiKytcIiwgXCItLVwiLCBcIn5cIiwgXCIhXCIsIFwiZGVsZXRlXCIsIFwidm9pZFwiLCBcInR5cGVvZlwiLCBcInlpZWxkXCIsIFwidGhyb3dcIiwgXCJuZXdcIl07XG5jb25zdCBpc0VtcHR5XzY0NSA9IFIud2hlcmVFcSh7c2l6ZTogMH0pO1xuY29uc3QgaXNQdW5jdHVhdG9yXzY0NiA9IHNfNjkwID0+IHNfNjkwLm1hdGNoKFwicHVuY3R1YXRvclwiKTtcbmNvbnN0IGlzS2V5d29yZF82NDcgPSBzXzY5MSA9PiBzXzY5MS5tYXRjaChcImtleXdvcmRcIik7XG5jb25zdCBpc0RlbGltaXRlcl82NDggPSBzXzY5MiA9PiBzXzY5Mi5tYXRjaChcImRlbGltaXRlclwiKTtcbmNvbnN0IGlzUGFyZW5zXzY0OSA9IHNfNjkzID0+IHNfNjkzLm1hdGNoKFwicGFyZW5zXCIpO1xuY29uc3QgaXNCcmFjZXNfNjUwID0gc182OTQgPT4gc182OTQubWF0Y2goXCJicmFjZXNcIik7XG5jb25zdCBpc0JyYWNrZXRzXzY1MSA9IHNfNjk1ID0+IHNfNjk1Lm1hdGNoKFwiYnJhY2tldHNcIik7XG5jb25zdCBpc0lkZW50aWZpZXJfNjUyID0gc182OTYgPT4gc182OTYubWF0Y2goXCJpZGVudGlmaWVyXCIpO1xuY29uc3QgdmFsXzY1MyA9IHNfNjk3ID0+IHNfNjk3LnZhbCgpO1xuY29uc3QgaXNWYWxfNjU0ID0gUi5jdXJyeSgodl82OTgsIHNfNjk5KSA9PiBzXzY5OS52YWwoKSA9PT0gdl82OTgpO1xuY29uc3QgaXNEb3RfNjU1ID0gUi5hbGxQYXNzKFtpc1B1bmN0dWF0b3JfNjQ2LCBpc1ZhbF82NTQoXCIuXCIpXSk7XG5jb25zdCBpc0NvbG9uXzY1NiA9IFIuYWxsUGFzcyhbaXNQdW5jdHVhdG9yXzY0NiwgaXNWYWxfNjU0KFwiOlwiKV0pO1xuY29uc3QgaXNGdW5jdGlvbktleXdvcmRfNjU3ID0gUi5hbGxQYXNzKFtpc0tleXdvcmRfNjQ3LCBpc1ZhbF82NTQoXCJmdW5jdGlvblwiKV0pO1xuY29uc3QgaXNPcGVyYXRvcl82NTggPSBzXzcwMCA9PiAoc183MDAubWF0Y2goXCJwdW5jdHVhdG9yXCIpIHx8IHNfNzAwLm1hdGNoKFwia2V5d29yZFwiKSkgJiYgUi5hbnkoUi5lcXVhbHMoc183MDAudmFsKCkpLCBhc3NpZ25PcHNfNjQyLmNvbmNhdChiaW5hcnlPcHNfNjQzKS5jb25jYXQodW5hcnlPcHNfNjQ0KSk7XG5jb25zdCBpc05vbkxpdGVyYWxLZXl3b3JkXzY1OSA9IFIuYWxsUGFzcyhbaXNLZXl3b3JkXzY0Nywgc183MDEgPT4gUi5ub25lKFIuZXF1YWxzKHNfNzAxLnZhbCgpKSwgbGl0ZXJhbEtleXdvcmRzXzYyOCldKTtcbmNvbnN0IGlzS2V5d29yZEV4cHJQcmVmaXhfNjYwID0gUi5hbGxQYXNzKFtpc0tleXdvcmRfNjQ3LCBzXzcwMiA9PiBSLmFueShSLmVxdWFscyhzXzcwMi52YWwoKSksIFtcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJkZWxldGVcIiwgXCJ2b2lkXCIsIFwieWllbGRcIiwgXCJ0aHJvd1wiLCBcIm5ld1wiLCBcImNhc2VcIl0pXSk7XG5sZXQgbGFzdF82NjEgPSBwXzcwMyA9PiBwXzcwMy5sYXN0KCk7XG5sZXQgc2FmZUxhc3RfNjYyID0gUi5waXBlKFIuY29uZChbW2lzRW1wdHlfNjQ1LCBSLmFsd2F5cyhOb3RoaW5nXzYyNCgpKV0sIFtSLlQsIFIuY29tcG9zZShNYXliZS5vZiwgbGFzdF82NjEpXV0pKTtcbmxldCBzdHVmZlRydWVfNjYzID0gUi5jdXJyeSgocF83MDQsIGJfNzA1KSA9PiBiXzcwNSA/IEp1c3RfNjIzKHBfNzA0KSA6IE5vdGhpbmdfNjI0KCkpO1xubGV0IHN0dWZmRmFsc2VfNjY0ID0gUi5jdXJyeSgocF83MDYsIGJfNzA3KSA9PiAhYl83MDcgPyBKdXN0XzYyMyhwXzcwNikgOiBOb3RoaW5nXzYyNCgpKTtcbmxldCBpc1RvcENvbG9uXzY2NSA9IFIucGlwZShzYWZlTGFzdF82NjIsIFIubWFwKGlzQ29sb25fNjU2KSwgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpKTtcbmxldCBpc1RvcFB1bmN0dWF0b3JfNjY2ID0gUi5waXBlKHNhZmVMYXN0XzY2MiwgUi5tYXAoaXNQdW5jdHVhdG9yXzY0NiksIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KSk7XG5sZXQgaXNFeHByUmV0dXJuXzY2NyA9IFIuY3VycnkoKGxfNzA4LCBwXzcwOSkgPT4ge1xuICBsZXQgcmV0S3dkXzcxMCA9IHNhZmVMYXN0XzY2MihwXzcwOSk7XG4gIGxldCBtYXliZURvdF83MTEgPSBwb3BfNjc4KHBfNzA5KS5jaGFpbihzYWZlTGFzdF82NjIpO1xuICBpZiAobWF5YmVEb3RfNzExLm1hcChpc0RvdF82NTUpLmdldE9yRWxzZShmYWxzZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0S3dkXzcxMC5tYXAoc183MTIgPT4ge1xuICAgIHJldHVybiBzXzcxMi5tYXRjaChcImtleXdvcmRcIikgJiYgc183MTIudmFsKCkgPT09IFwicmV0dXJuXCIgJiYgc183MTIubGluZU51bWJlcigpID09PSBsXzcwODtcbiAgfSkuZ2V0T3JFbHNlKGZhbHNlKTtcbn0pO1xuY29uc3QgaXNUb3BPcGVyYXRvcl82NjggPSBSLnBpcGUoc2FmZUxhc3RfNjYyLCBSLm1hcChpc09wZXJhdG9yXzY1OCksIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KSk7XG5jb25zdCBpc1RvcEtleXdvcmRFeHByUHJlZml4XzY2OSA9IFIucGlwZShzYWZlTGFzdF82NjIsIFIubWFwKGlzS2V5d29yZEV4cHJQcmVmaXhfNjYwKSwgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpKTtcbmxldCBpc0V4cHJQcmVmaXhfNjcwID0gUi5jdXJyeSgobF83MTMsIGJfNzE0KSA9PiBSLmNvbmQoW1tpc0VtcHR5XzY0NSwgUi5hbHdheXMoYl83MTQpXSwgW2lzVG9wQ29sb25fNjY1LCBSLmFsd2F5cyhiXzcxNCldLCBbaXNUb3BLZXl3b3JkRXhwclByZWZpeF82NjksIFIuVF0sIFtpc1RvcE9wZXJhdG9yXzY2OCwgUi5UXSwgW2lzVG9wUHVuY3R1YXRvcl82NjYsIFIuYWx3YXlzKGJfNzE0KV0sIFtpc0V4cHJSZXR1cm5fNjY3KGxfNzEzKSwgUi5UXSwgW1IuVCwgUi5GXV0pKTtcbmxldCBjdXJseV82NzEgPSBwXzcxNSA9PiBzYWZlTGFzdF82NjIocF83MTUpLm1hcChpc0JyYWNlc182NTApLmNoYWluKHN0dWZmVHJ1ZV82NjMocF83MTUpKTtcbmxldCBwYXJlbl82NzIgPSBwXzcxNiA9PiBzYWZlTGFzdF82NjIocF83MTYpLm1hcChpc1BhcmVuc182NDkpLmNoYWluKHN0dWZmVHJ1ZV82NjMocF83MTYpKTtcbmxldCBmdW5jXzY3MyA9IHBfNzE3ID0+IHNhZmVMYXN0XzY2MihwXzcxNykubWFwKGlzRnVuY3Rpb25LZXl3b3JkXzY1NykuY2hhaW4oc3R1ZmZUcnVlXzY2MyhwXzcxNykpO1xubGV0IGlkZW50XzY3NCA9IHBfNzE4ID0+IHNhZmVMYXN0XzY2MihwXzcxOCkubWFwKGlzSWRlbnRpZmllcl82NTIpLmNoYWluKHN0dWZmVHJ1ZV82NjMocF83MTgpKTtcbmxldCBub25MaXRlcmFsS2V5d29yZF82NzUgPSBwXzcxOSA9PiBzYWZlTGFzdF82NjIocF83MTkpLm1hcChpc05vbkxpdGVyYWxLZXl3b3JkXzY1OSkuY2hhaW4oc3R1ZmZUcnVlXzY2MyhwXzcxOSkpO1xubGV0IG9wdF82NzYgPSBSLmN1cnJ5KChhXzcyMCwgYl83MjEsIHBfNzIyKSA9PiB7XG4gIGxldCByZXN1bHRfNzIzID0gUi5waXBlSyhhXzcyMCwgYl83MjEpKE1heWJlLm9mKHBfNzIyKSk7XG4gIHJldHVybiBNYXliZS5pc0p1c3QocmVzdWx0XzcyMykgPyByZXN1bHRfNzIzIDogTWF5YmUub2YocF83MjIpO1xufSk7XG5sZXQgbm90RG90XzY3NyA9IFIuaWZFbHNlKFIud2hlcmVFcSh7c2l6ZTogMH0pLCBKdXN0XzYyMywgcF83MjQgPT4gc2FmZUxhc3RfNjYyKHBfNzI0KS5tYXAoc183MjUgPT4gIShzXzcyNS5tYXRjaChcInB1bmN0dWF0b3JcIikgJiYgc183MjUudmFsKCkgPT09IFwiLlwiKSkuY2hhaW4oc3R1ZmZUcnVlXzY2MyhwXzcyNCkpKTtcbmxldCBwb3BfNjc4ID0gUi5jb21wb3NlKEp1c3RfNjIzLCBwXzcyNiA9PiBwXzcyNi5wb3AoKSk7XG5jb25zdCBmdW5jdGlvblByZWZpeF82NzkgPSBSLnBpcGVLKGN1cmx5XzY3MSwgcG9wXzY3OCwgcGFyZW5fNjcyLCBwb3BfNjc4LCBvcHRfNjc2KGlkZW50XzY3NCwgcG9wXzY3OCksIGZ1bmNfNjczKTtcbmNvbnN0IGlzUmVnZXhQcmVmaXhfNjgwID0gYl83MjcgPT4gUi5hbnlQYXNzKFtpc0VtcHR5XzY0NSwgaXNUb3BQdW5jdHVhdG9yXzY2NiwgUi5waXBlKE1heWJlLm9mLCBSLnBpcGVLKG5vbkxpdGVyYWxLZXl3b3JkXzY3NSwgcG9wXzY3OCwgbm90RG90XzY3NyksIE1heWJlLmlzSnVzdCksIFIucGlwZShNYXliZS5vZiwgUi5waXBlSyhwYXJlbl82NzIsIHBvcF82NzgsIG5vbkxpdGVyYWxLZXl3b3JkXzY3NSwgcG9wXzY3OCwgbm90RG90XzY3NyksIE1heWJlLmlzSnVzdCksIFIucGlwZShNYXliZS5vZiwgZnVuY3Rpb25QcmVmaXhfNjc5LCBSLmNoYWluKHBfNzI4ID0+IHtcbiAgcmV0dXJuIHNhZmVMYXN0XzY2MihwXzcyOCkubWFwKHNfNzI5ID0+IHNfNzI5LmxpbmVOdW1iZXIoKSkuY2hhaW4oZm5MaW5lXzczMCA9PiB7XG4gICAgcmV0dXJuIHBvcF82NzgocF83MjgpLm1hcChpc0V4cHJQcmVmaXhfNjcwKGZuTGluZV83MzAsIGJfNzI3KSk7XG4gIH0pLmNoYWluKHN0dWZmRmFsc2VfNjY0KHBfNzI4KSk7XG59KSwgTWF5YmUuaXNKdXN0KSwgcF83MzEgPT4ge1xuICBsZXQgaXNDdXJseV83MzIgPSBNYXliZS5pc0p1c3Qoc2FmZUxhc3RfNjYyKHBfNzMxKS5tYXAoaXNCcmFjZXNfNjUwKSk7XG4gIGxldCBhbHJlYWR5Q2hlY2tlZEZ1bmN0aW9uXzczMyA9IFIucGlwZShNYXliZS5vZiwgZnVuY3Rpb25QcmVmaXhfNjc5LCBNYXliZS5pc0p1c3QpKHBfNzMxKTtcbiAgaWYgKGFscmVhZHlDaGVja2VkRnVuY3Rpb25fNzMzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBSLnBpcGUoTWF5YmUub2YsIFIuY2hhaW4oY3VybHlfNjcxKSwgUi5jaGFpbihwXzczNCA9PiB7XG4gICAgcmV0dXJuIHNhZmVMYXN0XzY2MihwXzczNCkubWFwKHNfNzM1ID0+IHNfNzM1LmxpbmVOdW1iZXIoKSkuY2hhaW4oY3VybHlMaW5lXzczNiA9PiB7XG4gICAgICByZXR1cm4gcG9wXzY3OChwXzczNCkubWFwKGlzRXhwclByZWZpeF82NzAoY3VybHlMaW5lXzczNiwgYl83MjcpKTtcbiAgICB9KS5jaGFpbihzdHVmZkZhbHNlXzY2NChwXzczNCkpO1xuICB9KSwgTWF5YmUuaXNKdXN0KShwXzczMSk7XG59XSk7XG5mdW5jdGlvbiBsYXN0RWxfNjgxKGxfNzM3KSB7XG4gIHJldHVybiBsXzczN1tsXzczNy5sZW5ndGggLSAxXTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWRlciBleHRlbmRzIFRva2VuaXplciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3NfNzM4LCBjb250ZXh0XzczOSwgcmVwbGFjZW1lbnRzXzc0MCkge1xuICAgIHN1cGVyKEFycmF5LmlzQXJyYXkoc3RyaW5nc183MzgpID8gc3RyaW5nc183Mzguam9pbihcIlwiKSA6IHN0cmluZ3NfNzM4KTtcbiAgICB0aGlzLmRlbGltU3RhY2sgPSBuZXcgTWFwO1xuICAgIHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUgPSBbZmFsc2VdO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfNzM5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0cmluZ3NfNzM4KSkge1xuICAgICAgbGV0IHRvdGFsSW5kZXggPSAwO1xuICAgICAgdGhpcy5yZXBsYWNlbWVudEluZGV4ID0gUi5yZWR1Y2UoKGFjY183NDEsIHN0clJlcF83NDIpID0+IHtcbiAgICAgICAgYWNjXzc0MS5wdXNoKHtpbmRleDogdG90YWxJbmRleCArIHN0clJlcF83NDJbMF0ubGVuZ3RoLCByZXBsYWNlbWVudDogc3RyUmVwXzc0MlsxXX0pO1xuICAgICAgICB0b3RhbEluZGV4ICs9IHN0clJlcF83NDJbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gYWNjXzc0MTtcbiAgICAgIH0sIFtdLCBSLnppcChzdHJpbmdzXzczOCwgcmVwbGFjZW1lbnRzXzc0MCkpO1xuICAgIH1cbiAgfVxuICByZWFkKHN0YWNrXzc0MyA9IFtdLCBiXzc0NCA9IGZhbHNlLCBzaW5nbGVEZWxpbWl0ZXJfNzQ1ID0gZmFsc2UpIHtcbiAgICBsZXQgcHJlZml4Xzc0NiA9IExpc3QoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHRvayA9IHRoaXMuYWR2YW5jZShwcmVmaXhfNzQ2LCBiXzc0NCk7XG4gICAgICBpZiAodG9rIGluc3RhbmNlb2YgU3ludGF4IHx8IHRvayBpbnN0YW5jZW9mIFRlcm0pIHtcbiAgICAgICAgc3RhY2tfNzQzLnB1c2godG9rKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2spKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHN0YWNrXzc0MywgdG9rKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoTGlzdC5pc0xpc3QodG9rKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzdGFja183NDMsIHRvay50b0FycmF5KCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VPU182MzUodG9rKSkge1xuICAgICAgICBpZiAoc3RhY2tfNzQzWzBdICYmIGlzTGVmdERlbGltaXRlcl82Mzkoc3RhY2tfNzQzWzBdLnRva2VuKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlVW5leHBlY3RlZCh0b2spO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGVmdERlbGltaXRlcl82MzkodG9rKSkge1xuICAgICAgICBpZiAoaXNMZWZ0U3ludGF4XzYzNyh0b2spKSB7XG4gICAgICAgICAgdGhpcy5pbnNpZGVTeW50YXhUZW1wbGF0ZS5wdXNoKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lID0gdG9rLnNsaWNlLnN0YXJ0TG9jYXRpb24ubGluZTtcbiAgICAgICAgbGV0IGlubmVyQiA9IGlzTGVmdEJyYWNlXzYzMCh0b2spID8gaXNFeHByUHJlZml4XzY3MChsaW5lLCBiXzc0NCkocHJlZml4Xzc0NikgOiB0cnVlO1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLnJlYWQoW25ldyBTeW50YXgodG9rLCB0aGlzLmNvbnRleHQpXSwgaW5uZXJCLCBmYWxzZSk7XG4gICAgICAgIGxldCBzdHggPSBuZXcgU3ludGF4KGlubmVyLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICBwcmVmaXhfNzQ2ID0gcHJlZml4Xzc0Ni5jb25jYXQoc3R4KTtcbiAgICAgICAgc3RhY2tfNzQzLnB1c2goc3R4KTtcbiAgICAgICAgaWYgKHNpbmdsZURlbGltaXRlcl83NDUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1JpZ2h0RGVsaW1pdGVyXzY0MCh0b2spKSB7XG4gICAgICAgIGlmIChzdGFja183NDNbMF0gJiYgIWlzTWF0Y2hpbmdEZWxpbWl0ZXJzXzY0MShzdGFja183NDNbMF0udG9rZW4sIHRvaykpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZVVuZXhwZWN0ZWQodG9rKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3R4ID0gbmV3IFN5bnRheCh0b2ssIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHN0YWNrXzc0My5wdXNoKHN0eCk7XG4gICAgICAgIGlmIChsYXN0RWxfNjgxKHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUpICYmIGlzUmlnaHRTeW50YXhfNjM4KHRvaykpIHtcbiAgICAgICAgICB0aGlzLmluc2lkZVN5bnRheFRlbXBsYXRlLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN0eCA9IG5ldyBTeW50YXgodG9rLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICBwcmVmaXhfNzQ2ID0gcHJlZml4Xzc0Ni5jb25jYXQoc3R4KTtcbiAgICAgICAgc3RhY2tfNzQzLnB1c2goc3R4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIExpc3Qoc3RhY2tfNzQzKTtcbiAgfVxuICBhZHZhbmNlKHByZWZpeF83NDcsIGJfNzQ4KSB7XG4gICAgbGV0IHN0YXJ0TG9jYXRpb25fNzQ5ID0gdGhpcy5nZXRMb2NhdGlvbigpO1xuICAgIHRoaXMubGFzdEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB0aGlzLmxhc3RMaW5lID0gdGhpcy5saW5lO1xuICAgIHRoaXMubGFzdExpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuICAgIHRoaXMuc2tpcENvbW1lbnQoKTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHRoaXMuc3RhcnRMaW5lID0gdGhpcy5saW5lO1xuICAgIHRoaXMuc3RhcnRMaW5lU3RhcnQgPSB0aGlzLmxpbmVTdGFydDtcbiAgICBpZiAodGhpcy5yZXBsYWNlbWVudEluZGV4ICYmIHRoaXMucmVwbGFjZW1lbnRJbmRleFswXSAmJiB0aGlzLmluZGV4ID49IHRoaXMucmVwbGFjZW1lbnRJbmRleFswXS5pbmRleCkge1xuICAgICAgbGV0IHJlcCA9IHRoaXMucmVwbGFjZW1lbnRJbmRleFswXS5yZXBsYWNlbWVudDtcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRJbmRleC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlcDtcbiAgICB9XG4gICAgbGV0IGNoYXJDb2RlXzc1MCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgaWYgKGNoYXJDb2RlXzc1MCA9PT0gOTYpIHtcbiAgICAgIGxldCBlbGVtZW50LCBpdGVtcyA9IFtdO1xuICAgICAgbGV0IHN0YXJ0TG9jYXRpb25fNzQ5ID0gdGhpcy5nZXRMb2NhdGlvbigpO1xuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIGlmIChsYXN0RWxfNjgxKHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUpKSB7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIHN0YXJ0TG9jYXRpb25fNzQ5KTtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBSU1lOVEFYXzYyNiwgdmFsdWU6IFwiYFwiLCBzbGljZTogc2xpY2V9O1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5zY2FuVGVtcGxhdGVFbGVtZW50KCk7XG4gICAgICAgIGl0ZW1zLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LmludGVycCkge1xuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLnJlYWQoW10sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBhc3NlcnQoZWxlbWVudC5zaXplID09PSAxLCBcInNob3VsZCBvbmx5IGhhdmUgcmVhZCBhIHNpbmdsZSBkZWxpbWl0ZXIgaW5zaWRlIGEgdGVtcGxhdGVcIik7XG4gICAgICAgICAgaXRlbXMucHVzaChlbGVtZW50LmdldCgwKSk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCFlbGVtZW50LnRhaWwpO1xuICAgICAgcmV0dXJuIHt0eXBlOiBUb2tlblR5cGUuVEVNUExBVEUsIGl0ZW1zOiBMaXN0KGl0ZW1zKX07XG4gICAgfSBlbHNlIGlmIChjaGFyQ29kZV83NTAgPT09IDM1KSB7XG4gICAgICBsZXQgc3RhcnRMb2NhdGlvbl83NDkgPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydCwgc3RhcnRMb2NhdGlvbl83NDkpO1xuICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDk2KSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBMU1lOVEFYXzYyNSwgdmFsdWU6IFwiI2BcIiwgc2xpY2U6IHNsaWNlfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7dHlwZTogVG9rZW5UeXBlLklERU5USUZJRVIsIHZhbHVlOiBcIiNcIiwgc2xpY2U6IHNsaWNlfTtcbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlXzc1MCA9PT0gNjQpIHtcbiAgICAgIGxldCBzdGFydExvY2F0aW9uXzc0OSA9IHRoaXMuZ2V0TG9jYXRpb24oKTtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICBsZXQgc2xpY2UgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBzdGFydExvY2F0aW9uXzc0OSk7XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgICByZXR1cm4ge3R5cGU6IEFUXzYyNywgdmFsdWU6IFwiQFwiLCBzbGljZTogc2xpY2V9O1xuICAgIH1cbiAgICBsZXQgbG9va2FoZWFkXzc1MSA9IHN1cGVyLmFkdmFuY2UoKTtcbiAgICBpZiAobG9va2FoZWFkXzc1MS50eXBlID09PSBUb2tlblR5cGUuRElWICYmIGlzUmVnZXhQcmVmaXhfNjgwKGJfNzQ4KShwcmVmaXhfNzQ3KSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNjYW5SZWdFeHAoXCIvXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbG9va2FoZWFkXzc1MTtcbiAgfVxuICBzY2FuVGVtcGxhdGVFbGVtZW50KCkge1xuICAgIGxldCBzdGFydExvY2F0aW9uXzc1MiA9IHRoaXMuZ2V0TG9jYXRpb24oKTtcbiAgICBsZXQgc3RhcnRfNzUzID0gdGhpcy5pbmRleDtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMuc291cmNlLmxlbmd0aCkge1xuICAgICAgbGV0IGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLmdldFNsaWNlKHN0YXJ0Xzc1Mywgc3RhcnRMb2NhdGlvbl83NTIpO1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRva2VuVHlwZS5URU1QTEFURSwgdGFpbDogdHJ1ZSwgaW50ZXJwOiBmYWxzZSwgc2xpY2U6IHNsaWNlfTtcbiAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDEyMykge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydF83NTMsIHN0YXJ0TG9jYXRpb25fNzUyKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogVG9rZW5UeXBlLlRFTVBMQVRFLCB0YWlsOiBmYWxzZSwgaW50ZXJwOiB0cnVlLCBzbGljZTogc2xpY2V9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IG9jdGFsID0gdGhpcy5zY2FuU3RyaW5nRXNjYXBlKFwiXCIsIG51bGwpWzFdO1xuICAgICAgICAgICAgaWYgKG9jdGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoKTtcbiAgfVxufVxuIl19

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JsError = exports.TokenType = exports.TokenClass = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(5);

	var _errors = __webpack_require__(10);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var TokenClass = exports.TokenClass = {
	  Eof: { name: "<End>" },
	  Ident: { name: "Identifier", isIdentifierName: true },
	  Keyword: { name: "Keyword", isIdentifierName: true },
	  NumericLiteral: { name: "Numeric" },
	  TemplateElement: { name: "Template" },
	  Punctuator: { name: "Punctuator" },
	  StringLiteral: { name: "String" },
	  RegularExpression: { name: "RegularExpression" },
	  Illegal: { name: "Illegal" }
	};

	var TokenType = exports.TokenType = {
	  EOS: { klass: TokenClass.Eof, name: "EOS" },
	  LPAREN: { klass: TokenClass.Punctuator, name: "(" },
	  RPAREN: { klass: TokenClass.Punctuator, name: ")" },
	  LBRACK: { klass: TokenClass.Punctuator, name: "[" },
	  RBRACK: { klass: TokenClass.Punctuator, name: "]" },
	  LBRACE: { klass: TokenClass.Punctuator, name: "{" },
	  RBRACE: { klass: TokenClass.Punctuator, name: "}" },
	  COLON: { klass: TokenClass.Punctuator, name: ":" },
	  SEMICOLON: { klass: TokenClass.Punctuator, name: ";" },
	  PERIOD: { klass: TokenClass.Punctuator, name: "." },
	  ELLIPSIS: { klass: TokenClass.Punctuator, name: "..." },
	  ARROW: { klass: TokenClass.Punctuator, name: "=>" },
	  CONDITIONAL: { klass: TokenClass.Punctuator, name: "?" },
	  INC: { klass: TokenClass.Punctuator, name: "++" },
	  DEC: { klass: TokenClass.Punctuator, name: "--" },
	  ASSIGN: { klass: TokenClass.Punctuator, name: "=" },
	  ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: "|=" },
	  ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: "^=" },
	  ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: "&=" },
	  ASSIGN_SHL: { klass: TokenClass.Punctuator, name: "<<=" },
	  ASSIGN_SHR: { klass: TokenClass.Punctuator, name: ">>=" },
	  ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>=" },
	  ASSIGN_ADD: { klass: TokenClass.Punctuator, name: "+=" },
	  ASSIGN_SUB: { klass: TokenClass.Punctuator, name: "-=" },
	  ASSIGN_MUL: { klass: TokenClass.Punctuator, name: "*=" },
	  ASSIGN_DIV: { klass: TokenClass.Punctuator, name: "/=" },
	  ASSIGN_MOD: { klass: TokenClass.Punctuator, name: "%=" },
	  COMMA: { klass: TokenClass.Punctuator, name: "," },
	  OR: { klass: TokenClass.Punctuator, name: "||" },
	  AND: { klass: TokenClass.Punctuator, name: "&&" },
	  BIT_OR: { klass: TokenClass.Punctuator, name: "|" },
	  BIT_XOR: { klass: TokenClass.Punctuator, name: "^" },
	  BIT_AND: { klass: TokenClass.Punctuator, name: "&" },
	  SHL: { klass: TokenClass.Punctuator, name: "<<" },
	  SHR: { klass: TokenClass.Punctuator, name: ">>" },
	  SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>" },
	  ADD: { klass: TokenClass.Punctuator, name: "+" },
	  SUB: { klass: TokenClass.Punctuator, name: "-" },
	  MUL: { klass: TokenClass.Punctuator, name: "*" },
	  DIV: { klass: TokenClass.Punctuator, name: "/" },
	  MOD: { klass: TokenClass.Punctuator, name: "%" },
	  EQ: { klass: TokenClass.Punctuator, name: "==" },
	  NE: { klass: TokenClass.Punctuator, name: "!=" },
	  EQ_STRICT: { klass: TokenClass.Punctuator, name: "===" },
	  NE_STRICT: { klass: TokenClass.Punctuator, name: "!==" },
	  LT: { klass: TokenClass.Punctuator, name: "<" },
	  GT: { klass: TokenClass.Punctuator, name: ">" },
	  LTE: { klass: TokenClass.Punctuator, name: "<=" },
	  GTE: { klass: TokenClass.Punctuator, name: ">=" },
	  INSTANCEOF: { klass: TokenClass.Keyword, name: "instanceof" },
	  IN: { klass: TokenClass.Keyword, name: "in" },
	  NOT: { klass: TokenClass.Punctuator, name: "!" },
	  BIT_NOT: { klass: TokenClass.Punctuator, name: "~" },
	  AWAIT: { klass: TokenClass.Keyword, name: "await" },
	  DELETE: { klass: TokenClass.Keyword, name: "delete" },
	  TYPEOF: { klass: TokenClass.Keyword, name: "typeof" },
	  VOID: { klass: TokenClass.Keyword, name: "void" },
	  BREAK: { klass: TokenClass.Keyword, name: "break" },
	  CASE: { klass: TokenClass.Keyword, name: "case" },
	  CATCH: { klass: TokenClass.Keyword, name: "catch" },
	  CLASS: { klass: TokenClass.Keyword, name: "class" },
	  CONTINUE: { klass: TokenClass.Keyword, name: "continue" },
	  DEBUGGER: { klass: TokenClass.Keyword, name: "debugger" },
	  DEFAULT: { klass: TokenClass.Keyword, name: "default" },
	  DO: { klass: TokenClass.Keyword, name: "do" },
	  ELSE: { klass: TokenClass.Keyword, name: "else" },
	  EXPORT: { klass: TokenClass.Keyword, name: "export" },
	  EXTENDS: { klass: TokenClass.Keyword, name: "extends" },
	  FINALLY: { klass: TokenClass.Keyword, name: "finally" },
	  FOR: { klass: TokenClass.Keyword, name: "for" },
	  FUNCTION: { klass: TokenClass.Keyword, name: "function" },
	  IF: { klass: TokenClass.Keyword, name: "if" },
	  IMPORT: { klass: TokenClass.Keyword, name: "import" },
	  LET: { klass: TokenClass.Keyword, name: "let" },
	  NEW: { klass: TokenClass.Keyword, name: "new" },
	  RETURN: { klass: TokenClass.Keyword, name: "return" },
	  SUPER: { klass: TokenClass.Keyword, name: "super" },
	  SWITCH: { klass: TokenClass.Keyword, name: "switch" },
	  THIS: { klass: TokenClass.Keyword, name: "this" },
	  THROW: { klass: TokenClass.Keyword, name: "throw" },
	  TRY: { klass: TokenClass.Keyword, name: "try" },
	  VAR: { klass: TokenClass.Keyword, name: "var" },
	  WHILE: { klass: TokenClass.Keyword, name: "while" },
	  WITH: { klass: TokenClass.Keyword, name: "with" },
	  NULL: { klass: TokenClass.Keyword, name: "null" },
	  TRUE: { klass: TokenClass.Keyword, name: "true" },
	  FALSE: { klass: TokenClass.Keyword, name: "false" },
	  YIELD: { klass: TokenClass.Keyword, name: "yield" },
	  NUMBER: { klass: TokenClass.NumericLiteral, name: "" },
	  STRING: { klass: TokenClass.StringLiteral, name: "" },
	  REGEXP: { klass: TokenClass.RegularExpression, name: "" },
	  IDENTIFIER: { klass: TokenClass.Ident, name: "" },
	  CONST: { klass: TokenClass.Keyword, name: "const" },
	  TEMPLATE: { klass: TokenClass.TemplateElement, name: "" },
	  ILLEGAL: { klass: TokenClass.Illegal, name: "" }
	};

	var TT = TokenType;
	var I = TT.ILLEGAL;
	var F = false;
	var T = true;

	var ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];

	var PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];

	var JsError = exports.JsError = function (_Error) {
	  _inherits(JsError, _Error);

	  function JsError(index, line, column, msg) {
	    _classCallCheck(this, JsError);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JsError).call(this, msg));

	    _this.index = index;
	    _this.line = line;
	    _this.column = column;
	    _this.description = msg;
	    _this.message = "[" + line + ":" + column + "]: " + msg;
	    return _this;
	  }

	  return JsError;
	}(Error);

	function fromCodePoint(cp) {
	  if (cp <= 0xFFFF) return String.fromCharCode(cp);
	  var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	  var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
	  return cu1 + cu2;
	}

	function decodeUtf16(lead, trail) {
	  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	}

	var Tokenizer = function () {
	  function Tokenizer(source) {
	    _classCallCheck(this, Tokenizer);

	    this.source = source;
	    this.index = 0;
	    this.line = 0;
	    this.lineStart = 0;
	    this.startIndex = 0;
	    this.startLine = 0;
	    this.startLineStart = 0;
	    this.lastIndex = 0;
	    this.lastLine = 0;
	    this.lastLineStart = 0;
	    this.hasLineTerminatorBeforeNext = false;
	    this.tokenIndex = 0;
	  }

	  _createClass(Tokenizer, [{
	    key: "saveLexerState",
	    value: function saveLexerState() {
	      return {
	        source: this.source,
	        index: this.index,
	        line: this.line,
	        lineStart: this.lineStart,
	        startIndex: this.startIndex,
	        startLine: this.startLine,
	        startLineStart: this.startLineStart,
	        lastIndex: this.lastIndex,
	        lastLine: this.lastLine,
	        lastLineStart: this.lastLineStart,
	        lookahead: this.lookahead,
	        hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,
	        tokenIndex: this.tokenIndex
	      };
	    }
	  }, {
	    key: "restoreLexerState",
	    value: function restoreLexerState(state) {
	      this.source = state.source;
	      this.index = state.index;
	      this.line = state.line;
	      this.lineStart = state.lineStart;
	      this.startIndex = state.startIndex;
	      this.startLine = state.startLine;
	      this.startLineStart = state.startLineStart;
	      this.lastIndex = state.lastIndex;
	      this.lastLine = state.lastLine;
	      this.lastLineStart = state.lastLineStart;
	      this.lookahead = state.lookahead;
	      this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;
	      this.tokenIndex = state.tokenIndex;
	    }
	  }, {
	    key: "createILLEGAL",
	    value: function createILLEGAL() {
	      this.startIndex = this.index;
	      this.startLine = this.line;
	      this.startLineStart = this.lineStart;
	      return this.index < this.source.length ? this.createError(_errors.ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index)) : this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
	    }
	  }, {
	    key: "createUnexpected",
	    value: function createUnexpected(token) {
	      switch (token.type.klass) {
	        case TokenClass.Eof:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
	        case TokenClass.Ident:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_IDENTIFIER);
	        case TokenClass.Keyword:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);
	        case TokenClass.NumericLiteral:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_NUMBER);
	        case TokenClass.TemplateElement:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TEMPLATE);
	        case TokenClass.Punctuator:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
	        case TokenClass.StringLiteral:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_STRING);
	        // the other token classes are RegularExpression and Illegal, but they cannot reach here
	      }
	    }
	  }, {
	    key: "createError",
	    value: function createError(message) {
	      var _arguments = arguments;

	      /* istanbul ignore next */
	      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
	        return JSON.stringify(_arguments[+n + 1]);
	      });
	      return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);
	    }
	  }, {
	    key: "createErrorWithLocation",
	    value: function createErrorWithLocation(location, message) {
	      var _arguments2 = arguments;

	      /* istanbul ignore next */
	      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
	        return JSON.stringify(_arguments2[+n + 2]);
	      });
	      if (location.slice && location.slice.startLocation) {
	        location = location.slice.startLocation;
	      }
	      return new JsError(location.offset, location.line, location.column + 1, msg);
	    }
	  }, {
	    key: "getKeyword",
	    value: function getKeyword(id) {
	      if (id.length === 1 || id.length > 10) {
	        return TokenType.IDENTIFIER;
	      }

	      /* istanbul ignore next */
	      switch (id.length) {
	        case 2:
	          switch (id.charAt(0)) {
	            case "i":
	              switch (id.charAt(1)) {
	                case "f":
	                  return TokenType.IF;
	                case "n":
	                  return TokenType.IN;
	                default:
	                  break;
	              }
	              break;
	            case "d":
	              if (id.charAt(1) === "o") {
	                return TokenType.DO;
	              }
	              break;
	          }
	          break;
	        case 3:
	          switch (id.charAt(0)) {
	            case "v":
	              if (Tokenizer.cse2(id, "a", "r")) {
	                return TokenType.VAR;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse2(id, "o", "r")) {
	                return TokenType.FOR;
	              }
	              break;
	            case "n":
	              if (Tokenizer.cse2(id, "e", "w")) {
	                return TokenType.NEW;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse2(id, "r", "y")) {
	                return TokenType.TRY;
	              }
	              break;
	            case "l":
	              if (Tokenizer.cse2(id, "e", "t")) {
	                return TokenType.LET;
	              }
	              break;
	          }
	          break;
	        case 4:
	          switch (id.charAt(0)) {
	            case "t":
	              if (Tokenizer.cse3(id, "h", "i", "s")) {
	                return TokenType.THIS;
	              } else if (Tokenizer.cse3(id, "r", "u", "e")) {
	                return TokenType.TRUE;
	              }
	              break;
	            case "n":
	              if (Tokenizer.cse3(id, "u", "l", "l")) {
	                return TokenType.NULL;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse3(id, "l", "s", "e")) {
	                return TokenType.ELSE;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse3(id, "a", "s", "e")) {
	                return TokenType.CASE;
	              }
	              break;
	            case "v":
	              if (Tokenizer.cse3(id, "o", "i", "d")) {
	                return TokenType.VOID;
	              }
	              break;
	            case "w":
	              if (Tokenizer.cse3(id, "i", "t", "h")) {
	                return TokenType.WITH;
	              }
	              break;
	          }
	          break;
	        case 5:
	          switch (id.charAt(0)) {
	            case "a":
	              if (this.moduleIsTheGoalSymbol && Tokenizer.cse4(id, "w", "a", "i", "t")) {
	                return TokenType.AWAIT;
	              }
	              break;
	            case "w":
	              if (Tokenizer.cse4(id, "h", "i", "l", "e")) {
	                return TokenType.WHILE;
	              }
	              break;
	            case "b":
	              if (Tokenizer.cse4(id, "r", "e", "a", "k")) {
	                return TokenType.BREAK;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse4(id, "a", "l", "s", "e")) {
	                return TokenType.FALSE;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse4(id, "a", "t", "c", "h")) {
	                return TokenType.CATCH;
	              } else if (Tokenizer.cse4(id, "o", "n", "s", "t")) {
	                return TokenType.CONST;
	              } else if (Tokenizer.cse4(id, "l", "a", "s", "s")) {
	                return TokenType.CLASS;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse4(id, "h", "r", "o", "w")) {
	                return TokenType.THROW;
	              }
	              break;
	            case "y":
	              if (Tokenizer.cse4(id, "i", "e", "l", "d")) {
	                return TokenType.YIELD;
	              }
	              break;
	            case "s":
	              if (Tokenizer.cse4(id, "u", "p", "e", "r")) {
	                return TokenType.SUPER;
	              }
	              break;
	          }
	          break;
	        case 6:
	          switch (id.charAt(0)) {
	            case "r":
	              if (Tokenizer.cse5(id, "e", "t", "u", "r", "n")) {
	                return TokenType.RETURN;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse5(id, "y", "p", "e", "o", "f")) {
	                return TokenType.TYPEOF;
	              }
	              break;
	            case "d":
	              if (Tokenizer.cse5(id, "e", "l", "e", "t", "e")) {
	                return TokenType.DELETE;
	              }
	              break;
	            case "s":
	              if (Tokenizer.cse5(id, "w", "i", "t", "c", "h")) {
	                return TokenType.SWITCH;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse5(id, "x", "p", "o", "r", "t")) {
	                return TokenType.EXPORT;
	              }
	              break;
	            case "i":
	              if (Tokenizer.cse5(id, "m", "p", "o", "r", "t")) {
	                return TokenType.IMPORT;
	              }
	              break;
	          }
	          break;
	        case 7:
	          switch (id.charAt(0)) {
	            case "d":
	              if (Tokenizer.cse6(id, "e", "f", "a", "u", "l", "t")) {
	                return TokenType.DEFAULT;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse6(id, "i", "n", "a", "l", "l", "y")) {
	                return TokenType.FINALLY;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse6(id, "x", "t", "e", "n", "d", "s")) {
	                return TokenType.EXTENDS;
	              }
	              break;
	          }
	          break;
	        case 8:
	          switch (id.charAt(0)) {
	            case "f":
	              if (Tokenizer.cse7(id, "u", "n", "c", "t", "i", "o", "n")) {
	                return TokenType.FUNCTION;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse7(id, "o", "n", "t", "i", "n", "u", "e")) {
	                return TokenType.CONTINUE;
	              }
	              break;
	            case "d":
	              if (Tokenizer.cse7(id, "e", "b", "u", "g", "g", "e", "r")) {
	                return TokenType.DEBUGGER;
	              }
	              break;
	          }
	          break;
	        case 10:
	          if (id === "instanceof") {
	            return TokenType.INSTANCEOF;
	          }
	          break;
	      }
	      return TokenType.IDENTIFIER;
	    }
	  }, {
	    key: "skipSingleLineComment",
	    value: function skipSingleLineComment(offset) {
	      this.index += offset;
	      while (this.index < this.source.length) {
	        /**
	         * @type {Number}
	         */
	        var chCode = this.source.charCodeAt(this.index);
	        this.index++;
	        if ((0, _utils.isLineTerminator)(chCode)) {
	          this.hasLineTerminatorBeforeNext = true;
	          if (chCode === 0xD /* "\r" */ && this.source.charCodeAt(this.index) === 0xA /*"\n" */) {
	              this.index++;
	            }
	          this.lineStart = this.index;
	          this.line++;
	          return;
	        }
	      }
	    }
	  }, {
	    key: "skipMultiLineComment",
	    value: function skipMultiLineComment() {
	      this.index += 2;
	      var length = this.source.length;
	      var isLineStart = false;
	      while (this.index < length) {
	        var chCode = this.source.charCodeAt(this.index);
	        if (chCode < 0x80) {
	          switch (chCode) {
	            case 42:
	              // "*"
	              // Block comment ends with "*/".
	              if (this.source.charAt(this.index + 1) === "/") {
	                this.index = this.index + 2;
	                return isLineStart;
	              }
	              this.index++;
	              break;
	            case 10:
	              // "\n"
	              isLineStart = true;
	              this.hasLineTerminatorBeforeNext = true;
	              this.index++;
	              this.lineStart = this.index;
	              this.line++;
	              break;
	            case 13:
	              // "\r":
	              isLineStart = true;
	              this.hasLineTerminatorBeforeNext = true;
	              if (this.source.charAt(this.index + 1) === "\n") {
	                this.index++;
	              }
	              this.index++;
	              this.lineStart = this.index;
	              this.line++;
	              break;
	            default:
	              this.index++;
	          }
	        } else if (chCode === 0x2028 || chCode === 0x2029) {
	          isLineStart = true;
	          this.hasLineTerminatorBeforeNext = true;
	          this.index++;
	          this.lineStart = this.index;
	          this.line++;
	        } else {
	          this.index++;
	        }
	      }
	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "skipComment",
	    value: function skipComment() {
	      this.hasLineTerminatorBeforeNext = false;

	      var isLineStart = this.index === 0;
	      var length = this.source.length;

	      while (this.index < length) {
	        var chCode = this.source.charCodeAt(this.index);
	        if ((0, _utils.isWhiteSpace)(chCode)) {
	          this.index++;
	        } else if ((0, _utils.isLineTerminator)(chCode)) {
	          this.hasLineTerminatorBeforeNext = true;
	          this.index++;
	          if (chCode === 13 /* "\r" */ && this.source.charAt(this.index) === "\n") {
	            this.index++;
	          }
	          this.lineStart = this.index;
	          this.line++;
	          isLineStart = true;
	        } else if (chCode === 47 /* "/" */) {
	            if (this.index + 1 >= length) {
	              break;
	            }
	            chCode = this.source.charCodeAt(this.index + 1);
	            if (chCode === 47 /* "/" */) {
	                this.skipSingleLineComment(2);
	                isLineStart = true;
	              } else if (chCode === 42 /* "*" */) {
	                isLineStart = this.skipMultiLineComment() || isLineStart;
	              } else {
	              break;
	            }
	          } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* "-" */) {
	            if (this.index + 2 >= length) {
	              break;
	            }
	            // U+003E is ">"
	            if (this.source.charAt(this.index + 1) === "-" && this.source.charAt(this.index + 2) === ">") {
	              // "-->" is a single-line comment
	              this.skipSingleLineComment(3);
	            } else {
	              break;
	            }
	          } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* "<" */) {
	            if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
	              this.skipSingleLineComment(4);
	            } else {
	              break;
	            }
	          } else {
	          break;
	        }
	      }
	    }
	  }, {
	    key: "scanHexEscape2",
	    value: function scanHexEscape2() {
	      if (this.index + 2 > this.source.length) {
	        return -1;
	      }
	      var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
	      if (r1 === -1) {
	        return -1;
	      }
	      var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
	      if (r2 === -1) {
	        return -1;
	      }
	      this.index += 2;
	      return r1 << 4 | r2;
	    }
	  }, {
	    key: "scanUnicode",
	    value: function scanUnicode() {
	      if (this.source.charAt(this.index) === "{") {
	        //\u{HexDigits}
	        var i = this.index + 1;
	        var hexDigits = 0,
	            ch = void 0;
	        while (i < this.source.length) {
	          ch = this.source.charAt(i);
	          var hex = (0, _utils.getHexValue)(ch);
	          if (hex === -1) {
	            break;
	          }
	          hexDigits = hexDigits << 4 | hex;
	          if (hexDigits > 0x10FFFF) {
	            throw this.createILLEGAL();
	          }
	          i++;
	        }
	        if (ch !== "}") {
	          throw this.createILLEGAL();
	        }
	        if (i === this.index + 1) {
	          ++this.index; // This is so that the error is 'Unexpected "}"' instead of 'Unexpected "{"'.
	          throw this.createILLEGAL();
	        }
	        this.index = i + 1;
	        return hexDigits;
	      } else {
	        //\uHex4Digits
	        if (this.index + 4 > this.source.length) {
	          return -1;
	        }
	        var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
	        if (r1 === -1) {
	          return -1;
	        }
	        var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
	        if (r2 === -1) {
	          return -1;
	        }
	        var r3 = (0, _utils.getHexValue)(this.source.charAt(this.index + 2));
	        if (r3 === -1) {
	          return -1;
	        }
	        var r4 = (0, _utils.getHexValue)(this.source.charAt(this.index + 3));
	        if (r4 === -1) {
	          return -1;
	        }
	        this.index += 4;
	        return r1 << 12 | r2 << 8 | r3 << 4 | r4;
	      }
	    }
	  }, {
	    key: "getEscapedIdentifier",
	    value: function getEscapedIdentifier() {
	      var id = "";
	      var check = _utils.isIdentifierStart;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        var code = ch.charCodeAt(0);
	        var start = this.index;
	        ++this.index;
	        if (ch === "\\") {
	          if (this.index >= this.source.length) {
	            throw this.createILLEGAL();
	          }
	          if (this.source.charAt(this.index) !== "u") {
	            throw this.createILLEGAL();
	          }
	          ++this.index;
	          code = this.scanUnicode();
	          if (code < 0) {
	            throw this.createILLEGAL();
	          }
	          ch = fromCodePoint(code);
	        } else if (0xD800 <= code && code <= 0xDBFF) {
	          if (this.index >= this.source.length) {
	            throw this.createILLEGAL();
	          }
	          var lowSurrogateCode = this.source.charCodeAt(this.index);
	          ++this.index;
	          if (!(0xDC00 <= lowSurrogateCode && lowSurrogateCode <= 0xDFFF)) {
	            throw this.createILLEGAL();
	          }
	          code = decodeUtf16(code, lowSurrogateCode);
	          ch = fromCodePoint(code);
	        }
	        if (!check(code)) {
	          if (id.length < 1) {
	            throw this.createILLEGAL();
	          }
	          this.index = start;
	          return id;
	        }
	        check = _utils.isIdentifierPart;
	        id += ch;
	      }
	      return id;
	    }
	  }, {
	    key: "getIdentifier",
	    value: function getIdentifier() {
	      var start = this.index;
	      var l = this.source.length;
	      var i = this.index;
	      var check = _utils.isIdentifierStart;
	      while (i < l) {
	        var ch = this.source.charAt(i);
	        var code = ch.charCodeAt(0);
	        if (ch === "\\" || 0xD800 <= code && code <= 0xDBFF) {
	          // Go back and try the hard one.
	          this.index = start;
	          return this.getEscapedIdentifier();
	        }
	        if (!check(code)) {
	          this.index = i;
	          return this.source.slice(start, i);
	        }
	        ++i;
	        check = _utils.isIdentifierPart;
	      }
	      this.index = i;
	      return this.source.slice(start, i);
	    }
	  }, {
	    key: "scanIdentifier",
	    value: function scanIdentifier() {
	      var startLocation = this.getLocation();
	      var start = this.index;

	      // Backslash (U+005C) starts an escaped character.
	      var id = this.source.charAt(this.index) === "\\" ? this.getEscapedIdentifier() : this.getIdentifier();

	      // There is no keyword or literal with only one character.
	      // Thus, it must be an identifier.
	      var slice = this.getSlice(start, startLocation);
	      slice.text = id;

	      return { type: this.getKeyword(id), value: id, slice: slice };
	    }
	  }, {
	    key: "getLocation",
	    value: function getLocation() {
	      return {
	        line: this.startLine + 1,
	        column: this.startIndex - this.startLineStart,
	        offset: this.startIndex
	      };
	    }
	  }, {
	    key: "getSlice",
	    value: function getSlice(start, startLocation) {
	      return { text: this.source.slice(start, this.index), start: start, startLocation: startLocation, end: this.index };
	    }
	  }, {
	    key: "scanPunctuatorHelper",
	    value: function scanPunctuatorHelper() {
	      var ch1 = this.source.charAt(this.index);

	      switch (ch1) {
	        // Check for most common single-character punctuators.
	        case ".":
	          var ch2 = this.source.charAt(this.index + 1);
	          if (ch2 !== ".") return TokenType.PERIOD;
	          var ch3 = this.source.charAt(this.index + 2);
	          if (ch3 !== ".") return TokenType.PERIOD;
	          return TokenType.ELLIPSIS;
	        case "(":
	          return TokenType.LPAREN;
	        case ")":
	        case ";":
	        case ",":
	          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	        case "{":
	          return TokenType.LBRACE;
	        case "}":
	        case "[":
	        case "]":
	        case ":":
	        case "?":
	        case "~":
	          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	        default:
	          // "=" (U+003D) marks an assignment or comparison operator.
	          if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === "=") {
	            switch (ch1) {
	              case "=":
	                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
	                  return TokenType.EQ_STRICT;
	                }
	                return TokenType.EQ;
	              case "!":
	                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
	                  return TokenType.NE_STRICT;
	                }
	                return TokenType.NE;
	              case "|":
	                return TokenType.ASSIGN_BIT_OR;
	              case "+":
	                return TokenType.ASSIGN_ADD;
	              case "-":
	                return TokenType.ASSIGN_SUB;
	              case "*":
	                return TokenType.ASSIGN_MUL;
	              case "<":
	                return TokenType.LTE;
	              case ">":
	                return TokenType.GTE;
	              case "/":
	                return TokenType.ASSIGN_DIV;
	              case "%":
	                return TokenType.ASSIGN_MOD;
	              case "^":
	                return TokenType.ASSIGN_BIT_XOR;
	              case "&":
	                return TokenType.ASSIGN_BIT_AND;
	              // istanbul ignore next
	              default:
	                break; //failed
	            }
	          }
	      }

	      if (this.index + 1 < this.source.length) {
	        var _ch = this.source.charAt(this.index + 1);
	        if (ch1 === _ch) {
	          if (this.index + 2 < this.source.length) {
	            var _ch2 = this.source.charAt(this.index + 2);
	            if (ch1 === ">" && _ch2 === ">") {
	              // 4-character punctuator: >>>=
	              if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === "=") {
	                return TokenType.ASSIGN_SHR_UNSIGNED;
	              }
	              return TokenType.SHR_UNSIGNED;
	            }

	            if (ch1 === "<" && _ch2 === "=") {
	              return TokenType.ASSIGN_SHL;
	            }

	            if (ch1 === ">" && _ch2 === "=") {
	              return TokenType.ASSIGN_SHR;
	            }
	          }
	          // Other 2-character punctuators: ++ -- << >> && ||
	          switch (ch1) {
	            case "+":
	              return TokenType.INC;
	            case "-":
	              return TokenType.DEC;
	            case "<":
	              return TokenType.SHL;
	            case ">":
	              return TokenType.SHR;
	            case "&":
	              return TokenType.AND;
	            case "|":
	              return TokenType.OR;
	            // istanbul ignore next
	            default:
	              break; //failed
	          }
	        } else if (ch1 === "=" && _ch === ">") {
	            return TokenType.ARROW;
	          }
	      }

	      return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	    }

	    // 7.7 Punctuators

	  }, {
	    key: "scanPunctuator",
	    value: function scanPunctuator() {
	      var startLocation = this.getLocation();
	      var start = this.index;
	      var subType = this.scanPunctuatorHelper();
	      this.index += subType.name.length;
	      return { type: subType, value: subType.name, slice: this.getSlice(start, startLocation) };
	    }
	  }, {
	    key: "scanHexLiteral",
	    value: function scanHexLiteral(start, startLocation) {
	      var i = this.index;
	      while (i < this.source.length) {
	        var ch = this.source.charAt(i);
	        var hex = (0, _utils.getHexValue)(ch);
	        if (hex === -1) {
	          break;
	        }
	        i++;
	      }

	      if (this.index === i) {
	        throw this.createILLEGAL();
	      }

	      if (i < this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(i))) {
	        throw this.createILLEGAL();
	      }

	      this.index = i;

	      var slice = this.getSlice(start, startLocation);
	      return { type: TokenType.NUMBER, value: parseInt(slice.text.substr(2), 16), slice: slice };
	    }
	  }, {
	    key: "scanBinaryLiteral",
	    value: function scanBinaryLiteral(start, startLocation) {
	      var offset = this.index - start;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch !== "0" && ch !== "1") {
	          break;
	        }
	        this.index++;
	      }

	      if (this.index - start <= offset) {
	        throw this.createILLEGAL();
	      }

	      if (this.index < this.source.length && ((0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index)) || (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index)))) {
	        throw this.createILLEGAL();
	      }

	      return {
	        type: TokenType.NUMBER,
	        value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),
	        slice: this.getSlice(start, startLocation),
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "scanOctalLiteral",
	    value: function scanOctalLiteral(start, startLocation) {
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if ("0" <= ch && ch <= "7") {
	          this.index++;
	        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          break;
	        }
	      }

	      if (this.index - start === 2) {
	        throw this.createILLEGAL();
	      }

	      return {
	        type: TokenType.NUMBER,
	        value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),
	        slice: this.getSlice(start, startLocation),
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "scanLegacyOctalLiteral",
	    value: function scanLegacyOctalLiteral(start, startLocation) {
	      var isOctal = true;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if ("0" <= ch && ch <= "7") {
	          this.index++;
	        } else if (ch === "8" || ch === "9") {
	          isOctal = false;
	          this.index++;
	        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          break;
	        }
	      }

	      var slice = this.getSlice(start, startLocation);
	      if (!isOctal) {
	        this.eatDecimalLiteralSuffix();
	        return {
	          type: TokenType.NUMBER,
	          slice: slice,
	          value: +slice.text,
	          octal: true,
	          noctal: !isOctal
	        };
	      }

	      return {
	        type: TokenType.NUMBER,
	        slice: slice,
	        value: parseInt(slice.text.substr(1), 8),
	        octal: true,
	        noctal: !isOctal
	      };
	    }
	  }, {
	    key: "scanNumericLiteral",
	    value: function scanNumericLiteral() {
	      var ch = this.source.charAt(this.index);
	      // assert(ch === "." || "0" <= ch && ch <= "9")
	      var startLocation = this.getLocation();
	      var start = this.index;

	      if (ch === "0") {
	        this.index++;
	        if (this.index < this.source.length) {
	          ch = this.source.charAt(this.index);
	          if (ch === "x" || ch === "X") {
	            this.index++;
	            return this.scanHexLiteral(start, startLocation);
	          } else if (ch === "b" || ch === "B") {
	            this.index++;
	            return this.scanBinaryLiteral(start, startLocation);
	          } else if (ch === "o" || ch === "O") {
	            this.index++;
	            return this.scanOctalLiteral(start, startLocation);
	          } else if ("0" <= ch && ch <= "9") {
	            return this.scanLegacyOctalLiteral(start, startLocation);
	          }
	        } else {
	          var _slice = this.getSlice(start, startLocation);
	          return {
	            type: TokenType.NUMBER,
	            value: +_slice.text,
	            slice: _slice,
	            octal: false,
	            noctal: false
	          };
	        }
	      } else if (ch !== ".") {
	        // Must be "1".."9"
	        ch = this.source.charAt(this.index);
	        while ("0" <= ch && ch <= "9") {
	          this.index++;
	          if (this.index === this.source.length) {
	            var _slice2 = this.getSlice(start, startLocation);
	            return {
	              type: TokenType.NUMBER,
	              value: +_slice2.text,
	              slice: _slice2,
	              octal: false,
	              noctal: false
	            };
	          }
	          ch = this.source.charAt(this.index);
	        }
	      }

	      this.eatDecimalLiteralSuffix();

	      if (this.index !== this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index))) {
	        throw this.createILLEGAL();
	      }

	      var slice = this.getSlice(start, startLocation);
	      return {
	        type: TokenType.NUMBER,
	        value: +slice.text,
	        slice: slice,
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "eatDecimalLiteralSuffix",
	    value: function eatDecimalLiteralSuffix() {
	      var ch = this.source.charAt(this.index);
	      if (ch === ".") {
	        this.index++;
	        if (this.index === this.source.length) {
	          return;
	        }

	        ch = this.source.charAt(this.index);
	        while ("0" <= ch && ch <= "9") {
	          this.index++;
	          if (this.index === this.source.length) {
	            return;
	          }
	          ch = this.source.charAt(this.index);
	        }
	      }

	      // EOF not reached here
	      if (ch === "e" || ch === "E") {
	        this.index++;
	        if (this.index === this.source.length) {
	          throw this.createILLEGAL();
	        }

	        ch = this.source.charAt(this.index);
	        if (ch === "+" || ch === "-") {
	          this.index++;
	          if (this.index === this.source.length) {
	            throw this.createILLEGAL();
	          }
	          ch = this.source.charAt(this.index);
	        }

	        if ("0" <= ch && ch <= "9") {
	          while ("0" <= ch && ch <= "9") {
	            this.index++;
	            if (this.index === this.source.length) {
	              break;
	            }
	            ch = this.source.charAt(this.index);
	          }
	        } else {
	          throw this.createILLEGAL();
	        }
	      }
	    }
	  }, {
	    key: "scanStringEscape",
	    value: function scanStringEscape(str, octal) {
	      this.index++;
	      if (this.index === this.source.length) {
	        throw this.createILLEGAL();
	      }
	      var ch = this.source.charAt(this.index);
	      if (!(0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	        switch (ch) {
	          case "n":
	            str += "\n";
	            this.index++;
	            break;
	          case "r":
	            str += "\r";
	            this.index++;
	            break;
	          case "t":
	            str += "\t";
	            this.index++;
	            break;
	          case "u":
	          case "x":
	            var unescaped = void 0;
	            this.index++;
	            if (this.index >= this.source.length) {
	              throw this.createILLEGAL();
	            }
	            unescaped = ch === "u" ? this.scanUnicode() : this.scanHexEscape2();
	            if (unescaped < 0) {
	              throw this.createILLEGAL();
	            }
	            str += fromCodePoint(unescaped);
	            break;
	          case "b":
	            str += "\b";
	            this.index++;
	            break;
	          case "f":
	            str += "\f";
	            this.index++;
	            break;
	          case "v":
	            str += "\u000b";
	            this.index++;
	            break;
	          default:
	            if ("0" <= ch && ch <= "7") {
	              var octalStart = this.index;
	              var octLen = 1;
	              // 3 digits are only allowed when string starts
	              // with 0, 1, 2, 3
	              if ("0" <= ch && ch <= "3") {
	                octLen = 0;
	              }
	              var code = 0;
	              while (octLen < 3 && "0" <= ch && ch <= "7") {
	                this.index++;
	                if (octLen > 0 || ch !== "0") {
	                  octal = this.source.slice(octalStart, this.index);
	                }
	                code *= 8;
	                code += ch - "0";
	                octLen++;
	                if (this.index === this.source.length) {
	                  throw this.createILLEGAL();
	                }
	                ch = this.source.charAt(this.index);
	              }
	              str += String.fromCharCode(code);
	            } else if (ch === "8" || ch === "9") {
	              throw this.createILLEGAL();
	            } else {
	              str += ch;
	              this.index++;
	            }
	        }
	      } else {
	        this.index++;
	        if (ch === "\r" && this.source.charAt(this.index) === "\n") {
	          this.index++;
	        }
	        this.lineStart = this.index;
	        this.line++;
	      }
	      return [str, octal];
	    }
	    // 7.8.4 String Literals

	  }, {
	    key: "scanStringLiteral",
	    value: function scanStringLiteral() {
	      var str = "";

	      var quote = this.source.charAt(this.index);
	      //  assert((quote === "\"" || quote === """), "String literal must starts with a quote")

	      var startLocation = this.getLocation();
	      var start = this.index;
	      this.index++;

	      var octal = null;
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch === quote) {
	          this.index++;
	          return { type: TokenType.STRING, slice: this.getSlice(start, startLocation), str: str, octal: octal };
	        } else if (ch === "\\") {
	          var _scanStringEscape = this.scanStringEscape(str, octal);

	          var _scanStringEscape2 = _slicedToArray(_scanStringEscape, 2);

	          str = _scanStringEscape2[0];
	          octal = _scanStringEscape2[1];
	        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          str += ch;
	          this.index++;
	        }
	      }

	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "scanTemplateElement",
	    value: function scanTemplateElement() {
	      var startLocation = this.getLocation();
	      var start = this.index;
	      this.index++;
	      while (this.index < this.source.length) {
	        var ch = this.source.charCodeAt(this.index);
	        switch (ch) {
	          case 0x60:
	            // `
	            this.index++;
	            return { type: TokenType.TEMPLATE, tail: true, slice: this.getSlice(start, startLocation) };
	          case 0x24:
	            // $
	            if (this.source.charCodeAt(this.index + 1) === 0x7B) {
	              // {
	              this.index += 2;
	              return { type: TokenType.TEMPLATE, tail: false, slice: this.getSlice(start, startLocation) };
	            }
	            this.index++;
	            break;
	          case 0x5C:
	            // \\
	            {
	              var octal = this.scanStringEscape("", null)[1];
	              if (octal != null) {
	                throw this.createILLEGAL();
	              }
	              break;
	            }
	          default:
	            this.index++;
	        }
	      }

	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "scanRegExp",
	    value: function scanRegExp(str) {
	      var startLocation = this.getLocation();
	      var start = this.index;

	      var terminated = false;
	      var classMarker = false;
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch === "\\") {
	          str += ch;
	          this.index++;
	          ch = this.source.charAt(this.index);
	          // ECMA-262 7.8.5
	          if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	            throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	          }
	          str += ch;
	          this.index++;
	        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	          throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	        } else {
	          if (classMarker) {
	            if (ch === "]") {
	              classMarker = false;
	            }
	          } else {
	            if (ch === "/") {
	              terminated = true;
	              str += ch;
	              this.index++;
	              break;
	            } else if (ch === "[") {
	              classMarker = true;
	            }
	          }
	          str += ch;
	          this.index++;
	        }
	      }

	      if (!terminated) {
	        throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	      }

	      while (this.index < this.source.length) {
	        var _ch3 = this.source.charAt(this.index);
	        if (_ch3 === "\\") {
	          throw this.createError(_errors.ErrorMessages.INVALID_REGEXP_FLAGS);
	        }
	        if (!(0, _utils.isIdentifierPart)(_ch3.charCodeAt(0))) {
	          break;
	        }
	        this.index++;
	        str += _ch3;
	      }
	      return { type: TokenType.REGEXP, value: str, slice: this.getSlice(start, startLocation) };
	    }
	  }, {
	    key: "advance",
	    value: function advance() {
	      var startLocation = this.getLocation();

	      this.lastIndex = this.index;
	      this.lastLine = this.line;
	      this.lastLineStart = this.lineStart;

	      this.skipComment();

	      this.startIndex = this.index;
	      this.startLine = this.line;
	      this.startLineStart = this.lineStart;

	      if (this.lastIndex === 0) {
	        this.lastIndex = this.index;
	        this.lastLine = this.line;
	        this.lastLineStart = this.lineStart;
	      }

	      if (this.index >= this.source.length) {
	        return { type: TokenType.EOS, slice: this.getSlice(this.index, startLocation) };
	      }

	      var charCode = this.source.charCodeAt(this.index);

	      if (charCode < 0x80) {
	        if (PUNCTUATOR_START[charCode]) {
	          return this.scanPunctuator();
	        }

	        if ((0, _utils.isIdentifierStart)(charCode) || charCode === 0x5C /* backslash (\) */) {
	            return this.scanIdentifier();
	          }

	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (charCode === 0x2E) {
	          if (this.index + 1 < this.source.length && (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index + 1))) {
	            return this.scanNumericLiteral();
	          }
	          return this.scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (charCode === 0x27 || charCode === 0x22) {
	          return this.scanStringLiteral();
	        }

	        // Template literal starts with back quote (U+0060)
	        if (charCode === 0x60) {
	          return this.scanTemplateElement();
	        }

	        if (0x30 /* "0" */ <= charCode && charCode <= 0x39 /* "9" */) {
	            return this.scanNumericLiteral();
	          }

	        // Slash (/) U+002F can also start a regex.
	        throw this.createILLEGAL();
	      } else {
	        if ((0, _utils.isIdentifierStart)(charCode) || 0xD800 <= charCode && charCode <= 0xDBFF) {
	          return this.scanIdentifier();
	        }

	        throw this.createILLEGAL();
	      }
	    }
	  }, {
	    key: "eof",
	    value: function eof() {
	      return this.lookahead.type === TokenType.EOS;
	    }
	  }, {
	    key: "lex",
	    value: function lex() {
	      var prevToken = this.lookahead;
	      this.lookahead = this.advance();
	      this.tokenIndex++;
	      return prevToken;
	    }
	  }], [{
	    key: "cse2",
	    value: function cse2(id, ch1, ch2) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2;
	    }
	  }, {
	    key: "cse3",
	    value: function cse3(id, ch1, ch2, ch3) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;
	    }
	  }, {
	    key: "cse4",
	    value: function cse4(id, ch1, ch2, ch3, ch4) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;
	    }
	  }, {
	    key: "cse5",
	    value: function cse5(id, ch1, ch2, ch3, ch4, ch5) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;
	    }
	  }, {
	    key: "cse6",
	    value: function cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;
	    }
	  }, {
	    key: "cse7",
	    value: function cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;
	    }
	  }]);

	  return Tokenizer;
	}();

	exports.default = Tokenizer;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isDecimalDigit = exports.isLineTerminator = exports.isWhiteSpace = exports.isIdentifierPart = exports.isIdentifierStart = exports.isRestrictedWord = undefined;
	exports.isStrictModeReservedWord = isStrictModeReservedWord;
	exports.getHexValue = getHexValue;

	var _esutils = __webpack_require__(6);

	var isReservedWordES6 = _esutils.keyword.isReservedWordES6; /**
	                                                             * Copyright 2014 Shape Security, Inc.
	                                                             *
	                                                             * Licensed under the Apache License, Version 2.0 (the "License")
	                                                             * you may not use this file except in compliance with the License.
	                                                             * You may obtain a copy of the License at
	                                                             *
	                                                             *     http://www.apache.org/licenses/LICENSE-2.0
	                                                             *
	                                                             * Unless required by applicable law or agreed to in writing, software
	                                                             * distributed under the License is distributed on an "AS IS" BASIS,
	                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                             * See the License for the specific language governing permissions and
	                                                             * limitations under the License.
	                                                             */

	var isRestrictedWord = _esutils.keyword.isRestrictedWord;
	var isIdentifierStartES6 = _esutils.code.isIdentifierStartES6;
	var isIdentifierPartES6 = _esutils.code.isIdentifierPartES6;
	var isWhiteSpace = _esutils.code.isWhiteSpace;
	var isLineTerminator = _esutils.code.isLineTerminator;
	var isDecimalDigit = _esutils.code.isDecimalDigit;
	exports.isRestrictedWord = isRestrictedWord;
	exports.isIdentifierStart = isIdentifierStartES6;
	exports.isIdentifierPart = isIdentifierPartES6;
	exports.isWhiteSpace = isWhiteSpace;
	exports.isLineTerminator = isLineTerminator;
	exports.isDecimalDigit = isDecimalDigit;
	function isStrictModeReservedWord(id) {
	  return isReservedWordES6(id, true);
	}

	function getHexValue(rune) {
	  if ("0" <= rune && rune <= "9") {
	    return rune.charCodeAt(0) - 48;
	  }
	  if ("a" <= rune && rune <= "f") {
	    return rune.charCodeAt(0) - 87;
	  }
	  if ("A" <= rune && rune <= "F") {
	    return rune.charCodeAt(0) - 55;
	  }
	  return -1;
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/


	(function () {
	    'use strict';

	    exports.ast = __webpack_require__(7);
	    exports.code = __webpack_require__(8);
	    exports.keyword = __webpack_require__(9);
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }

	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }

	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }

	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }

	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;

	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }

	    function isProblematicIfStatement(node) {
	        var current;

	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);

	        return false;
	    }

	    module.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,

	        trailingStatement: trailingStatement
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 8 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

	    // See `tools/generate-identifier-regex.js`.
	    ES5Regex = {
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	    };

	    ES6Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };

	    function isDecimalDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39;  // 0..9
	    }

	    function isHexDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
	            0x61 <= ch && ch <= 0x66 ||     // a..f
	            0x41 <= ch && ch <= 0x46;       // A..F
	    }

	    function isOctalDigit(ch) {
	        return ch >= 0x30 && ch <= 0x37;  // 0..7
	    }

	    // 7.2 White Space

	    NON_ASCII_WHITESPACES = [
	        0x1680, 0x180E,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];

	    function isWhiteSpace(ch) {
	        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
	            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	    }

	    // 7.6 Identifier Names and Identifiers

	    function fromCodePoint(cp) {
	        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
	        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
	        return cu1 + cu2;
	    }

	    IDENTIFIER_START = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_START[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    IDENTIFIER_PART = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_PART[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch >= 0x30 && ch <= 0x39 ||  // 0..9
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    function isIdentifierStartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    function isIdentifierStartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    module.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStartES5: isIdentifierStartES5,
	        isIdentifierPartES5: isIdentifierPartES5,
	        isIdentifierStartES6: isIdentifierStartES6,
	        isIdentifierPartES6: isIdentifierPartES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var code = __webpack_require__(8);

	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isKeywordES5(id, strict) {
	        // yield should not be treated as keyword under non-strict mode.
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }

	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }

	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    function isIdentifierNameES5(id) {
	        var i, iz, ch;

	        if (id.length === 0) { return false; }

	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStartES5(ch)) {
	            return false;
	        }

	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPartES5(ch)) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function decodeUtf16(lead, trail) {
	        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	    }

	    function isIdentifierNameES6(id) {
	        var i, iz, ch, lowCh, check;

	        if (id.length === 0) { return false; }

	        check = code.isIdentifierStartES6;
	        for (i = 0, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (0xD800 <= ch && ch <= 0xDBFF) {
	                ++i;
	                if (i >= iz) { return false; }
	                lowCh = id.charCodeAt(i);
	                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
	                    return false;
	                }
	                ch = decodeUtf16(ch, lowCh);
	            }
	            if (!check(ch)) {
	                return false;
	            }
	            check = code.isIdentifierPartES6;
	        }
	        return true;
	    }

	    function isIdentifierES5(id, strict) {
	        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	    }

	    function isIdentifierES6(id, strict) {
	        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	    }

	    module.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierNameES5: isIdentifierNameES5,
	        isIdentifierNameES6: isIdentifierNameES6,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Copyright 2014 Shape Security, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License")
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var ErrorMessages = exports.ErrorMessages = {
	  UNEXPECTED_TOKEN: "Unexpected token {0}",
	  UNEXPECTED_ILLEGAL_TOKEN: "Unexpected {0}",
	  UNEXPECTED_NUMBER: "Unexpected number",
	  UNEXPECTED_STRING: "Unexpected string",
	  UNEXPECTED_IDENTIFIER: "Unexpected identifier",
	  UNEXPECTED_RESERVED_WORD: "Unexpected reserved word",
	  UNEXPECTED_TEMPLATE: "Unexpected template",
	  UNEXPECTED_EOS: "Unexpected end of input",
	  UNEXPECTED_LINE_TERMINATOR: "Unexpected line terminator",
	  NEWLINE_AFTER_THROW: "Illegal newline after throw",
	  UNTERMINATED_REGEXP: "Invalid regular expression: missing /",
	  INVALID_REGEXP_FLAGS: "Invalid regular expression flags",
	  INVALID_LHS_IN_ASSIGNMENT: "Invalid left-hand side in assignment",
	  INVALID_LHS_IN_FOR_IN: "Invalid left-hand side in for-in",
	  INVALID_LHS_IN_FOR_OF: "Invalid left-hand side in for-of",
	  INVALID_UPDATE_OPERAND: "Increment/decrement target must be an identifier or member expression",
	  MULTIPLE_DEFAULTS_IN_SWITCH: "More than one default clause in switch statement",
	  NO_CATCH_OR_FINALLY: "Missing catch or finally after try",
	  ILLEGAL_RETURN: "Illegal return statement",
	  ILLEGAL_ARROW_FUNCTION_PARAMS: "Illegal arrow function parameter list",
	  INVALID_VAR_INIT_FOR_IN: "Invalid variable declaration in for-in statement",
	  INVALID_VAR_INIT_FOR_OF: "Invalid variable declaration in for-of statement",
	  ILLEGAL_PROPERTY: "Illegal property initializer"
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ALL_PHASES = exports.Types = undefined;

	var _immutable = __webpack_require__(11);

	var _errors = __webpack_require__(13);

	var _bindingMap = __webpack_require__(14);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _ramdaFantasy = __webpack_require__(15);

	var _tokenizer = __webpack_require__(4);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const Just_786 = _ramdaFantasy.Maybe.Just;
	const Nothing_787 = _ramdaFantasy.Maybe.Nothing;
	function sizeDecending_788(a_791, b_792) {
	  if (a_791.scopes.size > b_792.scopes.size) {
	    return -1;
	  } else if (b_792.scopes.size > a_791.scopes.size) {
	    return 1;
	  } else {
	    return 0;
	  }
	}
	let Types_789 = { null: { match: token_793 => !Types_789.delimiter.match(token_793) && token_793.type === _tokenizer.TokenType.NULL, create: (value_794, stx_795) => new Syntax({ type: _tokenizer.TokenType.NULL, value: null }, stx_795) }, number: { match: token_796 => !Types_789.delimiter.match(token_796) && token_796.type.klass === _tokenizer.TokenClass.NumericLiteral, create: (value_797, stx_798) => new Syntax({ type: _tokenizer.TokenType.NUMBER, value: value_797 }, stx_798) }, string: { match: token_799 => !Types_789.delimiter.match(token_799) && token_799.type.klass === _tokenizer.TokenClass.StringLiteral, create: (value_800, stx_801) => new Syntax({ type: _tokenizer.TokenType.STRING, str: value_800 }, stx_801) }, punctuator: { match: token_802 => !Types_789.delimiter.match(token_802) && token_802.type.klass === _tokenizer.TokenClass.Punctuator, create: (value_803, stx_804) => new Syntax({ type: { klass: _tokenizer.TokenClass.Punctuator, name: value_803 }, value: value_803 }, stx_804) }, keyword: { match: token_805 => !Types_789.delimiter.match(token_805) && token_805.type.klass === _tokenizer.TokenClass.Keyword, create: (value_806, stx_807) => new Syntax({ type: { klass: _tokenizer.TokenClass.Keyword, name: value_806 }, value: value_806 }, stx_807) }, identifier: { match: token_808 => !Types_789.delimiter.match(token_808) && token_808.type.klass === _tokenizer.TokenClass.Ident, create: (value_809, stx_810) => new Syntax({ type: _tokenizer.TokenType.IDENTIFIER, value: value_809 }, stx_810) }, regularExpression: { match: token_811 => !Types_789.delimiter.match(token_811) && token_811.type.klass === _tokenizer.TokenClass.RegularExpression, create: (value_812, stx_813) => new Syntax({ type: _tokenizer.TokenType.REGEXP, value: value_812 }, stx_813) }, braces: { match: token_814 => Types_789.delimiter.match(token_814) && token_814.get(0).token.type === _tokenizer.TokenType.LBRACE, create: (inner_815, stx_816) => {
	      let left_817 = new Syntax({ type: _tokenizer.TokenType.LBRACE, value: "{" });
	      let right_818 = new Syntax({ type: _tokenizer.TokenType.RBRACE, value: "}" });
	      return new Syntax(_immutable.List.of(left_817).concat(inner_815).push(right_818), stx_816);
	    } }, brackets: { match: token_819 => Types_789.delimiter.match(token_819) && token_819.get(0).token.type === _tokenizer.TokenType.LBRACK, create: (inner_820, stx_821) => {
	      let left_822 = new Syntax({ type: _tokenizer.TokenType.LBRACK, value: "[" });
	      let right_823 = new Syntax({ type: _tokenizer.TokenType.RBRACK, value: "]" });
	      return new Syntax(_immutable.List.of(left_822).concat(inner_820).push(right_823), stx_821);
	    } }, parens: { match: token_824 => Types_789.delimiter.match(token_824) && token_824.get(0).token.type === _tokenizer.TokenType.LPAREN, create: (inner_825, stx_826) => {
	      let left_827 = new Syntax({ type: _tokenizer.TokenType.LPAREN, value: "(" });
	      let right_828 = new Syntax({ type: _tokenizer.TokenType.RPAREN, value: ")" });
	      return new Syntax(_immutable.List.of(left_827).concat(inner_825).push(right_828), stx_826);
	    } }, assign: { match: token_829 => {
	      if (Types_789.punctuator.match(token_829)) {
	        switch (token_829.value) {
	          case "=":
	          case "|=":
	          case "^=":
	          case "&=":
	          case "<<=":
	          case ">>=":
	          case ">>>=":
	          case "+=":
	          case "-=":
	          case "*=":
	          case "/=":
	          case "%=":
	            return true;
	          default:
	            return false;
	        }
	      }
	      return false;
	    } }, boolean: { match: token_830 => !Types_789.delimiter.match(token_830) && token_830.type === _tokenizer.TokenType.TRUE || token_830.type === _tokenizer.TokenType.FALSE }, template: { match: token_831 => !Types_789.delimiter.match(token_831) && token_831.type === _tokenizer.TokenType.TEMPLATE }, delimiter: { match: token_832 => _immutable.List.isList(token_832) }, syntaxTemplate: { match: token_833 => Types_789.delimiter.match(token_833) && token_833.get(0).val() === "#`" }, eof: { match: token_834 => !Types_789.delimiter.match(token_834) && token_834.type === _tokenizer.TokenType.EOS } };
	;
	const ALL_PHASES_790 = {};
	;
	class Syntax {
	  constructor(token_835) {
	    let oldstx_836 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    this.token = token_835;
	    this.bindings = oldstx_836.bindings != null ? oldstx_836.bindings : new _bindingMap2.default();
	    this.scopesets = oldstx_836.scopesets != null ? oldstx_836.scopesets : { all: (0, _immutable.List)(), phase: (0, _immutable.Map)() };
	    Object.freeze(this);
	  }
	  static of(token_837) {
	    let stx_838 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return new Syntax(token_837, stx_838);
	  }
	  static from(type_839, value_840) {
	    let stx_841 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	    if (!Types_789[type_839]) {
	      throw new Error(type_839 + " is not a valid type");
	    } else if (!Types_789[type_839].create) {
	      throw new Error("Cannot create a syntax from type " + type_839);
	    }
	    return Types_789[type_839].create(value_840, stx_841);
	  }
	  static fromNull() {
	    let stx_842 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    return Syntax.from("null", null, stx_842);
	  }
	  static fromNumber(value_843) {
	    let stx_844 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("number", value_843, stx_844);
	  }
	  static fromString(value_845) {
	    let stx_846 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("string", value_845, stx_846);
	  }
	  static fromPunctuator(value_847) {
	    let stx_848 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("punctuator", value_847, stx_848);
	  }
	  static fromKeyword(value_849) {
	    let stx_850 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("keyword", value_849, stx_850);
	  }
	  static fromIdentifier(value_851) {
	    let stx_852 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("identifier", value_851, stx_852);
	  }
	  static fromRegularExpression(value_853) {
	    let stx_854 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("regularExpression", value_853, stx_854);
	  }
	  static fromBraces(inner_855) {
	    let stx_856 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("braces", inner_855, stx_856);
	  }
	  static fromBrackets(inner_857) {
	    let stx_858 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("brackets", inner_857, stx_858);
	  }
	  static fromParens(inner_859) {
	    let stx_860 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    return Syntax.from("parens", inner_859, stx_860);
	  }
	  resolve(phase_861) {
	    (0, _errors.assert)(phase_861 != null, "must provide a phase to resolve");
	    let allScopes_862 = this.scopesets.all;
	    let stxScopes_863 = this.scopesets.phase.has(phase_861) ? this.scopesets.phase.get(phase_861) : (0, _immutable.List)();
	    stxScopes_863 = allScopes_862.concat(stxScopes_863);
	    if (stxScopes_863.size === 0 || !(this.match("identifier") || this.match("keyword"))) {
	      return this.token.value;
	    }
	    let scope_864 = stxScopes_863.last();
	    let bindings_865 = this.bindings;
	    if (scope_864) {
	      let scopesetBindingList = bindings_865.get(this);
	      if (scopesetBindingList) {
	        let biggestBindingPair = scopesetBindingList.filter(_ref => {
	          let scopes = _ref.scopes;
	          let binding = _ref.binding;

	          return scopes.isSubset(stxScopes_863);
	        }).sort(sizeDecending_788);
	        if (biggestBindingPair.size >= 2 && biggestBindingPair.get(0).scopes.size === biggestBindingPair.get(1).scopes.size) {
	          let debugBase = "{" + stxScopes_863.map(s_866 => s_866.toString()).join(", ") + "}";
	          let debugAmbigousScopesets = biggestBindingPair.map(_ref2 => {
	            let scopes = _ref2.scopes;

	            return "{" + scopes.map(s_867 => s_867.toString()).join(", ") + "}";
	          }).join(", ");
	          throw new Error("Scopeset " + debugBase + " has ambiguous subsets " + debugAmbigousScopesets);
	        } else if (biggestBindingPair.size !== 0) {
	          let bindingStr = biggestBindingPair.get(0).binding.toString();
	          if (_ramdaFantasy.Maybe.isJust(biggestBindingPair.get(0).alias)) {
	            return biggestBindingPair.get(0).alias.getOrElse(null).resolve(phase_861);
	          }
	          return bindingStr;
	        }
	      }
	    }
	    return this.token.value;
	  }
	  val() {
	    (0, _errors.assert)(!this.match("delimiter"), "cannot get the val of a delimiter");
	    if (this.match("string")) {
	      return this.token.str;
	    }
	    if (this.match("template")) {
	      return this.token.items.map(el_868 => {
	        if (el_868 instanceof Syntax && el_868.match("delimiter")) {
	          return "${...}";
	        }
	        return el_868.slice.text;
	      }).join("");
	    }
	    return this.token.value;
	  }
	  lineNumber() {
	    if (!this.match("delimiter")) {
	      return this.token.slice.startLocation.line;
	    } else {
	      return this.token.get(0).lineNumber();
	    }
	  }
	  setLineNumber(line_869) {
	    let newTok_870 = {};
	    if (this.isDelimiter()) {
	      newTok_870 = this.token.map(s_871 => s_871.setLineNumber(line_869));
	    } else {
	      for (let key of Object.keys(this.token)) {
	        newTok_870[key] = this.token[key];
	      }
	      (0, _errors.assert)(newTok_870.slice && newTok_870.slice.startLocation, "all tokens must have line info");
	      newTok_870.slice.startLocation.line = line_869;
	    }
	    return new Syntax(newTok_870, this);
	  }
	  inner() {
	    (0, _errors.assert)(this.match("delimiter"), "can only get the inner of a delimiter");
	    return this.token.slice(1, this.token.size - 1);
	  }
	  addScope(scope_872, bindings_873, phase_874) {
	    let options_875 = arguments.length <= 3 || arguments[3] === undefined ? { flip: false } : arguments[3];

	    let token_876 = this.match("delimiter") ? this.token.map(s_880 => s_880.addScope(scope_872, bindings_873, phase_874, options_875)) : this.token;
	    if (this.match("template")) {
	      token_876 = { type: this.token.type, items: token_876.items.map(it_881 => {
	          if (it_881 instanceof Syntax && it_881.match("delimiter")) {
	            return it_881.addScope(scope_872, bindings_873, phase_874, options_875);
	          }
	          return it_881;
	        }) };
	    }
	    let oldScopeset_877;
	    if (phase_874 === ALL_PHASES_790) {
	      oldScopeset_877 = this.scopesets.all;
	    } else {
	      oldScopeset_877 = this.scopesets.phase.has(phase_874) ? this.scopesets.phase.get(phase_874) : (0, _immutable.List)();
	    }
	    let newScopeset_878;
	    if (options_875.flip) {
	      let index = oldScopeset_877.indexOf(scope_872);
	      if (index !== -1) {
	        newScopeset_878 = oldScopeset_877.remove(index);
	      } else {
	        newScopeset_878 = oldScopeset_877.push(scope_872);
	      }
	    } else {
	      newScopeset_878 = oldScopeset_877.push(scope_872);
	    }
	    let newstx_879 = { bindings: bindings_873, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } };
	    if (phase_874 === ALL_PHASES_790) {
	      newstx_879.scopesets.all = newScopeset_878;
	    } else {
	      newstx_879.scopesets.phase = newstx_879.scopesets.phase.set(phase_874, newScopeset_878);
	    }
	    return new Syntax(token_876, newstx_879);
	  }
	  removeScope(scope_882, phase_883) {
	    let token_884 = this.match("delimiter") ? this.token.map(s_890 => s_890.removeScope(scope_882, phase_883)) : this.token;
	    let phaseScopeset_885 = this.scopesets.phase.has(phase_883) ? this.scopesets.phase.get(phase_883) : (0, _immutable.List)();
	    let allScopeset_886 = this.scopesets.all;
	    let newstx_887 = { bindings: this.bindings, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } };
	    let phaseIndex_888 = phaseScopeset_885.indexOf(scope_882);
	    let allIndex_889 = allScopeset_886.indexOf(scope_882);
	    if (phaseIndex_888 !== -1) {
	      newstx_887.scopesets.phase = this.scopesets.phase.set(phase_883, phaseScopeset_885.remove(phaseIndex_888));
	    } else if (allIndex_889 !== -1) {
	      newstx_887.scopesets.all = allScopeset_886.remove(allIndex_889);
	    }
	    return new Syntax(token_884, newstx_887);
	  }
	  match(type_891, value_892) {
	    if (!Types_789[type_891]) {
	      throw new Error(type_891 + " is an invalid type");
	    }
	    return Types_789[type_891].match(this.token) && (value_892 == null || (value_892 instanceof RegExp ? value_892.test(this.val()) : this.val() == value_892));
	  }
	  isIdentifier(value_893) {
	    return this.match("identifier", value_893);
	  }
	  isAssign(value_894) {
	    return this.match("assign", value_894);
	  }
	  isBooleanLiteral(value_895) {
	    return this.match("boolean", value_895);
	  }
	  isKeyword(value_896) {
	    return this.match("keyword", value_896);
	  }
	  isNullLiteral(value_897) {
	    return this.match("null", value_897);
	  }
	  isNumericLiteral(value_898) {
	    return this.match("number", value_898);
	  }
	  isPunctuator(value_899) {
	    return this.match("punctuator", value_899);
	  }
	  isStringLiteral(value_900) {
	    return this.match("string", value_900);
	  }
	  isRegularExpression(value_901) {
	    return this.match("regularExpression", value_901);
	  }
	  isTemplate(value_902) {
	    return this.match("template", value_902);
	  }
	  isDelimiter(value_903) {
	    return this.match("delimiter", value_903);
	  }
	  isParens(value_904) {
	    return this.match("parens", value_904);
	  }
	  isBraces(value_905) {
	    return this.match("braces", value_905);
	  }
	  isBrackets(value_906) {
	    return this.match("brackets", value_906);
	  }
	  isSyntaxTemplate(value_907) {
	    return this.match("syntaxTemplate", value_907);
	  }
	  isEOF(value_908) {
	    return this.match("eof", value_908);
	  }
	  toString() {
	    if (this.match("delimiter")) {
	      return this.token.map(s_909 => s_909.toString()).join(" ");
	    }
	    if (this.match("string")) {
	      return "'" + this.token.str;
	    }
	    if (this.match("template")) {
	      return this.val();
	    }
	    return this.token.value;
	  }
	}
	exports.default = Syntax;
	exports.Types = Types_789;
	exports.ALL_PHASES = ALL_PHASES_790;
	//# sourceMappingURL=data:application/json;base64,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IjpbImltcG9ydCB7TGlzdCwgTWFwfSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgQmluZGluZ01hcCBmcm9tIFwiLi9iaW5kaW5nLW1hcFwiO1xuaW1wb3J0IHtNYXliZX0gZnJvbSBcInJhbWRhLWZhbnRhc3lcIjtcbmltcG9ydCB7VG9rZW5UeXBlLCBUb2tlbkNsYXNzfSBmcm9tIFwic2hpZnQtcGFyc2VyL2Rpc3QvdG9rZW5pemVyXCI7XG5pbXBvcnQgICogYXMgXyBmcm9tIFwicmFtZGFcIjtcbmNvbnN0IEp1c3RfNzg2ID0gTWF5YmUuSnVzdDtcbmNvbnN0IE5vdGhpbmdfNzg3ID0gTWF5YmUuTm90aGluZztcbmZ1bmN0aW9uIHNpemVEZWNlbmRpbmdfNzg4KGFfNzkxLCBiXzc5Mikge1xuICBpZiAoYV83OTEuc2NvcGVzLnNpemUgPiBiXzc5Mi5zY29wZXMuc2l6ZSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiXzc5Mi5zY29wZXMuc2l6ZSA+IGFfNzkxLnNjb3Blcy5zaXplKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbmxldCBUeXBlc183ODkgPSB7bnVsbDoge21hdGNoOiB0b2tlbl83OTMgPT4gIVR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fNzkzKSAmJiB0b2tlbl83OTMudHlwZSA9PT0gVG9rZW5UeXBlLk5VTEwsIGNyZWF0ZTogKHZhbHVlXzc5NCwgc3R4Xzc5NSkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLk5VTEwsIHZhbHVlOiBudWxsfSwgc3R4Xzc5NSl9LCBudW1iZXI6IHttYXRjaDogdG9rZW5fNzk2ID0+ICFUeXBlc183ODkuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzc5NikgJiYgdG9rZW5fNzk2LnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuTnVtZXJpY0xpdGVyYWwsIGNyZWF0ZTogKHZhbHVlXzc5Nywgc3R4Xzc5OCkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLk5VTUJFUiwgdmFsdWU6IHZhbHVlXzc5N30sIHN0eF83OTgpfSwgc3RyaW5nOiB7bWF0Y2g6IHRva2VuXzc5OSA9PiAhVHlwZXNfNzg5LmRlbGltaXRlci5tYXRjaCh0b2tlbl83OTkpICYmIHRva2VuXzc5OS50eXBlLmtsYXNzID09PSBUb2tlbkNsYXNzLlN0cmluZ0xpdGVyYWwsIGNyZWF0ZTogKHZhbHVlXzgwMCwgc3R4XzgwMSkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLlNUUklORywgc3RyOiB2YWx1ZV84MDB9LCBzdHhfODAxKX0sIHB1bmN0dWF0b3I6IHttYXRjaDogdG9rZW5fODAyID0+ICFUeXBlc183ODkuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzgwMikgJiYgdG9rZW5fODAyLnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuUHVuY3R1YXRvciwgY3JlYXRlOiAodmFsdWVfODAzLCBzdHhfODA0KSA9PiBuZXcgU3ludGF4KHt0eXBlOiB7a2xhc3M6IFRva2VuQ2xhc3MuUHVuY3R1YXRvciwgbmFtZTogdmFsdWVfODAzfSwgdmFsdWU6IHZhbHVlXzgwM30sIHN0eF84MDQpfSwga2V5d29yZDoge21hdGNoOiB0b2tlbl84MDUgPT4gIVR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODA1KSAmJiB0b2tlbl84MDUudHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5LZXl3b3JkLCBjcmVhdGU6ICh2YWx1ZV84MDYsIHN0eF84MDcpID0+IG5ldyBTeW50YXgoe3R5cGU6IHtrbGFzczogVG9rZW5DbGFzcy5LZXl3b3JkLCBuYW1lOiB2YWx1ZV84MDZ9LCB2YWx1ZTogdmFsdWVfODA2fSwgc3R4XzgwNyl9LCBpZGVudGlmaWVyOiB7bWF0Y2g6IHRva2VuXzgwOCA9PiAhVHlwZXNfNzg5LmRlbGltaXRlci5tYXRjaCh0b2tlbl84MDgpICYmIHRva2VuXzgwOC50eXBlLmtsYXNzID09PSBUb2tlbkNsYXNzLklkZW50LCBjcmVhdGU6ICh2YWx1ZV84MDksIHN0eF84MTApID0+IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5JREVOVElGSUVSLCB2YWx1ZTogdmFsdWVfODA5fSwgc3R4XzgxMCl9LCByZWd1bGFyRXhwcmVzc2lvbjoge21hdGNoOiB0b2tlbl84MTEgPT4gIVR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODExKSAmJiB0b2tlbl84MTEudHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5SZWd1bGFyRXhwcmVzc2lvbiwgY3JlYXRlOiAodmFsdWVfODEyLCBzdHhfODEzKSA9PiBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuUkVHRVhQLCB2YWx1ZTogdmFsdWVfODEyfSwgc3R4XzgxMyl9LCBicmFjZXM6IHttYXRjaDogdG9rZW5fODE0ID0+IFR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODE0KSAmJiB0b2tlbl84MTQuZ2V0KDApLnRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5MQlJBQ0UsIGNyZWF0ZTogKGlubmVyXzgxNSwgc3R4XzgxNikgPT4ge1xuICBsZXQgbGVmdF84MTcgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuTEJSQUNFLCB2YWx1ZTogXCJ7XCJ9KTtcbiAgbGV0IHJpZ2h0XzgxOCA9IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5SQlJBQ0UsIHZhbHVlOiBcIn1cIn0pO1xuICByZXR1cm4gbmV3IFN5bnRheChMaXN0Lm9mKGxlZnRfODE3KS5jb25jYXQoaW5uZXJfODE1KS5wdXNoKHJpZ2h0XzgxOCksIHN0eF84MTYpO1xufX0sIGJyYWNrZXRzOiB7bWF0Y2g6IHRva2VuXzgxOSA9PiBUeXBlc183ODkuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzgxOSkgJiYgdG9rZW5fODE5LmdldCgwKS50b2tlbi50eXBlID09PSBUb2tlblR5cGUuTEJSQUNLLCBjcmVhdGU6IChpbm5lcl84MjAsIHN0eF84MjEpID0+IHtcbiAgbGV0IGxlZnRfODIyID0gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLkxCUkFDSywgdmFsdWU6IFwiW1wifSk7XG4gIGxldCByaWdodF84MjMgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuUkJSQUNLLCB2YWx1ZTogXCJdXCJ9KTtcbiAgcmV0dXJuIG5ldyBTeW50YXgoTGlzdC5vZihsZWZ0XzgyMikuY29uY2F0KGlubmVyXzgyMCkucHVzaChyaWdodF84MjMpLCBzdHhfODIxKTtcbn19LCBwYXJlbnM6IHttYXRjaDogdG9rZW5fODI0ID0+IFR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODI0KSAmJiB0b2tlbl84MjQuZ2V0KDApLnRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5MUEFSRU4sIGNyZWF0ZTogKGlubmVyXzgyNSwgc3R4XzgyNikgPT4ge1xuICBsZXQgbGVmdF84MjcgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuTFBBUkVOLCB2YWx1ZTogXCIoXCJ9KTtcbiAgbGV0IHJpZ2h0XzgyOCA9IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5SUEFSRU4sIHZhbHVlOiBcIilcIn0pO1xuICByZXR1cm4gbmV3IFN5bnRheChMaXN0Lm9mKGxlZnRfODI3KS5jb25jYXQoaW5uZXJfODI1KS5wdXNoKHJpZ2h0XzgyOCksIHN0eF84MjYpO1xufX0sIGFzc2lnbjoge21hdGNoOiB0b2tlbl84MjkgPT4ge1xuICBpZiAoVHlwZXNfNzg5LnB1bmN0dWF0b3IubWF0Y2godG9rZW5fODI5KSkge1xuICAgIHN3aXRjaCAodG9rZW5fODI5LnZhbHVlKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgY2FzZSBcInw9XCI6XG4gICAgICBjYXNlIFwiXj1cIjpcbiAgICAgIGNhc2UgXCImPVwiOlxuICAgICAgY2FzZSBcIjw8PVwiOlxuICAgICAgY2FzZSBcIj4+PVwiOlxuICAgICAgY2FzZSBcIj4+Pj1cIjpcbiAgICAgIGNhc2UgXCIrPVwiOlxuICAgICAgY2FzZSBcIi09XCI6XG4gICAgICBjYXNlIFwiKj1cIjpcbiAgICAgIGNhc2UgXCIvPVwiOlxuICAgICAgY2FzZSBcIiU9XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59fSwgYm9vbGVhbjoge21hdGNoOiB0b2tlbl84MzAgPT4gIVR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODMwKSAmJiB0b2tlbl84MzAudHlwZSA9PT0gVG9rZW5UeXBlLlRSVUUgfHwgdG9rZW5fODMwLnR5cGUgPT09IFRva2VuVHlwZS5GQUxTRX0sIHRlbXBsYXRlOiB7bWF0Y2g6IHRva2VuXzgzMSA9PiAhVHlwZXNfNzg5LmRlbGltaXRlci5tYXRjaCh0b2tlbl84MzEpICYmIHRva2VuXzgzMS50eXBlID09PSBUb2tlblR5cGUuVEVNUExBVEV9LCBkZWxpbWl0ZXI6IHttYXRjaDogdG9rZW5fODMyID0+IExpc3QuaXNMaXN0KHRva2VuXzgzMil9LCBzeW50YXhUZW1wbGF0ZToge21hdGNoOiB0b2tlbl84MzMgPT4gVHlwZXNfNzg5LmRlbGltaXRlci5tYXRjaCh0b2tlbl84MzMpICYmIHRva2VuXzgzMy5nZXQoMCkudmFsKCkgPT09IFwiI2BcIn0sIGVvZjoge21hdGNoOiB0b2tlbl84MzQgPT4gIVR5cGVzXzc4OS5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODM0KSAmJiB0b2tlbl84MzQudHlwZSA9PT0gVG9rZW5UeXBlLkVPU319O1xuO1xuY29uc3QgQUxMX1BIQVNFU183OTAgPSB7fTtcbjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bnRheCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuXzgzNSwgb2xkc3R4XzgzNiA9IHt9KSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuXzgzNTtcbiAgICB0aGlzLmJpbmRpbmdzID0gb2xkc3R4XzgzNi5iaW5kaW5ncyAhPSBudWxsID8gb2xkc3R4XzgzNi5iaW5kaW5ncyA6IG5ldyBCaW5kaW5nTWFwO1xuICAgIHRoaXMuc2NvcGVzZXRzID0gb2xkc3R4XzgzNi5zY29wZXNldHMgIT0gbnVsbCA/IG9sZHN0eF84MzYuc2NvcGVzZXRzIDoge2FsbDogTGlzdCgpLCBwaGFzZTogTWFwKCl9O1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgc3RhdGljIG9mKHRva2VuXzgzNywgc3R4XzgzOCA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXgodG9rZW5fODM3LCBzdHhfODM4KTtcbiAgfVxuICBzdGF0aWMgZnJvbSh0eXBlXzgzOSwgdmFsdWVfODQwLCBzdHhfODQxID0ge30pIHtcbiAgICBpZiAoIVR5cGVzXzc4OVt0eXBlXzgzOV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlXzgzOSArIFwiIGlzIG5vdCBhIHZhbGlkIHR5cGVcIik7XG4gICAgfSBlbHNlIGlmICghVHlwZXNfNzg5W3R5cGVfODM5XS5jcmVhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBzeW50YXggZnJvbSB0eXBlIFwiICsgdHlwZV84MzkpO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZXNfNzg5W3R5cGVfODM5XS5jcmVhdGUodmFsdWVfODQwLCBzdHhfODQxKTtcbiAgfVxuICBzdGF0aWMgZnJvbU51bGwoc3R4Xzg0MiA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwibnVsbFwiLCBudWxsLCBzdHhfODQyKTtcbiAgfVxuICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZV84NDMsIHN0eF84NDQgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcIm51bWJlclwiLCB2YWx1ZV84NDMsIHN0eF84NDQpO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlXzg0NSwgc3R4Xzg0NiA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwic3RyaW5nXCIsIHZhbHVlXzg0NSwgc3R4Xzg0Nik7XG4gIH1cbiAgc3RhdGljIGZyb21QdW5jdHVhdG9yKHZhbHVlXzg0Nywgc3R4Xzg0OCA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwicHVuY3R1YXRvclwiLCB2YWx1ZV84NDcsIHN0eF84NDgpO1xuICB9XG4gIHN0YXRpYyBmcm9tS2V5d29yZCh2YWx1ZV84NDksIHN0eF84NTAgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcImtleXdvcmRcIiwgdmFsdWVfODQ5LCBzdHhfODUwKTtcbiAgfVxuICBzdGF0aWMgZnJvbUlkZW50aWZpZXIodmFsdWVfODUxLCBzdHhfODUyID0ge30pIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oXCJpZGVudGlmaWVyXCIsIHZhbHVlXzg1MSwgc3R4Xzg1Mik7XG4gIH1cbiAgc3RhdGljIGZyb21SZWd1bGFyRXhwcmVzc2lvbih2YWx1ZV84NTMsIHN0eF84NTQgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcInJlZ3VsYXJFeHByZXNzaW9uXCIsIHZhbHVlXzg1Mywgc3R4Xzg1NCk7XG4gIH1cbiAgc3RhdGljIGZyb21CcmFjZXMoaW5uZXJfODU1LCBzdHhfODU2ID0ge30pIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oXCJicmFjZXNcIiwgaW5uZXJfODU1LCBzdHhfODU2KTtcbiAgfVxuICBzdGF0aWMgZnJvbUJyYWNrZXRzKGlubmVyXzg1Nywgc3R4Xzg1OCA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwiYnJhY2tldHNcIiwgaW5uZXJfODU3LCBzdHhfODU4KTtcbiAgfVxuICBzdGF0aWMgZnJvbVBhcmVucyhpbm5lcl84NTksIHN0eF84NjAgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcInBhcmVuc1wiLCBpbm5lcl84NTksIHN0eF84NjApO1xuICB9XG4gIHJlc29sdmUocGhhc2VfODYxKSB7XG4gICAgYXNzZXJ0KHBoYXNlXzg2MSAhPSBudWxsLCBcIm11c3QgcHJvdmlkZSBhIHBoYXNlIHRvIHJlc29sdmVcIik7XG4gICAgbGV0IGFsbFNjb3Blc184NjIgPSB0aGlzLnNjb3Blc2V0cy5hbGw7XG4gICAgbGV0IHN0eFNjb3Blc184NjMgPSB0aGlzLnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfODYxKSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZV84NjEpIDogTGlzdCgpO1xuICAgIHN0eFNjb3Blc184NjMgPSBhbGxTY29wZXNfODYyLmNvbmNhdChzdHhTY29wZXNfODYzKTtcbiAgICBpZiAoc3R4U2NvcGVzXzg2My5zaXplID09PSAwIHx8ICEodGhpcy5tYXRjaChcImlkZW50aWZpZXJcIikgfHwgdGhpcy5tYXRjaChcImtleXdvcmRcIikpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi52YWx1ZTtcbiAgICB9XG4gICAgbGV0IHNjb3BlXzg2NCA9IHN0eFNjb3Blc184NjMubGFzdCgpO1xuICAgIGxldCBiaW5kaW5nc184NjUgPSB0aGlzLmJpbmRpbmdzO1xuICAgIGlmIChzY29wZV84NjQpIHtcbiAgICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gYmluZGluZ3NfODY1LmdldCh0aGlzKTtcbiAgICAgIGlmIChzY29wZXNldEJpbmRpbmdMaXN0KSB7XG4gICAgICAgIGxldCBiaWdnZXN0QmluZGluZ1BhaXIgPSBzY29wZXNldEJpbmRpbmdMaXN0LmZpbHRlcigoe3Njb3BlcywgYmluZGluZ30pID0+IHtcbiAgICAgICAgICByZXR1cm4gc2NvcGVzLmlzU3Vic2V0KHN0eFNjb3Blc184NjMpO1xuICAgICAgICB9KS5zb3J0KHNpemVEZWNlbmRpbmdfNzg4KTtcbiAgICAgICAgaWYgKGJpZ2dlc3RCaW5kaW5nUGFpci5zaXplID49IDIgJiYgYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5zY29wZXMuc2l6ZSA9PT0gYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgxKS5zY29wZXMuc2l6ZSkge1xuICAgICAgICAgIGxldCBkZWJ1Z0Jhc2UgPSBcIntcIiArIHN0eFNjb3Blc184NjMubWFwKHNfODY2ID0+IHNfODY2LnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuICAgICAgICAgIGxldCBkZWJ1Z0FtYmlnb3VzU2NvcGVzZXRzID0gYmlnZ2VzdEJpbmRpbmdQYWlyLm1hcCgoe3Njb3Blc30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBcIntcIiArIHNjb3Blcy5tYXAoc184NjcgPT4gc184NjcudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3Blc2V0IFwiICsgZGVidWdCYXNlICsgXCIgaGFzIGFtYmlndW91cyBzdWJzZXRzIFwiICsgZGVidWdBbWJpZ291c1Njb3Blc2V0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmlnZ2VzdEJpbmRpbmdQYWlyLnNpemUgIT09IDApIHtcbiAgICAgICAgICBsZXQgYmluZGluZ1N0ciA9IGJpZ2dlc3RCaW5kaW5nUGFpci5nZXQoMCkuYmluZGluZy50b1N0cmluZygpO1xuICAgICAgICAgIGlmIChNYXliZS5pc0p1c3QoYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5hbGlhcykpIHtcbiAgICAgICAgICAgIHJldHVybiBiaWdnZXN0QmluZGluZ1BhaXIuZ2V0KDApLmFsaWFzLmdldE9yRWxzZShudWxsKS5yZXNvbHZlKHBoYXNlXzg2MSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiaW5kaW5nU3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG4gIHZhbCgpIHtcbiAgICBhc3NlcnQoIXRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIiksIFwiY2Fubm90IGdldCB0aGUgdmFsIG9mIGEgZGVsaW1pdGVyXCIpO1xuICAgIGlmICh0aGlzLm1hdGNoKFwic3RyaW5nXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5zdHI7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLml0ZW1zLm1hcChlbF84NjggPT4ge1xuICAgICAgICBpZiAoZWxfODY4IGluc3RhbmNlb2YgU3ludGF4ICYmIGVsXzg2OC5tYXRjaChcImRlbGltaXRlclwiKSkge1xuICAgICAgICAgIHJldHVybiBcIiR7Li4ufVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbF84Njguc2xpY2UudGV4dDtcbiAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG4gIGxpbmVOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5zbGljZS5zdGFydExvY2F0aW9uLmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLmdldCgwKS5saW5lTnVtYmVyKCk7XG4gICAgfVxuICB9XG4gIHNldExpbmVOdW1iZXIobGluZV84NjkpIHtcbiAgICBsZXQgbmV3VG9rXzg3MCA9IHt9O1xuICAgIGlmICh0aGlzLmlzRGVsaW1pdGVyKCkpIHtcbiAgICAgIG5ld1Rva184NzAgPSB0aGlzLnRva2VuLm1hcChzXzg3MSA9PiBzXzg3MS5zZXRMaW5lTnVtYmVyKGxpbmVfODY5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnRva2VuKSkge1xuICAgICAgICBuZXdUb2tfODcwW2tleV0gPSB0aGlzLnRva2VuW2tleV07XG4gICAgICB9XG4gICAgICBhc3NlcnQobmV3VG9rXzg3MC5zbGljZSAmJiBuZXdUb2tfODcwLnNsaWNlLnN0YXJ0TG9jYXRpb24sIFwiYWxsIHRva2VucyBtdXN0IGhhdmUgbGluZSBpbmZvXCIpO1xuICAgICAgbmV3VG9rXzg3MC5zbGljZS5zdGFydExvY2F0aW9uLmxpbmUgPSBsaW5lXzg2OTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTeW50YXgobmV3VG9rXzg3MCwgdGhpcyk7XG4gIH1cbiAgaW5uZXIoKSB7XG4gICAgYXNzZXJ0KHRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIiksIFwiY2FuIG9ubHkgZ2V0IHRoZSBpbm5lciBvZiBhIGRlbGltaXRlclwiKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbi5zbGljZSgxLCB0aGlzLnRva2VuLnNpemUgLSAxKTtcbiAgfVxuICBhZGRTY29wZShzY29wZV84NzIsIGJpbmRpbmdzXzg3MywgcGhhc2VfODc0LCBvcHRpb25zXzg3NSA9IHtmbGlwOiBmYWxzZX0pIHtcbiAgICBsZXQgdG9rZW5fODc2ID0gdGhpcy5tYXRjaChcImRlbGltaXRlclwiKSA/IHRoaXMudG9rZW4ubWFwKHNfODgwID0+IHNfODgwLmFkZFNjb3BlKHNjb3BlXzg3MiwgYmluZGluZ3NfODczLCBwaGFzZV84NzQsIG9wdGlvbnNfODc1KSkgOiB0aGlzLnRva2VuO1xuICAgIGlmICh0aGlzLm1hdGNoKFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHRva2VuXzg3NiA9IHt0eXBlOiB0aGlzLnRva2VuLnR5cGUsIGl0ZW1zOiB0b2tlbl84NzYuaXRlbXMubWFwKGl0Xzg4MSA9PiB7XG4gICAgICAgIGlmIChpdF84ODEgaW5zdGFuY2VvZiBTeW50YXggJiYgaXRfODgxLm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGl0Xzg4MS5hZGRTY29wZShzY29wZV84NzIsIGJpbmRpbmdzXzg3MywgcGhhc2VfODc0LCBvcHRpb25zXzg3NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0Xzg4MTtcbiAgICAgIH0pfTtcbiAgICB9XG4gICAgbGV0IG9sZFNjb3Blc2V0Xzg3NztcbiAgICBpZiAocGhhc2VfODc0ID09PSBBTExfUEhBU0VTXzc5MCkge1xuICAgICAgb2xkU2NvcGVzZXRfODc3ID0gdGhpcy5zY29wZXNldHMuYWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRTY29wZXNldF84NzcgPSB0aGlzLnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfODc0KSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZV84NzQpIDogTGlzdCgpO1xuICAgIH1cbiAgICBsZXQgbmV3U2NvcGVzZXRfODc4O1xuICAgIGlmIChvcHRpb25zXzg3NS5mbGlwKSB7XG4gICAgICBsZXQgaW5kZXggPSBvbGRTY29wZXNldF84NzcuaW5kZXhPZihzY29wZV84NzIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBuZXdTY29wZXNldF84NzggPSBvbGRTY29wZXNldF84NzcucmVtb3ZlKGluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Njb3Blc2V0Xzg3OCA9IG9sZFNjb3Blc2V0Xzg3Ny5wdXNoKHNjb3BlXzg3Mik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Njb3Blc2V0Xzg3OCA9IG9sZFNjb3Blc2V0Xzg3Ny5wdXNoKHNjb3BlXzg3Mik7XG4gICAgfVxuICAgIGxldCBuZXdzdHhfODc5ID0ge2JpbmRpbmdzOiBiaW5kaW5nc184NzMsIHNjb3Blc2V0czoge2FsbDogdGhpcy5zY29wZXNldHMuYWxsLCBwaGFzZTogdGhpcy5zY29wZXNldHMucGhhc2V9fTtcbiAgICBpZiAocGhhc2VfODc0ID09PSBBTExfUEhBU0VTXzc5MCkge1xuICAgICAgbmV3c3R4Xzg3OS5zY29wZXNldHMuYWxsID0gbmV3U2NvcGVzZXRfODc4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdzdHhfODc5LnNjb3Blc2V0cy5waGFzZSA9IG5ld3N0eF84Nzkuc2NvcGVzZXRzLnBoYXNlLnNldChwaGFzZV84NzQsIG5ld1Njb3Blc2V0Xzg3OCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3ludGF4KHRva2VuXzg3NiwgbmV3c3R4Xzg3OSk7XG4gIH1cbiAgcmVtb3ZlU2NvcGUoc2NvcGVfODgyLCBwaGFzZV84ODMpIHtcbiAgICBsZXQgdG9rZW5fODg0ID0gdGhpcy5tYXRjaChcImRlbGltaXRlclwiKSA/IHRoaXMudG9rZW4ubWFwKHNfODkwID0+IHNfODkwLnJlbW92ZVNjb3BlKHNjb3BlXzg4MiwgcGhhc2VfODgzKSkgOiB0aGlzLnRva2VuO1xuICAgIGxldCBwaGFzZVNjb3Blc2V0Xzg4NSA9IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZV84ODMpID8gdGhpcy5zY29wZXNldHMucGhhc2UuZ2V0KHBoYXNlXzg4MykgOiBMaXN0KCk7XG4gICAgbGV0IGFsbFNjb3Blc2V0Xzg4NiA9IHRoaXMuc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgbmV3c3R4Xzg4NyA9IHtiaW5kaW5nczogdGhpcy5iaW5kaW5ncywgc2NvcGVzZXRzOiB7YWxsOiB0aGlzLnNjb3Blc2V0cy5hbGwsIHBoYXNlOiB0aGlzLnNjb3Blc2V0cy5waGFzZX19O1xuICAgIGxldCBwaGFzZUluZGV4Xzg4OCA9IHBoYXNlU2NvcGVzZXRfODg1LmluZGV4T2Yoc2NvcGVfODgyKTtcbiAgICBsZXQgYWxsSW5kZXhfODg5ID0gYWxsU2NvcGVzZXRfODg2LmluZGV4T2Yoc2NvcGVfODgyKTtcbiAgICBpZiAocGhhc2VJbmRleF84ODggIT09IC0xKSB7XG4gICAgICBuZXdzdHhfODg3LnNjb3Blc2V0cy5waGFzZSA9IHRoaXMuc2NvcGVzZXRzLnBoYXNlLnNldChwaGFzZV84ODMsIHBoYXNlU2NvcGVzZXRfODg1LnJlbW92ZShwaGFzZUluZGV4Xzg4OCkpO1xuICAgIH0gZWxzZSBpZiAoYWxsSW5kZXhfODg5ICE9PSAtMSkge1xuICAgICAgbmV3c3R4Xzg4Ny5zY29wZXNldHMuYWxsID0gYWxsU2NvcGVzZXRfODg2LnJlbW92ZShhbGxJbmRleF84ODkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN5bnRheCh0b2tlbl84ODQsIG5ld3N0eF84ODcpO1xuICB9XG4gIG1hdGNoKHR5cGVfODkxLCB2YWx1ZV84OTIpIHtcbiAgICBpZiAoIVR5cGVzXzc4OVt0eXBlXzg5MV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlXzg5MSArIFwiIGlzIGFuIGludmFsaWQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVzXzc4OVt0eXBlXzg5MV0ubWF0Y2godGhpcy50b2tlbikgJiYgKHZhbHVlXzg5MiA9PSBudWxsIHx8ICh2YWx1ZV84OTIgaW5zdGFuY2VvZiBSZWdFeHAgPyB2YWx1ZV84OTIudGVzdCh0aGlzLnZhbCgpKSA6IHRoaXMudmFsKCkgPT0gdmFsdWVfODkyKSk7XG4gIH1cbiAgaXNJZGVudGlmaWVyKHZhbHVlXzg5Mykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiaWRlbnRpZmllclwiLCB2YWx1ZV84OTMpO1xuICB9XG4gIGlzQXNzaWduKHZhbHVlXzg5NCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiYXNzaWduXCIsIHZhbHVlXzg5NCk7XG4gIH1cbiAgaXNCb29sZWFuTGl0ZXJhbCh2YWx1ZV84OTUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJvb2xlYW5cIiwgdmFsdWVfODk1KTtcbiAgfVxuICBpc0tleXdvcmQodmFsdWVfODk2KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJrZXl3b3JkXCIsIHZhbHVlXzg5Nik7XG4gIH1cbiAgaXNOdWxsTGl0ZXJhbCh2YWx1ZV84OTcpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcIm51bGxcIiwgdmFsdWVfODk3KTtcbiAgfVxuICBpc051bWVyaWNMaXRlcmFsKHZhbHVlXzg5OCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwibnVtYmVyXCIsIHZhbHVlXzg5OCk7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHZhbHVlXzg5OSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwicHVuY3R1YXRvclwiLCB2YWx1ZV84OTkpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh2YWx1ZV85MDApIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcInN0cmluZ1wiLCB2YWx1ZV85MDApO1xuICB9XG4gIGlzUmVndWxhckV4cHJlc3Npb24odmFsdWVfOTAxKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJyZWd1bGFyRXhwcmVzc2lvblwiLCB2YWx1ZV85MDEpO1xuICB9XG4gIGlzVGVtcGxhdGUodmFsdWVfOTAyKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJ0ZW1wbGF0ZVwiLCB2YWx1ZV85MDIpO1xuICB9XG4gIGlzRGVsaW1pdGVyKHZhbHVlXzkwMykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIsIHZhbHVlXzkwMyk7XG4gIH1cbiAgaXNQYXJlbnModmFsdWVfOTA0KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJwYXJlbnNcIiwgdmFsdWVfOTA0KTtcbiAgfVxuICBpc0JyYWNlcyh2YWx1ZV85MDUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJyYWNlc1wiLCB2YWx1ZV85MDUpO1xuICB9XG4gIGlzQnJhY2tldHModmFsdWVfOTA2KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJicmFja2V0c1wiLCB2YWx1ZV85MDYpO1xuICB9XG4gIGlzU3ludGF4VGVtcGxhdGUodmFsdWVfOTA3KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJzeW50YXhUZW1wbGF0ZVwiLCB2YWx1ZV85MDcpO1xuICB9XG4gIGlzRU9GKHZhbHVlXzkwOCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZW9mXCIsIHZhbHVlXzkwOCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLm1hcChzXzkwOSA9PiBzXzkwOS50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goXCJzdHJpbmdcIikpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHRoaXMudG9rZW4uc3RyO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaChcInRlbXBsYXRlXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9rZW4udmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7VHlwZXNfNzg5IGFzIFR5cGVzfTtcbmV4cG9ydCB7QUxMX1BIQVNFU183OTAgYXMgQUxMX1BIQVNFU30iXX0=

/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function expect_316(cond_318, message_319, offendingSyntax_320, rest_321) {
	  if (!cond_318) {
	    let ctx = "";
	    if (rest_321) {
	      let ctx = rest_321.slice(0, 20).map(s_322 => {
	        let val_323 = s_322.isDelimiter() ? "( ... )" : s_322.val();
	        if (s_322 === offendingSyntax_320) {
	          return "__" + val_323 + "__";
	        }
	        return val_323;
	      }).join(" ");
	    }
	    throw new Error("[error]: " + message_319 + "\n" + ctx);
	  }
	}
	function assert_317(cond_324, message_325) {
	  if (!cond_324) {
	    throw new Error("[assertion error]: " + message_325);
	  }
	}
	exports.expect = expect_316;
	exports.assert = assert_317;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2Vycm9ycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QixXQUE5QixFQUEyQyxtQkFBM0MsRUFBZ0UsUUFBaEUsRUFBMEU7QUFDeEUsTUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLFFBQUksTUFBTSxFQUFWO0FBQ0EsUUFBSSxRQUFKLEVBQWM7QUFDWixVQUFJLE1BQU0sU0FBUyxLQUFULENBQWUsQ0FBZixFQUFrQixFQUFsQixFQUFzQixHQUF0QixDQUEwQixTQUFTO0FBQzNDLFlBQUksVUFBVSxNQUFNLFdBQU4sS0FBc0IsU0FBdEIsR0FBa0MsTUFBTSxHQUFOLEVBQWhEO0FBQ0EsWUFBSSxVQUFVLG1CQUFkLEVBQW1DO0FBQ2pDLGlCQUFPLE9BQU8sT0FBUCxHQUFpQixJQUF4QjtBQUNEO0FBQ0QsZUFBTyxPQUFQO0FBQ0QsT0FOUyxFQU1QLElBTk8sQ0FNRixHQU5FLENBQVY7QUFPRDtBQUNELFVBQU0sSUFBSSxLQUFKLENBQVUsY0FBYyxXQUFkLEdBQTRCLElBQTVCLEdBQW1DLEdBQTdDLENBQU47QUFDRDtBQUNGO0FBQ0QsU0FBUyxVQUFULENBQW9CLFFBQXBCLEVBQThCLFdBQTlCLEVBQTJDO0FBQ3pDLE1BQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixVQUFNLElBQUksS0FBSixDQUFVLHdCQUF3QixXQUFsQyxDQUFOO0FBQ0Q7QUFDRjtRQUNxQixNLEdBQWQsVTtRQUNjLE0sR0FBZCxVIiwiZmlsZSI6ImVycm9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4cGVjdF8zMTYoY29uZF8zMTgsIG1lc3NhZ2VfMzE5LCBvZmZlbmRpbmdTeW50YXhfMzIwLCByZXN0XzMyMSkge1xuICBpZiAoIWNvbmRfMzE4KSB7XG4gICAgbGV0IGN0eCA9IFwiXCI7XG4gICAgaWYgKHJlc3RfMzIxKSB7XG4gICAgICBsZXQgY3R4ID0gcmVzdF8zMjEuc2xpY2UoMCwgMjApLm1hcChzXzMyMiA9PiB7XG4gICAgICAgIGxldCB2YWxfMzIzID0gc18zMjIuaXNEZWxpbWl0ZXIoKSA/IFwiKCAuLi4gKVwiIDogc18zMjIudmFsKCk7XG4gICAgICAgIGlmIChzXzMyMiA9PT0gb2ZmZW5kaW5nU3ludGF4XzMyMCkge1xuICAgICAgICAgIHJldHVybiBcIl9fXCIgKyB2YWxfMzIzICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxfMzIzO1xuICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIltlcnJvcl06IFwiICsgbWVzc2FnZV8zMTkgKyBcIlxcblwiICsgY3R4KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0XzMxNyhjb25kXzMyNCwgbWVzc2FnZV8zMjUpIHtcbiAgaWYgKCFjb25kXzMyNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlthc3NlcnRpb24gZXJyb3JdOiBcIiArIG1lc3NhZ2VfMzI1KTtcbiAgfVxufVxuZXhwb3J0IHtleHBlY3RfMzE2IGFzIGV4cGVjdH07XG5leHBvcnQge2Fzc2VydF8zMTcgYXMgYXNzZXJ0fSJdfQ==

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(11);

	var _errors = __webpack_require__(13);

	var _ramdaFantasy = __webpack_require__(15);

	var _syntax = __webpack_require__(12);

	class BindingMap {
	  constructor() {
	    this._map = new Map();
	  }
	  add(stx_20, _ref) {
	    let binding = _ref.binding;
	    let phase = _ref.phase;
	    var _ref$skipDup = _ref.skipDup;
	    let skipDup = _ref$skipDup === undefined ? false : _ref$skipDup;

	    let stxName_21 = stx_20.val();
	    let allScopeset_22 = stx_20.scopesets.all;
	    let scopeset_23 = stx_20.scopesets.phase.has(phase) ? stx_20.scopesets.phase.get(phase) : (0, _immutable.List)();
	    scopeset_23 = allScopeset_22.concat(scopeset_23);
	    (0, _errors.assert)(phase != null, "must provide a phase for binding add");
	    if (this._map.has(stxName_21)) {
	      let scopesetBindingList = this._map.get(stxName_21);
	      if (skipDup && scopesetBindingList.some(s_24 => s_24.scopes.equals(scopeset_23))) {
	        return;
	      }
	      this._map.set(stxName_21, scopesetBindingList.push({ scopes: scopeset_23, binding: binding, alias: _ramdaFantasy.Maybe.Nothing() }));
	    } else {
	      this._map.set(stxName_21, _immutable.List.of({ scopes: scopeset_23, binding: binding, alias: _ramdaFantasy.Maybe.Nothing() }));
	    }
	  }
	  addForward(stx_25, forwardStx_26, binding_27, phase_28) {
	    let stxName_29 = stx_25.token.value;
	    let allScopeset_30 = stx_25.scopesets.all;
	    let scopeset_31 = stx_25.scopesets.phase.has(phase_28) ? stx_25.scopesets.phase.get(phase_28) : (0, _immutable.List)();
	    scopeset_31 = allScopeset_30.concat(scopeset_31);
	    (0, _errors.assert)(phase_28 != null, "must provide a phase for binding add");
	    if (this._map.has(stxName_29)) {
	      let scopesetBindingList = this._map.get(stxName_29);
	      this._map.set(stxName_29, scopesetBindingList.push({ scopes: scopeset_31, binding: binding_27, alias: _ramdaFantasy.Maybe.of(forwardStx_26) }));
	    } else {
	      this._map.set(stxName_29, _immutable.List.of({ scopes: scopeset_31, binding: binding_27, alias: _ramdaFantasy.Maybe.of(forwardStx_26) }));
	    }
	  }
	  get(stx_32) {
	    return this._map.get(stx_32.token.value);
	  }
	}
	exports.default = BindingMap;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2JpbmRpbmctbWFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNlLE1BQU0sVUFBTixDQUFpQjtBQUM5QixnQkFBYztBQUNaLFNBQUssSUFBTCxHQUFZLElBQUksR0FBSixFQUFaO0FBQ0Q7QUFDRCxNQUFJLE1BQUosUUFBK0M7QUFBQSxRQUFsQyxPQUFrQyxRQUFsQyxPQUFrQztBQUFBLFFBQXpCLEtBQXlCLFFBQXpCLEtBQXlCO0FBQUEsNEJBQWxCLE9BQWtCO0FBQUEsUUFBbEIsT0FBa0IsZ0NBQVIsS0FBUTs7QUFDN0MsUUFBSSxhQUFhLE9BQU8sR0FBUCxFQUFqQjtBQUNBLFFBQUksaUJBQWlCLE9BQU8sU0FBUCxDQUFpQixHQUF0QztBQUNBLFFBQUksY0FBYyxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBMkIsS0FBM0IsSUFBb0MsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCLENBQTJCLEtBQTNCLENBQXBDLEdBQXdFLHNCQUExRjtBQUNBLGtCQUFjLGVBQWUsTUFBZixDQUFzQixXQUF0QixDQUFkO0FBQ0Esd0JBQU8sU0FBUyxJQUFoQixFQUFzQixzQ0FBdEI7QUFDQSxRQUFJLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxVQUFkLENBQUosRUFBK0I7QUFDN0IsVUFBSSxzQkFBc0IsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLFVBQWQsQ0FBMUI7QUFDQSxVQUFJLFdBQVcsb0JBQW9CLElBQXBCLENBQXlCLFFBQVEsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixXQUFuQixDQUFqQyxDQUFmLEVBQWtGO0FBQ2hGO0FBQ0Q7QUFDRCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixvQkFBb0IsSUFBcEIsQ0FBeUIsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxPQUEvQixFQUF3QyxPQUFPLG9CQUFNLE9BQU4sRUFBL0MsRUFBekIsQ0FBMUI7QUFDRCxLQU5ELE1BTU87QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixnQkFBSyxFQUFMLENBQVEsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxPQUEvQixFQUF3QyxPQUFPLG9CQUFNLE9BQU4sRUFBL0MsRUFBUixDQUExQjtBQUNEO0FBQ0Y7QUFDRCxhQUFXLE1BQVgsRUFBbUIsYUFBbkIsRUFBa0MsVUFBbEMsRUFBOEMsUUFBOUMsRUFBd0Q7QUFDdEQsUUFBSSxhQUFhLE9BQU8sS0FBUCxDQUFhLEtBQTlCO0FBQ0EsUUFBSSxpQkFBaUIsT0FBTyxTQUFQLENBQWlCLEdBQXRDO0FBQ0EsUUFBSSxjQUFjLE9BQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixHQUF2QixDQUEyQixRQUEzQixJQUF1QyxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBMkIsUUFBM0IsQ0FBdkMsR0FBOEUsc0JBQWhHO0FBQ0Esa0JBQWMsZUFBZSxNQUFmLENBQXNCLFdBQXRCLENBQWQ7QUFDQSx3QkFBTyxZQUFZLElBQW5CLEVBQXlCLHNDQUF6QjtBQUNBLFFBQUksS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLFVBQWQsQ0FBSixFQUErQjtBQUM3QixVQUFJLHNCQUFzQixLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxDQUExQjtBQUNBLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxVQUFkLEVBQTBCLG9CQUFvQixJQUFwQixDQUF5QixFQUFDLFFBQVEsV0FBVCxFQUFzQixTQUFTLFVBQS9CLEVBQTJDLE9BQU8sb0JBQU0sRUFBTixDQUFTLGFBQVQsQ0FBbEQsRUFBekIsQ0FBMUI7QUFDRCxLQUhELE1BR087QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixnQkFBSyxFQUFMLENBQVEsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxVQUEvQixFQUEyQyxPQUFPLG9CQUFNLEVBQU4sQ0FBUyxhQUFULENBQWxELEVBQVIsQ0FBMUI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxNQUFKLEVBQVk7QUFDVixXQUFPLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxPQUFPLEtBQVAsQ0FBYSxLQUEzQixDQUFQO0FBQ0Q7QUFuQzZCO2tCQUFYLFUiLCJmaWxlIjoiYmluZGluZy1tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCB7ZXhwZWN0LCBhc3NlcnR9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHtNYXliZX0gZnJvbSBcInJhbWRhLWZhbnRhc3lcIjtcbmltcG9ydCB7QUxMX1BIQVNFU30gZnJvbSBcIi4vc3ludGF4XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5kaW5nTWFwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcDtcbiAgfVxuICBhZGQoc3R4XzIwLCB7YmluZGluZywgcGhhc2UsIHNraXBEdXAgPSBmYWxzZX0pIHtcbiAgICBsZXQgc3R4TmFtZV8yMSA9IHN0eF8yMC52YWwoKTtcbiAgICBsZXQgYWxsU2NvcGVzZXRfMjIgPSBzdHhfMjAuc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgc2NvcGVzZXRfMjMgPSBzdHhfMjAuc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZSkgPyBzdHhfMjAuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgc2NvcGVzZXRfMjMgPSBhbGxTY29wZXNldF8yMi5jb25jYXQoc2NvcGVzZXRfMjMpO1xuICAgIGFzc2VydChwaGFzZSAhPSBudWxsLCBcIm11c3QgcHJvdmlkZSBhIHBoYXNlIGZvciBiaW5kaW5nIGFkZFwiKTtcbiAgICBpZiAodGhpcy5fbWFwLmhhcyhzdHhOYW1lXzIxKSkge1xuICAgICAgbGV0IHNjb3Blc2V0QmluZGluZ0xpc3QgPSB0aGlzLl9tYXAuZ2V0KHN0eE5hbWVfMjEpO1xuICAgICAgaWYgKHNraXBEdXAgJiYgc2NvcGVzZXRCaW5kaW5nTGlzdC5zb21lKHNfMjQgPT4gc18yNC5zY29wZXMuZXF1YWxzKHNjb3Blc2V0XzIzKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChzdHhOYW1lXzIxLCBzY29wZXNldEJpbmRpbmdMaXN0LnB1c2goe3Njb3Blczogc2NvcGVzZXRfMjMsIGJpbmRpbmc6IGJpbmRpbmcsIGFsaWFzOiBNYXliZS5Ob3RoaW5nKCl9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yMSwgTGlzdC5vZih7c2NvcGVzOiBzY29wZXNldF8yMywgYmluZGluZzogYmluZGluZywgYWxpYXM6IE1heWJlLk5vdGhpbmcoKX0pKTtcbiAgICB9XG4gIH1cbiAgYWRkRm9yd2FyZChzdHhfMjUsIGZvcndhcmRTdHhfMjYsIGJpbmRpbmdfMjcsIHBoYXNlXzI4KSB7XG4gICAgbGV0IHN0eE5hbWVfMjkgPSBzdHhfMjUudG9rZW4udmFsdWU7XG4gICAgbGV0IGFsbFNjb3Blc2V0XzMwID0gc3R4XzI1LnNjb3Blc2V0cy5hbGw7XG4gICAgbGV0IHNjb3Blc2V0XzMxID0gc3R4XzI1LnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfMjgpID8gc3R4XzI1LnNjb3Blc2V0cy5waGFzZS5nZXQocGhhc2VfMjgpIDogTGlzdCgpO1xuICAgIHNjb3Blc2V0XzMxID0gYWxsU2NvcGVzZXRfMzAuY29uY2F0KHNjb3Blc2V0XzMxKTtcbiAgICBhc3NlcnQocGhhc2VfMjggIT0gbnVsbCwgXCJtdXN0IHByb3ZpZGUgYSBwaGFzZSBmb3IgYmluZGluZyBhZGRcIik7XG4gICAgaWYgKHRoaXMuX21hcC5oYXMoc3R4TmFtZV8yOSkpIHtcbiAgICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gdGhpcy5fbWFwLmdldChzdHhOYW1lXzI5KTtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yOSwgc2NvcGVzZXRCaW5kaW5nTGlzdC5wdXNoKHtzY29wZXM6IHNjb3Blc2V0XzMxLCBiaW5kaW5nOiBiaW5kaW5nXzI3LCBhbGlhczogTWF5YmUub2YoZm9yd2FyZFN0eF8yNil9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yOSwgTGlzdC5vZih7c2NvcGVzOiBzY29wZXNldF8zMSwgYmluZGluZzogYmluZGluZ18yNywgYWxpYXM6IE1heWJlLm9mKGZvcndhcmRTdHhfMjYpfSkpO1xuICAgIH1cbiAgfVxuICBnZXQoc3R4XzMyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc3R4XzMyLnRva2VuLnZhbHVlKTtcbiAgfVxufVxuIl19

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    Either: __webpack_require__(16),
	    Future: __webpack_require__(19),
	    Identity: __webpack_require__(20),
	    IO: __webpack_require__(21),
	    lift2: __webpack_require__(22),
	    lift3: __webpack_require__(23),
	    Maybe: __webpack_require__(24),
	    Tuple: __webpack_require__(25),
	    Reader: __webpack_require__(26)
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	var util = __webpack_require__(18);


	function Either(left, right) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Either');
	    case 1:
	      return function(right) {
	        return right == null ? Either.Left(left) : Either.Right(right);
	      };
	    default:
	      return right == null ? Either.Left(left) : Either.Right(right);
	  }
	}

	Either.prototype.map = util.returnThis;

	Either.of = Either.prototype.of = function(value) {
	  return Either.Right(value);
	};

	Either.prototype.chain = util.returnThis; // throw?

	Either.equals = Either.prototype.equals = util.getEquals(Either);


	// Right
	function _Right(x) {
	  this.value = x;
	}
	util.extend(_Right, Either);

	_Right.prototype.map = function(fn) {
	  return new _Right(fn(this.value));
	};

	_Right.prototype.ap = function(that) {
	  return that.map(this.value);
	};

	_Right.prototype.chain = function(f) {
	  return f(this.value);
	};

	_Right.prototype.bimap = function(_, f) {
	  return new _Right(f(this.value));
	};

	_Right.prototype.extend = function(f) {
	  return new _Right(f(this));
	};

	_Right.prototype.toString = function() {
	  return 'Either.Right(' + R.toString(this.value) + ')';
	};

	Either.Right = function(value) {
	  return new _Right(value);
	};


	// Left
	function _Left(x) {
	  this.value = x;
	}
	util.extend(_Left, Either);

	_Left.prototype.ap = function(that) { return that; };

	_Left.prototype.bimap = function(f) {
	  return new _Left(f(this.value));
	};

	_Left.prototype.extend = util.returnThis;

	_Left.prototype.toString = function() {
	  return 'Either.Left(' + R.toString(this.value) + ')';
	};

	Either.Left = function(value) {
	  return new _Left(value);
	};


	module.exports = Either;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	//  Ramda v0.17.1
	//  https://github.com/ramda/ramda
	//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
	//  Ramda may be freely distributed under the MIT license.

	;(function() {

	  'use strict';

	  /**
	     * A special placeholder value used to specify "gaps" within curried functions,
	     * allowing partial application of any combination of arguments,
	     * regardless of their positions.
	     *
	     * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2, _)(1, 3)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @constant
	     * @memberOf R
	     * @category Function
	     * @example
	     *
	     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	     *      greet('Alice'); //=> 'Hello, Alice!'
	     */
	    var __ = { '@@functional/placeholder': true };

	    // jshint unused:vars
	    var _arity = function _arity(n, fn) {
	        // jshint unused:vars
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _cloneRegExp = function _cloneRegExp(pattern) {
	        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	    };

	    var _complement = function _complement(f) {
	        return function () {
	            return !f.apply(this, arguments);
	        };
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _containsWith = function _containsWith(pred, x, list) {
	        var idx = 0, len = list.length;
	        while (idx < len) {
	            if (pred(x, list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0) {
	                return f1;
	            } else if (a != null && a['@@functional/placeholder'] === true) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            var n = arguments.length;
	            if (n === 0) {
	                return f2;
	            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
	                return f2;
	            } else if (n === 1) {
	                return _curry1(function (b) {
	                    return fn(a, b);
	                });
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return f2;
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry1(function (a) {
	                    return fn(a, b);
	                });
	            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry1(function (b) {
	                    return fn(a, b);
	                });
	            } else {
	                return fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            var n = arguments.length;
	            if (n === 0) {
	                return f3;
	            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 1) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry2(function (a, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2) {
	                return _curry1(function (c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return _curry2(function (a, b) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return _curry2(function (a, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry1(function (a) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry1(function (b) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
	                return _curry1(function (c) {
	                    return fn(a, b, c);
	                });
	            } else {
	                return fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @return {array} An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (result == null || result['@@functional/placeholder'] !== true) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0, len = list.length, result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * @private
	     * @param {Function} fn The strategy for extracting function names from an object
	     * @return {Function} A function that takes an object and returns an array of function names.
	     */
	    var _functionsWith = function _functionsWith(fn) {
	        return function (obj) {
	            return _filter(function (key) {
	                return typeof obj[key] === 'function';
	            }, fn(obj));
	        };
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    var _identity = function _identity(x) {
	        return x;
	    };

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    /**
	     * Determine if the passed argument is an integer.
	     *
	     * @private
	     * @param {*} n
	     * @category Type
	     * @return {Boolean}
	     */
	    var _isInteger = Number.isInteger || function _isInteger(n) {
	        return n << 0 === n;
	    };

	    var _isNumber = function _isNumber(x) {
	        return Object.prototype.toString.call(x) === '[object Number]';
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, list) {
	        var idx = 0, len = list.length, result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(list[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _pipeP = function _pipeP(f, g) {
	        return function () {
	            var ctx = this;
	            return f.apply(ctx, arguments).then(function (x) {
	                return g.call(ctx, x);
	            });
	        };
	    };

	    var _quote = function _quote(s) {
	        return '"' + s.replace(/"/g, '\\"') + '"';
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    /**
	     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	     */
	    var _toISOString = function () {
	        var pad = function pad(n) {
	            return (n < 10 ? '0' : '') + n;
	        };
	        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	            return d.toISOString();
	        } : function _toISOString(d) {
	            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	        };
	    }();

	    var _xdropRepeatsWith = function () {
	        function XDropRepeatsWith(pred, xf) {
	            this.xf = xf;
	            this.pred = pred;
	            this.lastValue = undefined;
	            this.seenFirstValue = false;
	        }
	        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
	            return this.xf['@@transducer/init']();
	        };
	        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	            var sameAsLast = false;
	            if (!this.seenFirstValue) {
	                this.seenFirstValue = true;
	            } else if (this.pred(this.lastValue, input)) {
	                sameAsLast = true;
	            }
	            this.lastValue = input;
	            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropRepeatsWith(pred, xf) {
	            return new XDropRepeatsWith(pred, xf);
	        });
	    }();

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xfindLast = function () {
	        function XFindLast(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLast.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	        };
	        XFindLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.last = input;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLast(f, xf) {
	            return new XFindLast(f, xf);
	        });
	    }();

	    var _xfindLastIndex = function () {
	        function XFindLastIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.lastIdx = -1;
	        }
	        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	        };
	        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.lastIdx = this.idx;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLastIndex(f, xf) {
	            return new XFindLastIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    var _xtake = function () {
	        function XTake(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XTake.prototype['@@transducer/init'] = _xfBase.init;
	        XTake.prototype['@@transducer/result'] = _xfBase.result;
	        XTake.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n === 0) {
	                return _reduced(result);
	            } else {
	                this.n -= 1;
	                return this.xf['@@transducer/step'](result, input);
	            }
	        };
	        return _curry2(function _xtake(n, xf) {
	            return new XTake(n, xf);
	        });
	    }();

	    var _xtakeWhile = function () {
	        function XTakeWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	        };
	        return _curry2(function _xtakeWhile(f, xf) {
	            return new XTakeWhile(f, xf);
	        });
	    }();

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    /**
	     * Adds two numbers. Equivalent to `a + b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Number}
	     * @see R.subtract
	     * @example
	     *
	     *      R.add(2, 3);       //=>  5
	     *      R.add(7)(10);      //=> 17
	     */
	    var add = _curry2(function add(a, b) {
	        return a + b;
	    });

	    /**
	     * Applies a function to the value at the given index of an array,
	     * returning a new copy of the array with the element at the given
	     * index replaced with the result of the function application.
	     * @see R.update
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> a) -> Number -> [a] -> [a]
	     * @param {Function} fn The function to apply.
	     * @param {Number} idx The index.
	     * @param {Array|Arguments} list An array-like object whose value
	     *        at the supplied index will be replaced.
	     * @return {Array} A copy of the supplied array-like object with
	     *         the element at index `idx` replaced with the value
	     *         returned by applying `fn` to the existing element.
	     * @example
	     *
	     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var adjust = _curry3(function adjust(fn, idx, list) {
	        if (idx >= list.length || idx < -list.length) {
	            return list;
	        }
	        var start = idx < 0 ? list.length : 0;
	        var _idx = start + idx;
	        var _list = _concat(list);
	        _list[_idx] = fn(list[_idx]);
	        return _list;
	    });

	    /**
	     * Returns a function that always returns the given value. Note that for
	     * non-primitives the value returned is a reference to the original value.
	     *
	     * This function is known as `const`, `constant`, or `K` (for K combinator)
	     * in other languages and libraries.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> (* -> a)
	     * @param {*} val The value to wrap in a function
	     * @return {Function} A Function :: * -> val.
	     * @example
	     *
	     *      var t = R.always('Tee');
	     *      t(); //=> 'Tee'
	     */
	    var always = _curry1(function always(val) {
	        return function () {
	            return val;
	        };
	    });

	    /**
	     * Returns a new list, composed of n-tuples of consecutive elements
	     * If `n` is greater than the length of the list, an empty list is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @param {Number} n The size of the tuples to create
	     * @param {Array} list The list to split into `n`-tuples
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	     */
	    var aperture = _curry2(function aperture(n, list) {
	        var idx = 0;
	        var limit = list.length - (n - 1);
	        var acc = new Array(limit >= 0 ? limit : 0);
	        while (idx < limit) {
	            acc[idx] = _slice(list, idx, idx + n);
	            idx += 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a new list containing the contents of the given list, followed by the given
	     * element.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The element to add to the end of the new list.
	     * @param {Array} list The list whose contents will be added to the beginning of the output
	     *        list.
	     * @return {Array} A new list containing the contents of the old list followed by `el`.
	     * @see R.prepend
	     * @example
	     *
	     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	     *      R.append('tests', []); //=> ['tests']
	     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	     */
	    var append = _curry2(function append(el, list) {
	        return _concat(list, [el]);
	    });

	    /**
	     * Applies function `fn` to the argument list `args`. This is useful for
	     * creating a fixed-arity function from a variadic function. `fn` should
	     * be a bound function if context is significant.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a) -> [*] -> a
	     * @param {Function} fn
	     * @param {Array} args
	     * @return {*}
	     * @see R.call, R.unapply
	     * @example
	     *
	     *      var nums = [1, 2, 3, -99, 42, 6, 7];
	     *      R.apply(Math.max, nums); //=> 42
	     */
	    var apply = _curry2(function apply(fn, args) {
	        return fn.apply(this, args);
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the specified
	     * property with the given value.  Note that this copies and flattens
	     * prototype properties onto the new object as well.  All non-primitive
	     * properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> a -> {k: v} -> {k: v}
	     * @param {String} prop the property name to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except for the specified property.
	     * @see R.dissoc
	     * @example
	     *
	     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	     */
	    var assoc = _curry3(function assoc(prop, val, obj) {
	        var result = {};
	        for (var p in obj) {
	            result[p] = obj[p];
	        }
	        result[prop] = val;
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the nodes
	     * required to create the given path, and placing the specific value at the
	     * tail end of that path.  Note that this copies and flattens prototype
	     * properties onto the new object as well.  All non-primitive properties
	     * are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> a -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except along the specified path.
	     * @see R.dissocPath
	     * @example
	     *
	     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	     */
	    var assocPath = _curry3(function assocPath(path, val, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return assoc(path[0], val, obj);
	        default:
	            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
	        }
	    });

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @category Object
	     * @see R.partial
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
	     * function if it is false-y and the result of the second function otherwise.  Note that this is
	     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	     * @see R.and
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0 };
	     *      var f = R.both(gt10, even);
	     *      f(100); //=> true
	     *      f(101); //=> false
	     */
	    var both = _curry2(function both(f, g) {
	        return function _both() {
	            return f.apply(this, arguments) && g.apply(this, arguments);
	        };
	    });

	    /**
	     * Makes a comparator function out of a function that reports whether the first element is less than the second.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a, b -> Boolean) -> (a, b -> Number)
	     * @param {Function} pred A predicate function of arity two.
	     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
	     * @example
	     *
	     *      var cmp = R.comparator(function(a, b) {
	     *        return a.age < b.age;
	     *      });
	     *      var people = [
	     *        // ...
	     *      ];
	     *      R.sort(cmp, people);
	     */
	    var comparator = _curry1(function comparator(pred) {
	        return function (a, b) {
	            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	        };
	    });

	    /**
	     * Takes a function `f` and returns a function `g` such that:
	     *
	     *   - applying `g` to zero or more arguments will give __true__ if applying
	     *     the same arguments to `f` gives a logical __false__ value; and
	     *
	     *   - applying `g` to zero or more arguments will give __false__ if applying
	     *     the same arguments to `f` gives a logical __true__ value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> *) -> (*... -> Boolean)
	     * @param {Function} f
	     * @return {Function}
	     * @see R.not
	     * @example
	     *
	     *      var isEven = function(n) { return n % 2 === 0; };
	     *      var isOdd = R.complement(isEven);
	     *      isOdd(21); //=> true
	     *      isOdd(42); //=> false
	     */
	    var complement = _curry1(_complement);

	    /**
	     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
	     * `R.cond` takes a list of [predicate, transform] pairs. All of the
	     * arguments to `fn` are applied to each of the predicates in turn
	     * until one returns a "truthy" value, at which point `fn` returns the
	     * result of applying its arguments to the corresponding transformer.
	     * If none of the predicates matches, `fn` returns undefined.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	     * @param {Array} pairs
	     * @return {Function}
	     * @example
	     *
	     *      var fn = R.cond([
	     *        [R.equals(0),   R.always('water freezes at 0°C')],
	     *        [R.equals(100), R.always('water boils at 100°C')],
	     *        [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]
	     *      ]);
	     *      fn(0); //=> 'water freezes at 0°C'
	     *      fn(50); //=> 'nothing special happens at 50°C'
	     *      fn(100); //=> 'water boils at 100°C'
	     */
	    var cond = _curry1(function cond(pairs) {
	        return function () {
	            var idx = 0;
	            while (idx < pairs.length) {
	                if (pairs[idx][0].apply(this, arguments)) {
	                    return pairs[idx][1].apply(this, arguments);
	                }
	                idx += 1;
	            }
	        };
	    });

	    /**
	     * Returns `true` if the `x` is found in the `list`, using `pred` as an
	     * equality predicate for `x`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {*} x The item to find
	     * @param {Array} list The list to iterate over
	     * @return {Boolean} `true` if `x` is in `list`, else `false`.
	     * @example
	     *
	     *      var xs = [{x: 12}, {x: 11}, {x: 10}];
	     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true
	     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false
	     */
	    var containsWith = _curry3(_containsWith);

	    /**
	     * Counts the elements of a list according to how many match each value
	     * of a key generated by the supplied function. Returns an object
	     * mapping the keys produced by `fn` to the number of occurrences in
	     * the list. Note that all keys are coerced to strings because of how
	     * JavaScript objects work.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a -> String) -> [a] -> {*}
	     * @param {Function} fn The function used to map values to keys.
	     * @param {Array} list The list to count elements from.
	     * @return {Object} An object mapping keys to number of occurrences in the list.
	     * @example
	     *
	     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	     *      var letters = R.split('', 'abcABCaaaBBc');
	     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
	     */
	    var countBy = _curry2(function countBy(fn, list) {
	        var counts = {};
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            var key = fn(list[idx]);
	            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
	            idx += 1;
	        }
	        return counts;
	    });

	    /**
	     * Creates an object containing a single key:value pair.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> a -> {String:a}
	     * @param {String} key
	     * @param {*} val
	     * @return {Object}
	     * @example
	     *
	     *      var matchPhrases = R.compose(
	     *        R.createMapEntry('must'),
	     *        R.map(R.createMapEntry('match_phrase'))
	     *      );
	     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	     */
	    var createMapEntry = _curry2(function createMapEntry(key, val) {
	        var obj = {};
	        obj[key] = val;
	        return obj;
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the
	     * specified arity. The curried function has two unusual capabilities.
	     * First, its arguments needn't be provided one at a time. If `g` is
	     * `R.curryN(3, f)`, the following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`,
	     * the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFourNumbers = function() {
	     *        return R.sum([].slice.call(arguments, 0, 4));
	     *      };
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Decrements its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.inc
	     * @example
	     *
	     *      R.dec(42); //=> 41
	     */
	    var dec = add(-1);

	    /**
	     * Returns the second argument if it is not null or undefined. If it is null
	     * or undefined, the first (default) argument is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig a -> b -> a | b
	     * @param {a} val The default value.
	     * @param {b} val The value to return if it is not null or undefined
	     * @return {*} The the second value or the default value
	     * @example
	     *
	     *      var defaultTo42 = defaultTo(42);
	     *
	     *      defaultTo42(null);  //=> 42
	     *      defaultTo42(undefined);  //=> 42
	     *      defaultTo42('Ramda');  //=> 'Ramda'
	     */
	    var defaultTo = _curry2(function defaultTo(d, v) {
	        return v == null ? d : v;
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
	     * Duplication is determined according to the value returned by applying the supplied predicate to two list
	     * elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @see R.difference
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @example
	     *
	     *      function cmp(x, y) { return x.a === y.a; }
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	     *      var l2 = [{a: 3}, {a: 4}];
	     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	     */
	    var differenceWith = _curry3(function differenceWith(pred, first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        var containsPred = containsWith(pred);
	        while (idx < firstLen) {
	            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object that does not contain a `prop` property.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> {k: v} -> {k: v}
	     * @param {String} prop the name of the property to dissociate
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original but without the specified property
	     * @see R.assoc
	     * @example
	     *
	     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	     */
	    var dissoc = _curry2(function dissoc(prop, obj) {
	        var result = {};
	        for (var p in obj) {
	            if (p !== prop) {
	                result[p] = obj[p];
	            }
	        }
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, omitting the property at the
	     * given path. Note that this copies and flattens prototype properties
	     * onto the new object as well.  All non-primitive properties are copied
	     * by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object without the property at path
	     * @see R.assocPath
	     * @example
	     *
	     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	     */
	    var dissocPath = _curry2(function dissocPath(path, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return dissoc(path[0], obj);
	        default:
	            var head = path[0];
	            var tail = _slice(path, 1);
	            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
	        }
	    });

	    /**
	     * Divides two numbers. Equivalent to `a / b`.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a / b`.
	     * @see R.multiply
	     * @example
	     *
	     *      R.divide(71, 100); //=> 0.71
	     *
	     *      var half = R.divide(R.__, 2);
	     *      half(42); //=> 21
	     *
	     *      var reciprocal = R.divide(1);
	     *      reciprocal(4);   //=> 0.25
	     */
	    var divide = _curry2(function divide(a, b) {
	        return a / b;
	    });

	    /**
	     * Returns a new list containing all but last the`n` elements of a given list,
	     * passing each value from the right to the supplied predicate function, skipping
	     * elements while the predicate function returns `true`. The predicate function
	     * is passed one argument: (value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeLastWhile
	     * @example
	     *
	     *      var lteThree = function(x) {
	     *        return x <= 3;
	     *      };
	     *
	     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2]
	     */
	    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && pred(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, 0, idx + 1);
	    });

	    /**
	     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
	     * function if it is truth-y and the result of the second function otherwise.  Note that this is
	     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	     * @see R.or
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0 };
	     *      var f = R.either(gt10, even);
	     *      f(101); //=> true
	     *      f(8); //=> true
	     */
	    var either = _curry2(function either(f, g) {
	        return function _either() {
	            return f.apply(this, arguments) || g.apply(this, arguments);
	        };
	    });

	    /**
	     * Returns the empty value of its argument's type. Ramda defines the empty
	     * value of Array (`[]`), Object (`{}`), and String (`''`). Other types are
	     * supported if they define `<Type>.empty` and/or `<Type>.prototype.empty`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> a
	     * @param {*} x
	     * @return {*}
	     * @example
	     *
	     *      R.empty(Just(42));      //=> Nothing()
	     *      R.empty([1, 2, 3]);     //=> []
	     *      R.empty('unicorns');    //=> ''
	     *      R.empty({x: 1, y: 2});  //=> {}
	     */
	    var empty = _curry1(function empty(x) {
	        if (x != null && typeof x.empty === 'function') {
	            return x.empty();
	        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
	            return x.constructor.empty();
	        } else {
	            switch (Object.prototype.toString.call(x)) {
	            case '[object Array]':
	                return [];
	            case '[object Object]':
	                return {};
	            case '[object String]':
	                return '';
	            }
	        }
	    });

	    /**
	     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
	     * `transformation` functions. All non-primitive properties are copied by reference.
	     *
	     * A `tranformation` function will not be invoked if its corresponding key does not exist in
	     * the evolved object.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	     * @param {Object} transformations The object specifying transformation functions to apply
	     *        to the object.
	     * @param {Object} object The object to be transformed.
	     * @return {Object} The transformed object.
	     * @example
	     *
	     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	     *      var transformations = {
	     *        firstName: R.trim,
	     *        lastName: R.trim, // Will not get invoked.
	     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	     *      };
	     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	     */
	    var evolve = _curry2(function evolve(transformations, object) {
	        var transformation, key, type, result = {};
	        for (key in object) {
	            transformation = transformations[key];
	            type = typeof transformation;
	            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
	        }
	        return result;
	    });

	    /**
	     * Creates a new object out of a list key-value pairs.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [[k,v]] -> {k: v}
	     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	     * @return {Object} The object made by pairing up `keys` and `values`.
	     * @see R.toPairs
	     * @example
	     *
	     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	     */
	    var fromPairs = _curry1(function fromPairs(pairs) {
	        var idx = 0, len = pairs.length, out = {};
	        while (idx < len) {
	            if (_isArray(pairs[idx]) && pairs[idx].length) {
	                out[pairs[idx][0]] = pairs[idx][1];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the first argument is greater than the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.lt
	     * @example
	     *
	     *      R.gt(2, 1); //=> true
	     *      R.gt(2, 2); //=> false
	     *      R.gt(2, 3); //=> false
	     *      R.gt('a', 'z'); //=> false
	     *      R.gt('z', 'a'); //=> true
	     */
	    var gt = _curry2(function gt(a, b) {
	        return a > b;
	    });

	    /**
	     * Returns `true` if the first argument is greater than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.lte
	     * @example
	     *
	     *      R.gte(2, 1); //=> true
	     *      R.gte(2, 2); //=> true
	     *      R.gte(2, 3); //=> false
	     *      R.gte('a', 'z'); //=> false
	     *      R.gte('z', 'a'); //=> true
	     */
	    var gte = _curry2(function gte(a, b) {
	        return a >= b;
	    });

	    /**
	     * Returns whether or not an object has an own property with
	     * the specified name
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      var hasName = R.has('name');
	     *      hasName({name: 'alice'});   //=> true
	     *      hasName({name: 'bob'});     //=> true
	     *      hasName({});                //=> false
	     *
	     *      var point = {x: 0, y: 0};
	     *      var pointHas = R.has(R.__, point);
	     *      pointHas('x');  //=> true
	     *      pointHas('y');  //=> true
	     *      pointHas('z');  //=> false
	     */
	    var has = _curry2(_has);

	    /**
	     * Returns whether or not an object or its prototype chain has
	     * a property with the specified name
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      function Rectangle(width, height) {
	     *        this.width = width;
	     *        this.height = height;
	     *      }
	     *      Rectangle.prototype.area = function() {
	     *        return this.width * this.height;
	     *      };
	     *
	     *      var square = new Rectangle(2, 2);
	     *      R.hasIn('width', square);  //=> true
	     *      R.hasIn('area', square);  //=> true
	     */
	    var hasIn = _curry2(function hasIn(prop, obj) {
	        return prop in obj;
	    });

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * A function that does nothing but return the parameter supplied to it. Good as a default
	     * or placeholder function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> a
	     * @param {*} x The value to return.
	     * @return {*} The input value, `x`.
	     * @example
	     *
	     *      R.identity(1); //=> 1
	     *
	     *      var obj = {};
	     *      R.identity(obj) === obj; //=> true
	     */
	    var identity = _curry1(_identity);

	    /**
	     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
	     * upon the result of the `condition` predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	     * @param {Function} condition A predicate function
	     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	     *                    function depending upon the result of the `condition` predicate.
	     * @example
	     *
	     *      // Flatten all arrays in the list but leave other values alone.
	     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));
	     *
	     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]
	     *      flattenArrays([[[10], 123], [8, [10]], "hello"]); //=> [[10, 123], [8, 10], "hello"]
	     */
	    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
	        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	        });
	    });

	    /**
	     * Increments its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.dec
	     * @example
	     *
	     *      R.inc(42); //=> 43
	     */
	    var inc = add(1);

	    /**
	     * Inserts the supplied element into the list, at index `index`.  _Note
	     * that this is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} index The position to insert the element
	     * @param {*} elt The element to insert into the Array
	     * @param {Array} list The list to insert into
	     * @return {Array} A new Array with `elt` inserted at `index`.
	     * @example
	     *
	     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	     */
	    var insert = _curry3(function insert(idx, elt, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        var result = _slice(list);
	        result.splice(idx, 0, elt);
	        return result;
	    });

	    /**
	     * Inserts the sub-list into the list, at index `index`.  _Note  that this
	     * is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a] -> [a]
	     * @param {Number} index The position to insert the sub-list
	     * @param {Array} elts The sub-list to insert into the Array
	     * @param {Array} list The list to insert the sub-list into
	     * @return {Array} A new Array with `elts` inserted starting at `index`.
	     * @example
	     *
	     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	     */
	    var insertAll = _curry3(function insertAll(idx, elts, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
	    });

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor.
	     * This function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Reports whether the list has zero elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [a] -> Boolean
	     * @param {Array} list
	     * @return {Boolean}
	     * @example
	     *
	     *      R.isEmpty([1, 2, 3]);   //=> false
	     *      R.isEmpty([]);          //=> true
	     *      R.isEmpty('');          //=> true
	     *      R.isEmpty(null);        //=> false
	     *      R.isEmpty(R.keys({}));  //=> true
	     *      R.isEmpty({});          //=> false ({} does not have a length property)
	     *      R.isEmpty({length: 0}); //=> true
	     */
	    var isEmpty = _curry1(function isEmpty(list) {
	        return Object(list).length === 0;
	    });

	    /**
	     * Checks if the input value is `null` or `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig * -> Boolean
	     * @param {*} x The value to test.
	     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	     * @example
	     *
	     *      R.isNil(null); //=> true
	     *      R.isNil(undefined); //=> true
	     *      R.isNil(0); //=> false
	     *      R.isNil([]); //=> false
	     */
	    var isNil = _curry1(function isNil(x) {
	        return x == null;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own
	     * properties of the supplied object.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, ks = [], nIdx;
	            for (prop in obj) {
	                if (_has(prop, obj)) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a list containing the names of all the
	     * properties of the supplied object, including prototype properties.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.keysIn(f); //=> ['x', 'y']
	     */
	    var keysIn = _curry1(function keysIn(obj) {
	        var prop, ks = [];
	        for (prop in obj) {
	            ks[ks.length] = prop;
	        }
	        return ks;
	    });

	    /**
	     * Returns the number of elements in the array by returning `list.length`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> Number
	     * @param {Array} list The array to inspect.
	     * @return {Number} The length of the array.
	     * @example
	     *
	     *      R.length([]); //=> 0
	     *      R.length([1, 2, 3]); //=> 3
	     */
	    var length = _curry1(function length(list) {
	        return list != null && is(Number, list.length) ? list.length : NaN;
	    });

	    /**
	     * Returns `true` if the first argument is less than the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.gt
	     * @example
	     *
	     *      R.lt(2, 1); //=> false
	     *      R.lt(2, 2); //=> false
	     *      R.lt(2, 3); //=> true
	     *      R.lt('a', 'z'); //=> true
	     *      R.lt('z', 'a'); //=> false
	     */
	    var lt = _curry2(function lt(a, b) {
	        return a < b;
	    });

	    /**
	     * Returns `true` if the first argument is less than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.gte
	     * @example
	     *
	     *      R.lte(2, 1); //=> false
	     *      R.lte(2, 2); //=> true
	     *      R.lte(2, 3); //=> true
	     *      R.lte('a', 'z'); //=> true
	     *      R.lte('z', 'a'); //=> false
	     */
	    var lte = _curry2(function lte(a, b) {
	        return a <= b;
	    });

	    /**
	     * The mapAccum function behaves like a combination of map and reduce; it applies a
	     * function to each element of a list, passing an accumulating parameter from left to
	     * right, and returning a final value of this accumulator together with the new list.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should return
	     * a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = function(a, b) {
	     *        return [a + b, a + b];
	     *      }
	     *
	     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	     */
	    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
	        var idx = 0, len = list.length, result = [], tuple = [acc];
	        while (idx < len) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx += 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
	     * function to each element of a list, passing an accumulating parameter from right
	     * to left, and returning a final value of this accumulator together with the new list.
	     *
	     * Similar to `mapAccum`, except moves through the input list from the right to the
	     * left.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should return
	     * a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = function(a, b) {
	     *        return [a + b, a + b];
	     *      }
	     *
	     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
	     */
	    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
	        var idx = list.length - 1, result = [], tuple = [acc];
	        while (idx >= 0) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx -= 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * Tests a regular expression against a String. Note that this function
	     * will return an empty array when there are no matches. This differs
	     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	     * which returns `null` when there are no matches.
	     *
	     * @func
	     * @memberOf R
	     * @see R.test
	     * @category String
	     * @sig RegExp -> String -> [String | Undefined]
	     * @param {RegExp} rx A regular expression.
	     * @param {String} str The string to match against
	     * @return {Array} The list of matches or empty array.
	     * @example
	     *
	     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	     *      R.match(/a/, 'b'); //=> []
	     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	     */
	    var match = _curry2(function match(rx, str) {
	        return str.match(rx) || [];
	    });

	    /**
	     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
	     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
	     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
	     * when the modulus is zero or negative.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} m The dividend.
	     * @param {Number} p the modulus.
	     * @return {Number} The result of `b mod a`.
	     * @example
	     *
	     *      R.mathMod(-17, 5);  //=> 3
	     *      R.mathMod(17, 5);   //=> 2
	     *      R.mathMod(17, -5);  //=> NaN
	     *      R.mathMod(17, 0);   //=> NaN
	     *      R.mathMod(17.2, 5); //=> NaN
	     *      R.mathMod(17, 5.3); //=> NaN
	     *
	     *      var clock = R.mathMod(R.__, 12);
	     *      clock(15); //=> 3
	     *      clock(24); //=> 0
	     *
	     *      var seventeenMod = R.mathMod(17);
	     *      seventeenMod(3);  //=> 2
	     *      seventeenMod(4);  //=> 1
	     *      seventeenMod(10); //=> 7
	     */
	    var mathMod = _curry2(function mathMod(m, p) {
	        if (!_isInteger(m)) {
	            return NaN;
	        }
	        if (!_isInteger(p) || p < 1) {
	            return NaN;
	        }
	        return (m % p + p) % p;
	    });

	    /**
	     * Returns the larger of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.maxBy, R.min
	     * @example
	     *
	     *      R.max(789, 123); //=> 789
	     *      R.max('a', 'b'); //=> 'b'
	     */
	    var max = _curry2(function max(a, b) {
	        return b > a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces
	     * the larger result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.max, R.minBy
	     * @example
	     *
	     *      R.maxBy(function(n) { return n * n; }, -3, 2); //=> -3
	     */
	    var maxBy = _curry3(function maxBy(f, a, b) {
	        return f(b) > f(a) ? b : a;
	    });

	    /**
	     * Create a new object with the own properties of `a`
	     * merged with the own properties of object `b`.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> {k: v} -> {k: v}
	     * @param {Object} a
	     * @param {Object} b
	     * @return {Object}
	     * @example
	     *
	     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	     *      //=> { 'name': 'fred', 'age': 40 }
	     *
	     *      var resetToDefault = R.merge(R.__, {x: 0});
	     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	     */
	    var merge = _curry2(function merge(a, b) {
	        var result = {};
	        var ks = keys(a);
	        var idx = 0;
	        while (idx < ks.length) {
	            result[ks[idx]] = a[ks[idx]];
	            idx += 1;
	        }
	        ks = keys(b);
	        idx = 0;
	        while (idx < ks.length) {
	            result[ks[idx]] = b[ks[idx]];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the smaller of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.minBy, R.max
	     * @example
	     *
	     *      R.min(789, 123); //=> 123
	     *      R.min('a', 'b'); //=> 'a'
	     */
	    var min = _curry2(function min(a, b) {
	        return b < a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces
	     * the smaller result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.min, R.maxBy
	     * @example
	     *
	     *      R.minBy(function(n) { return n * n; }, -3, 2); //=> 2
	     */
	    var minBy = _curry3(function minBy(f, a, b) {
	        return f(b) < f(a) ? b : a;
	    });

	    /**
	     * Divides the second parameter by the first and returns the remainder.
	     * Note that this functions preserves the JavaScript-style behavior for
	     * modulo. For mathematical modulo see `mathMod`
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The value to the divide.
	     * @param {Number} b The pseudo-modulus
	     * @return {Number} The result of `b % a`.
	     * @see R.mathMod
	     * @example
	     *
	     *      R.modulo(17, 3); //=> 2
	     *      // JS behavior:
	     *      R.modulo(-17, 3); //=> -2
	     *      R.modulo(17, -3); //=> 2
	     *
	     *      var isOdd = R.modulo(R.__, 2);
	     *      isOdd(42); //=> 0
	     *      isOdd(21); //=> 1
	     */
	    var modulo = _curry2(function modulo(a, b) {
	        return a % b;
	    });

	    /**
	     * Multiplies two numbers. Equivalent to `a * b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a * b`.
	     * @see R.divide
	     * @example
	     *
	     *      var double = R.multiply(2);
	     *      var triple = R.multiply(3);
	     *      double(3);       //=>  6
	     *      triple(4);       //=> 12
	     *      R.multiply(2, 5);  //=> 10
	     */
	    var multiply = _curry2(function multiply(a, b) {
	        return a * b;
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
	     * parameters. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} n The desired arity of the new function.
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity `n`.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.nAry(1, takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only `n` arguments are passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var nAry = _curry2(function nAry(n, fn) {
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.call(this);
	            };
	        case 1:
	            return function (a0) {
	                return fn.call(this, a0);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.call(this, a0, a1);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.call(this, a0, a1, a2);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.call(this, a0, a1, a2, a3);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.call(this, a0, a1, a2, a3, a4);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	            };
	        default:
	            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	        }
	    });

	    /**
	     * Negates its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @example
	     *
	     *      R.negate(42); //=> -42
	     */
	    var negate = _curry1(function negate(n) {
	        return -n;
	    });

	    /**
	     * A function that returns the `!` of its argument. It will return `true` when
	     * passed false-y value, and `false` when passed a truth-y one.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> Boolean
	     * @param {*} a any value
	     * @return {Boolean} the logical inverse of passed argument.
	     * @see R.complement
	     * @example
	     *
	     *      R.not(true); //=> false
	     *      R.not(false); //=> true
	     *      R.not(0); => true
	     *      R.not(1); => false
	     */
	    var not = _curry1(function not(a) {
	        return !a;
	    });

	    /**
	     * Returns the nth element of the given list or string.
	     * If n is negative the element at index length + n is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> a | Undefined
	     * @sig Number -> String -> String
	     * @param {Number} offset
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      var list = ['foo', 'bar', 'baz', 'quux'];
	     *      R.nth(1, list); //=> 'bar'
	     *      R.nth(-1, list); //=> 'quux'
	     *      R.nth(-99, list); //=> undefined
	     *
	     *      R.nth('abc', 2); //=> 'c'
	     *      R.nth('abc', 3); //=> ''
	     */
	    var nth = _curry2(function nth(offset, list) {
	        var idx = offset < 0 ? list.length + offset : offset;
	        return _isString(list) ? list.charAt(idx) : list[idx];
	    });

	    /**
	     * Returns a function which returns its nth argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> *... -> *
	     * @param {Number} n
	     * @return {Function}
	     * @example
	     *
	     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	     */
	    var nthArg = _curry1(function nthArg(n) {
	        return function () {
	            return nth(n, arguments);
	        };
	    });

	    /**
	     * Returns the nth character of the given string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {String} str
	     * @return {String}
	     * @deprecated since v0.16.0
	     * @example
	     *
	     *      R.nthChar(2, 'Ramda'); //=> 'm'
	     *      R.nthChar(-2, 'Ramda'); //=> 'd'
	     */
	    var nthChar = _curry2(function nthChar(n, str) {
	        return str.charAt(n < 0 ? str.length + n : n);
	    });

	    /**
	     * Returns the character code of the nth character of the given string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig Number -> String -> Number
	     * @param {Number} n
	     * @param {String} str
	     * @return {Number}
	     * @deprecated since v0.16.0
	     * @example
	     *
	     *      R.nthCharCode(2, 'Ramda'); //=> 'm'.charCodeAt(0)
	     *      R.nthCharCode(-2, 'Ramda'); //=> 'd'.charCodeAt(0)
	     */
	    var nthCharCode = _curry2(function nthCharCode(n, str) {
	        return str.charCodeAt(n < 0 ? str.length + n : n);
	    });

	    /**
	     * Returns a singleton array containing the value provided.
	     *
	     * Note this `of` is different from the ES6 `of`; See
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> [a]
	     * @param {*} x any value
	     * @return {Array} An array wrapping `x`.
	     * @example
	     *
	     *      R.of(null); //=> [null]
	     *      R.of([42]); //=> [[42]]
	     */
	    var of = _curry1(function of(x) {
	        return [x];
	    });

	    /**
	     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
	     * `fn` can only ever be called once, no matter how many times the returned function is
	     * invoked.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a... -> b) -> (a... -> b)
	     * @param {Function} fn The function to wrap in a call-only-once wrapper.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var addOneOnce = R.once(function(x){ return x + 1; });
	     *      addOneOnce(10); //=> 11
	     *      addOneOnce(addOneOnce(50)); //=> 11
	     */
	    var once = _curry1(function once(fn) {
	        var called = false, result;
	        return function () {
	            if (called) {
	                return result;
	            }
	            called = true;
	            result = fn.apply(this, arguments);
	            return result;
	        };
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> (a -> a) -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	     */
	    var over = function () {
	        var Identity = function (x) {
	            return {
	                value: x,
	                map: function (f) {
	                    return Identity(f(x));
	                }
	            };
	        };
	        return _curry3(function over(lens, f, x) {
	            return lens(function (y) {
	                return Identity(f(y));
	            })(x).value;
	        });
	    }();

	    /**
	     * Retrieve the value at a given path.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {k: v} -> v | Undefined
	     * @param {Array} path The path to use.
	     * @return {*} The data at `path`.
	     * @example
	     *
	     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	     */
	    var path = _curry2(function path(paths, obj) {
	        if (obj == null) {
	            return;
	        } else {
	            var val = obj;
	            for (var idx = 0, len = paths.length; idx < len && val != null; idx += 1) {
	                val = val[paths[idx]];
	            }
	            return val;
	        }
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
	     * property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	     */
	    var pickAll = _curry2(function pickAll(names, obj) {
	        var result = {};
	        var idx = 0;
	        var len = names.length;
	        while (idx < len) {
	            var name = names[idx];
	            result[name] = obj[name];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that
	     * satisfy the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick
	     * @example
	     *
	     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a new list with the given element at the front, followed by the contents of the
	     * list.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The item to add to the head of the output list.
	     * @param {Array} list The array to add to the tail of the output list.
	     * @return {Array} A new array.
	     * @see R.append
	     * @example
	     *
	     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	     */
	    var prepend = _curry2(function prepend(el, list) {
	        return _concat([el], list);
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * If the given, non-null object has an own property with the specified name,
	     * returns the value of that property.
	     * Otherwise returns the provided default value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig a -> String -> Object -> a
	     * @param {*} val The default value.
	     * @param {String} p The name of the property to return.
	     * @param {Object} obj The object to query.
	     * @return {*} The value of given property of the supplied object or the default value.
	     * @example
	     *
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var favorite = R.prop('favoriteLibrary');
	     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	     *
	     *      favorite(alice);  //=> undefined
	     *      favoriteWithDefault(alice);  //=> 'Ramda'
	     */
	    var propOr = _curry3(function propOr(val, p, obj) {
	        return obj != null && _has(p, obj) ? obj[p] : val;
	    });

	    /**
	     * Returns `true` if the specified object property satisfies the given
	     * predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	     * @param {Function} pred
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propEq
	     * @see R.propIs
	     * @example
	     *
	     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	     */
	    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
	        return pred(obj[name]);
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a list of numbers from `from` (inclusive) to `to`
	     * (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [Number]
	     * @param {Number} from The first number in the list.
	     * @param {Number} to One more than the last number in the list.
	     * @return {Array} The list of numbers in tthe set `[a, b)`.
	     * @example
	     *
	     *      R.range(1, 5);    //=> [1, 2, 3, 4]
	     *      R.range(50, 53);  //=> [50, 51, 52]
	     */
	    var range = _curry2(function range(from, to) {
	        if (!(_isNumber(from) && _isNumber(to))) {
	            throw new TypeError('Both arguments to range must be numbers');
	        }
	        var result = [];
	        var n = from;
	        while (n < to) {
	            result.push(n);
	            n += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling the iterator
	     * function and passing it an accumulator value and the current value from the array, and
	     * then passing the result to the next call.
	     *
	     * Similar to `reduce`, except moves through the input list from the right to the left.
	     *
	     * The iterator function receives two values: *(acc, value)*
	     *
	     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
	     *      var flattenPairs = function(acc, pair) {
	     *        return acc.concat(pair);
	     *      };
	     *
	     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
	     */
	    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            acc = fn(acc, list[idx]);
	            idx -= 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a value wrapped to indicate that it is the final value of the
	     * reduce and transduce functions.  The returned value
	     * should be considered a black box: the internal structure is not
	     * guaranteed to be stable.
	     *
	     * Note: this optimization is unavailable to functions not explicitly listed
	     * above.  For instance, it is not currently supported by reduceIndexed,
	     * reduceRight, or reduceRightIndexed.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.reduce, R.transduce
	     * @sig a -> *
	     * @param {*} x The final value of the reduce.
	     * @return {*} The wrapped value.
	     * @example
	     *
	     *      R.reduce(
	     *        R.pipe(R.add, R.ifElse(R.lte(10), R.reduced, R.identity)),
	     *        0,
	     *        [1, 2, 3, 4, 5]) // 10
	     */
	    var reduced = _curry1(_reduced);

	    /**
	     * Removes the sub-list of `list` starting at index `start` and containing
	     * `count` elements.  _Note that this is not destructive_: it returns a
	     * copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @param {Number} start The position to start removing elements
	     * @param {Number} count The number of elements to remove
	     * @param {Array} list The list to remove from
	     * @return {Array} A new Array with `count` elements from `start` removed.
	     * @example
	     *
	     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	     */
	    var remove = _curry3(function remove(start, count, list) {
	        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
	    });

	    /**
	     * Replace a substring or regex match in a string with a replacement.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig RegExp|String -> String -> String -> String
	     * @param {RegExp|String} pattern A regular expression or a substring to match.
	     * @param {String} replacement The string to replace the matches with.
	     * @param {String} str The String to do the search and replacement in.
	     * @return {String} The result.
	     * @example
	     *
	     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *
	     *      // Use the "g" (global) flag to replace all occurrences:
	     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	     */
	    var replace = _curry3(function replace(regex, replacement, str) {
	        return str.replace(regex, replacement);
	    });

	    /**
	     * Returns a new list with the same elements as the original list, just
	     * in the reverse order.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The list to reverse.
	     * @return {Array} A copy of the list in reverse order.
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _slice(list).reverse();
	    });

	    /**
	     * Scan is similar to reduce, but returns a list of successively reduced values from the left
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> [a]
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} A list of all intermediately reduced values.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	     */
	    var scan = _curry3(function scan(fn, acc, list) {
	        var idx = 0, len = list.length, result = [acc];
	        while (idx < len) {
	            acc = fn(acc, list[idx]);
	            result[idx + 1] = acc;
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> a -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	     */
	    var set = _curry3(function set(lens, v, x) {
	        return over(lens, always(v), x);
	    });

	    /**
	     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
	     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
	     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,a -> Number) -> [a] -> [a]
	     * @param {Function} comparator A sorting function :: a -> b -> Int
	     * @param {Array} list The list to sort
	     * @return {Array} a new array with its elements sorted by the comparator function.
	     * @example
	     *
	     *      var diff = function(a, b) { return a - b; };
	     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	     */
	    var sort = _curry2(function sort(comparator, list) {
	        return _slice(list).sort(comparator);
	    });

	    /**
	     * Sorts the list according to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> [a] -> [a]
	     * @param {Function} fn
	     * @param {Array} list The list to sort.
	     * @return {Array} A new list sorted by the keys generated by `fn`.
	     * @example
	     *
	     *      var sortByFirstItem = R.sortBy(prop(0));
	     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var bob = {
	     *        name: 'Bob',
	     *        age: -10
	     *      };
	     *      var clara = {
	     *        name: 'clara',
	     *        age: 314.159
	     *      };
	     *      var people = [clara, bob, alice];
	     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	     */
	    var sortBy = _curry2(function sortBy(fn, list) {
	        return _slice(list).sort(function (a, b) {
	            var aa = fn(a);
	            var bb = fn(b);
	            return aa < bb ? -1 : aa > bb ? 1 : 0;
	        });
	    });

	    /**
	     * Subtracts two numbers. Equivalent to `a - b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a - b`.
	     * @see R.add
	     * @example
	     *
	     *      R.subtract(10, 8); //=> 2
	     *
	     *      var minus5 = R.subtract(R.__, 5);
	     *      minus5(17); //=> 12
	     *
	     *      var complementaryAngle = R.subtract(90);
	     *      complementaryAngle(30); //=> 60
	     *      complementaryAngle(72); //=> 18
	     */
	    var subtract = _curry2(function subtract(a, b) {
	        return a - b;
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing each value
	     * to the supplied predicate function, and terminating when the predicate function returns
	     * `false`. Excludes the element that caused the predicate function to fail. The predicate
	     * function is passed one argument: *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropLastWhile
	     * @example
	     *
	     *      var isNotOne = function(x) {
	     *        return !(x === 1);
	     *      };
	     *
	     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	     */
	    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && fn(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, idx + 1, Infinity);
	    });

	    /**
	     * Runs the given function with the supplied object, then returns the object.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> *) -> a -> a
	     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	     * @param {*} x
	     * @return {*} `x`.
	     * @example
	     *
	     *      var sayX = function(x) { console.log('x is ' + x); };
	     *      R.tap(sayX, 100); //=> 100
	     *      //-> 'x is 100'
	     */
	    var tap = _curry2(function tap(fn, x) {
	        fn(x);
	        return x;
	    });

	    /**
	     * Determines whether a given string matches a given regular expression.
	     *
	     * @func
	     * @memberOf R
	     * @see R.match
	     * @category String
	     * @sig RegExp -> String -> Boolean
	     * @param {RegExp} pattern
	     * @param {String} str
	     * @return {Boolean}
	     * @example
	     *
	     *      R.test(/^x/, 'xyz'); //=> true
	     *      R.test(/^y/, 'xyz'); //=> false
	     */
	    var test = _curry2(function test(pattern, str) {
	        return _cloneRegExp(pattern).test(str);
	    });

	    /**
	     * Calls an input function `n` times, returning an array containing the results of those
	     * function calls.
	     *
	     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
	     * gradually incremented to `n - 1`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (i -> a) -> i -> [a]
	     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	     * @return {Array} An array containing the return values of all calls to `fn`.
	     * @example
	     *
	     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	     */
	    var times = _curry2(function times(fn, n) {
	        var len = Number(n);
	        var list = new Array(len);
	        var idx = 0;
	        while (idx < len) {
	            list[idx] = fn(idx);
	            idx += 1;
	        }
	        return list;
	    });

	    /**
	     * Converts an object into an array of key, value arrays.
	     * Only the object's own properties are used.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own properties.
	     * @see R.fromPairs
	     * @example
	     *
	     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	     */
	    var toPairs = _curry1(function toPairs(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            if (_has(prop, obj)) {
	                pairs[pairs.length] = [
	                    prop,
	                    obj[prop]
	                ];
	            }
	        }
	        return pairs;
	    });

	    /**
	     * Converts an object into an array of key, value arrays.
	     * The object's own properties and prototype properties are used.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own
	     *         and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	     */
	    var toPairsIn = _curry1(function toPairsIn(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            pairs[pairs.length] = [
	                prop,
	                obj[prop]
	            ];
	        }
	        return pairs;
	    });

	    /**
	     * Removes (strips) whitespace from both ends of the string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to trim.
	     * @return {String} Trimmed version of `str`.
	     * @example
	     *
	     *      R.trim('   xyz  '); //=> 'xyz'
	     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	     */
	    var trim = function () {
	        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	        var zeroWidth = '\u200B';
	        var hasProtoTrim = typeof String.prototype.trim === 'function';
	        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
	            return _curry1(function trim(str) {
	                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	                return str.replace(beginRx, '').replace(endRx, '');
	            });
	        } else {
	            return _curry1(function trim(str) {
	                return str.trim();
	            });
	        }
	    }();

	    /**
	     * Gives a single-word string description of the (native) type of a value, returning such
	     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
	     * Object types any further, reporting them all as 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Takes a function `fn`, which takes a single array argument, and returns
	     * a function which:
	     *
	     *   - takes any number of positional arguments;
	     *   - passes these arguments to `fn` as an array; and
	     *   - returns the result.
	     *
	     * In other words, R.unapply derives a variadic function from a function
	     * which takes an array. R.unapply is the inverse of R.apply.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ([*...] -> a) -> (*... -> a)
	     * @param {Function} fn
	     * @return {Function}
	     * @see R.apply
	     * @example
	     *
	     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	     */
	    var unapply = _curry1(function unapply(fn) {
	        return function () {
	            return fn(_slice(arguments));
	        };
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
	     * parameter. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> b) -> (a -> b)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 1.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.unary(takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only 1 argument is passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var unary = _curry1(function unary(fn) {
	        return nAry(1, fn);
	    });

	    /**
	     * Returns a function of arity `n` from a (manually) curried function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (a -> b) -> (a -> c)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to uncurry.
	     * @return {Function} A new function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFour = function(a) {
	     *        return function(b) {
	     *          return function(c) {
	     *            return function(d) {
	     *              return a + b + c + d;
	     *            };
	     *          };
	     *        };
	     *      };
	     *
	     *      var uncurriedAddFour = R.uncurryN(4, addFour);
	     *      curriedAddFour(1, 2, 3, 4); //=> 10
	     */
	    var uncurryN = _curry2(function uncurryN(depth, fn) {
	        return curryN(depth, function () {
	            var currentDepth = 1;
	            var value = fn;
	            var idx = 0;
	            var endIdx;
	            while (currentDepth <= depth && typeof value === 'function') {
	                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	                value = value.apply(this, _slice(arguments, idx, endIdx));
	                currentDepth += 1;
	                idx = endIdx;
	            }
	            return value;
	        });
	    });

	    /**
	     * Builds a list from a seed value. Accepts an iterator function, which returns either false
	     * to stop iteration or an array of length 2 containing the value to add to the resulting
	     * list and the seed to be used in the next call to the iterator function.
	     *
	     * The iterator function receives one argument: *(seed)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> [b]) -> * -> [b]
	     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	     *        either false to quit iteration or an array of length two to proceed. The element
	     *        at index 0 of this array will be added to the resulting array, and the element
	     *        at index 1 will be passed to the next call to `fn`.
	     * @param {*} seed The seed value.
	     * @return {Array} The final list.
	     * @example
	     *
	     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };
	     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	     */
	    var unfold = _curry2(function unfold(fn, seed) {
	        var pair = fn(seed);
	        var result = [];
	        while (pair && pair.length) {
	            result[result.length] = pair[0];
	            pair = fn(pair[1]);
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original list, based
	     * upon the value returned by applying the supplied predicate to two list elements. Prefers
	     * the first item if two items compare equal based on the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      var strEq = function(a, b) { return String(a) === String(b); };
	     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	     */
	    var uniqWith = _curry2(function uniqWith(pred, list) {
	        var idx = 0, len = list.length;
	        var result = [], item;
	        while (idx < len) {
	            item = list[idx];
	            if (!_containsWith(pred, item, result)) {
	                result[result.length] = item;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a new copy of the array with the element at the
	     * provided index replaced with the given value.
	     * @see R.adjust
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} idx The index to update.
	     * @param {*} x The value to exist at the given index of the returned array.
	     * @param {Array|Arguments} list The source array-like object to be updated.
	     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	     * @example
	     *
	     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var update = _curry3(function update(idx, x, list) {
	        return adjust(always(x), idx, list);
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across
	     * different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    /**
	     * Returns a list of all the properties, including prototype properties,
	     * of the supplied object.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.valuesIn(f); //=> ['X', 'Y']
	     */
	    var valuesIn = _curry1(function valuesIn(obj) {
	        var prop, vs = [];
	        for (prop in obj) {
	            vs[vs.length] = obj[prop];
	        }
	        return vs;
	    });

	    /**
	     * Returns a "view" of the given data structure, determined by the given lens.
	     * The lens's focus determines which portion of the data structure is visible.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> s -> a
	     * @param {Lens} lens
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});  //=> 1
	     *      R.view(xLens, {x: 4, y: 2});  //=> 4
	     */
	    var view = function () {
	        var Const = function (x) {
	            return {
	                value: x,
	                map: function () {
	                    return this;
	                }
	            };
	        };
	        return _curry2(function view(lens, x) {
	            return lens(Const)(x).value;
	        });
	    }();

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec. Each of the spec's own properties must be a predicate function.
	     * Each predicate is applied to the value of the corresponding property of
	     * the test object. `where` returns true if all the predicates return true,
	     * false otherwise.
	     *
	     * `where` is well suited to declaratively expressing constraints for other
	     * functions such as `filter` and `find`.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.where({
	     *        a: R.equals('foo'),
	     *        b: R.complement(R.equals('bar')),
	     *        x: R.gt(_, 10),
	     *        y: R.lt(_, 20)
	     *      });
	     *
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	     */
	    var where = _curry2(function where(spec, testObj) {
	        for (var prop in spec) {
	            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	                return false;
	            }
	        }
	        return true;
	    });

	    /**
	     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
	     * other processing either before the internal function is called or with its results.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
	     * @param {Function} fn The function to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var greet = function(name) {return 'Hello ' + name;};
	     *
	     *      var shoutedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name).toUpperCase();
	     *      });
	     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
	     *
	     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name.substring(0, 3));
	     *      });
	     *      shortenedGreet("Robert"); //=> "Hello Rob"
	     */
	    var wrap = _curry2(function wrap(fn, wrapper) {
	        return curryN(fn.length, function () {
	            return wrapper.apply(this, _concat([fn], arguments));
	        });
	    });

	    /**
	     * Creates a new list out of the two supplied by creating each possible
	     * pair from the lists.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The list made by combining each possible pair from
	     *         `as` and `bs` into pairs (`[a, b]`).
	     * @example
	     *
	     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	     */
	    // = xprodWith(prepend); (takes about 3 times as long...)
	    var xprod = _curry2(function xprod(a, b) {
	        // = xprodWith(prepend); (takes about 3 times as long...)
	        var idx = 0;
	        var ilen = a.length;
	        var j;
	        var jlen = b.length;
	        var result = [];
	        while (idx < ilen) {
	            j = 0;
	            while (j < jlen) {
	                result[result.length] = [
	                    a[idx],
	                    b[j]
	                ];
	                j += 1;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Creates a new list out of the two supplied by pairing up
	     * equally-positioned items from both lists.  The returned list is
	     * truncated to the length of the shorter of the two input lists.
	     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	     * @example
	     *
	     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     */
	    var zip = _curry2(function zip(a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = [
	                a[idx],
	                b[idx]
	            ];
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * Creates a new object out of a list of keys and a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [String] -> [*] -> {String: *}
	     * @param {Array} keys The array that will be properties on the output object.
	     * @param {Array} values The list of values on the output object.
	     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	     * @example
	     *
	     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	     */
	    var zipObj = _curry2(function zipObj(keys, values) {
	        var idx = 0, len = keys.length, out = {};
	        while (idx < len) {
	            out[keys[idx]] = values[idx];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Creates a new list out of the two supplied by applying the function to
	     * each equally-positioned pair in the lists. The returned list is
	     * truncated to the length of the shorter of the two input lists.
	     *
	     * @function
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> c) -> [a] -> [b] -> [c]
	     * @param {Function} fn The function used to combine the two elements into one value.
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	     *         using `fn`.
	     * @example
	     *
	     *      var f = function(x, y) {
	     *        // ...
	     *      };
	     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	     */
	    var zipWith = _curry3(function zipWith(fn, a, b) {
	        var rv = [], idx = 0, len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = fn(a[idx], b[idx]);
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * A function that always returns `false`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig * -> false
	     * @return {Boolean} false
	     * @see R.always, R.T
	     * @example
	     *
	     *      R.F(); //=> false
	     */
	    var F = always(false);

	    /**
	     * A function that always returns `true`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig * -> true
	     * @return {Boolean} `true`.
	     * @see R.always, R.F
	     * @example
	     *
	     *      R.T(); //=> true
	     */
	    var T = always(true);

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it will
	     * default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Copies an object.
	     *
	     * @private
	     * @param {*} value The value to be copied
	     * @param {Array} refFrom Array containing the source references
	     * @param {Array} refTo Array containing the copied source references
	     * @return {*} The copied value.
	     */
	    var _clone = function _clone(value, refFrom, refTo) {
	        var copy = function copy(copiedValue) {
	            var len = refFrom.length;
	            var idx = 0;
	            while (idx < len) {
	                if (value === refFrom[idx]) {
	                    return refTo[idx];
	                }
	                idx += 1;
	            }
	            refFrom[idx + 1] = value;
	            refTo[idx + 1] = copiedValue;
	            for (var key in value) {
	                copiedValue[key] = _clone(value[key], refFrom, refTo);
	            }
	            return copiedValue;
	        };
	        switch (type(value)) {
	        case 'Object':
	            return copy({});
	        case 'Array':
	            return copy([]);
	        case 'Date':
	            return new Date(value);
	        case 'RegExp':
	            return _cloneRegExp(value);
	        default:
	            return value;
	        }
	    };

	    var _createPartialApplicator = function _createPartialApplicator(concat) {
	        return function (fn) {
	            var args = _slice(arguments, 1);
	            return _arity(Math.max(0, fn.length - args.length), function () {
	                return fn.apply(this, concat(args, arguments));
	            });
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a  function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    // The algorithm used to handle cyclic structures is
	    // inspired by underscore's isEqual
	    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
	    var _equals = function _equals(a, b, stackA, stackB) {
	        var typeA = type(a);
	        if (typeA !== type(b)) {
	            return false;
	        }
	        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
	            return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
	        }
	        if (identical(a, b)) {
	            return true;
	        }
	        if (typeA === 'RegExp') {
	            // RegExp equality algorithm: http://stackoverflow.com/a/10776635
	            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
	        }
	        if (Object(a) === a) {
	            if (typeA === 'Date' && a.getTime() !== b.getTime()) {
	                return false;
	            }
	            var keysA = keys(a);
	            if (keysA.length !== keys(b).length) {
	                return false;
	            }
	            var idx = stackA.length - 1;
	            while (idx >= 0) {
	                if (stackA[idx] === a) {
	                    return stackB[idx] === b;
	                }
	                idx -= 1;
	            }
	            stackA[stackA.length] = a;
	            stackB[stackB.length] = b;
	            idx = keysA.length - 1;
	            while (idx >= 0) {
	                var key = keysA[idx];
	                if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
	                    return false;
	                }
	                idx -= 1;
	            }
	            stackA.pop();
	            stackB.pop();
	            return true;
	        }
	        return false;
	    };

	    /**
	     * Private function that determines whether or not a provided object has a given method.
	     * Does not ignore methods stored on the object's prototype chain. Used for dynamically
	     * dispatching Ramda methods to non-Array objects.
	     *
	     * @private
	     * @param {String} methodName The name of the method to check for.
	     * @param {Object} obj The object to test.
	     * @return {Boolean} `true` has a given method, `false` otherwise.
	     * @example
	     *
	     *      var person = { name: 'John' };
	     *      person.shout = function() { alert(this.name); };
	     *
	     *      _hasMethod('shout', person); //=> true
	     *      _hasMethod('foo', person); //=> false
	     */
	    var _hasMethod = function _hasMethod(methodName, obj) {
	        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
	     * based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, result = [], idx = 0, j, ilen = list.length, jlen;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0, len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    var _stepCat = function () {
	        var _stepCatArray = {
	            '@@transducer/init': Array,
	            '@@transducer/step': function (xs, x) {
	                return _concat(xs, [x]);
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatString = {
	            '@@transducer/init': String,
	            '@@transducer/step': function (a, b) {
	                return a + b;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatObject = {
	            '@@transducer/init': Object,
	            '@@transducer/step': function (result, input) {
	                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
	            },
	            '@@transducer/result': _identity
	        };
	        return function _stepCat(obj) {
	            if (_isTransformer(obj)) {
	                return obj;
	            }
	            if (isArrayLike(obj)) {
	                return _stepCatArray;
	            }
	            if (typeof obj === 'string') {
	                return _stepCatString;
	            }
	            if (typeof obj === 'object') {
	                return _stepCatObject;
	            }
	            throw new Error('Cannot create transformer for ' + obj);
	        };
	    }();

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xany = function () {
	        function XAny(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.any = false;
	        }
	        XAny.prototype['@@transducer/init'] = _xfBase.init;
	        XAny.prototype['@@transducer/result'] = function (result) {
	            if (!this.any) {
	                result = this.xf['@@transducer/step'](result, false);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAny.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.any = true;
	                result = _reduced(this.xf['@@transducer/step'](result, true));
	            }
	            return result;
	        };
	        return _curry2(function _xany(f, xf) {
	            return new XAny(f, xf);
	        });
	    }();

	    var _xdrop = function () {
	        function XDrop(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XDrop.prototype['@@transducer/init'] = _xfBase.init;
	        XDrop.prototype['@@transducer/result'] = _xfBase.result;
	        XDrop.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n > 0) {
	                this.n -= 1;
	                return result;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdrop(n, xf) {
	            return new XDrop(n, xf);
	        });
	    }();

	    var _xdropWhile = function () {
	        function XDropWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f) {
	                if (this.f(input)) {
	                    return result;
	                }
	                this.f = null;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropWhile(f, xf) {
	            return new XDropWhile(f, xf);
	        });
	    }();

	    var _xgroupBy = function () {
	        function XGroupBy(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.inputs = {};
	        }
	        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
	        XGroupBy.prototype['@@transducer/result'] = function (result) {
	            var key;
	            for (key in this.inputs) {
	                if (_has(key, this.inputs)) {
	                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
	                    if (result['@@transducer/reduced']) {
	                        result = result['@@transducer/value'];
	                        break;
	                    }
	                }
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
	            var key = this.f(input);
	            this.inputs[key] = this.inputs[key] || [
	                key,
	                []
	            ];
	            this.inputs[key][1] = append(input, this.inputs[key][1]);
	            return result;
	        };
	        return _curry2(function _xgroupBy(f, xf) {
	            return new XGroupBy(f, xf);
	        });
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new parameters
	     * to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that more closely
	     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
	     * the iteration callback function is the first parameter, and where the list is the last
	     * parameter.  (This latter might be unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed(function(val, idx) {return idx + '-' + val;}, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if there are any
	     * that don't.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * A function that returns the first argument if it's falsy otherwise the second
	     * argument. Note that this is NOT short-circuited, meaning that if expressions
	     * are passed they are both evaluated.
	     *
	     * Dispatches to the `and` method of the first argument if applicable.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {*} a any value
	     * @param {*} b any other value
	     * @return {*} the first argument if falsy otherwise the second argument.
	     * @see R.both
	     * @example
	     *
	     *      R.and(false, true); //=> false
	     *      R.and(0, []); //=> 0
	     *      R.and(null, ''); => null
	     */
	    var and = _curry2(function and(a, b) {
	        return _hasMethod('and', a) ? a.and(b) : a && b;
	    });

	    /**
	     * Returns `true` if at least one of elements of the list match the predicate, `false`
	     * otherwise.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	     *         otherwise.
	     * @see R.all, R.none
	     * @example
	     *
	     *      var lessThan0 = R.flip(R.lt)(0);
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      R.any(lessThan0)([1, 2]); //=> false
	     *      R.any(lessThan2)([1, 2]); //=> true
	     */
	    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (fn(list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    }));

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
	     * parameters. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> c) -> (a, b -> c)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 2.
	     * @example
	     *
	     *      var takesThreeArgs = function(a, b, c) {
	     *        return [a, b, c];
	     *      };
	     *      takesThreeArgs.length; //=> 3
	     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      var takesTwoArgs = R.binary(takesThreeArgs);
	     *      takesTwoArgs.length; //=> 2
	     *      // Only 2 arguments are passed to the wrapped function
	     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	     */
	    var binary = _curry1(function binary(fn) {
	        return nAry(2, fn);
	    });

	    /**
	     * Creates a deep copy of the value which may contain (nested) `Array`s and
	     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
	     * not copied, but assigned by their reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> {*}
	     * @param {*} value The object or array to clone
	     * @return {*} A new object or array.
	     * @example
	     *
	     *      var objects = [{}, {}, {}];
	     *      var objectsClone = R.clone(objects);
	     *      objects[0] === objectsClone[0]; //=> false
	     */
	    var clone = _curry1(function clone(value) {
	        return _clone(value, [], []);
	    });

	    /**
	     * Returns a new list consisting of the elements of the first list followed by the elements
	     * of the second.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list to merge.
	     * @param {Array} list2 The second set to merge.
	     * @return {Array} A new array consisting of the contents of `list1` followed by the
	     *         contents of `list2`. If, instead of an Array for `list1`, you pass an
	     *         object with a `concat` method on it, `concat` will call `list1.concat`
	     *         and pass it the value of `list2`.
	     *
	     * @example
	     *
	     *      R.concat([], []); //=> []
	     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	     */
	    var concat = _curry2(function concat(set1, set2) {
	        if (_isArray(set2)) {
	            return _concat(set1, set2);
	        } else if (_hasMethod('concat', set1)) {
	            return set1.concat(set2);
	        } else {
	            throw new TypeError('can\'t concat ' + typeof set1);
	        }
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried
	     * function has two unusual capabilities. First, its arguments needn't
	     * be provided one at a time. If `f` is a ternary function and `g` is
	     * `R.curry(f)`, the following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`,
	     * the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = function(a, b, c, d) {
	     *        return a + b + c + d;
	     *      };
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing each value
	     * to the supplied predicate function, skipping elements while the predicate function returns
	     * `true`. The predicate function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeWhile
	     * @example
	     *
	     *      var lteTwo = function(x) {
	     *        return x <= 2;
	     *      };
	     *
	     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	     */
	    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
	        var idx = 0, len = list.length;
	        while (idx < len && pred(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, idx);
	    }));

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise.
	     * Dispatches to an `equals` method if present. Handles cyclical data
	     * structures.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
	    });

	    /**
	     * Returns a new list containing only those items that match a given predicate function.
	     * The predicate function is passed one argument: *(value)*.
	     *
	     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
	     * `Array.prototype.filter` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.reject
	     * @example
	     *
	     *      var isEven = function(n) {
	     *        return n % 2 === 0;
	     *      };
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

	    /**
	     * Returns the first element of the list which matches the predicate, or `undefined` if no
	     * element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the predicate, or `-1`
	     * if no element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns the last element of the list which matches the predicate, or `undefined` if no
	     * element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx -= 1;
	        }
	    }));

	    /**
	     * Returns the index of the last element of the list which matches the predicate, or
	     * `-1` if no element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx -= 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
	     * them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new function much like the supplied one, except that the first two arguments'
	     * order is reversed.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
	     * @param {Function} fn The function to invoke with its first two parameters reversed.
	     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	     * @example
	     *
	     *      var mergeThree = function(a, b, c) {
	     *        return ([]).concat(a, b, c);
	     *      };
	     *
	     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	     */
	    var flip = _curry1(function flip(fn) {
	        return curry(function (a, b) {
	            var args = _slice(arguments);
	            args[0] = b;
	            args[1] = a;
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each element in the
	     * list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
	     * array. In some libraries this function is named `each`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @example
	     *
	     *      var printXPlusFive = function(x) { console.log(x + 5); };
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Returns a list of function names of object's own functions
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> [String]
	     * @param {Object} obj The objects with functions in it
	     * @return {Array} A list of the object's own properties that map to functions.
	     * @example
	     *
	     *      R.functions(R); // returns list of ramda's own function names
	     *
	     *      var F = function() { this.x = function(){}; this.y = 1; }
	     *      F.prototype.z = function() {};
	     *      F.prototype.a = 100;
	     *      R.functions(new F()); //=> ["x"]
	     */
	    var functions = _curry1(_functionsWith(keys));

	    /**
	     * Returns a list of function names of object's own and prototype functions
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> [String]
	     * @param {Object} obj The objects with functions in it
	     * @return {Array} A list of the object's own properties and prototype
	     *         properties that map to functions.
	     * @example
	     *
	     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
	     *
	     *      var F = function() { this.x = function(){}; this.y = 1; }
	     *      F.prototype.z = function() {};
	     *      F.prototype.a = 100;
	     *      R.functionsIn(new F()); //=> ["x", "z"]
	     */
	    var functionsIn = _curry1(_functionsWith(keysIn));

	    /**
	     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
	     * on each element, and grouping the results according to values returned.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> String) -> [a] -> {String: [a]}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} list The array to group
	     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	     *         that produced that key when passed to `fn`.
	     * @example
	     *
	     *      var byGrade = R.groupBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Abby', score: 84},
	     *                      {name: 'Eddy', score: 58},
	     *                      // ...
	     *                      {name: 'Jack', score: 69}];
	     *      byGrade(students);
	     *      // {
	     *      //   'A': [{name: 'Dianne', score: 99}],
	     *      //   'B': [{name: 'Abby', score: 84}]
	     *      //   // ...,
	     *      //   'F': [{name: 'Eddy', score: 58}]
	     *      // }
	     */
	    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
	        return _reduce(function (acc, elt) {
	            var key = fn(elt);
	            acc[key] = append(elt, acc[key] || (acc[key] = []));
	            return acc;
	        }, {}, list);
	    }));

	    /**
	     * Returns the first element of the given list or string. In some libraries
	     * this function is named `first`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.tail, R.init, R.last
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	     *      R.head([]); //=> undefined
	     *
	     *      R.head('abc'); //=> 'a'
	     *      R.head(''); //=> ''
	     */
	    var head = nth(0);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists.  Duplication is determined according
	     * to the value returned by applying the supplied predicate to two list
	     * elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate function that determines whether
	     *        the two supplied elements are equal.
	     * @param {Array} list1 One list of items to compare
	     * @param {Array} list2 A second list of items to compare
	     * @see R.intersection
	     * @return {Array} A new list containing those elements common to both lists.
	     * @example
	     *
	     *      var buffaloSpringfield = [
	     *        {id: 824, name: 'Richie Furay'},
	     *        {id: 956, name: 'Dewey Martin'},
	     *        {id: 313, name: 'Bruce Palmer'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *      var csny = [
	     *        {id: 204, name: 'David Crosby'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 539, name: 'Graham Nash'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *
	     *      var sameId = function(o1, o2) {return o1.id === o2.id;};
	     *
	     *      R.intersectionWith(sameId, buffaloSpringfield, csny);
	     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	     */
	    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
	        var results = [], idx = 0;
	        while (idx < list1.length) {
	            if (_containsWith(pred, list1[idx], list2)) {
	                results[results.length] = list1[idx];
	            }
	            idx += 1;
	        }
	        return uniqWith(pred, results);
	    });

	    /**
	     * Creates a new list with the separator interposed between elements.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} separator The element to add to the list.
	     * @param {Array} list The list to be interposed.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	     */
	    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
	        var out = [];
	        var idx = 0;
	        var length = list.length;
	        while (idx < length) {
	            if (idx === length - 1) {
	                out.push(list[idx]);
	            } else {
	                out.push(list[idx], separator);
	            }
	            idx += 1;
	        }
	        return out;
	    }));

	    /**
	     * Transforms the items of the list with the transducer and appends the transformed items to
	     * the accumulator using an appropriate iterator function based on the accumulator type.
	     *
	     * The accumulator can be an array, string, object or a transformer. Iterated items will
	     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
	     * arrays will be merged as key, value pairs.
	     *
	     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
	     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
	     * result. The step function is used as the iterator function in reduce. The result function is
	     * used to convert the final accumulator into the return type and in most cases is R.identity.
	     * The init function is used to provide the initial accumulator.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> (b -> b) -> [c] -> a
	     * @param {*} acc The initial accumulator value.
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.into([], transducer, numbers); //=> [2, 3]
	     *
	     *      var intoArray = R.into([]);
	     *      intoArray(transducer, numbers); //=> [2, 3]
	     */
	    var into = _curry3(function into(acc, xf, list) {
	        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
	    });

	    /**
	     * Same as R.invertObj, however this accounts for objects
	     * with duplicate values by putting the values into an
	     * array.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {s: x} -> {x: [ s, ... ]}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object with keys
	     * in an array.
	     * @example
	     *
	     *      var raceResultsByFirstName = {
	     *        first: 'alice',
	     *        second: 'jake',
	     *        third: 'alice',
	     *      };
	     *      R.invert(raceResultsByFirstName);
	     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	     */
	    var invert = _curry1(function invert(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            var val = obj[key];
	            var list = _has(val, out) ? out[val] : out[val] = [];
	            list[list.length] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object with the keys of the given object
	     * as values, and the values of the given object as keys.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {s: x} -> {x: s}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object
	     * @example
	     *
	     *      var raceResults = {
	     *        first: 'alice',
	     *        second: 'jake'
	     *      };
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': 'first', 'jake':'second' }
	     *
	     *      // Alternatively:
	     *      var raceResults = ['alice', 'jake'];
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': '0', 'jake':'1' }
	     */
	    var invertObj = _curry1(function invertObj(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            out[obj[key]] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.init, R.head, R.tail
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	     *      R.last([]); //=> undefined
	     *
	     *      R.last('abc'); //=> 'c'
	     *      R.last(''); //=> ''
	     */
	    var last = nth(-1);

	    /**
	     * Returns the position of the last occurrence of an item in
	     * an array, or -1 if the item is not included in the array.
	     * `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.indexOf
	     * @example
	     *
	     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	     */
	    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
	        if (_hasMethod('lastIndexOf', xs)) {
	            return xs.lastIndexOf(target);
	        } else {
	            var idx = xs.length - 1;
	            while (idx >= 0) {
	                if (equals(xs[idx], target)) {
	                    return idx;
	                }
	                idx -= 1;
	            }
	            return -1;
	        }
	    });

	    /**
	     * Returns a new list, constructed by applying the supplied function to every element of the
	     * supplied list.
	     *
	     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
	     * native `Array.prototype.map` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> b) -> [a] -> [b]
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      var double = function(x) {
	     *        return x * 2;
	     *      };
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     */
	    var map = _curry2(_dispatchable('map', _xmap, _map));

	    /**
	     * Map, but for objects. Creates an object with the same keys as `obj` and values
	     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     * become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var double = function(num) {
	     *        return num * 2;
	     *      };
	     *
	     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
	     */
	    var mapObj = _curry2(function mapObj(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key]);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Like `mapObj`, but but passes additional arguments to the predicate function. The
	     * predicate function is passed three arguments: *(value, key, obj)*.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     *        become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = function(num, key, obj) {
	     *        return key + (num * 2);
	     *      };
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Returns `true` if no elements of the list match the predicate,
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	     * @see R.all, R.any
	     * @example
	     *
	     *      R.none(R.isNaN, [1, 2, 3]); //=> true
	     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
	     */
	    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

	    /**
	     * A function that returns the first truthy of two arguments otherwise the
	     * last argument. Note that this is NOT short-circuited, meaning that if
	     * expressions are passed they are both evaluated.
	     *
	     * Dispatches to the `or` method of the first argument if applicable.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {*} a any value
	     * @param {*} b any other value
	     * @return {*} the first truthy argument, otherwise the last argument.
	     * @see R.either
	     * @example
	     *
	     *      R.or(false, true); //=> true
	     *      R.or(0, []); //=> []
	     *      R.or(null, ''); => ''
	     */
	    var or = _curry2(function or(a, b) {
	        return _hasMethod('or', a) ? a.or(b) : a || b;
	    });

	    /**
	     * Accepts as its arguments a function and any number of values and returns a function that,
	     * when invoked, calls the original function with all of the values prepended to the
	     * original function's arguments list. In some libraries this function is named `applyLeft`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)
	     * @param {Function} fn The function to invoke.
	     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
	     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
	     *         with `args` prepended to `fn`'s arguments list.
	     * @example
	     *
	     *      var multiply = function(a, b) { return a * b; };
	     *      var double = R.partial(multiply, 2);
	     *      double(2); //=> 4
	     *
	     *      var greet = function(salutation, title, firstName, lastName) {
	     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *      };
	     *      var sayHello = R.partial(greet, 'Hello');
	     *      var sayHelloToMs = R.partial(sayHello, 'Ms.');
	     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partial = curry(_createPartialApplicator(_concat));

	    /**
	     * Accepts as its arguments a function and any number of values and returns a function that,
	     * when invoked, calls the original function with all of the values appended to the original
	     * function's arguments list.
	     *
	     * Note that `partialRight` is the opposite of `partial`: `partialRight` fills `fn`'s arguments
	     * from the right to the left.  In some libraries this function is named `applyRight`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)
	     * @param {Function} fn The function to invoke.
	     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
	     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
	     *         `args` appended to `fn`'s arguments list.
	     * @example
	     *
	     *      var greet = function(salutation, title, firstName, lastName) {
	     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *      };
	     *      var greetMsJaneJones = R.partialRight(greet, 'Ms.', 'Jane', 'Jones');
	     *
	     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partialRight = curry(_createPartialApplicator(flip(_concat)));

	    /**
	     * Takes a predicate and a list and returns the pair of lists of
	     * elements which do and do not satisfy the predicate, respectively.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
	     * @param {Function} pred A predicate to determine which array the element belongs to.
	     * @param {Array} list The array to partition.
	     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
	     *         and second an array of elements that did not satisfy.
	     * @example
	     *
	     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	     */
	    var partition = _curry2(function partition(pred, list) {
	        return _reduce(function (acc, elt) {
	            var xs = acc[pred(elt) ? 0 : 1];
	            xs[xs.length] = elt;
	            return acc;
	        }, [
	            [],
	            []
	        ], list);
	    });

	    /**
	     * Determines whether a nested path on an object has a specific value,
	     * in `R.equals` terms. Most likely used to filter a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [String] -> * -> {String: *} -> Boolean
	     * @param {Array} path The path of the nested property to use
	     * @param {*} val The value to compare the nested property with
	     * @param {Object} obj The object to check the nested property in
	     * @return {Boolean} `true` if the value equals the nested object property,
	     *         `false` otherwise.
	     * @example
	     *
	     *      var user1 = { address: { zipCode: 90210 } };
	     *      var user2 = { address: { zipCode: 55555 } };
	     *      var user3 = { name: 'Bob' };
	     *      var users = [ user1, user2, user3 ];
	     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	     *      R.filter(isFamous, users); //=> [ user1 ]
	     */
	    var pathEq = _curry3(function pathEq(_path, val, obj) {
	        return equals(path(_path, obj), val);
	    });

	    /**
	     * Returns a new list by plucking the same named property off all objects in the list supplied.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig k -> [{k: v}] -> [v]
	     * @param {Number|String} key The key name to pluck off of each object.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of values for the given key.
	     * @example
	     *
	     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	     */
	    var pluck = _curry2(function pluck(p, list) {
	        return map(prop(p), list);
	    });

	    /**
	     * Returns `true` if the specified object property is equal, in `R.equals`
	     * terms, to the given value; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig String -> a -> Object -> Boolean
	     * @param {String} name
	     * @param {*} val
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.equals, R.propSatisfies
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	     *      var kids = [abby, fred, rusty, alois];
	     *      var hasBrownHair = R.propEq('hair', 'brown');
	     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	     */
	    var propEq = _curry3(function propEq(name, val, obj) {
	        return propSatisfies(equals(val), name, obj);
	    });

	    /**
	     * Returns `true` if the specified object property is of the given type;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig Type -> String -> Object -> Boolean
	     * @param {Function} type
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.is
	     * @see R.propSatisfies
	     * @example
	     *
	     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	     *      R.propIs(Number, 'x', {});            //=> false
	     */
	    var propIs = _curry3(function propIs(type, name, obj) {
	        return propSatisfies(is(type), name, obj);
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling the iterator
	     * function and passing it an accumulator value and the current value from the array, and
	     * then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
	     * shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     * @see R.reduced
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = function(a, b) {
	     *        return a + b;
	     *      };
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    /**
	     * Similar to `filter`, except that it keeps only values for which the given predicate
	     * function returns falsy. The predicate function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.filter
	     * @example
	     *
	     *      var isOdd = function(n) {
	     *        return n % 2 === 1;
	     *      };
	     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var reject = _curry2(function reject(fn, list) {
	        return filter(_complement(fn), list);
	    });

	    /**
	     * Returns a fixed list of size `n` containing a specified identical value.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> n -> [a]
	     * @param {*} value The value to repeat.
	     * @param {Number} n The desired size of the output list.
	     * @return {Array} A new array containing `n` `value`s.
	     * @example
	     *
	     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	     *
	     *      var obj = {};
	     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	     */
	    var repeat = _curry2(function repeat(value, n) {
	        return times(always(value), n);
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Splits a collection into slices of the specified length.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @sig Number -> String -> [String]
	     * @param {Number} n
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	     */
	    var splitEvery = _curry2(function splitEvery(n, list) {
	        if (n <= 0) {
	            throw new Error('First argument to splitEvery must be a positive integer');
	        }
	        var result = [];
	        var idx = 0;
	        while (idx < list.length) {
	            result.push(slice(idx, idx += n, list));
	        }
	        return result;
	    });

	    /**
	     * Adds together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The sum of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.sum([2,4,6,8,100,1]); //=> 121
	     */
	    var sum = reduce(add, 0);

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.head, R.init, R.last
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Returns the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `take` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.drop
	     * @example
	     *
	     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(3, 'ramda');               //=> 'ram'
	     *
	     *      var personnel = [
	     *        'Dave Brubeck',
	     *        'Paul Desmond',
	     *        'Eugene Wright',
	     *        'Joe Morello',
	     *        'Gerry Mulligan',
	     *        'Bob Bates',
	     *        'Joe Dodge',
	     *        'Ron Crotty'
	     *      ];
	     *
	     *      var takeFive = R.take(5);
	     *      takeFive(personnel);
	     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	     */
	    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
	        return slice(0, n < 0 ? Infinity : n, xs);
	    }));

	    /**
	     * Returns a new list containing the first `n` elements of a given list, passing each value
	     * to the supplied predicate function, and terminating when the predicate function returns
	     * `false`. Excludes the element that caused the predicate function to fail. The predicate
	     * function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropWhile
	     * @example
	     *
	     *      var isNotFour = function(x) {
	     *        return !(x === 4);
	     *      };
	     *
	     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
	     */
	    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
	        var idx = 0, len = list.length;
	        while (idx < len && fn(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, 0, idx);
	    }));

	    /**
	     * Initializes a transducer using supplied iterator function. Returns a single item by
	     * iterating through the list, successively calling the transformed iterator function and
	     * passing it an accumulator value and the current value from the array, and then passing
	     * the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
	     * transformer to initialize the transducer. A transformer can be passed directly in place
	     * of an iterator function.  In both cases, iteration may be stopped early with the
	     * `R.reduced` function.
	     *
	     * A transducer is a function that accepts a transformer and returns a transformer and can
	     * be composed directly.
	     *
	     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
	     * 0-arity initial value function, init, and 1-arity result extraction function, result.
	     * The step function is used as the iterator function in reduce. The result function is used
	     * to convert the final accumulator into the return type and in most cases is R.identity.
	     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.reduce, R.reduced, R.into
	     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array. Wrapped as transformer, if necessary, and used to
	     *        initialize the transducer
	     * @param {*} acc The initial accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	     */
	    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
	        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
	     * determined according to the value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @see R.union
	     * @example
	     *
	     *      function cmp(x, y) { return x.a === y.a; }
	     *      var l1 = [{a: 1}, {a: 2}];
	     *      var l2 = [{a: 1}, {a: 4}];
	     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	     */
	    var unionWith = _curry3(function unionWith(pred, list1, list2) {
	        return uniqWith(pred, _concat(list1, list2));
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original list.
	     * `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	     *      R.uniq([1, '1']);     //=> [1, '1']
	     *      R.uniq([[42], [42]]); //=> [[42]]
	     */
	    var uniq = uniqWith(equals);

	    /**
	     * Returns a new list by pulling every item at the first level of nesting out, and putting
	     * them in a new array.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.flatten
	     * @example
	     *
	     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	     */
	    var unnest = _curry1(_makeFlat(false));

	    /**
	     * Accepts a function `fn` and any number of transformer functions and returns a new
	     * function. When the new function is invoked, it calls the function `fn` with parameters
	     * consisting of the result of calling each supplied handler on successive arguments to the
	     * new function.
	     *
	     * If more arguments are passed to the returned function than transformer functions, those
	     * arguments are passed directly to `fn` as additional parameters. If you expect additional
	     * arguments that don't need to be transformed, although you can ignore them, it's best to
	     * pass an identity function so that the new function reports the correct arity.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> ((a -> x1), (b -> x2), ...) -> (a -> b -> ... -> z)
	     * @param {Function} fn The function to wrap.
	     * @param {...Function} transformers A variable number of transformer functions
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var double = function(y) { return y * 2; };
	     *      var square = function(x) { return x * x; };
	     *      var add = function(a, b) { return a + b; };
	     *      // Adds any number of arguments together
	     *      var addAll = function() {
	     *        return R.reduce(add, 0, arguments);
	     *      };
	     *
	     *      // Basic example
	     *      var addDoubleAndSquare = R.useWith(addAll, double, square);
	     *
	     *      //≅ addAll(double(10), square(5));
	     *      addDoubleAndSquare(10, 5); //=> 45
	     *
	     *      // Example of passing more arguments than transformers
	     *      //≅ addAll(double(10), square(5), 100);
	     *      addDoubleAndSquare(10, 5, 100); //=> 145
	     *
	     *      // If there are extra _expected_ arguments that don't need to be transformed, although
	     *      // you can ignore them, it might be best to pass in the identity function so that the new
	     *      // function correctly reports arity.
	     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);
	     *      // addDoubleAndSquareWithExtraParams.length //=> 3
	     *      //≅ addAll(double(10), square(5), R.identity(100));
	     *      addDoubleAndSquare(10, 5, 100); //=> 145
	     */
	    /*, transformers */
	    var useWith = curry(function useWith(fn) {
	        var transformers = _slice(arguments, 1);
	        var tlen = transformers.length;
	        return curry(_arity(tlen, function () {
	            var args = [], idx = 0;
	            while (idx < tlen) {
	                args[idx] = transformers[idx](arguments[idx]);
	                idx += 1;
	            }
	            return fn.apply(this, args.concat(_slice(arguments, tlen)));
	        }));
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec, false otherwise. An object satisfies the spec if, for each of the
	     * spec's own properties, accessing that property of the object gives the same
	     * value (in `R.equals` terms) as accessing that property of the spec.
	     *
	     * `whereEq` is a specialization of [`where`](#where).
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @see R.where
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.whereEq({a: 1, b: 2});
	     *
	     *      pred({a: 1});              //=> false
	     *      pred({a: 1, b: 2});        //=> true
	     *      pred({a: 1, b: 2, c: 3});  //=> true
	     *      pred({a: 1, b: 1});        //=> false
	     */
	    var whereEq = _curry2(function whereEq(spec, testObj) {
	        return where(mapObj(equals, spec), testObj);
	    });

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    var _indexOf = function _indexOf(list, item, from) {
	        var idx = from;
	        while (idx < list.length) {
	            if (equals(list[idx], item)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    /**
	     * Create a predicate wrapper which will call a pick function (all/any) for each predicate
	     *
	     * @private
	     * @see R.all
	     * @see R.any
	     */
	    // Call function immediately if given arguments
	    // Return a function which will call the predicates with the provided arguments
	    var _predicateWrap = function _predicateWrap(predPicker) {
	        return function (preds) {
	            var predIterator = function () {
	                var args = arguments;
	                return predPicker(function (predicate) {
	                    return predicate.apply(null, args);
	                }, preds);
	            };
	            return arguments.length > 1 ? // Call function immediately if given arguments
	            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments
	            _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
	        };
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} list An array of predicate functions
	     * @param {*} optional Any arguments to pass into the predicates
	     * @return {Function} a function that applies its arguments to each of
	     *         the predicates, returning `true` if all are satisfied.
	     * @see R.anyPass
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0};
	     *      var f = R.allPass([gt10, even]);
	     *      f(11); //=> false
	     *      f(12); //=> true
	     */
	    var allPass = _curry1(_predicateWrap(all));

	    /**
	     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} list An array of predicate functions
	     * @param {*} optional Any arguments to pass into the predicates
	     * @return {Function} A function that applies its arguments to each of the predicates, returning
	     *         `true` if all are satisfied.
	     * @see R.allPass
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0};
	     *      var f = R.anyPass([gt10, even]);
	     *      f(11); //=> true
	     *      f(8); //=> true
	     *      f(9); //=> false
	     */
	    var anyPass = _curry1(_predicateWrap(any));

	    /**
	     * ap applies a list of functions to a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig [f] -> [a] -> [f a]
	     * @param {Array} fns An array of functions
	     * @param {Array} vs An array of values
	     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
	     * @example
	     *
	     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	     */
	    var ap = _curry2(function ap(fns, vs) {
	        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function (acc, fn) {
	            return _concat(acc, map(fn, vs));
	        }, [], fns);
	    });

	    /**
	     * Returns the result of calling its first argument with the remaining
	     * arguments. This is occasionally useful as a converging function for
	     * `R.converge`: the left branch can produce a function while the right
	     * branch produces a value to be passed to that function as an argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a),*... -> a
	     * @param {Function} fn The function to apply to the remaining arguments.
	     * @param {...*} args Any number of positional arguments.
	     * @return {*}
	     * @see R.apply
	     * @example
	     *
	     *      var indentN = R.pipe(R.times(R.always(' ')),
	     *                           R.join(''),
	     *                           R.replace(/^(?!$)/gm));
	     *
	     *      var format = R.converge(R.call,
	     *                              R.pipe(R.prop('indent'), indentN),
	     *                              R.prop('value'));
	     *
	     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	     */
	    var call = curry(function call(fn) {
	        return fn.apply(this, _slice(arguments, 1));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results.
	     * This implementation is compatible with the
	     * Fantasy-land Chain spec, and will work with types that implement that spec.
	     * `chain` is also known as `flatMap` in some libraries
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = function(n) {
	     *        return [n, n];
	     *      };
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
	        return unnest(map(fn, list));
	    }));

	    /**
	     * Turns a list of Functors into a Functor of a list, applying
	     * a mapping function to the elements of the list along the way.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.commute
	     * @sig Functor f => (f a -> f b) -> (x -> f x) -> [f a] -> f [b]
	     * @param {Function} fn The transformation function
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @example
	     *
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
	     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
	     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commuteMap = _curry3(function commuteMap(fn, of, list) {
	        function consF(acc, ftor) {
	            return ap(map(append, fn(ftor)), acc);
	        }
	        return _reduce(consF, of([]), list);
	    });

	    /**
	     * Wraps a constructor function inside a curried function that can be called with the same
	     * arguments and returns the same type. The arity of the function returned is specified
	     * to allow using variadic constructor functions.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> {*}) -> (* -> {*})
	     * @param {Number} n The arity of the constructor function.
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Variadic constructor function
	     *      var Widget = function() {
	     *        this.children = Array.prototype.slice.call(arguments);
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
	     */
	    var constructN = _curry2(function constructN(n, Fn) {
	        if (n > 10) {
	            throw new Error('Constructor with greater than ten arguments');
	        }
	        if (n === 0) {
	            return function () {
	                return new Fn();
	            };
	        }
	        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	            switch (arguments.length) {
	            case 1:
	                return new Fn($0);
	            case 2:
	                return new Fn($0, $1);
	            case 3:
	                return new Fn($0, $1, $2);
	            case 4:
	                return new Fn($0, $1, $2, $3);
	            case 5:
	                return new Fn($0, $1, $2, $3, $4);
	            case 6:
	                return new Fn($0, $1, $2, $3, $4, $5);
	            case 7:
	                return new Fn($0, $1, $2, $3, $4, $5, $6);
	            case 8:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	            case 9:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	            case 10:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	            }
	        }));
	    });

	    /**
	     * Accepts at least three functions and returns a new function. When invoked, this new
	     * function will invoke the first function, `after`, passing as its arguments the
	     * results of invoking the subsequent functions with whatever arguments are passed to
	     * the new function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> ((a -> b -> ... -> x1), (a -> b -> ... -> x2), ...) -> (a -> b -> ... -> z)
	     * @param {Function} after A function. `after` will be invoked with the return values of
	     *        `fn1` and `fn2` as its arguments.
	     * @param {...Function} functions A variable number of functions.
	     * @return {Function} A new function.
	     * @example
	     *
	     *      var add = function(a, b) { return a + b; };
	     *      var multiply = function(a, b) { return a * b; };
	     *      var subtract = function(a, b) { return a - b; };
	     *
	     *      //≅ multiply( add(1, 2), subtract(1, 2) );
	     *      R.converge(multiply, add, subtract)(1, 2); //=> -3
	     *
	     *      var add3 = function(a, b, c) { return a + b + c; };
	     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4
	     */
	    var converge = curryN(3, function converge(after) {
	        var fns = _slice(arguments, 1);
	        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
	            var args = arguments;
	            var context = this;
	            return after.apply(context, _map(function (fn) {
	                return fn.apply(context, args);
	            }, fns));
	        });
	    });

	    /**
	     * Returns all but the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `drop` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.transduce
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.take
	     * @example
	     *
	     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(3, 'ramda');               //=> 'da'
	     */
	    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
	        return slice(Math.max(0, n), Infinity, xs);
	    }));

	    /**
	     * Returns a list containing all but the last `n` elements of the given `list`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements of `xs` to skip.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.takeLast
	     * @example
	     *
	     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(3, 'ramda');               //=> 'ra'
	     */
	    var dropLast = _curry2(function dropLast(n, xs) {
	        return take(n < xs.length ? xs.length - n : 0, xs);
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. Equality is
	     * determined by applying the supplied predicate two consecutive elements.
	     * The first element in a series of equal element is the one being preserved.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @example
	     *
	     *      function lengthEq(x, y) { return Math.abs(x) === Math.abs(y); };
	     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	     *      R.dropRepeatsWith(lengthEq, l); //=> [1, 3, 4, -5, 3]
	     */
	    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	        var result = [];
	        var idx = 1;
	        var len = list.length;
	        if (len !== 0) {
	            result[0] = list[0];
	            while (idx < len) {
	                if (!pred(last(result), list[idx])) {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	        }
	        return result;
	    }));

	    /**
	     * Reports whether two objects have the same value, in `R.equals` terms,
	     * for the specified property. Useful as a curried predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig k -> {k: v} -> {k: v} -> Boolean
	     * @param {String} prop The name of the property to compare
	     * @param {Object} obj1
	     * @param {Object} obj2
	     * @return {Boolean}
	     *
	     * @example
	     *
	     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	     *      R.eqProps('a', o1, o2); //=> false
	     *      R.eqProps('c', o1, o2); //=> true
	     */
	    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
	        return equals(obj1[prop], obj2[prop]);
	    });

	    /**
	     * Returns the position of the first occurrence of an item in an array,
	     * or -1 if the item is not included in the array. `R.equals` is used to
	     * determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.lastIndexOf
	     * @example
	     *
	     *      R.indexOf(3, [1,2,3,4]); //=> 2
	     *      R.indexOf(10, [1,2,3,4]); //=> -1
	     */
	    var indexOf = _curry2(function indexOf(target, xs) {
	        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	    });

	    /**
	     * Returns all but the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.last, R.head, R.tail
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.init([1, 2, 3]);  //=> [1, 2]
	     *      R.init([1, 2]);     //=> [1]
	     *      R.init([1]);        //=> []
	     *      R.init([]);         //=> []
	     *
	     *      R.init('abc');  //=> 'ab'
	     *      R.init('ab');   //=> 'a'
	     *      R.init('a');    //=> ''
	     *      R.init('');     //=> ''
	     */
	    var init = slice(0, -1);

	    /**
	     * Returns `true` if all elements are unique, in `R.equals` terms,
	     * otherwise `false`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> Boolean
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if all elements are unique, else `false`.
	     * @example
	     *
	     *      R.isSet(['1', 1]); //=> true
	     *      R.isSet([1, 1]);   //=> false
	     *      R.isSet([[42], [42]]); //=> false
	     */
	    var isSet = _curry1(function isSet(list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            if (_indexOf(list, list[idx], idx + 1) >= 0) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    });

	    /**
	     * Returns a lens for the given getter and setter functions. The getter "gets"
	     * the value of the focus; the setter "sets" the value of the focus. The setter
	     * should not mutate the data structure.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	     * @param {Function} getter
	     * @param {Function} setter
	     * @return {Lens}
	     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lens = _curry2(function lens(getter, setter) {
	        return function (f) {
	            return function (s) {
	                return map(function (v) {
	                    return setter(v, s);
	                }, f(getter(s)));
	            };
	        };
	    });

	    /**
	     * Returns a lens whose focus is the specified index.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Number -> Lens s a
	     * @param {Number} n
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	     */
	    var lensIndex = _curry1(function lensIndex(n) {
	        return lens(nth(n), update(n));
	    });

	    /**
	     * Returns a lens whose focus is the specified property.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig String -> Lens s a
	     * @param {String} k
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lensProp = _curry1(function lensProp(k) {
	        return lens(prop(k), assoc(k));
	    });

	    /**
	     * "lifts" a function to be the specified arity, so that it may "map over" that many
	     * lists (or other Functors).
	     *
	     * @func
	     * @memberOf R
	     * @see R.lift
	     * @category Function
	     * @sig Number -> (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The function `fn` applicable to mappable objects.
	     * @example
	     *
	     *      var madd3 = R.liftN(3, R.curryN(3, function() {
	     *        return R.reduce(R.add, 0, arguments);
	     *      }));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     */
	    var liftN = _curry2(function liftN(arity, fn) {
	        var lifted = curryN(arity, fn);
	        return curryN(arity, function () {
	            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
	        });
	    });

	    /**
	     * Returns the mean of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.mean([2, 7, 9]); //=> 6
	     *      R.mean([]); //=> NaN
	     */
	    var mean = _curry1(function mean(list) {
	        return sum(list) / list.length;
	    });

	    /**
	     * Returns the median of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.median([2, 9, 7]); //=> 7
	     *      R.median([7, 2, 10, 9]); //=> 8
	     *      R.median([]); //=> NaN
	     */
	    var median = _curry1(function median(list) {
	        var len = list.length;
	        if (len === 0) {
	            return NaN;
	        }
	        var width = 2 - len % 2;
	        var idx = (len - width) / 2;
	        return mean(_slice(list).sort(function (a, b) {
	            return a < b ? -1 : a > b ? 1 : 0;
	        }).slice(idx, idx + width));
	    });

	    /**
	     * Merges a list of objects together into one object.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [{k: v}] -> {k: v}
	     * @param {Array} list An array of objects
	     * @return {Object} A merged object.
	     * @see R.reduce
	     * @example
	     *
	     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	     */
	    var mergeAll = _curry1(function mergeAll(list) {
	        return reduce(merge, {}, list);
	    });

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /**
	     * Performs left-to-right composition of one or more Promise-returning
	     * functions. The leftmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.composeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	     */
	    var pipeP = function pipeP() {
	        if (arguments.length === 0) {
	            throw new Error('pipeP requires at least one argument');
	        }
	        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	    };

	    /**
	     * Multiplies together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The product of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.product([2,4,6,8,100,1]); //=> 38400
	     */
	    var product = reduce(multiply, 1);

	    /**
	     * Reasonable analog to SQL `select` statement.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @category Relation
	     * @sig [k] -> [{k: v}] -> [{k: v}]
	     * @param {Array} props The property names to project
	     * @param {Array} objs The objects to query
	     * @return {Array} An array of objects with just the `props` properties.
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	     *      var kids = [abby, fred];
	     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	     */
	    // passing `identity` gives correct arity
	    var project = useWith(_map, pickAll, identity);

	    /**
	     * Returns a new list containing the last `n` elements of the given list.
	     * If `n > list.length`, returns a list of `list.length` elements.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements to return.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.dropLast
	     * @example
	     *
	     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['for', 'baz']
	     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(3, 'ramda');               //=> 'mda'
	     */
	    var takeLast = _curry2(function takeLast(n, xs) {
	        return drop(n >= 0 ? xs.length - n : 0, xs);
	    });

	    var _contains = function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    };

	    //  mapPairs :: (Object, [String]) -> [String]
	    // Function, RegExp, user-defined types
	    var _toString = function _toString(x, seen) {
	        var recur = function recur(y) {
	            var xs = seen.concat([x]);
	            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	        };
	        //  mapPairs :: (Object, [String]) -> [String]
	        var mapPairs = function (obj, keys) {
	            return _map(function (k) {
	                return _quote(k) + ': ' + recur(obj[k]);
	            }, keys.slice().sort());
	        };
	        switch (Object.prototype.toString.call(x)) {
	        case '[object Arguments]':
	            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	        case '[object Array]':
	            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
	        case '[object Boolean]':
	            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	        case '[object Date]':
	            return 'new Date(' + _quote(_toISOString(x)) + ')';
	        case '[object Null]':
	            return 'null';
	        case '[object Number]':
	            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	        case '[object String]':
	            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	        case '[object Undefined]':
	            return 'undefined';
	        default:
	            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
	            '{' + mapPairs(x, keys(x)).join(', ') + '}';
	        }
	    };

	    /**
	     * Turns a list of Functors into a Functor of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.commuteMap
	     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @example
	     *
	     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
	     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
	     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
	     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commute = commuteMap(identity);

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the right-to-left Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @see R.pipeK
	     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.composeK(
	     *        R.compose(Maybe.of, R.toUpper),
	     *        get('state'),
	     *        get('address'),
	     *        get('user'),
	     *        parseJson
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var composeK = function composeK() {
	        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
	    };

	    /**
	     * Performs right-to-left composition of one or more Promise-returning
	     * functions. The rightmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
	     */
	    var composeP = function composeP() {
	        if (arguments.length === 0) {
	            throw new Error('composeP requires at least one argument');
	        }
	        return pipeP.apply(this, reverse(arguments));
	    };

	    /**
	     * Wraps a constructor function inside a curried function that can be called with the same
	     * arguments and returns the same type.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> {*}) -> (* -> {*})
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Constructor function
	     *      var Widget = function(config) {
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
	     */
	    var construct = _curry1(function construct(Fn) {
	        return constructN(Fn.length, Fn);
	    });

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms,
	     * to at least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     *
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.differenceWith
	     * @example
	     *
	     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	     */
	    var difference = _curry2(function difference(first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements.
	     * `R.equals` is used to determine equality.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @example
	     *
	     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	     */
	    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @see R.intersectionWith
	     * @return {Array} The list of elements found in both `list1` and `list2`.
	     * @example
	     *
	     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	     */
	    var intersection = _curry2(function intersection(list1, list2) {
	        return uniq(_filter(flip(_contains)(list1), list2));
	    });

	    /**
	     * "lifts" a function of arity > 1 so that it may "map over" an Array or
	     * other Functor.
	     *
	     * @func
	     * @memberOf R
	     * @see R.liftN
	     * @category Function
	     * @sig (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The function `fn` applicable to mappable objects.
	     * @example
	     *
	     *      var madd3 = R.lift(R.curry(function(a, b, c) {
	     *        return a + b + c;
	     *      }));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     *
	     *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {
	     *        return a + b + c + d + e;
	     *      }));
	     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	     */
	    var lift = _curry1(function lift(fn) {
	        return liftN(fn.length, fn);
	    });

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the left-to-right Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @see R.composeK
	     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.pipeK(
	     *        parseJson,
	     *        get('user'),
	     *        get('address'),
	     *        get('state'),
	     *        R.compose(Maybe.of, R.toUpper)
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var pipeK = function pipeK() {
	        return composeK.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the string representation of the given value. `eval`'ing the output
	     * should result in a value equivalent to the input value. Many of the built-in
	     * `toString` methods do not satisfy this requirement.
	     *
	     * If the given value is an `[object Object]` with a `toString` method other
	     * than `Object.prototype.toString`, this method is invoked with no arguments
	     * to produce the return value. This means user-defined constructor functions
	     * can provide a suitable `toString` method. For example:
	     *
	     *     function Point(x, y) {
	     *       this.x = x;
	     *       this.y = y;
	     *     }
	     *
	     *     Point.prototype.toString = function() {
	     *       return 'new Point(' + this.x + ', ' + this.y + ')';
	     *     };
	     *
	     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig * -> String
	     * @param {*} val
	     * @return {String}
	     * @example
	     *
	     *      R.toString(42); //=> '42'
	     *      R.toString('abc'); //=> '"abc"'
	     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	     */
	    var toString = _curry1(function toString(val) {
	        return _toString(val, []);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the
	     * elements of each list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @example
	     *
	     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	     */
	    var union = _curry2(compose(uniq, _concat));

	    /**
	     * Returns a new list containing only one copy of each element in the
	     * original list, based upon the value returned by applying the supplied
	     * function to each list element. Prefers the first item if the supplied
	     * function produces the same value on two items. `R.equals` is used for
	     * comparison.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> b) -> [a] -> [a]
	     * @param {Function} fn A function used to produce a value to use during comparisons.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	     */
	    var uniqBy = _curry2(function uniqBy(fn, list) {
	        var idx = 0, applied = [], result = [], appliedItem, item;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            if (!_contains(appliedItem, applied)) {
	                result.push(item);
	                applied.push(appliedItem);
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Turns a named method with a specified arity into a function
	     * that can be called directly supplied with arguments and a target object.
	     *
	     * The returned function is curried and accepts `arity + 1` parameters where
	     * the final parameter is the target object.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	     * @param {Number} arity Number of arguments the returned function should take
	     *        before the target object.
	     * @param {Function} method Name of the method to call.
	     * @return {Function} A new curried function.
	     * @example
	     *
	     *      var sliceFrom = R.invoker(1, 'slice');
	     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	     */
	    var invoker = _curry2(function invoker(arity, method) {
	        return curryN(arity + 1, function () {
	            var target = arguments[arity];
	            if (target != null && is(Function, target[method])) {
	                return target[method].apply(target, _slice(arguments, 0, arity));
	            }
	            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	        });
	    });

	    /**
	     * Returns a string made by inserting the `separator` between each
	     * element and concatenating all the elements into a single string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig String -> [a] -> String
	     * @param {Number|String} separator The string used to separate the elements.
	     * @param {Array} xs The elements to join into a string.
	     * @return {String} str The string made by concatenating `xs` with `separator`.
	     * @see R.split
	     * @example
	     *
	     *      var spacer = R.join(' ');
	     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	     */
	    var join = invoker(1, 'join');

	    /**
	     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
	     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
	     * argument set will not result in an additional call to `fn`; instead, the cached result
	     * for that set of arguments will be returned.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a) -> (*... -> a)
	     * @param {Function} fn The function to memoize.
	     * @return {Function} Memoized version of `fn`.
	     * @example
	     *
	     *      var count = 0;
	     *      var factorial = R.memoize(function(n) {
	     *        count += 1;
	     *        return R.product(R.range(1, n + 1));
	     *      });
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      count; //=> 1
	     */
	    var memoize = _curry1(function memoize(fn) {
	        var cache = {};
	        return function () {
	            var key = toString(arguments);
	            if (!_has(key, cache)) {
	                cache[key] = fn.apply(this, arguments);
	            }
	            return cache[key];
	        };
	    });

	    /**
	     * Splits a string into an array of strings based on the given
	     * separator.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String -> [String]
	     * @param {String} sep The separator string.
	     * @param {String} str The string to separate into an array.
	     * @return {Array} The array of strings from `str` separated by `str`.
	     * @see R.join
	     * @example
	     *
	     *      var pathComponents = R.split('/');
	     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	     *
	     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	     */
	    var split = invoker(1, 'split');

	    /**
	     * The lower case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to lower case.
	     * @return {String} The lower case version of `str`.
	     * @see R.toUpper
	     * @example
	     *
	     *      R.toLower('XYZ'); //=> 'xyz'
	     */
	    var toLower = invoker(0, 'toLowerCase');

	    /**
	     * The upper case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to upper case.
	     * @return {String} The upper case version of `str`.
	     * @see R.toLower
	     * @example
	     *
	     *      R.toUpper('abc'); //=> 'ABC'
	     */
	    var toUpper = invoker(0, 'toUpperCase');

	    var R = {
	        F: F,
	        T: T,
	        __: __,
	        add: add,
	        addIndex: addIndex,
	        adjust: adjust,
	        all: all,
	        allPass: allPass,
	        always: always,
	        and: and,
	        any: any,
	        anyPass: anyPass,
	        ap: ap,
	        aperture: aperture,
	        append: append,
	        apply: apply,
	        assoc: assoc,
	        assocPath: assocPath,
	        binary: binary,
	        bind: bind,
	        both: both,
	        call: call,
	        chain: chain,
	        clone: clone,
	        commute: commute,
	        commuteMap: commuteMap,
	        comparator: comparator,
	        complement: complement,
	        compose: compose,
	        composeK: composeK,
	        composeP: composeP,
	        concat: concat,
	        cond: cond,
	        construct: construct,
	        constructN: constructN,
	        contains: contains,
	        containsWith: containsWith,
	        converge: converge,
	        countBy: countBy,
	        createMapEntry: createMapEntry,
	        curry: curry,
	        curryN: curryN,
	        dec: dec,
	        defaultTo: defaultTo,
	        difference: difference,
	        differenceWith: differenceWith,
	        dissoc: dissoc,
	        dissocPath: dissocPath,
	        divide: divide,
	        drop: drop,
	        dropLast: dropLast,
	        dropLastWhile: dropLastWhile,
	        dropRepeats: dropRepeats,
	        dropRepeatsWith: dropRepeatsWith,
	        dropWhile: dropWhile,
	        either: either,
	        empty: empty,
	        eqProps: eqProps,
	        equals: equals,
	        evolve: evolve,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        findLast: findLast,
	        findLastIndex: findLastIndex,
	        flatten: flatten,
	        flip: flip,
	        forEach: forEach,
	        fromPairs: fromPairs,
	        functions: functions,
	        functionsIn: functionsIn,
	        groupBy: groupBy,
	        gt: gt,
	        gte: gte,
	        has: has,
	        hasIn: hasIn,
	        head: head,
	        identical: identical,
	        identity: identity,
	        ifElse: ifElse,
	        inc: inc,
	        indexOf: indexOf,
	        init: init,
	        insert: insert,
	        insertAll: insertAll,
	        intersection: intersection,
	        intersectionWith: intersectionWith,
	        intersperse: intersperse,
	        into: into,
	        invert: invert,
	        invertObj: invertObj,
	        invoker: invoker,
	        is: is,
	        isArrayLike: isArrayLike,
	        isEmpty: isEmpty,
	        isNil: isNil,
	        isSet: isSet,
	        join: join,
	        keys: keys,
	        keysIn: keysIn,
	        last: last,
	        lastIndexOf: lastIndexOf,
	        length: length,
	        lens: lens,
	        lensIndex: lensIndex,
	        lensProp: lensProp,
	        lift: lift,
	        liftN: liftN,
	        lt: lt,
	        lte: lte,
	        map: map,
	        mapAccum: mapAccum,
	        mapAccumRight: mapAccumRight,
	        mapObj: mapObj,
	        mapObjIndexed: mapObjIndexed,
	        match: match,
	        mathMod: mathMod,
	        max: max,
	        maxBy: maxBy,
	        mean: mean,
	        median: median,
	        memoize: memoize,
	        merge: merge,
	        mergeAll: mergeAll,
	        min: min,
	        minBy: minBy,
	        modulo: modulo,
	        multiply: multiply,
	        nAry: nAry,
	        negate: negate,
	        none: none,
	        not: not,
	        nth: nth,
	        nthArg: nthArg,
	        nthChar: nthChar,
	        nthCharCode: nthCharCode,
	        of: of,
	        omit: omit,
	        once: once,
	        or: or,
	        over: over,
	        partial: partial,
	        partialRight: partialRight,
	        partition: partition,
	        path: path,
	        pathEq: pathEq,
	        pick: pick,
	        pickAll: pickAll,
	        pickBy: pickBy,
	        pipe: pipe,
	        pipeK: pipeK,
	        pipeP: pipeP,
	        pluck: pluck,
	        prepend: prepend,
	        product: product,
	        project: project,
	        prop: prop,
	        propEq: propEq,
	        propIs: propIs,
	        propOr: propOr,
	        propSatisfies: propSatisfies,
	        props: props,
	        range: range,
	        reduce: reduce,
	        reduceRight: reduceRight,
	        reduced: reduced,
	        reject: reject,
	        remove: remove,
	        repeat: repeat,
	        replace: replace,
	        reverse: reverse,
	        scan: scan,
	        set: set,
	        slice: slice,
	        sort: sort,
	        sortBy: sortBy,
	        split: split,
	        splitEvery: splitEvery,
	        subtract: subtract,
	        sum: sum,
	        tail: tail,
	        take: take,
	        takeLast: takeLast,
	        takeLastWhile: takeLastWhile,
	        takeWhile: takeWhile,
	        tap: tap,
	        test: test,
	        times: times,
	        toLower: toLower,
	        toPairs: toPairs,
	        toPairsIn: toPairsIn,
	        toString: toString,
	        toUpper: toUpper,
	        transduce: transduce,
	        trim: trim,
	        type: type,
	        unapply: unapply,
	        unary: unary,
	        uncurryN: uncurryN,
	        unfold: unfold,
	        union: union,
	        unionWith: unionWith,
	        uniq: uniq,
	        uniqBy: uniqBy,
	        uniqWith: uniqWith,
	        unnest: unnest,
	        update: update,
	        useWith: useWith,
	        values: values,
	        valuesIn: valuesIn,
	        view: view,
	        where: where,
	        whereEq: whereEq,
	        wrap: wrap,
	        xprod: xprod,
	        zip: zip,
	        zipObj: zipObj,
	        zipWith: zipWith
	    };

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var _equals = __webpack_require__(17).equals;


	module.exports = {

	  baseMap: function(f) {
	    return f(this.value);
	  },

	  getEquals: function(constructor) {
	    return function equals(that) {
	      return that instanceof constructor && _equals(this.value, that.value);
	    };
	  },

	  extend: function(Child, Parent) {
	    function Ctor() {
	      this.constructor = Child;
	    }
	    Ctor.prototype = Parent.prototype;
	    Child.prototype = new Ctor();
	    Child.super_ = Parent.prototype;
	  },

	  identity: function(x) { return x; },

	  notImplemented: function(str) {
	    return function() {
	      throw new Error(str + ' is not implemented');
	    };
	  },

	  notCallable: function(fn) {
	    return function() {
	      throw new Error(fn + ' cannot be called directly');
	    };
	  },

	  returnThis: function() { return this; }

	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	// `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)
	function Future(f) {
	  if (!(this instanceof Future)) {
	    return new Future(f);
	  }
	  this._fork = f;
	}

	Future.prototype.fork = function(reject, resolve) {
	  try {
	    this._fork(reject, resolve);
	  } catch(e) {
	    reject(e);
	  }
	};

	// functor
	Future.prototype.map = function(f) {
	  return this.chain(function(a) { return Future.of(f(a)); });
	};

	// apply
	Future.prototype.ap = function(m) {
	  var self = this;

	  return new Future(function(rej, res) {
	    var applyFn, val;
	    var doReject = R.once(rej);

	    function resolveIfDone() {
	      if (applyFn != null && val != null) {
	        return res(applyFn(val));
	      }
	    }

	    self.fork(doReject, function(fn) {
	      applyFn = fn;
	      resolveIfDone();
	    });

	    m.fork(doReject, function(v) {
	      val = v;
	      resolveIfDone();
	    });

	  });

	};

	// applicative
	Future.of = function(x) {
	  // should include a default rejection?
	  return new Future(function(_, resolve) { return resolve(x); });
	};

	Future.prototype.of = Future.of;

	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	//:: Future a, b => (b -> Future c) -> Future c
	Future.prototype.chain = function(f) {  // Sorella's:
	  return new Future(function(reject, resolve) {
	    return this.fork(function(a) { return reject(a); },
	                     function(b) { return f(b).fork(reject, resolve); });
	  }.bind(this));
	};

	// chainReject
	// Like chain but operates on the reject instead of the resolve case.
	//:: Future a, b => (a -> Future c) -> Future c
	Future.prototype.chainReject = function(f) {
	  return new Future(function(reject, resolve) {
	    return this.fork(function(a) { return f(a).fork(reject, resolve); },
	                     function(b) { return resolve(b);
	    });
	  }.bind(this));
	};

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	Future.prototype.bimap = function(errFn, successFn) {
	  var self = this;
	  return new Future(function(reject, resolve) {
	    self.fork(function(err) {
	      reject(errFn(err));
	    }, function(val) {
	      resolve(successFn(val));
	    });
	  });
	};

	Future.reject = function(val) {
	  return new Future(function(reject) {
	    reject(val);
	  });
	};

	Future.prototype.toString = function() {
	  return 'Future(' + R.toString(this._fork) + ')';
	};

	Future.cache = function(f) {
	  var status = 'IDLE';
	  var listeners = [];
	  var cachedValue;

	  var handleCompletion = R.curry(function(newStatus, cb, val) {
	    status = newStatus;
	    cachedValue = val;
	    cb(val);
	    R.forEach(function(listener) {
	      listener[status](cachedValue);
	    }, listeners);
	  });

	  function addListeners(reject, resolve) {
	    listeners.push({ REJECTED: reject, RESOLVED: resolve } );
	  }

	  function doResolve(reject, resolve) {
	    status = 'PENDING';
	    return f.fork(
	      handleCompletion('REJECTED', reject),
	      handleCompletion('RESOLVED', resolve)
	    );
	  }

	  return new Future(function(reject, resolve) {

	    switch(status) {
	      case 'IDLE': doResolve(reject, resolve); break;
	      case 'PENDING': addListeners(reject, resolve); break;
	      case 'REJECTED': reject(cachedValue); break;
	      case 'RESOLVED': resolve(cachedValue); break;
	    }

	  });
	};

	module.exports = Future;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	var util = __webpack_require__(18);


	/**
	 * A data type that holds a value and exposes a monadic api.
	 */

	/**
	 * Constructs a new `Identity[a]` data type that holds a single
	 * value `a`.
	 * @param {*} a Value of any type
	 * @sig a -> Identity[a]
	 */
	function Identity(x) {
	  if (!(this instanceof Identity)) {
	    return new Identity(x);
	  }
	  this.value = x;
	}

	/**
	 * Applicative specification. Creates a new `Identity[a]` holding the value `a`.
	 * @param {*} a Value of any type
	 * @returns Identity[a]
	 * @sig a -> Identity[a]
	 */
	Identity.of = function(x) {
	  return new Identity(x);
	};
	Identity.prototype.of = Identity.of;

	/**
	 * Functor specification. Creates a new `Identity[a]` mapping function `f` onto
	 * `a` returning any value b.
	 * @param {Function} f Maps `a` to any value `b`
	 * @returns Identity[b]
	 * @sig @Identity[a] => (a -> b) -> Identity[b]
	 */
	Identity.prototype.map = function(f) {
	  return new Identity(f(this.value));
	};

	/**
	 * Apply specification. Applies the function inside the `Identity[a]`
	 * type to another applicative type.
	 * @param {Applicative[a]} app Applicative that will apply its function
	 * @returns Applicative[b]
	 * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]
	 */
	Identity.prototype.ap = function(app) {
	  return app.map(this.value);
	};

	/**
	 * Chain specification. Transforms the value of the `Identity[a]`
	 * type using an unary function to monads. The `Identity[a]` type
	 * should contain a function, otherwise an error is thrown.
	 *
	 * @param {Function} fn Transforms `a` into a `Monad[b]`
	 * @returns Monad[b]
	 * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]
	 */
	Identity.prototype.chain = function(fn) {
	  return fn(this.value);
	};

	/**
	 * Returns the value of `Identity[a]`
	 *
	 * @returns a
	 * @sig (Identity[a]) => a
	 */
	Identity.prototype.get = function() {
	  return this.value;
	};

	// equality method to enable testing
	Identity.prototype.equals = util.getEquals(Identity);

	Identity.prototype.toString = function() {
	  return 'Identity(' + R.toString(this.value) + ')';
	};

	module.exports = Identity;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	module.exports = IO;

	var compose = R.compose;

	function IO(fn) {
	  if (!(this instanceof IO)) {
	    return new IO(fn);
	  }
	  this.fn = fn;
	}

	// `f` must return an IO
	IO.prototype.chain = function(f) {
	  var io = this;
	  return new IO(function() {
	    var next = f(io.fn.apply(io, arguments));
	    return next.fn.apply(next, arguments);
	  });
	};

	IO.prototype.map = function(f) {
	  var io = this;
	  return new IO(compose(f, io.fn));
	};

	// `this` IO must wrap a function `f` that takes an IO (`thatIo`) as input
	// `f` must return an IO
	IO.prototype.ap = function(thatIo) {
	  return this.chain(function(f) {
	    return thatIo.map(f);
	  });
	};

	IO.runIO = function(io) {
	  return io.runIO.apply(io, [].slice.call(arguments, 1));
	};

	IO.prototype.runIO = function() {
	  return this.fn.apply(this, arguments);
	};

	IO.prototype.of = function(x) {
	  return new IO(function() { return x; });
	};

	IO.of = IO.prototype.of;

	IO.prototype.toString = function() {
	  return 'IO(' + R.toString(this.fn) + ')';
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	module.exports = R.curryN(3, function lift2(f, a1, a2) {
	  return a1.map(f).ap(a2);
	});


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	module.exports = R.curryN(4, function lift3(f, a1, a2, a3) {
	  return a1.map(f).ap(a2).ap(a3);
	});


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);

	var util = __webpack_require__(18);

	function Maybe(x) {
	  return x == null ? _nothing : Maybe.Just(x);
	}

	function _Just(x) {
	  this.value = x;
	}
	util.extend(_Just, Maybe);

	function _Nothing() {}
	util.extend(_Nothing, Maybe);

	var _nothing = new _Nothing();

	Maybe.Nothing = function() {
	  return _nothing;
	};

	Maybe.Just = function(x) {
	  return new _Just(x);
	};

	Maybe.of = Maybe.Just;

	Maybe.prototype.of = Maybe.Just;

	Maybe.isJust = function(x) {
	  return x instanceof _Just;
	};

	Maybe.isNothing = function(x) {
	  return x === _nothing;
	};

	Maybe.maybe = R.curry(function(nothingVal, justFn, m) {
	  return m.reduce(function(_, x) {
	    return justFn(x);
	  }, nothingVal);
	});

	// functor
	_Just.prototype.map = function(f) {
	  return this.of(f(this.value));
	};

	_Nothing.prototype.map = util.returnThis;

	// apply
	// takes a Maybe that wraps a function (`app`) and applies its `map`
	// method to this Maybe's value, which must be a function.
	_Just.prototype.ap = function(m) {
	  return m.map(this.value);
	};

	_Nothing.prototype.ap = util.returnThis;

	// applicative
	// `of` inherited from `Maybe`


	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	_Just.prototype.chain = util.baseMap;

	_Nothing.prototype.chain = util.returnThis;


	//
	_Just.prototype.datatype = _Just;

	_Nothing.prototype.datatype = _Nothing;

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	// equality method to enable testing
	_Just.prototype.equals = util.getEquals(_Just);

	_Nothing.prototype.equals = function(that) {
	  return that === _nothing;
	};

	Maybe.prototype.isNothing = function() {
	  return this === _nothing;
	};

	Maybe.prototype.isJust = function() {
	  return this instanceof _Just;
	};

	_Just.prototype.getOrElse = function() {
	  return this.value;
	};

	_Nothing.prototype.getOrElse = function(a) {
	  return a;
	};

	_Just.prototype.reduce = function(f, x) {
	  return f(x, this.value);
	};

	_Nothing.prototype.reduce = function(f, x) {
	  return x;
	};

	_Just.prototype.toString = function() {
	  return 'Maybe.Just(' + R.toString(this.value) + ')';
	};

	_Nothing.prototype.toString = function() {
	  return 'Maybe.Nothing()';
	};

	module.exports = Maybe;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);


	function Tuple(x, y) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Tuple');
	    case 1:
	      return function(y) {
	        return new _Tuple(x, y);
	      };
	    default:
	      return new _Tuple(x, y);
	  }
	}

	function _Tuple(x, y) {
	  this[0] = x;
	  this[1] = y;
	  this.length = 2;
	}

	function ensureConcat(xs) {
	  xs.forEach(function(x) {
	    if (typeof x.concat != 'function') {
	      throw new TypeError(R.toString(x) + ' must be a semigroup to perform this operation');
	    }
	  });
	}

	Tuple.fst = function(x) {
	  return x[0];
	};

	Tuple.snd = function(x) {
	  return x[1];
	};

	// semigroup
	_Tuple.prototype.concat = function(x) {
	  ensureConcat([this[0], this[1]]);
	  return Tuple(this[0].concat(x[0]), this[1].concat(x[1]));
	};

	// functor
	_Tuple.prototype.map = function(f) {
	  return Tuple(this[0], f(this[1]));
	};

	// apply
	_Tuple.prototype.ap = function(m) {
	  ensureConcat([this[0]]);
	  return Tuple(this[0].concat(m[0]), this[1](m[1]));
	};

	// setoid
	_Tuple.prototype.equals = function(that) {
	  return that instanceof _Tuple && R.equals(this[0], that[0]) && R.equals(this[1], that[1]);
	};

	_Tuple.prototype.toString = function() {
	  return 'Tuple(' + R.toString(this[0]) + ', ' + R.toString(this[1]) + ')';
	};

	module.exports = Tuple;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(17);


	function Reader(run) {
	  if (!(this instanceof Reader)) {
	    return new Reader(run);
	  }
	  this.run = run;
	}

	Reader.run = function(reader) {
	  return reader.run.apply(reader, [].slice.call(arguments, 1));
	};

	Reader.prototype.chain = function(f) {
	  var reader = this;
	  return new Reader(function(r) {
	    return f(reader.run(r)).run(r);
	  });
	};

	Reader.prototype.ap = function(a) {
	  return this.chain(function(f) {
	    return a.map(f);
	  });
	};

	Reader.prototype.map = function(f) {
	  return this.chain(function(a) {
	    return Reader.of(f(a));
	  });
	};

	Reader.prototype.of = function(a) {
	  return new Reader(function() {
	    return a;
	  });
	};
	Reader.of = Reader.prototype.of;

	Reader.ask = Reader(R.identity);

	Reader.prototype.toString = function() {
	  return 'Reader(' + R.toString(this.run) + ')';
	};

	Reader.T = function(M) {
	  var ReaderT = function ReaderT(run) {
	    if (!(this instanceof ReaderT)) {
	      return new ReaderT(run);
	    }
	    this.run = run;
	  };

	  ReaderT.lift = R.compose(ReaderT, R.always);

	  ReaderT.ask = ReaderT(M.of);

	  ReaderT.prototype.of = ReaderT.of = function(a) {
	    return ReaderT(function() {
	      return M.of(a);
	    });
	  };

	  ReaderT.prototype.chain = function(f) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      var m = readerT.run(e);
	      return m.chain(function(a) {
	        return f(a).run(e);
	      });
	    });
	  };

	  ReaderT.prototype.map = function(f) {
	    return this.chain(function(a) {
	      return ReaderT.of(f(a));
	    });
	  };

	  ReaderT.prototype.ap = function(a) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      return readerT.run(e).ap(a.run(e));
	    });
	  };

	  ReaderT.prototype.equals = function(that) {
	    return this === that ||
	      this.run === that.run ||
	      R.equals(this.run().get(), that.run().get());
	  };

	  ReaderT.prototype.toString = function() {
	    return 'ReaderT[' + M.name + '](' + R.toString(this.run) + ')';
	  };

	  return ReaderT;
	};

	module.exports = Reader;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	//  Ramda v0.19.1
	//  https://github.com/ramda/ramda
	//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
	//  Ramda may be freely distributed under the MIT license.

	;(function() {

	  'use strict';

	  /**
	     * A special placeholder value used to specify "gaps" within curried functions,
	     * allowing partial application of any combination of arguments, regardless of
	     * their positions.
	     *
	     * If `g` is a curried ternary function and `_` is `R.__`, the following are
	     * equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2, _)(1, 3)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @constant
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @example
	     *
	     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	     *      greet('Alice'); //=> 'Hello, Alice!'
	     */
	    var __ = { '@@functional/placeholder': true };

	    /* eslint-disable no-unused-vars */
	    var _arity = function _arity(n, fn) {
	        /* eslint-disable no-unused-vars */
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _arrayFromIterator = function _arrayFromIterator(iter) {
	        var list = [];
	        var next;
	        while (!(next = iter.next()).done) {
	            list.push(next.value);
	        }
	        return list;
	    };

	    var _cloneRegExp = function _cloneRegExp(pattern) {
	        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	    };

	    var _complement = function _complement(f) {
	        return function () {
	            return !f.apply(this, arguments);
	        };
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _containsWith = function _containsWith(pred, x, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (pred(x, list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    var _identity = function _identity(x) {
	        return x;
	    };

	    var _isArguments = function () {
	        var toString = Object.prototype.toString;
	        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
	            return toString.call(x) === '[object Arguments]';
	        } : function _isArguments(x) {
	            return _has('callee', x);
	        };
	    }();

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    /**
	     * Determine if the passed argument is an integer.
	     *
	     * @private
	     * @param {*} n
	     * @category Type
	     * @return {Boolean}
	     */
	    var _isInteger = Number.isInteger || function _isInteger(n) {
	        return n << 0 === n;
	    };

	    var _isNumber = function _isNumber(x) {
	        return Object.prototype.toString.call(x) === '[object Number]';
	    };

	    var _isObject = function _isObject(x) {
	        return Object.prototype.toString.call(x) === '[object Object]';
	    };

	    var _isPlaceholder = function _isPlaceholder(a) {
	        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	    };

	    var _isRegExp = function _isRegExp(x) {
	        return Object.prototype.toString.call(x) === '[object RegExp]';
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, functor) {
	        var idx = 0;
	        var len = functor.length;
	        var result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(functor[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    var _of = function _of(x) {
	        return [x];
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _pipeP = function _pipeP(f, g) {
	        return function () {
	            var ctx = this;
	            return f.apply(ctx, arguments).then(function (x) {
	                return g.call(ctx, x);
	            });
	        };
	    };

	    // \b matches word boundary; [\b] matches backspace
	    var _quote = function _quote(s) {
	        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
	    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
	        return '"' + escaped.replace(/"/g, '\\"') + '"';
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    /**
	     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	     */
	    var _toISOString = function () {
	        var pad = function pad(n) {
	            return (n < 10 ? '0' : '') + n;
	        };
	        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	            return d.toISOString();
	        } : function _toISOString(d) {
	            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	        };
	    }();

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    var _aperture = function _aperture(n, list) {
	        var idx = 0;
	        var limit = list.length - (n - 1);
	        var acc = new Array(limit >= 0 ? limit : 0);
	        while (idx < limit) {
	            acc[idx] = _slice(list, idx, idx + n);
	            idx += 1;
	        }
	        return acc;
	    };

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it
	     * will default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Optimized internal one-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0 || _isPlaceholder(a)) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            switch (arguments.length) {
	            case 0:
	                return f2;
	            case 1:
	                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	                    return fn(a, _b);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b);
	                }) : fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            switch (arguments.length) {
	            case 0:
	                return f3;
	            case 1:
	                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                });
	            case 2:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _curry1(function (_c) {
	                    return fn(a, b, _c);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	                    return fn(_a, _b, c);
	                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b, c);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b, c);
	                }) : _isPlaceholder(c) ? _curry1(function (_c) {
	                    return fn(a, b, _c);
	                }) : fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @param {Array} received An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (!_isPlaceholder(result)) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    var _dropLastWhile = function dropLastWhile(pred, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && pred(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, 0, idx + 1);
	    };

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xany = function () {
	        function XAny(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.any = false;
	        }
	        XAny.prototype['@@transducer/init'] = _xfBase.init;
	        XAny.prototype['@@transducer/result'] = function (result) {
	            if (!this.any) {
	                result = this.xf['@@transducer/step'](result, false);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAny.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.any = true;
	                result = _reduced(this.xf['@@transducer/step'](result, true));
	            }
	            return result;
	        };
	        return _curry2(function _xany(f, xf) {
	            return new XAny(f, xf);
	        });
	    }();

	    var _xaperture = function () {
	        function XAperture(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XAperture.prototype['@@transducer/init'] = _xfBase.init;
	        XAperture.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XAperture.prototype['@@transducer/step'] = function (result, input) {
	            this.store(input);
	            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
	        };
	        XAperture.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        XAperture.prototype.getCopy = function () {
	            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
	        };
	        return _curry2(function _xaperture(n, xf) {
	            return new XAperture(n, xf);
	        });
	    }();

	    var _xdrop = function () {
	        function XDrop(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XDrop.prototype['@@transducer/init'] = _xfBase.init;
	        XDrop.prototype['@@transducer/result'] = _xfBase.result;
	        XDrop.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n > 0) {
	                this.n -= 1;
	                return result;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdrop(n, xf) {
	            return new XDrop(n, xf);
	        });
	    }();

	    var _xdropLast = function () {
	        function XDropLast(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLast.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.full) {
	                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
	            }
	            this.store(input);
	            return result;
	        };
	        XDropLast.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        return _curry2(function _xdropLast(n, xf) {
	            return new XDropLast(n, xf);
	        });
	    }();

	    var _xdropRepeatsWith = function () {
	        function XDropRepeatsWith(pred, xf) {
	            this.xf = xf;
	            this.pred = pred;
	            this.lastValue = undefined;
	            this.seenFirstValue = false;
	        }
	        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
	            return this.xf['@@transducer/init']();
	        };
	        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	            var sameAsLast = false;
	            if (!this.seenFirstValue) {
	                this.seenFirstValue = true;
	            } else if (this.pred(this.lastValue, input)) {
	                sameAsLast = true;
	            }
	            this.lastValue = input;
	            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropRepeatsWith(pred, xf) {
	            return new XDropRepeatsWith(pred, xf);
	        });
	    }();

	    var _xdropWhile = function () {
	        function XDropWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f) {
	                if (this.f(input)) {
	                    return result;
	                }
	                this.f = null;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropWhile(f, xf) {
	            return new XDropWhile(f, xf);
	        });
	    }();

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xfindLast = function () {
	        function XFindLast(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLast.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	        };
	        XFindLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.last = input;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLast(f, xf) {
	            return new XFindLast(f, xf);
	        });
	    }();

	    var _xfindLastIndex = function () {
	        function XFindLastIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.lastIdx = -1;
	        }
	        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	        };
	        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.lastIdx = this.idx;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLastIndex(f, xf) {
	            return new XFindLastIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    var _xtake = function () {
	        function XTake(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XTake.prototype['@@transducer/init'] = _xfBase.init;
	        XTake.prototype['@@transducer/result'] = _xfBase.result;
	        XTake.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n === 0) {
	                return _reduced(result);
	            } else {
	                this.n -= 1;
	                return this.xf['@@transducer/step'](result, input);
	            }
	        };
	        return _curry2(function _xtake(n, xf) {
	            return new XTake(n, xf);
	        });
	    }();

	    var _xtakeWhile = function () {
	        function XTakeWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	        };
	        return _curry2(function _xtakeWhile(f, xf) {
	            return new XTakeWhile(f, xf);
	        });
	    }();

	    /**
	     * Adds two numbers. Equivalent to `a + b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Number}
	     * @see R.subtract
	     * @example
	     *
	     *      R.add(2, 3);       //=>  5
	     *      R.add(7)(10);      //=> 17
	     */
	    var add = _curry2(function add(a, b) {
	        return a + b;
	    });

	    /**
	     * Applies a function to the value at the given index of an array, returning a
	     * new copy of the array with the element at the given index replaced with the
	     * result of the function application.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a -> a) -> Number -> [a] -> [a]
	     * @param {Function} fn The function to apply.
	     * @param {Number} idx The index.
	     * @param {Array|Arguments} list An array-like object whose value
	     *        at the supplied index will be replaced.
	     * @return {Array} A copy of the supplied array-like object with
	     *         the element at index `idx` replaced with the value
	     *         returned by applying `fn` to the existing element.
	     * @see R.update
	     * @example
	     *
	     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var adjust = _curry3(function adjust(fn, idx, list) {
	        if (idx >= list.length || idx < -list.length) {
	            return list;
	        }
	        var start = idx < 0 ? list.length : 0;
	        var _idx = start + idx;
	        var _list = _concat(list);
	        _list[_idx] = fn(list[_idx]);
	        return _list;
	    });

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if
	     * there are any that don't.
	     *
	     * Dispatches to the `all` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * Returns a function that always returns the given value. Note that for
	     * non-primitives the value returned is a reference to the original value.
	     *
	     * This function is known as `const`, `constant`, or `K` (for K combinator) in
	     * other languages and libraries.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> (* -> a)
	     * @param {*} val The value to wrap in a function
	     * @return {Function} A Function :: * -> val.
	     * @example
	     *
	     *      var t = R.always('Tee');
	     *      t(); //=> 'Tee'
	     */
	    var always = _curry1(function always(val) {
	        return function () {
	            return val;
	        };
	    });

	    /**
	     * Returns `true` if both arguments are `true`; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
	     * @see R.both
	     * @example
	     *
	     *      R.and(true, true); //=> true
	     *      R.and(true, false); //=> false
	     *      R.and(false, true); //=> false
	     *      R.and(false, false); //=> false
	     */
	    var and = _curry2(function and(a, b) {
	        return a && b;
	    });

	    /**
	     * Returns `true` if at least one of elements of the list match the predicate,
	     * `false` otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	     *         otherwise.
	     * @see R.all, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan0 = R.flip(R.lt)(0);
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      R.any(lessThan0)([1, 2]); //=> false
	     *      R.any(lessThan2)([1, 2]); //=> true
	     */
	    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (fn(list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    }));

	    /**
	     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
	     * greater than the length of the list, an empty list is returned.
	     *
	     * Dispatches to the `aperture` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @param {Number} n The size of the tuples to create
	     * @param {Array} list The list to split into `n`-tuples
	     * @return {Array} The new list.
	     * @see R.transduce
	     * @example
	     *
	     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	     */
	    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

	    /**
	     * Returns a new list containing the contents of the given list, followed by
	     * the given element.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The element to add to the end of the new list.
	     * @param {Array} list The list whose contents will be added to the beginning of the output
	     *        list.
	     * @return {Array} A new list containing the contents of the old list followed by `el`.
	     * @see R.prepend
	     * @example
	     *
	     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	     *      R.append('tests', []); //=> ['tests']
	     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	     */
	    var append = _curry2(function append(el, list) {
	        return _concat(list, [el]);
	    });

	    /**
	     * Applies function `fn` to the argument list `args`. This is useful for
	     * creating a fixed-arity function from a variadic function. `fn` should be a
	     * bound function if context is significant.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> a) -> [*] -> a
	     * @param {Function} fn
	     * @param {Array} args
	     * @return {*}
	     * @see R.call, R.unapply
	     * @example
	     *
	     *      var nums = [1, 2, 3, -99, 42, 6, 7];
	     *      R.apply(Math.max, nums); //=> 42
	     */
	    var apply = _curry2(function apply(fn, args) {
	        return fn.apply(this, args);
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the specified
	     * property with the given value. Note that this copies and flattens prototype
	     * properties onto the new object as well. All non-primitive properties are
	     * copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig String -> a -> {k: v} -> {k: v}
	     * @param {String} prop the property name to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except for the specified property.
	     * @see R.dissoc
	     * @example
	     *
	     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	     */
	    var assoc = _curry3(function assoc(prop, val, obj) {
	        var result = {};
	        for (var p in obj) {
	            result[p] = obj[p];
	        }
	        result[prop] = val;
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the nodes required
	     * to create the given path, and placing the specific value at the tail end of
	     * that path. Note that this copies and flattens prototype properties onto the
	     * new object as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig [String] -> a -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except along the specified path.
	     * @see R.dissocPath
	     * @example
	     *
	     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	     */
	    var assocPath = _curry3(function assocPath(path, val, obj) {
	        switch (path.length) {
	        case 0:
	            return val;
	        case 1:
	            return assoc(path[0], val, obj);
	        default:
	            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
	        }
	    });

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @category Object
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     * @see R.partial
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * A function wrapping calls to the two functions in an `&&` operation,
	     * returning the result of the first function if it is false-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * false-y value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	     * @see R.and
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.both(gt10, even);
	     *      f(100); //=> true
	     *      f(101); //=> false
	     */
	    var both = _curry2(function both(f, g) {
	        return function _both() {
	            return f.apply(this, arguments) && g.apply(this, arguments);
	        };
	    });

	    /**
	     * Makes a comparator function out of a function that reports whether the first
	     * element is less than the second.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a, b -> Boolean) -> (a, b -> Number)
	     * @param {Function} pred A predicate function of arity two.
	     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
	     * @example
	     *
	     *      var cmp = R.comparator((a, b) => a.age < b.age);
	     *      var people = [
	     *        // ...
	     *      ];
	     *      R.sort(cmp, people);
	     */
	    var comparator = _curry1(function comparator(pred) {
	        return function (a, b) {
	            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	        };
	    });

	    /**
	     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
	     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
	     * to `fn` are applied to each of the predicates in turn until one returns a
	     * "truthy" value, at which point `fn` returns the result of applying its
	     * arguments to the corresponding transformer. If none of the predicates
	     * matches, `fn` returns undefined.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Logic
	     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	     * @param {Array} pairs
	     * @return {Function}
	     * @example
	     *
	     *      var fn = R.cond([
	     *        [R.equals(0),   R.always('water freezes at 0°C')],
	     *        [R.equals(100), R.always('water boils at 100°C')],
	     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
	     *      ]);
	     *      fn(0); //=> 'water freezes at 0°C'
	     *      fn(50); //=> 'nothing special happens at 50°C'
	     *      fn(100); //=> 'water boils at 100°C'
	     */
	    var cond = _curry1(function cond(pairs) {
	        return function () {
	            var idx = 0;
	            while (idx < pairs.length) {
	                if (pairs[idx][0].apply(this, arguments)) {
	                    return pairs[idx][1].apply(this, arguments);
	                }
	                idx += 1;
	            }
	        };
	    });

	    /**
	     * Counts the elements of a list according to how many match each value of a
	     * key generated by the supplied function. Returns an object mapping the keys
	     * produced by `fn` to the number of occurrences in the list. Note that all
	     * keys are coerced to strings because of how JavaScript objects work.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> String) -> [a] -> {*}
	     * @param {Function} fn The function used to map values to keys.
	     * @param {Array} list The list to count elements from.
	     * @return {Object} An object mapping keys to number of occurrences in the list.
	     * @example
	     *
	     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	     *      var letters = R.split('', 'abcABCaaaBBc');
	     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
	     */
	    var countBy = _curry2(function countBy(fn, list) {
	        var counts = {};
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            var key = fn(list[idx]);
	            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
	            idx += 1;
	        }
	        return counts;
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the specified
	     * arity. The curried function has two unusual capabilities. First, its
	     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var sumArgs = (...args) => R.sum(args);
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Decrements its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.inc
	     * @example
	     *
	     *      R.dec(42); //=> 41
	     */
	    var dec = add(-1);

	    /**
	     * Returns the second argument if it is not `null`, `undefined` or `NaN`
	     * otherwise the first argument is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Logic
	     * @sig a -> b -> a | b
	     * @param {a} val The default value.
	     * @param {b} val The value to return if it is not null or undefined
	     * @return {*} The the second value or the default value
	     * @example
	     *
	     *      var defaultTo42 = R.defaultTo(42);
	     *
	     *      defaultTo42(null);  //=> 42
	     *      defaultTo42(undefined);  //=> 42
	     *      defaultTo42('Ramda');  //=> 'Ramda'
	     *      defaultTo42(parseInt('string')); //=> 42
	     */
	    var defaultTo = _curry2(function defaultTo(d, v) {
	        return v == null || v !== v ? d : v;
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.difference
	     * @example
	     *
	     *      function cmp(x, y) => x.a === y.a;
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	     *      var l2 = [{a: 3}, {a: 4}];
	     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	     */
	    var differenceWith = _curry3(function differenceWith(pred, first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
	                out.push(first[idx]);
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object that does not contain a `prop` property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Object
	     * @sig String -> {k: v} -> {k: v}
	     * @param {String} prop the name of the property to dissociate
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original but without the specified property
	     * @see R.assoc
	     * @example
	     *
	     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	     */
	    var dissoc = _curry2(function dissoc(prop, obj) {
	        var result = {};
	        for (var p in obj) {
	            if (p !== prop) {
	                result[p] = obj[p];
	            }
	        }
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, omitting the property at the given path.
	     * Note that this copies and flattens prototype properties onto the new object
	     * as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.11.0
	     * @category Object
	     * @sig [String] -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object without the property at path
	     * @see R.assocPath
	     * @example
	     *
	     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	     */
	    var dissocPath = _curry2(function dissocPath(path, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return dissoc(path[0], obj);
	        default:
	            var head = path[0];
	            var tail = _slice(path, 1);
	            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
	        }
	    });

	    /**
	     * Divides two numbers. Equivalent to `a / b`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a / b`.
	     * @see R.multiply
	     * @example
	     *
	     *      R.divide(71, 100); //=> 0.71
	     *
	     *      var half = R.divide(R.__, 2);
	     *      half(42); //=> 21
	     *
	     *      var reciprocal = R.divide(1);
	     *      reciprocal(4);   //=> 0.25
	     */
	    var divide = _curry2(function divide(a, b) {
	        return a / b;
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing
	     * each value to the supplied predicate function, skipping elements while the
	     * predicate function returns `true`. The predicate function is passed one
	     * argument: *(value)*.
	     *
	     * Dispatches to the `dropWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var lteTwo = x => x <= 2;
	     *
	     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	     */
	    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && pred(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, idx);
	    }));

	    /**
	     * A function wrapping calls to the two functions in an `||` operation,
	     * returning the result of the first function if it is truth-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * truth-y value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	     * @see R.or
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.either(gt10, even);
	     *      f(101); //=> true
	     *      f(8); //=> true
	     */
	    var either = _curry2(function either(f, g) {
	        return function _either() {
	            return f.apply(this, arguments) || g.apply(this, arguments);
	        };
	    });

	    /**
	     * Returns the empty value of its argument's type. Ramda defines the empty
	     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
	     * types are supported if they define `<Type>.empty` and/or
	     * `<Type>.prototype.empty`.
	     *
	     * Dispatches to the `empty` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x
	     * @return {*}
	     * @example
	     *
	     *      R.empty(Just(42));      //=> Nothing()
	     *      R.empty([1, 2, 3]);     //=> []
	     *      R.empty('unicorns');    //=> ''
	     *      R.empty({x: 1, y: 2});  //=> {}
	     */
	    // else
	    var empty = _curry1(function empty(x) {
	        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
	            return arguments;
	        }() : // else
	        void 0;
	    });

	    /**
	     * Creates a new object by recursively evolving a shallow copy of `object`,
	     * according to the `transformation` functions. All non-primitive properties
	     * are copied by reference.
	     *
	     * A `transformation` function will not be invoked if its corresponding key
	     * does not exist in the evolved object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	     * @param {Object} transformations The object specifying transformation functions to apply
	     *        to the object.
	     * @param {Object} object The object to be transformed.
	     * @return {Object} The transformed object.
	     * @example
	     *
	     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	     *      var transformations = {
	     *        firstName: R.trim,
	     *        lastName: R.trim, // Will not get invoked.
	     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	     *      };
	     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	     */
	    var evolve = _curry2(function evolve(transformations, object) {
	        var result = {};
	        var transformation, key, type;
	        for (key in object) {
	            transformation = transformations[key];
	            type = typeof transformation;
	            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
	        }
	        return result;
	    });

	    /**
	     * Returns the first element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `find` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns the last element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `findLast` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx -= 1;
	        }
	    }));

	    /**
	     * Returns the index of the last element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findLastIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx -= 1;
	        }
	        return -1;
	    }));

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each
	     * element in the list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.forEach` method. For more
	     * details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	     * the original array. In some libraries this function is named `each`.
	     *
	     * Dispatches to the `forEach` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @see R.addIndex
	     * @example
	     *
	     *      var printXPlusFive = x => console.log(x + 5);
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Creates a new object out of a list key-value pairs.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [[k,v]] -> {k: v}
	     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	     * @return {Object} The object made by pairing up `keys` and `values`.
	     * @see R.toPairs, R.pair
	     * @example
	     *
	     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	     */
	    var fromPairs = _curry1(function fromPairs(pairs) {
	        var idx = 0;
	        var len = pairs.length;
	        var out = {};
	        while (idx < len) {
	            if (_isArray(pairs[idx]) && pairs[idx].length) {
	                out[pairs[idx][0]] = pairs[idx][1];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the first argument is greater than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.lt
	     * @example
	     *
	     *      R.gt(2, 1); //=> true
	     *      R.gt(2, 2); //=> false
	     *      R.gt(2, 3); //=> false
	     *      R.gt('a', 'z'); //=> false
	     *      R.gt('z', 'a'); //=> true
	     */
	    var gt = _curry2(function gt(a, b) {
	        return a > b;
	    });

	    /**
	     * Returns `true` if the first argument is greater than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.lte
	     * @example
	     *
	     *      R.gte(2, 1); //=> true
	     *      R.gte(2, 2); //=> true
	     *      R.gte(2, 3); //=> false
	     *      R.gte('a', 'z'); //=> false
	     *      R.gte('z', 'a'); //=> true
	     */
	    var gte = _curry2(function gte(a, b) {
	        return a >= b;
	    });

	    /**
	     * Returns whether or not an object has an own property with the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      var hasName = R.has('name');
	     *      hasName({name: 'alice'});   //=> true
	     *      hasName({name: 'bob'});     //=> true
	     *      hasName({});                //=> false
	     *
	     *      var point = {x: 0, y: 0};
	     *      var pointHas = R.has(R.__, point);
	     *      pointHas('x');  //=> true
	     *      pointHas('y');  //=> true
	     *      pointHas('z');  //=> false
	     */
	    var has = _curry2(_has);

	    /**
	     * Returns whether or not an object or its prototype chain has a property with
	     * the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      function Rectangle(width, height) {
	     *        this.width = width;
	     *        this.height = height;
	     *      }
	     *      Rectangle.prototype.area = function() {
	     *        return this.width * this.height;
	     *      };
	     *
	     *      var square = new Rectangle(2, 2);
	     *      R.hasIn('width', square);  //=> true
	     *      R.hasIn('area', square);  //=> true
	     */
	    var hasIn = _curry2(function hasIn(prop, obj) {
	        return prop in obj;
	    });

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * A function that does nothing but return the parameter supplied to it. Good
	     * as a default or placeholder function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x The value to return.
	     * @return {*} The input value, `x`.
	     * @example
	     *
	     *      R.identity(1); //=> 1
	     *
	     *      var obj = {};
	     *      R.identity(obj) === obj; //=> true
	     */
	    var identity = _curry1(_identity);

	    /**
	     * Creates a function that will process either the `onTrue` or the `onFalse`
	     * function depending upon the result of the `condition` predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	     * @param {Function} condition A predicate function
	     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	     *                    function depending upon the result of the `condition` predicate.
	     * @see R.unless, R.when
	     * @example
	     *
	     *      var incCount = R.ifElse(
	     *        R.has('count'),
	     *        R.over(R.lensProp('count'), R.inc),
	     *        R.assoc('count', 1)
	     *      );
	     *      incCount({});           //=> { count: 1 }
	     *      incCount({ count: 1 }); //=> { count: 2 }
	     */
	    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
	        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	        });
	    });

	    /**
	     * Increments its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.dec
	     * @example
	     *
	     *      R.inc(42); //=> 43
	     */
	    var inc = add(1);

	    /**
	     * Inserts the supplied element into the list, at index `index`. _Note that
	     * this is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} index The position to insert the element
	     * @param {*} elt The element to insert into the Array
	     * @param {Array} list The list to insert into
	     * @return {Array} A new Array with `elt` inserted at `index`.
	     * @example
	     *
	     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	     */
	    var insert = _curry3(function insert(idx, elt, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        var result = _slice(list);
	        result.splice(idx, 0, elt);
	        return result;
	    });

	    /**
	     * Inserts the sub-list into the list, at index `index`. _Note that this is not
	     * destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig Number -> [a] -> [a] -> [a]
	     * @param {Number} index The position to insert the sub-list
	     * @param {Array} elts The sub-list to insert into the Array
	     * @param {Array} list The list to insert the sub-list into
	     * @return {Array} A new Array with `elts` inserted starting at `index`.
	     * @example
	     *
	     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	     */
	    var insertAll = _curry3(function insertAll(idx, elts, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
	    });

	    /**
	     * Creates a new list with the separator interposed between elements.
	     *
	     * Dispatches to the `intersperse` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} separator The element to add to the list.
	     * @param {Array} list The list to be interposed.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	     */
	    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
	        var out = [];
	        var idx = 0;
	        var length = list.length;
	        while (idx < length) {
	            if (idx === length - 1) {
	                out.push(list[idx]);
	            } else {
	                out.push(list[idx], separator);
	            }
	            idx += 1;
	        }
	        return out;
	    }));

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor. This
	     * function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Checks if the input value is `null` or `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Type
	     * @sig * -> Boolean
	     * @param {*} x The value to test.
	     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	     * @example
	     *
	     *      R.isNil(null); //=> true
	     *      R.isNil(undefined); //=> true
	     *      R.isNil(0); //=> false
	     *      R.isNil([]); //=> false
	     */
	    var isNil = _curry1(function isNil(x) {
	        return x == null;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own properties of
	     * the supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    // Safari bug
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        // Safari bug
	        var hasArgsEnumBug = function () {
	            'use strict';
	            return arguments.propertyIsEnumerable('length');
	        }();
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, nIdx;
	            var ks = [];
	            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
	            for (prop in obj) {
	                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a list containing the names of all the properties of the supplied
	     * object, including prototype properties.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.keysIn(f); //=> ['x', 'y']
	     */
	    var keysIn = _curry1(function keysIn(obj) {
	        var prop;
	        var ks = [];
	        for (prop in obj) {
	            ks[ks.length] = prop;
	        }
	        return ks;
	    });

	    /**
	     * Returns the number of elements in the array by returning `list.length`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [a] -> Number
	     * @param {Array} list The array to inspect.
	     * @return {Number} The length of the array.
	     * @example
	     *
	     *      R.length([]); //=> 0
	     *      R.length([1, 2, 3]); //=> 3
	     */
	    var length = _curry1(function length(list) {
	        return list != null && is(Number, list.length) ? list.length : NaN;
	    });

	    /**
	     * Returns `true` if the first argument is less than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.gt
	     * @example
	     *
	     *      R.lt(2, 1); //=> false
	     *      R.lt(2, 2); //=> false
	     *      R.lt(2, 3); //=> true
	     *      R.lt('a', 'z'); //=> true
	     *      R.lt('z', 'a'); //=> false
	     */
	    var lt = _curry2(function lt(a, b) {
	        return a < b;
	    });

	    /**
	     * Returns `true` if the first argument is less than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.gte
	     * @example
	     *
	     *      R.lte(2, 1); //=> false
	     *      R.lte(2, 2); //=> true
	     *      R.lte(2, 3); //=> true
	     *      R.lte('a', 'z'); //=> true
	     *      R.lte('z', 'a'); //=> false
	     */
	    var lte = _curry2(function lte(a, b) {
	        return a <= b;
	    });

	    /**
	     * The mapAccum function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from left to right, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	     */
	    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var tuple = [acc];
	        while (idx < len) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx += 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * The mapAccumRight function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from right to left, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * Similar to `mapAccum`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
	     */
	    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
	        var idx = list.length - 1;
	        var result = [];
	        var tuple = [acc];
	        while (idx >= 0) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx -= 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * Tests a regular expression against a String. Note that this function will
	     * return an empty array when there are no matches. This differs from
	     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	     * which returns `null` when there are no matches.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig RegExp -> String -> [String | Undefined]
	     * @param {RegExp} rx A regular expression.
	     * @param {String} str The string to match against
	     * @return {Array} The list of matches or empty array.
	     * @see R.test
	     * @example
	     *
	     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	     *      R.match(/a/, 'b'); //=> []
	     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	     */
	    var match = _curry2(function match(rx, str) {
	        return str.match(rx) || [];
	    });

	    /**
	     * mathMod behaves like the modulo operator should mathematically, unlike the
	     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
	     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
	     * when the modulus is zero or negative.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} m The dividend.
	     * @param {Number} p the modulus.
	     * @return {Number} The result of `b mod a`.
	     * @example
	     *
	     *      R.mathMod(-17, 5);  //=> 3
	     *      R.mathMod(17, 5);   //=> 2
	     *      R.mathMod(17, -5);  //=> NaN
	     *      R.mathMod(17, 0);   //=> NaN
	     *      R.mathMod(17.2, 5); //=> NaN
	     *      R.mathMod(17, 5.3); //=> NaN
	     *
	     *      var clock = R.mathMod(R.__, 12);
	     *      clock(15); //=> 3
	     *      clock(24); //=> 0
	     *
	     *      var seventeenMod = R.mathMod(17);
	     *      seventeenMod(3);  //=> 2
	     *      seventeenMod(4);  //=> 1
	     *      seventeenMod(10); //=> 7
	     */
	    var mathMod = _curry2(function mathMod(m, p) {
	        if (!_isInteger(m)) {
	            return NaN;
	        }
	        if (!_isInteger(p) || p < 1) {
	            return NaN;
	        }
	        return (m % p + p) % p;
	    });

	    /**
	     * Returns the larger of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.maxBy, R.min
	     * @example
	     *
	     *      R.max(789, 123); //=> 789
	     *      R.max('a', 'b'); //=> 'b'
	     */
	    var max = _curry2(function max(a, b) {
	        return b > a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * larger result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.max, R.minBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.maxBy(square, -3, 2); //=> -3
	     *
	     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
	     *      R.reduce(R.maxBy(square), 0, []); //=> 0
	     */
	    var maxBy = _curry3(function maxBy(f, a, b) {
	        return f(b) > f(a) ? b : a;
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the key
	     * and the values associated with the key in each object, with the result being
	     * used as the value associated with the key in the returned object. The key
	     * will be excluded from the returned object if the resulting value is
	     * `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWith
	     * @example
	     *
	     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	     *      R.mergeWithKey(concatValues,
	     *                     { a: true, thing: 'foo', values: [10, 20] },
	     *                     { b: true, thing: 'bar', values: [15, 35] });
	     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
	     */
	    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
	        var result = {};
	        var k;
	        for (k in l) {
	            if (_has(k, l)) {
	                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
	            }
	        }
	        for (k in r) {
	            if (_has(k, r) && !_has(k, result)) {
	                result[k] = r[k];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the smaller of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.minBy, R.max
	     * @example
	     *
	     *      R.min(789, 123); //=> 123
	     *      R.min('a', 'b'); //=> 'a'
	     */
	    var min = _curry2(function min(a, b) {
	        return b < a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * smaller result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.min, R.maxBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.minBy(square, -3, 2); //=> 2
	     *
	     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
	     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
	     */
	    var minBy = _curry3(function minBy(f, a, b) {
	        return f(b) < f(a) ? b : a;
	    });

	    /**
	     * Divides the second parameter by the first and returns the remainder. Note
	     * that this function preserves the JavaScript-style behavior for modulo. For
	     * mathematical modulo see `mathMod`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The value to the divide.
	     * @param {Number} b The pseudo-modulus
	     * @return {Number} The result of `b % a`.
	     * @see R.mathMod
	     * @example
	     *
	     *      R.modulo(17, 3); //=> 2
	     *      // JS behavior:
	     *      R.modulo(-17, 3); //=> -2
	     *      R.modulo(17, -3); //=> 2
	     *
	     *      var isOdd = R.modulo(R.__, 2);
	     *      isOdd(42); //=> 0
	     *      isOdd(21); //=> 1
	     */
	    var modulo = _curry2(function modulo(a, b) {
	        return a % b;
	    });

	    /**
	     * Multiplies two numbers. Equivalent to `a * b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a * b`.
	     * @see R.divide
	     * @example
	     *
	     *      var double = R.multiply(2);
	     *      var triple = R.multiply(3);
	     *      double(3);       //=>  6
	     *      triple(4);       //=> 12
	     *      R.multiply(2, 5);  //=> 10
	     */
	    var multiply = _curry2(function multiply(a, b) {
	        return a * b;
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly `n` parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} n The desired arity of the new function.
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity `n`.
	     * @example
	     *
	     *      var takesTwoArgs = (a, b) => [a, b];
	     *
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.nAry(1, takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only `n` arguments are passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var nAry = _curry2(function nAry(n, fn) {
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.call(this);
	            };
	        case 1:
	            return function (a0) {
	                return fn.call(this, a0);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.call(this, a0, a1);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.call(this, a0, a1, a2);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.call(this, a0, a1, a2, a3);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.call(this, a0, a1, a2, a3, a4);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	            };
	        default:
	            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	        }
	    });

	    /**
	     * Negates its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @example
	     *
	     *      R.negate(42); //=> -42
	     */
	    var negate = _curry1(function negate(n) {
	        return -n;
	    });

	    /**
	     * Returns `true` if no elements of the list match the predicate, `false`
	     * otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	     * @see R.all, R.any
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
	     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
	     */
	    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

	    /**
	     * A function that returns the `!` of its argument. It will return `true` when
	     * passed false-y value, and `false` when passed a truth-y one.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> Boolean
	     * @param {*} a any value
	     * @return {Boolean} the logical inverse of passed argument.
	     * @see R.complement
	     * @example
	     *
	     *      R.not(true); //=> false
	     *      R.not(false); //=> true
	     *      R.not(0); => true
	     *      R.not(1); => false
	     */
	    var not = _curry1(function not(a) {
	        return !a;
	    });

	    /**
	     * Returns the nth element of the given list or string. If n is negative the
	     * element at index length + n is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> a | Undefined
	     * @sig Number -> String -> String
	     * @param {Number} offset
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      var list = ['foo', 'bar', 'baz', 'quux'];
	     *      R.nth(1, list); //=> 'bar'
	     *      R.nth(-1, list); //=> 'quux'
	     *      R.nth(-99, list); //=> undefined
	     *
	     *      R.nth('abc', 2); //=> 'c'
	     *      R.nth('abc', 3); //=> ''
	     */
	    var nth = _curry2(function nth(offset, list) {
	        var idx = offset < 0 ? list.length + offset : offset;
	        return _isString(list) ? list.charAt(idx) : list[idx];
	    });

	    /**
	     * Returns a function which returns its nth argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig Number -> *... -> *
	     * @param {Number} n
	     * @return {Function}
	     * @example
	     *
	     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	     */
	    var nthArg = _curry1(function nthArg(n) {
	        return function () {
	            return nth(n, arguments);
	        };
	    });

	    /**
	     * Creates an object containing a single key:value pair.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig String -> a -> {String:a}
	     * @param {String} key
	     * @param {*} val
	     * @return {Object}
	     * @see R.pair
	     * @example
	     *
	     *      var matchPhrases = R.compose(
	     *        R.objOf('must'),
	     *        R.map(R.objOf('match_phrase'))
	     *      );
	     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	     */
	    var objOf = _curry2(function objOf(key, val) {
	        var obj = {};
	        obj[key] = val;
	        return obj;
	    });

	    /**
	     * Returns a singleton array containing the value provided.
	     *
	     * Note this `of` is different from the ES6 `of`; See
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> [a]
	     * @param {*} x any value
	     * @return {Array} An array wrapping `x`.
	     * @example
	     *
	     *      R.of(null); //=> [null]
	     *      R.of([42]); //=> [[42]]
	     */
	    var of = _curry1(_of);

	    /**
	     * Accepts a function `fn` and returns a function that guards invocation of
	     * `fn` such that `fn` can only ever be called once, no matter how many times
	     * the returned function is invoked. The first value calculated is returned in
	     * subsequent invocations.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> (a... -> b)
	     * @param {Function} fn The function to wrap in a call-only-once wrapper.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var addOneOnce = R.once(x => x + 1);
	     *      addOneOnce(10); //=> 11
	     *      addOneOnce(addOneOnce(50)); //=> 11
	     */
	    var once = _curry1(function once(fn) {
	        var called = false;
	        var result;
	        return _arity(fn.length, function () {
	            if (called) {
	                return result;
	            }
	            called = true;
	            result = fn.apply(this, arguments);
	            return result;
	        });
	    });

	    /**
	     * Returns `true` if one or both of its arguments are `true`. Returns `false`
	     * if both arguments are `false`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
	     * @see R.either
	     * @example
	     *
	     *      R.or(true, true); //=> true
	     *      R.or(true, false); //=> true
	     *      R.or(false, true); //=> true
	     *      R.or(false, false); //=> false
	     */
	    var or = _curry2(function or(a, b) {
	        return a || b;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the result of applying the given function to
	     * the focused value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> (a -> a) -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	     */
	    var over = function () {
	        var Identity = function (x) {
	            return {
	                value: x,
	                map: function (f) {
	                    return Identity(f(x));
	                }
	            };
	        };
	        return _curry3(function over(lens, f, x) {
	            return lens(function (y) {
	                return Identity(f(y));
	            })(x).value;
	        });
	    }();

	    /**
	     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category List
	     * @sig a -> b -> (a,b)
	     * @param {*} fst
	     * @param {*} snd
	     * @return {Array}
	     * @see R.createMapEntry, R.of
	     * @example
	     *
	     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
	     */
	    var pair = _curry2(function pair(fst, snd) {
	        return [
	            fst,
	            snd
	        ];
	    });

	    /**
	     * Retrieve the value at a given path.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig [String] -> {k: v} -> v | Undefined
	     * @param {Array} path The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path`.
	     * @example
	     *
	     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	     */
	    var path = _curry2(function path(paths, obj) {
	        var val = obj;
	        var idx = 0;
	        while (idx < paths.length) {
	            if (val == null) {
	                return;
	            }
	            val = val[paths[idx]];
	            idx += 1;
	        }
	        return val;
	    });

	    /**
	     * If the given, non-null object has a value at the given path, returns the
	     * value at that path. Otherwise returns the provided default value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig a -> [String] -> Object -> a
	     * @param {*} d The default value.
	     * @param {Array} p The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path` of the supplied object or the default value.
	     * @example
	     *
	     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
	     */
	    var pathOr = _curry3(function pathOr(d, p, obj) {
	        return defaultTo(d, path(p, obj));
	    });

	    /**
	     * Returns `true` if the specified object property at given path satisfies the
	     * given predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Logic
	     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
	     * @param {Function} pred
	     * @param {Array} propPath
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propSatisfies, R.path
	     * @example
	     *
	     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
	     */
	    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
	        return propPath.length > 0 && pred(path(propPath, obj));
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys specified. If
	     * the key does not exist, the property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit, R.props
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Similar to `pick` except that this one includes a `key: undefined` pair for
	     * properties that don't exist.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	     */
	    var pickAll = _curry2(function pickAll(names, obj) {
	        var result = {};
	        var idx = 0;
	        var len = names.length;
	        while (idx < len) {
	            var name = names[idx];
	            result[name] = obj[name];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that satisfy
	     * the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick, R.filter
	     * @example
	     *
	     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a new list with the given element at the front, followed by the
	     * contents of the list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The item to add to the head of the output list.
	     * @param {Array} list The array to add to the tail of the output list.
	     * @return {Array} A new array.
	     * @see R.append
	     * @example
	     *
	     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	     */
	    var prepend = _curry2(function prepend(el, list) {
	        return _concat([el], list);
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated
	     * property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * If the given, non-null object has an own property with the specified name,
	     * returns the value of that property. Otherwise returns the provided default
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Object
	     * @sig a -> String -> Object -> a
	     * @param {*} val The default value.
	     * @param {String} p The name of the property to return.
	     * @param {Object} obj The object to query.
	     * @return {*} The value of given property of the supplied object or the default value.
	     * @example
	     *
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var favorite = R.prop('favoriteLibrary');
	     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	     *
	     *      favorite(alice);  //=> undefined
	     *      favoriteWithDefault(alice);  //=> 'Ramda'
	     */
	    var propOr = _curry3(function propOr(val, p, obj) {
	        return obj != null && _has(p, obj) ? obj[p] : val;
	    });

	    /**
	     * Returns `true` if the specified object property satisfies the given
	     * predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Logic
	     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	     * @param {Function} pred
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propEq, R.propIs
	     * @example
	     *
	     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	     */
	    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
	        return pred(obj[name]);
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> Number -> [Number]
	     * @param {Number} from The first number in the list.
	     * @param {Number} to One more than the last number in the list.
	     * @return {Array} The list of numbers in tthe set `[a, b)`.
	     * @example
	     *
	     *      R.range(1, 5);    //=> [1, 2, 3, 4]
	     *      R.range(50, 53);  //=> [50, 51, 52]
	     */
	    var range = _curry2(function range(from, to) {
	        if (!(_isNumber(from) && _isNumber(to))) {
	            throw new TypeError('Both arguments to range must be numbers');
	        }
	        var result = [];
	        var n = from;
	        while (n < to) {
	            result.push(n);
	            n += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * Similar to `reduce`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two values: *(acc, value)*
	     *
	     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
	     *      var flattenPairs = (acc, pair) => acc.concat(pair);
	     *
	     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
	     */
	    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            acc = fn(acc, list[idx]);
	            idx -= 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a value wrapped to indicate that it is the final value of the reduce
	     * and transduce functions. The returned value should be considered a black
	     * box: the internal structure is not guaranteed to be stable.
	     *
	     * Note: this optimization is unavailable to functions not explicitly listed
	     * above. For instance, it is not currently supported by reduceRight.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category List
	     * @sig a -> *
	     * @param {*} x The final value of the reduce.
	     * @return {*} The wrapped value.
	     * @see R.reduce, R.transduce
	     * @example
	     *
	     *      R.reduce(
	     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
	     *        0,
	     *        [1, 2, 3, 4, 5]) // 10
	     */
	    var reduced = _curry1(_reduced);

	    /**
	     * Removes the sub-list of `list` starting at index `start` and containing
	     * `count` elements. _Note that this is not destructive_: it returns a copy of
	     * the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @param {Number} start The position to start removing elements
	     * @param {Number} count The number of elements to remove
	     * @param {Array} list The list to remove from
	     * @return {Array} A new Array with `count` elements from `start` removed.
	     * @example
	     *
	     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	     */
	    var remove = _curry3(function remove(start, count, list) {
	        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
	    });

	    /**
	     * Replace a substring or regex match in a string with a replacement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category String
	     * @sig RegExp|String -> String -> String -> String
	     * @param {RegExp|String} pattern A regular expression or a substring to match.
	     * @param {String} replacement The string to replace the matches with.
	     * @param {String} str The String to do the search and replacement in.
	     * @return {String} The result.
	     * @example
	     *
	     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *
	     *      // Use the "g" (global) flag to replace all occurrences:
	     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	     */
	    var replace = _curry3(function replace(regex, replacement, str) {
	        return str.replace(regex, replacement);
	    });

	    /**
	     * Returns a new list or string with the elements or characters in reverse
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {Array|String}
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     *
	     *      R.reverse('abc');      //=> 'cba'
	     *      R.reverse('ab');       //=> 'ba'
	     *      R.reverse('a');        //=> 'a'
	     *      R.reverse('');         //=> ''
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
	    });

	    /**
	     * Scan is similar to reduce, but returns a list of successively reduced values
	     * from the left
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> [a]
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} A list of all intermediately reduced values.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	     */
	    var scan = _curry3(function scan(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [acc];
	        while (idx < len) {
	            acc = fn(acc, list[idx]);
	            result[idx + 1] = acc;
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> a -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	     */
	    var set = _curry3(function set(lens, v, x) {
	        return over(lens, always(v), x);
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * Dispatches to the `slice` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Returns a copy of the list, sorted according to the comparator function,
	     * which should accept two values at a time and return a negative number if the
	     * first value is smaller, a positive number if it's larger, and zero if they
	     * are equal. Please note that this is a **copy** of the list. It does not
	     * modify the original.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,a -> Number) -> [a] -> [a]
	     * @param {Function} comparator A sorting function :: a -> b -> Int
	     * @param {Array} list The list to sort
	     * @return {Array} a new array with its elements sorted by the comparator function.
	     * @example
	     *
	     *      var diff = function(a, b) { return a - b; };
	     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	     */
	    var sort = _curry2(function sort(comparator, list) {
	        return _slice(list).sort(comparator);
	    });

	    /**
	     * Sorts the list according to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> [a] -> [a]
	     * @param {Function} fn
	     * @param {Array} list The list to sort.
	     * @return {Array} A new list sorted by the keys generated by `fn`.
	     * @example
	     *
	     *      var sortByFirstItem = R.sortBy(R.prop(0));
	     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var bob = {
	     *        name: 'Bob',
	     *        age: -10
	     *      };
	     *      var clara = {
	     *        name: 'clara',
	     *        age: 314.159
	     *      };
	     *      var people = [clara, bob, alice];
	     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	     */
	    var sortBy = _curry2(function sortBy(fn, list) {
	        return _slice(list).sort(function (a, b) {
	            var aa = fn(a);
	            var bb = fn(b);
	            return aa < bb ? -1 : aa > bb ? 1 : 0;
	        });
	    });

	    /**
	     * Splits a given list or string at a given index.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig Number -> [a] -> [[a], [a]]
	     * @sig Number -> String -> [String, String]
	     * @param {Number} index The index where the array/string is split.
	     * @param {Array|String} array The array/string to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
	     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
	     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
	     */
	    var splitAt = _curry2(function splitAt(index, array) {
	        return [
	            slice(0, index, array),
	            slice(index, length(array), array)
	        ];
	    });

	    /**
	     * Splits a collection into slices of the specified length.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @sig Number -> String -> [String]
	     * @param {Number} n
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	     */
	    var splitEvery = _curry2(function splitEvery(n, list) {
	        if (n <= 0) {
	            throw new Error('First argument to splitEvery must be a positive integer');
	        }
	        var result = [];
	        var idx = 0;
	        while (idx < list.length) {
	            result.push(slice(idx, idx += n, list));
	        }
	        return result;
	    });

	    /**
	     * Takes a list and a predicate and returns a pair of lists with the following properties:
	     *
	     *  - the result of concatenating the two output lists is equivalent to the input list;
	     *  - none of the elements of the first output list satisfies the predicate; and
	     *  - if the second output list is non-empty, its first element satisfies the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
	     * @param {Function} pred The predicate that determines where the array is split.
	     * @param {Array} list The array to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
	     */
	    var splitWhen = _curry2(function splitWhen(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var prefix = [];
	        while (idx < len && !pred(list[idx])) {
	            prefix.push(list[idx]);
	            idx += 1;
	        }
	        return [
	            prefix,
	            _slice(list, idx)
	        ];
	    });

	    /**
	     * Subtracts two numbers. Equivalent to `a - b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a - b`.
	     * @see R.add
	     * @example
	     *
	     *      R.subtract(10, 8); //=> 2
	     *
	     *      var minus5 = R.subtract(R.__, 5);
	     *      minus5(17); //=> 12
	     *
	     *      var complementaryAngle = R.subtract(90);
	     *      complementaryAngle(30); //=> 60
	     *      complementaryAngle(72); //=> 18
	     */
	    var subtract = _curry2(function subtract(a, b) {
	        return a - b;
	    });

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * Dispatches to the `slice` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.head, R.init, R.last
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Returns the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `take` method).
	     *
	     * Dispatches to the `take` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.drop
	     * @example
	     *
	     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(3, 'ramda');               //=> 'ram'
	     *
	     *      var personnel = [
	     *        'Dave Brubeck',
	     *        'Paul Desmond',
	     *        'Eugene Wright',
	     *        'Joe Morello',
	     *        'Gerry Mulligan',
	     *        'Bob Bates',
	     *        'Joe Dodge',
	     *        'Ron Crotty'
	     *      ];
	     *
	     *      var takeFive = R.take(5);
	     *      takeFive(personnel);
	     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	     */
	    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
	        return slice(0, n < 0 ? Infinity : n, xs);
	    }));

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing
	     * each value to the supplied predicate function, and terminating when the
	     * predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropLastWhile, R.addIndex
	     * @example
	     *
	     *      var isNotOne = x => x !== 1;
	     *
	     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	     */
	    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && fn(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, idx + 1, Infinity);
	    });

	    /**
	     * Returns a new list containing the first `n` elements of a given list,
	     * passing each value to the supplied predicate function, and terminating when
	     * the predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * Dispatches to the `takeWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isNotFour = x => x !== 4;
	     *
	     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
	     */
	    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && fn(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, 0, idx);
	    }));

	    /**
	     * Runs the given function with the supplied object, then returns the object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> *) -> a -> a
	     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	     * @param {*} x
	     * @return {*} `x`.
	     * @example
	     *
	     *      var sayX = x => console.log('x is ' + x);
	     *      R.tap(sayX, 100); //=> 100
	     *      //-> 'x is 100'
	     */
	    var tap = _curry2(function tap(fn, x) {
	        fn(x);
	        return x;
	    });

	    /**
	     * Calls an input function `n` times, returning an array containing the results
	     * of those function calls.
	     *
	     * `fn` is passed one argument: The current value of `n`, which begins at `0`
	     * and is gradually incremented to `n - 1`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.3
	     * @category List
	     * @sig (Number -> a) -> Number -> [a]
	     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	     * @return {Array} An array containing the return values of all calls to `fn`.
	     * @example
	     *
	     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	     */
	    var times = _curry2(function times(fn, n) {
	        var len = Number(n);
	        var idx = 0;
	        var list;
	        if (len < 0 || isNaN(len)) {
	            throw new RangeError('n must be a non-negative number');
	        }
	        list = new Array(len);
	        while (idx < len) {
	            list[idx] = fn(idx);
	            idx += 1;
	        }
	        return list;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. Only the object's
	     * own properties are used.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own properties.
	     * @see R.fromPairs
	     * @example
	     *
	     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	     */
	    var toPairs = _curry1(function toPairs(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            if (_has(prop, obj)) {
	                pairs[pairs.length] = [
	                    prop,
	                    obj[prop]
	                ];
	            }
	        }
	        return pairs;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. The object's own
	     * properties and prototype properties are used. Note that the order of the
	     * output array is not guaranteed to be consistent across different JS
	     * platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own
	     *         and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	     */
	    var toPairsIn = _curry1(function toPairsIn(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            pairs[pairs.length] = [
	                prop,
	                obj[prop]
	            ];
	        }
	        return pairs;
	    });

	    /**
	     * Transposes the rows and columns of a 2D list.
	     * When passed a list of `n` lists of length `x`,
	     * returns a list of `x` lists of length `n`.
	     *
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig [[a]] -> [[a]]
	     * @param {Array} list A 2D list
	     * @return {Array} A 2D list
	     * @example
	     *
	     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
	     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     *
	     * If some of the rows are shorter than the following rows, their elements are skipped:
	     *
	     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
	     */
	    var transpose = _curry1(function transpose(outerlist) {
	        var i = 0;
	        var result = [];
	        while (i < outerlist.length) {
	            var innerlist = outerlist[i];
	            var j = 0;
	            while (j < innerlist.length) {
	                if (typeof result[j] === 'undefined') {
	                    result[j] = [];
	                }
	                result[j].push(innerlist[j]);
	                j += 1;
	            }
	            i += 1;
	        }
	        return result;
	    });

	    /**
	     * Removes (strips) whitespace from both ends of the string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to trim.
	     * @return {String} Trimmed version of `str`.
	     * @example
	     *
	     *      R.trim('   xyz  '); //=> 'xyz'
	     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	     */
	    var trim = function () {
	        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	        var zeroWidth = '\u200B';
	        var hasProtoTrim = typeof String.prototype.trim === 'function';
	        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
	            return _curry1(function trim(str) {
	                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	                return str.replace(beginRx, '').replace(endRx, '');
	            });
	        } else {
	            return _curry1(function trim(str) {
	                return str.trim();
	            });
	        }
	    }();

	    /**
	     * Gives a single-word string description of the (native) type of a value,
	     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	     * attempt to distinguish user Object types any further, reporting them all as
	     * 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Takes a function `fn`, which takes a single array argument, and returns a
	     * function which:
	     *
	     *   - takes any number of positional arguments;
	     *   - passes these arguments to `fn` as an array; and
	     *   - returns the result.
	     *
	     * In other words, R.unapply derives a variadic function from a function which
	     * takes an array. R.unapply is the inverse of R.apply.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Function
	     * @sig ([*...] -> a) -> (*... -> a)
	     * @param {Function} fn
	     * @return {Function}
	     * @see R.apply
	     * @example
	     *
	     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	     */
	    var unapply = _curry1(function unapply(fn) {
	        return function () {
	            return fn(_slice(arguments));
	        };
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 1 parameter. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> b) -> (a -> b)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 1.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.unary(takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only 1 argument is passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var unary = _curry1(function unary(fn) {
	        return nAry(1, fn);
	    });

	    /**
	     * Returns a function of arity `n` from a (manually) curried function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Function
	     * @sig Number -> (a -> b) -> (a -> c)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to uncurry.
	     * @return {Function} A new function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFour = a => b => c => d => a + b + c + d;
	     *
	     *      var uncurriedAddFour = R.uncurryN(4, addFour);
	     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
	     */
	    var uncurryN = _curry2(function uncurryN(depth, fn) {
	        return curryN(depth, function () {
	            var currentDepth = 1;
	            var value = fn;
	            var idx = 0;
	            var endIdx;
	            while (currentDepth <= depth && typeof value === 'function') {
	                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	                value = value.apply(this, _slice(arguments, idx, endIdx));
	                currentDepth += 1;
	                idx = endIdx;
	            }
	            return value;
	        });
	    });

	    /**
	     * Builds a list from a seed value. Accepts an iterator function, which returns
	     * either false to stop iteration or an array of length 2 containing the value
	     * to add to the resulting list and the seed to be used in the next call to the
	     * iterator function.
	     *
	     * The iterator function receives one argument: *(seed)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a -> [b]) -> * -> [b]
	     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	     *        either false to quit iteration or an array of length two to proceed. The element
	     *        at index 0 of this array will be added to the resulting array, and the element
	     *        at index 1 will be passed to the next call to `fn`.
	     * @param {*} seed The seed value.
	     * @return {Array} The final list.
	     * @example
	     *
	     *      var f = n => n > 50 ? false : [-n, n + 10];
	     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	     */
	    var unfold = _curry2(function unfold(fn, seed) {
	        var pair = fn(seed);
	        var result = [];
	        while (pair && pair.length) {
	            result[result.length] = pair[0];
	            pair = fn(pair[1]);
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied predicate to
	     * two list elements. Prefers the first item if two items compare equal based
	     * on the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      var strEq = R.eqBy(String);
	     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	     */
	    var uniqWith = _curry2(function uniqWith(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var item;
	        while (idx < len) {
	            item = list[idx];
	            if (!_containsWith(pred, item, result)) {
	                result[result.length] = item;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is not satisfied, the function will return the result of
	     * calling the `whenFalseFn` function with the same argument. If the predicate
	     * is satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred        A predicate function
	     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
	     *                               to a falsy value.
	     * @param {*}        x           An object to test with the `pred` function and
	     *                               pass to `whenFalseFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
	     * @see R.ifElse, R.when
	     * @example
	     *
	     *      // coerceArray :: (a|[a]) -> [a]
	     *      var coerceArray = R.unless(R.isArrayLike, R.of);
	     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
	     *      coerceArray(1);         //=> [1]
	     */
	    var unless = _curry3(function unless(pred, whenFalseFn, x) {
	        return pred(x) ? x : whenFalseFn(x);
	    });

	    /**
	     * Returns a new copy of the array with the element at the provided index
	     * replaced with the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} idx The index to update.
	     * @param {*} x The value to exist at the given index of the returned array.
	     * @param {Array|Arguments} list The source array-like object to be updated.
	     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	     * @see R.adjust
	     * @example
	     *
	     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var update = _curry3(function update(idx, x, list) {
	        return adjust(always(x), idx, list);
	    });

	    /**
	     * Accepts a function `fn` and a list of transformer functions and returns a
	     * new curried function. When the new function is invoked, it calls the
	     * function `fn` with parameters consisting of the result of calling each
	     * supplied handler on successive arguments to the new function.
	     *
	     * If more arguments are passed to the returned function than transformer
	     * functions, those arguments are passed directly to `fn` as additional
	     * parameters. If you expect additional arguments that don't need to be
	     * transformed, although you can ignore them, it's best to pass an identity
	     * function so that the new function reports the correct arity.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} fn The function to wrap.
	     * @param {Array} transformers A list of transformer functions
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
	     */
	    var useWith = _curry2(function useWith(fn, transformers) {
	        return curryN(transformers.length, function () {
	            var args = [];
	            var idx = 0;
	            while (idx < transformers.length) {
	                args.push(transformers[idx].call(this, arguments[idx]));
	                idx += 1;
	            }
	            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
	        });
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across different
	     * JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    /**
	     * Returns a list of all the properties, including prototype properties, of the
	     * supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.valuesIn(f); //=> ['X', 'Y']
	     */
	    var valuesIn = _curry1(function valuesIn(obj) {
	        var prop;
	        var vs = [];
	        for (prop in obj) {
	            vs[vs.length] = obj[prop];
	        }
	        return vs;
	    });

	    /**
	     * Returns a "view" of the given data structure, determined by the given lens.
	     * The lens's focus determines which portion of the data structure is visible.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> s -> a
	     * @param {Lens} lens
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});  //=> 1
	     *      R.view(xLens, {x: 4, y: 2});  //=> 4
	     */
	    var view = function () {
	        var Const = function (x) {
	            return {
	                value: x,
	                map: function () {
	                    return this;
	                }
	            };
	        };
	        return _curry2(function view(lens, x) {
	            return lens(Const)(x).value;
	        });
	    }();

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is satisfied, the function will return the result of calling
	     * the `whenTrueFn` function with the same argument. If the predicate is not
	     * satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred       A predicate function
	     * @param {Function} whenTrueFn A function to invoke when the `condition`
	     *                              evaluates to a truthy value.
	     * @param {*}        x          An object to test with the `pred` function and
	     *                              pass to `whenTrueFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
	     * @see R.ifElse, R.unless
	     * @example
	     *
	     *      // truncate :: String -> String
	     *      var truncate = R.when(
	     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
	     *        R.pipe(R.take(10), R.append('…'), R.join(''))
	     *      );
	     *      truncate('12345');         //=> '12345'
	     *      truncate('0123456789ABC'); //=> '0123456789…'
	     */
	    var when = _curry3(function when(pred, whenTrueFn, x) {
	        return pred(x) ? whenTrueFn(x) : x;
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec. Each of the spec's own properties must be a predicate function.
	     * Each predicate is applied to the value of the corresponding property of the
	     * test object. `where` returns true if all the predicates return true, false
	     * otherwise.
	     *
	     * `where` is well suited to declaratively expressing constraints for other
	     * functions such as `filter` and `find`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Object
	     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.where({
	     *        a: R.equals('foo'),
	     *        b: R.complement(R.equals('bar')),
	     *        x: R.gt(_, 10),
	     *        y: R.lt(_, 20)
	     *      });
	     *
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	     */
	    var where = _curry2(function where(spec, testObj) {
	        for (var prop in spec) {
	            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	                return false;
	            }
	        }
	        return true;
	    });

	    /**
	     * Wrap a function inside another to allow you to make adjustments to the
	     * parameters, or do other processing either before the internal function is
	     * called or with its results.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
	     * @param {Function} fn The function to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var greet = name => 'Hello ' + name;
	     *
	     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
	     *
	     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
	     *
	     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name.substring(0, 3));
	     *      });
	     *      shortenedGreet("Robert"); //=> "Hello Rob"
	     */
	    var wrap = _curry2(function wrap(fn, wrapper) {
	        return curryN(fn.length, function () {
	            return wrapper.apply(this, _concat([fn], arguments));
	        });
	    });

	    /**
	     * Creates a new list out of the two supplied by creating each possible pair
	     * from the lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The list made by combining each possible pair from
	     *         `as` and `bs` into pairs (`[a, b]`).
	     * @example
	     *
	     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	     */
	    // = xprodWith(prepend); (takes about 3 times as long...)
	    var xprod = _curry2(function xprod(a, b) {
	        // = xprodWith(prepend); (takes about 3 times as long...)
	        var idx = 0;
	        var ilen = a.length;
	        var j;
	        var jlen = b.length;
	        var result = [];
	        while (idx < ilen) {
	            j = 0;
	            while (j < jlen) {
	                result[result.length] = [
	                    a[idx],
	                    b[j]
	                ];
	                j += 1;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Creates a new list out of the two supplied by pairing up equally-positioned
	     * items from both lists. The returned list is truncated to the length of the
	     * shorter of the two input lists.
	     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	     * @example
	     *
	     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     */
	    var zip = _curry2(function zip(a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = [
	                a[idx],
	                b[idx]
	            ];
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * Creates a new object out of a list of keys and a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [String] -> [*] -> {String: *}
	     * @param {Array} keys The array that will be properties on the output object.
	     * @param {Array} values The list of values on the output object.
	     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	     * @example
	     *
	     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	     */
	    var zipObj = _curry2(function zipObj(keys, values) {
	        var idx = 0;
	        var len = keys.length;
	        var out = {};
	        while (idx < len) {
	            out[keys[idx]] = values[idx];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Creates a new list out of the two supplied by applying the function to each
	     * equally-positioned pair in the lists. The returned list is truncated to the
	     * length of the shorter of the two input lists.
	     *
	     * @function
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> c) -> [a] -> [b] -> [c]
	     * @param {Function} fn The function used to combine the two elements into one value.
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	     *         using `fn`.
	     * @example
	     *
	     *      var f = (x, y) => {
	     *        // ...
	     *      };
	     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	     */
	    var zipWith = _curry3(function zipWith(fn, a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = fn(a[idx], b[idx]);
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * A function that always returns `false`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.T
	     * @example
	     *
	     *      R.F(); //=> false
	     */
	    var F = always(false);

	    /**
	     * A function that always returns `true`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.F
	     * @example
	     *
	     *      R.T(); //=> true
	     */
	    var T = always(true);

	    /**
	     * Copies an object.
	     *
	     * @private
	     * @param {*} value The value to be copied
	     * @param {Array} refFrom Array containing the source references
	     * @param {Array} refTo Array containing the copied source references
	     * @return {*} The copied value.
	     */
	    var _clone = function _clone(value, refFrom, refTo) {
	        var copy = function copy(copiedValue) {
	            var len = refFrom.length;
	            var idx = 0;
	            while (idx < len) {
	                if (value === refFrom[idx]) {
	                    return refTo[idx];
	                }
	                idx += 1;
	            }
	            refFrom[idx + 1] = value;
	            refTo[idx + 1] = copiedValue;
	            for (var key in value) {
	                copiedValue[key] = _clone(value[key], refFrom, refTo);
	            }
	            return copiedValue;
	        };
	        switch (type(value)) {
	        case 'Object':
	            return copy({});
	        case 'Array':
	            return copy([]);
	        case 'Date':
	            return new Date(value.valueOf());
	        case 'RegExp':
	            return _cloneRegExp(value);
	        default:
	            return value;
	        }
	    };

	    var _createPartialApplicator = function _createPartialApplicator(concat) {
	        return _curry2(function (fn, args) {
	            return _arity(Math.max(0, fn.length - args.length), function () {
	                return fn.apply(this, concat(args, arguments));
	            });
	        });
	    };

	    var _dropLast = function dropLast(n, xs) {
	        return take(n < xs.length ? xs.length - n : 0, xs);
	    };

	    // Values of other types are only equal if identical.
	    var _equals = function _equals(a, b, stackA, stackB) {
	        if (identical(a, b)) {
	            return true;
	        }
	        if (type(a) !== type(b)) {
	            return false;
	        }
	        if (a == null || b == null) {
	            return false;
	        }
	        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	        }
	        switch (type(a)) {
	        case 'Arguments':
	        case 'Array':
	        case 'Object':
	            break;
	        case 'Boolean':
	        case 'Number':
	        case 'String':
	            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	                return false;
	            }
	            break;
	        case 'Date':
	            if (!identical(a.valueOf(), b.valueOf())) {
	                return false;
	            }
	            break;
	        case 'Error':
	            return a.name === b.name && a.message === b.message;
	        case 'RegExp':
	            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	                return false;
	            }
	            break;
	        case 'Map':
	        case 'Set':
	            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
	                return false;
	            }
	            break;
	        case 'Int8Array':
	        case 'Uint8Array':
	        case 'Uint8ClampedArray':
	        case 'Int16Array':
	        case 'Uint16Array':
	        case 'Int32Array':
	        case 'Uint32Array':
	        case 'Float32Array':
	        case 'Float64Array':
	            break;
	        case 'ArrayBuffer':
	            break;
	        default:
	            // Values of other types are only equal if identical.
	            return false;
	        }
	        var keysA = keys(a);
	        if (keysA.length !== keys(b).length) {
	            return false;
	        }
	        var idx = stackA.length - 1;
	        while (idx >= 0) {
	            if (stackA[idx] === a) {
	                return stackB[idx] === b;
	            }
	            idx -= 1;
	        }
	        stackA.push(a);
	        stackB.push(b);
	        idx = keysA.length - 1;
	        while (idx >= 0) {
	            var key = keysA[idx];
	            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
	                return false;
	            }
	            idx -= 1;
	        }
	        stackA.pop();
	        stackB.pop();
	        return true;
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive
	     * function based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, jlen, j;
	            var result = [];
	            var idx = 0;
	            var ilen = list.length;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0;
	            var len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    var _xdropLastWhile = function () {
	        function XDropLastWhile(fn, xf) {
	            this.f = fn;
	            this.retained = [];
	            this.xf = xf;
	        }
	        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
	            this.retained = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
	        };
	        XDropLastWhile.prototype.flush = function (result, input) {
	            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
	            this.retained = [];
	            return this.xf['@@transducer/step'](result, input);
	        };
	        XDropLastWhile.prototype.retain = function (result, input) {
	            this.retained.push(input);
	            return result;
	        };
	        return _curry2(function _xdropLastWhile(fn, xf) {
	            return new XDropLastWhile(fn, xf);
	        });
	    }();

	    var _xgroupBy = function () {
	        function XGroupBy(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.inputs = {};
	        }
	        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
	        XGroupBy.prototype['@@transducer/result'] = function (result) {
	            var key;
	            for (key in this.inputs) {
	                if (_has(key, this.inputs)) {
	                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
	                    if (result['@@transducer/reduced']) {
	                        result = result['@@transducer/value'];
	                        break;
	                    }
	                }
	            }
	            this.inputs = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
	            var key = this.f(input);
	            this.inputs[key] = this.inputs[key] || [
	                key,
	                []
	            ];
	            this.inputs[key][1] = append(input, this.inputs[key][1]);
	            return result;
	        };
	        return _curry2(function _xgroupBy(f, xf) {
	            return new XGroupBy(f, xf);
	        });
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new
	     * parameters to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that
	     * more closely resembles `Array.prototype.map`. Note that this will only work
	     * for functions in which the iteration callback function is the first
	     * parameter, and where the list is the last parameter. (This latter might be
	     * unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 2 parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> c) -> (a, b -> c)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 2.
	     * @example
	     *
	     *      var takesThreeArgs = function(a, b, c) {
	     *        return [a, b, c];
	     *      };
	     *      takesThreeArgs.length; //=> 3
	     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      var takesTwoArgs = R.binary(takesThreeArgs);
	     *      takesTwoArgs.length; //=> 2
	     *      // Only 2 arguments are passed to the wrapped function
	     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	     */
	    var binary = _curry1(function binary(fn) {
	        return nAry(2, fn);
	    });

	    /**
	     * Creates a deep copy of the value which may contain (nested) `Array`s and
	     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
	     * copied, but assigned by their reference.
	     *
	     * Dispatches to a `clone` method if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {*} -> {*}
	     * @param {*} value The object or array to clone
	     * @return {*} A new object or array.
	     * @example
	     *
	     *      var objects = [{}, {}, {}];
	     *      var objectsClone = R.clone(objects);
	     *      objects[0] === objectsClone[0]; //=> false
	     */
	    var clone = _curry1(function clone(value) {
	        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried function
	     * has two unusual capabilities. First, its arguments needn't be provided one
	     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns all but the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `drop` method).
	     *
	     * Dispatches to the `drop` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.take, R.transduce
	     * @example
	     *
	     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(3, 'ramda');               //=> 'da'
	     */
	    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
	        return slice(Math.max(0, n), Infinity, xs);
	    }));

	    /**
	     * Returns a list containing all but the last `n` elements of the given `list`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements of `xs` to skip.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.takeLast
	     * @example
	     *
	     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(3, 'ramda');               //=> 'ra'
	     */
	    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

	    /**
	     * Returns a new list containing all but last the`n` elements of a given list,
	     * passing each value from the right to the supplied predicate function,
	     * skipping elements while the predicate function returns `true`. The predicate
	     * function is passed one argument: (value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeLastWhile, R.addIndex
	     * @example
	     *
	     *      var lteThree = x => x <= 3;
	     *
	     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
	     */
	    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	     * cyclical data structures.
	     *
	     * Dispatches symmetrically to the `equals` methods of both arguments, if
	     * present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _equals(a, b, [], []);
	    });

	    /**
	     * Takes a predicate and a "filterable", and returns a new filterable of the
	     * same type containing the members of the given filterable which satisfy the
	     * given predicate.
	     *
	     * Dispatches to the `filter` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.reject, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    // else
	    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
	        return _isObject(filterable) ? _reduce(function (acc, key) {
	            if (pred(filterable[key])) {
	                acc[key] = filterable[key];
	            }
	            return acc;
	        }, {}, keys(filterable)) : // else
	        _filter(pred, filterable);
	    }));

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays)
	     * and putting them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new function much like the supplied one, except that the first two
	     * arguments' order is reversed.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
	     * @param {Function} fn The function to invoke with its first two parameters reversed.
	     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	     * @example
	     *
	     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
	     *
	     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	     */
	    var flip = _curry1(function flip(fn) {
	        return curry(function (a, b) {
	            var args = _slice(arguments);
	            args[0] = b;
	            args[1] = a;
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Splits a list into sub-lists stored in an object, based on the result of
	     * calling a String-returning function on each element, and grouping the
	     * results according to values returned.
	     *
	     * Dispatches to the `groupBy` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> String) -> [a] -> {String: [a]}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} list The array to group
	     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	     *         that produced that key when passed to `fn`.
	     * @see R.transduce
	     * @example
	     *
	     *      var byGrade = R.groupBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Abby', score: 84},
	     *                      {name: 'Eddy', score: 58},
	     *                      // ...
	     *                      {name: 'Jack', score: 69}];
	     *      byGrade(students);
	     *      // {
	     *      //   'A': [{name: 'Dianne', score: 99}],
	     *      //   'B': [{name: 'Abby', score: 84}]
	     *      //   // ...,
	     *      //   'F': [{name: 'Eddy', score: 58}]
	     *      // }
	     */
	    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
	        return _reduce(function (acc, elt) {
	            var key = fn(elt);
	            acc[key] = append(elt, acc[key] || (acc[key] = []));
	            return acc;
	        }, {}, list);
	    }));

	    /**
	     * Returns the first element of the given list or string. In some libraries
	     * this function is named `first`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {*}
	     * @see R.tail, R.init, R.last
	     * @example
	     *
	     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	     *      R.head([]); //=> undefined
	     *
	     *      R.head('abc'); //=> 'a'
	     *      R.head(''); //=> ''
	     */
	    var head = nth(0);

	    /**
	     * Given a function that generates a key, turns a list of objects into an
	     * object indexing the objects by the given key. Note that if multiple
	     * objects generate the same value for the indexing key only the last value
	     * will be included in the generated object.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} array The array of objects to index
	     * @return {Object} An object indexing each array element by the given property.
	     * @example
	     *
	     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
	     *      R.indexBy(R.prop('id'), list);
	     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
	     */
	    var indexBy = _curry2(function indexBy(fn, list) {
	        return _reduce(function (acc, elem) {
	            var key = fn(elem);
	            acc[key] = elem;
	            return acc;
	        }, {}, list);
	    });

	    /**
	     * Returns all but the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.last, R.head, R.tail
	     * @example
	     *
	     *      R.init([1, 2, 3]);  //=> [1, 2]
	     *      R.init([1, 2]);     //=> [1]
	     *      R.init([1]);        //=> []
	     *      R.init([]);         //=> []
	     *
	     *      R.init('abc');  //=> 'ab'
	     *      R.init('ab');   //=> 'a'
	     *      R.init('a');    //=> ''
	     *      R.init('');     //=> ''
	     */
	    var init = slice(0, -1);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate function that determines whether
	     *        the two supplied elements are equal.
	     * @param {Array} list1 One list of items to compare
	     * @param {Array} list2 A second list of items to compare
	     * @return {Array} A new list containing those elements common to both lists.
	     * @see R.intersection
	     * @example
	     *
	     *      var buffaloSpringfield = [
	     *        {id: 824, name: 'Richie Furay'},
	     *        {id: 956, name: 'Dewey Martin'},
	     *        {id: 313, name: 'Bruce Palmer'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *      var csny = [
	     *        {id: 204, name: 'David Crosby'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 539, name: 'Graham Nash'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *
	     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
	     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	     */
	    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
	        var results = [];
	        var idx = 0;
	        while (idx < list1.length) {
	            if (_containsWith(pred, list1[idx], list2)) {
	                results[results.length] = list1[idx];
	            }
	            idx += 1;
	        }
	        return uniqWith(pred, results);
	    });

	    /**
	     * Same as R.invertObj, however this accounts for objects with duplicate values
	     * by putting the values into an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: [ s, ... ]}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object with keys
	     * in an array.
	     * @example
	     *
	     *      var raceResultsByFirstName = {
	     *        first: 'alice',
	     *        second: 'jake',
	     *        third: 'alice',
	     *      };
	     *      R.invert(raceResultsByFirstName);
	     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	     */
	    var invert = _curry1(function invert(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            var val = obj[key];
	            var list = _has(val, out) ? out[val] : out[val] = [];
	            list[list.length] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object with the keys of the given object as values, and the
	     * values of the given object, which are coerced to strings, as keys. Note
	     * that the last key found is preferred when handling the same value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: s}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object
	     * @example
	     *
	     *      var raceResults = {
	     *        first: 'alice',
	     *        second: 'jake'
	     *      };
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': 'first', 'jake':'second' }
	     *
	     *      // Alternatively:
	     *      var raceResults = ['alice', 'jake'];
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': '0', 'jake':'1' }
	     */
	    var invertObj = _curry1(function invertObj(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            out[obj[key]] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the given value is its type's empty value; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig a -> Boolean
	     * @param {*} x
	     * @return {Boolean}
	     * @see R.empty
	     * @example
	     *
	     *      R.isEmpty([1, 2, 3]);   //=> false
	     *      R.isEmpty([]);          //=> true
	     *      R.isEmpty('');          //=> true
	     *      R.isEmpty(null);        //=> false
	     *      R.isEmpty({});          //=> true
	     *      R.isEmpty({length: 0}); //=> false
	     */
	    var isEmpty = _curry1(function isEmpty(x) {
	        return x != null && equals(x, empty(x));
	    });

	    /**
	     * Returns the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.init, R.head, R.tail
	     * @example
	     *
	     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	     *      R.last([]); //=> undefined
	     *
	     *      R.last('abc'); //=> 'c'
	     *      R.last(''); //=> ''
	     */
	    var last = nth(-1);

	    /**
	     * Returns the position of the last occurrence of an item in an array, or -1 if
	     * the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.indexOf
	     * @example
	     *
	     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	     */
	    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
	        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
	            return xs.lastIndexOf(target);
	        } else {
	            var idx = xs.length - 1;
	            while (idx >= 0) {
	                if (equals(xs[idx], target)) {
	                    return idx;
	                }
	                idx -= 1;
	            }
	            return -1;
	        }
	    });

	    /**
	     * Takes a function and
	     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
	     * applies the function to each of the functor's values, and returns
	     * a functor of the same shape.
	     *
	     * Ramda provides suitable `map` implementations for `Array` and `Object`,
	     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
	     *
	     * Dispatches to the `map` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * Also treats functions as functors and will compose them together.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Functor f => (a -> b) -> f a -> f b
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @see R.transduce, R.addIndex
	     * @example
	     *
	     *      var double = x => x * 2;
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     *
	     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	     */
	    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
	        switch (Object.prototype.toString.call(functor)) {
	        case '[object Function]':
	            return curryN(functor.length, function () {
	                return fn.call(this, functor.apply(this, arguments));
	            });
	        case '[object Object]':
	            return _reduce(function (acc, key) {
	                acc[key] = fn(functor[key]);
	                return acc;
	            }, {}, keys(functor));
	        default:
	            return _map(fn, functor);
	        }
	    }));

	    /**
	     * An Object-specific version of `map`. The function is applied to three
	     * arguments: *(value, key, obj)*. If only the value is significant, use
	     * `map` instead.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig ((*, String, Object) -> *) -> Object -> Object
	     * @param {Function} fn
	     * @param {Object} obj
	     * @return {Object}
	     * @see R.map
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the values
	     * associated with the key in each object, with the result being used as the
	     * value associated with the key in the returned object. The key will be
	     * excluded from the returned object if the resulting value is `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWithKey
	     * @example
	     *
	     *      R.mergeWith(R.concat,
	     *                  { a: true, values: [10, 20] },
	     *                  { b: true, values: [15, 35] });
	     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
	     */
	    var mergeWith = _curry3(function mergeWith(fn, l, r) {
	        return mergeWithKey(function (_, _l, _r) {
	            return fn(_l, _r);
	        }, l, r);
	    });

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided initially followed by the arguments provided to `g`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partialRight
	     * @example
	     *
	     *      var multiply = (a, b) => a * b;
	     *      var double = R.partial(multiply, [2]);
	     *      double(2); //=> 4
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var sayHello = R.partial(greet, ['Hello']);
	     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
	     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partial = _createPartialApplicator(_concat);

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided to `g` followed by the arguments provided initially.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partial
	     * @example
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
	     *
	     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partialRight = _createPartialApplicator(flip(_concat));

	    /**
	     * Takes a predicate and a list and returns the pair of lists of elements which
	     * do and do not satisfy the predicate, respectively.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
	     * @param {Function} pred A predicate to determine which array the element belongs to.
	     * @param {Array} list The array to partition.
	     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
	     *         and second an array of elements that did not satisfy.
	     * @see R.filter, R.reject
	     * @example
	     *
	     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	     */
	    var partition = _curry2(function partition(pred, list) {
	        return _reduce(function (acc, elt) {
	            var xs = acc[pred(elt) ? 0 : 1];
	            xs[xs.length] = elt;
	            return acc;
	        }, [
	            [],
	            []
	        ], list);
	    });

	    /**
	     * Determines whether a nested path on an object has a specific value, in
	     * `R.equals` terms. Most likely used to filter a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Relation
	     * @sig [String] -> * -> {String: *} -> Boolean
	     * @param {Array} path The path of the nested property to use
	     * @param {*} val The value to compare the nested property with
	     * @param {Object} obj The object to check the nested property in
	     * @return {Boolean} `true` if the value equals the nested object property,
	     *         `false` otherwise.
	     * @example
	     *
	     *      var user1 = { address: { zipCode: 90210 } };
	     *      var user2 = { address: { zipCode: 55555 } };
	     *      var user3 = { name: 'Bob' };
	     *      var users = [ user1, user2, user3 ];
	     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	     *      R.filter(isFamous, users); //=> [ user1 ]
	     */
	    var pathEq = _curry3(function pathEq(_path, val, obj) {
	        return equals(path(_path, obj), val);
	    });

	    /**
	     * Returns a new list by plucking the same named property off all objects in
	     * the list supplied.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig k -> [{k: v}] -> [v]
	     * @param {Number|String} key The key name to pluck off of each object.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of values for the given key.
	     * @see R.props
	     * @example
	     *
	     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	     */
	    var pluck = _curry2(function pluck(p, list) {
	        return map(prop(p), list);
	    });

	    /**
	     * Reasonable analog to SQL `select` statement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @category Relation
	     * @sig [k] -> [{k: v}] -> [{k: v}]
	     * @param {Array} props The property names to project
	     * @param {Array} objs The objects to query
	     * @return {Array} An array of objects with just the `props` properties.
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	     *      var kids = [abby, fred];
	     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	     */
	    // passing `identity` gives correct arity
	    var project = useWith(_map, [
	        pickAll,
	        identity
	    ]);

	    /**
	     * Returns `true` if the specified object property is equal, in `R.equals`
	     * terms, to the given value; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig String -> a -> Object -> Boolean
	     * @param {String} name
	     * @param {*} val
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.equals, R.propSatisfies
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	     *      var kids = [abby, fred, rusty, alois];
	     *      var hasBrownHair = R.propEq('hair', 'brown');
	     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	     */
	    var propEq = _curry3(function propEq(name, val, obj) {
	        return propSatisfies(equals(val), name, obj);
	    });

	    /**
	     * Returns `true` if the specified object property is of the given type;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Type
	     * @sig Type -> String -> Object -> Boolean
	     * @param {Function} type
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.is, R.propSatisfies
	     * @example
	     *
	     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	     *      R.propIs(Number, 'x', {});            //=> false
	     */
	    var propIs = _curry3(function propIs(type, name, obj) {
	        return propSatisfies(is(type), name, obj);
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It may use
	     * `R.reduced` to shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     *
	     * Dispatches to the `reduce` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduced, R.addIndex
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = (a, b) => a + b;
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    /**
	     * The complement of `filter`.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.filter, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isOdd = (n) => n % 2 === 1;
	     *
	     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    var reject = _curry2(function reject(pred, filterable) {
	        return filter(_complement(pred), filterable);
	    });

	    /**
	     * Returns a fixed list of size `n` containing a specified identical value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig a -> n -> [a]
	     * @param {*} value The value to repeat.
	     * @param {Number} n The desired size of the output list.
	     * @return {Array} A new array containing `n` `value`s.
	     * @example
	     *
	     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	     *
	     *      var obj = {};
	     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	     */
	    var repeat = _curry2(function repeat(value, n) {
	        return times(always(value), n);
	    });

	    /**
	     * Adds together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The sum of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.sum([2,4,6,8,100,1]); //=> 121
	     */
	    var sum = reduce(add, 0);

	    /**
	     * Returns a new list containing the last `n` elements of the given list.
	     * If `n > list.length`, returns a list of `list.length` elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements to return.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.dropLast
	     * @example
	     *
	     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(3, 'ramda');               //=> 'mda'
	     */
	    var takeLast = _curry2(function takeLast(n, xs) {
	        return drop(n >= 0 ? xs.length - n : 0, xs);
	    });

	    /**
	     * Initializes a transducer using supplied iterator function. Returns a single
	     * item by iterating through the list, successively calling the transformed
	     * iterator function and passing it an accumulator value and the current value
	     * from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It will be
	     * wrapped as a transformer to initialize the transducer. A transformer can be
	     * passed directly in place of an iterator function. In both cases, iteration
	     * may be stopped early with the `R.reduced` function.
	     *
	     * A transducer is a function that accepts a transformer and returns a
	     * transformer and can be composed directly.
	     *
	     * A transformer is an an object that provides a 2-arity reducing iterator
	     * function, step, 0-arity initial value function, init, and 1-arity result
	     * extraction function, result. The step function is used as the iterator
	     * function in reduce. The result function is used to convert the final
	     * accumulator into the return type and in most cases is R.identity. The init
	     * function can be used to provide an initial accumulator, but is ignored by
	     * transduce.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array. Wrapped as transformer, if necessary, and used to
	     *        initialize the transducer
	     * @param {*} acc The initial accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduce, R.reduced, R.into
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	     */
	    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
	        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list. Duplication is determined according to the value returned by
	     * applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @see R.union
	     * @example
	     *
	     *      var l1 = [{a: 1}, {a: 2}];
	     *      var l2 = [{a: 1}, {a: 4}];
	     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	     */
	    var unionWith = _curry3(function unionWith(pred, list1, list2) {
	        return uniqWith(pred, _concat(list1, list2));
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec, false otherwise. An object satisfies the spec if, for each of the
	     * spec's own properties, accessing that property of the object gives the same
	     * value (in `R.equals` terms) as accessing that property of the spec.
	     *
	     * `whereEq` is a specialization of [`where`](#where).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @sig {String: *} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @see R.where
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.whereEq({a: 1, b: 2});
	     *
	     *      pred({a: 1});              //=> false
	     *      pred({a: 1, b: 2});        //=> true
	     *      pred({a: 1, b: 2, c: 3});  //=> true
	     *      pred({a: 1, b: 1});        //=> false
	     */
	    var whereEq = _curry2(function whereEq(spec, testObj) {
	        return where(map(equals, spec), testObj);
	    });

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    // Array.prototype.indexOf doesn't exist below IE9
	    // manually crawl the list to distinguish between +0 and -0
	    // NaN
	    // non-zero numbers can utilise Set
	    // all these types can utilise Set
	    // null can utilise Set
	    // anything else not covered above, defer to R.equals
	    var _indexOf = function _indexOf(list, a, idx) {
	        var inf, item;
	        // Array.prototype.indexOf doesn't exist below IE9
	        if (typeof list.indexOf === 'function') {
	            switch (typeof a) {
	            case 'number':
	                if (a === 0) {
	                    // manually crawl the list to distinguish between +0 and -0
	                    inf = 1 / a;
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (item === 0 && 1 / item === inf) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                } else if (a !== a) {
	                    // NaN
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (typeof item === 'number' && item !== item) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                }
	                // non-zero numbers can utilise Set
	                return list.indexOf(a, idx);
	            // all these types can utilise Set
	            case 'string':
	            case 'boolean':
	            case 'function':
	            case 'undefined':
	                return list.indexOf(a, idx);
	            case 'object':
	                if (a === null) {
	                    // null can utilise Set
	                    return list.indexOf(a, idx);
	                }
	            }
	        }
	        // anything else not covered above, defer to R.equals
	        while (idx < list.length) {
	            if (equals(list[idx], a)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if every one of the provided predicates is satisfied
	     * by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.anyPass
	     * @example
	     *
	     *      var isQueen = R.propEq('rank', 'Q');
	     *      var isSpade = R.propEq('suit', '♠︎');
	     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
	     *
	     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
	     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
	     */
	    var allPass = _curry1(function allPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (!preds[idx].apply(this, arguments)) {
	                    return false;
	                }
	                idx += 1;
	            }
	            return true;
	        });
	    });

	    /**
	     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
	     * `false`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category List
	     * @sig [a] -> Boolean
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if all elements are unique, else `false`.
	     * @example
	     *
	     *      R.allUniq(['1', 1]); //=> true
	     *      R.allUniq([1, 1]);   //=> false
	     *      R.allUniq([[42], [42]]); //=> false
	     */
	    var allUniq = _curry1(function allUniq(list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            if (_indexOf(list, list[idx], idx + 1) >= 0) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if at least one of the provided predicates is
	     * satisfied by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.allPass
	     * @example
	     *
	     *      var gte = R.anyPass([R.gt, R.equals]);
	     *
	     *      gte(3, 2); //=> true
	     *      gte(2, 2); //=> true
	     *      gte(2, 3); //=> false
	     */
	    var anyPass = _curry1(function anyPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (preds[idx].apply(this, arguments)) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        });
	    });

	    /**
	     * ap applies a list of functions to a list of values.
	     *
	     * Dispatches to the `ap` method of the second argument, if present. Also
	     * treats functions as applicatives.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig [f] -> [a] -> [f a]
	     * @param {Array} fns An array of functions
	     * @param {Array} vs An array of values
	     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
	     * @example
	     *
	     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	     */
	    // else
	    var ap = _curry2(function ap(applicative, fn) {
	        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
	            return applicative.apply(this, arguments)(fn.apply(this, arguments));
	        }) : // else
	        _reduce(function (acc, f) {
	            return _concat(acc, map(f, fn));
	        }, [], applicative);
	    });

	    /**
	     * Returns the result of calling its first argument with the remaining
	     * arguments. This is occasionally useful as a converging function for
	     * `R.converge`: the left branch can produce a function while the right branch
	     * produces a value to be passed to that function as an argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig (*... -> a),*... -> a
	     * @param {Function} fn The function to apply to the remaining arguments.
	     * @param {...*} args Any number of positional arguments.
	     * @return {*}
	     * @see R.apply
	     * @example
	     *
	     *      var indentN = R.pipe(R.times(R.always(' ')),
	     *                           R.join(''),
	     *                           R.replace(/^(?!$)/gm));
	     *
	     *      var format = R.converge(R.call, [
	     *                                  R.pipe(R.prop('indent'), indentN),
	     *                                  R.prop('value')
	     *                              ]);
	     *
	     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	     */
	    var call = curry(function call(fn) {
	        return fn.apply(this, _slice(arguments, 1));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results. `chain`
	     * is also known as `flatMap` in some libraries
	     *
	     * Dispatches to the `chain` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = n => [n, n];
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
	        if (typeof monad === 'function') {
	            return function () {
	                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
	            };
	        }
	        return _makeFlat(false)(map(fn, monad));
	    }));

	    /**
	     * Turns a list of Functors into a Functor of a list, applying a mapping
	     * function to the elements of the list along the way.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category List
	     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]
	     * @param {Function} fn The transformation function
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @see R.traverse
	     * @deprecated since v0.19.0
	     * @example
	     *
	     *      var add10 = R.map(R.add(10));
	     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
	     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
	     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
	     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
	     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));
	     *      R.commuteMap(fetch, Future.of, [
	     *        'http://ramdajs.com',
	     *        'http://github.com/ramda'
	     *      ]); //=> Future([IncomingMessage, IncomingMessage])
	     */
	    var commuteMap = _curry3(function commuteMap(fn, of, list) {
	        function consF(acc, x) {
	            return ap(map(prepend, fn(x)), acc);
	        }
	        return reduceRight(consF, of([]), list);
	    });

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type. The arity of the function
	     * returned is specified to allow using variadic constructor functions.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Function
	     * @sig Number -> (* -> {*}) -> (* -> {*})
	     * @param {Number} n The arity of the constructor function.
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Variadic constructor function
	     *      var Widget = () => {
	     *        this.children = Array.prototype.slice.call(arguments);
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
	     */
	    var constructN = _curry2(function constructN(n, Fn) {
	        if (n > 10) {
	            throw new Error('Constructor with greater than ten arguments');
	        }
	        if (n === 0) {
	            return function () {
	                return new Fn();
	            };
	        }
	        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	            switch (arguments.length) {
	            case 1:
	                return new Fn($0);
	            case 2:
	                return new Fn($0, $1);
	            case 3:
	                return new Fn($0, $1, $2);
	            case 4:
	                return new Fn($0, $1, $2, $3);
	            case 5:
	                return new Fn($0, $1, $2, $3, $4);
	            case 6:
	                return new Fn($0, $1, $2, $3, $4, $5);
	            case 7:
	                return new Fn($0, $1, $2, $3, $4, $5, $6);
	            case 8:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	            case 9:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	            case 10:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	            }
	        }));
	    });

	    /**
	     * Accepts a converging function and a list of branching functions and returns
	     * a new function. When invoked, this new function is applied to some
	     * arguments, each branching function is applied to those same arguments. The
	     * results of each branching function are passed as arguments to the converging
	     * function to produce the return value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.2
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} after A function. `after` will be invoked with the return values of
	     *        `fn1` and `fn2` as its arguments.
	     * @param {Array} functions A list of functions.
	     * @return {Function} A new function.
	     * @example
	     *
	     *      var add = (a, b) => a + b;
	     *      var multiply = (a, b) => a * b;
	     *      var subtract = (a, b) => a - b;
	     *
	     *      //≅ multiply( add(1, 2), subtract(1, 2) );
	     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
	     *
	     *      var add3 = (a, b, c) => a + b + c;
	     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
	     */
	    var converge = _curry2(function converge(after, fns) {
	        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
	            var args = arguments;
	            var context = this;
	            return after.apply(context, _map(function (fn) {
	                return fn.apply(context, args);
	            }, fns));
	        });
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. Equality is
	     * determined by applying the supplied predicate two consecutive elements. The
	     * first element in a series of equal element is the one being preserved.
	     *
	     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);
	     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
	     */
	    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	        var result = [];
	        var idx = 1;
	        var len = list.length;
	        if (len !== 0) {
	            result[0] = list[0];
	            while (idx < len) {
	                if (!pred(last(result), list[idx])) {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	        }
	        return result;
	    }));

	    /**
	     * Takes a function and two values in its domain and returns `true` if the
	     * values map to the same value in the codomain; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Relation
	     * @sig (a -> b) -> a -> a -> Boolean
	     * @param {Function} f
	     * @param {*} x
	     * @param {*} y
	     * @return {Boolean}
	     * @example
	     *
	     *      R.eqBy(Math.abs, 5, -5); //=> true
	     */
	    var eqBy = _curry3(function eqBy(f, x, y) {
	        return equals(f(x), f(y));
	    });

	    /**
	     * Reports whether two objects have the same value, in `R.equals` terms, for
	     * the specified property. Useful as a curried predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig k -> {k: v} -> {k: v} -> Boolean
	     * @param {String} prop The name of the property to compare
	     * @param {Object} obj1
	     * @param {Object} obj2
	     * @return {Boolean}
	     *
	     * @example
	     *
	     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	     *      R.eqProps('a', o1, o2); //=> false
	     *      R.eqProps('c', o1, o2); //=> true
	     */
	    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
	        return equals(obj1[prop], obj2[prop]);
	    });

	    /**
	     * Returns the position of the first occurrence of an item in an array, or -1
	     * if the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.lastIndexOf
	     * @example
	     *
	     *      R.indexOf(3, [1,2,3,4]); //=> 2
	     *      R.indexOf(10, [1,2,3,4]); //=> -1
	     */
	    var indexOf = _curry2(function indexOf(target, xs) {
	        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	    });

	    /**
	     * juxt applies a list of functions to a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Function
	     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
	     * @param {Array} fns An array of functions
	     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
	     * @example
	     *
	     *      var range = R.juxt([Math.min, Math.max]);
	     *      range(3, 4, 9, -3); //=> [-3, 9]
	     */
	    var juxt = _curry1(function juxt(fns) {
	        return function () {
	            return map(apply(__, arguments), fns);
	        };
	    });

	    /**
	     * Returns a lens for the given getter and setter functions. The getter "gets"
	     * the value of the focus; the setter "sets" the value of the focus. The setter
	     * should not mutate the data structure.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	     * @param {Function} getter
	     * @param {Function} setter
	     * @return {Lens}
	     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lens = _curry2(function lens(getter, setter) {
	        return function (f) {
	            return function (s) {
	                return map(function (v) {
	                    return setter(v, s);
	                }, f(getter(s)));
	            };
	        };
	    });

	    /**
	     * Returns a lens whose focus is the specified index.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Number -> Lens s a
	     * @param {Number} n
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	     */
	    var lensIndex = _curry1(function lensIndex(n) {
	        return lens(nth(n), update(n));
	    });

	    /**
	     * Returns a lens whose focus is the specified path.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig [String] -> Lens s a
	     * @param {Array} path The path to use.
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xyLens = R.lensPath(['x', 'y']);
	     *
	     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
	     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
	     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
	     */
	    var lensPath = _curry1(function lensPath(p) {
	        return lens(path(p), assocPath(p));
	    });

	    /**
	     * Returns a lens whose focus is the specified property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig String -> Lens s a
	     * @param {String} k
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lensProp = _curry1(function lensProp(k) {
	        return lens(prop(k), assoc(k));
	    });

	    /**
	     * "lifts" a function to be the specified arity, so that it may "map over" that
	     * many lists (or other objects that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply)).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig Number -> (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.lift
	     * @example
	     *
	     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     */
	    var liftN = _curry2(function liftN(arity, fn) {
	        var lifted = curryN(arity, fn);
	        return curryN(arity, function () {
	            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
	        });
	    });

	    /**
	     * Returns the mean of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.mean([2, 7, 9]); //=> 6
	     *      R.mean([]); //=> NaN
	     */
	    var mean = _curry1(function mean(list) {
	        return sum(list) / list.length;
	    });

	    /**
	     * Returns the median of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.median([2, 9, 7]); //=> 7
	     *      R.median([7, 2, 10, 9]); //=> 8
	     *      R.median([]); //=> NaN
	     */
	    var median = _curry1(function median(list) {
	        var len = list.length;
	        if (len === 0) {
	            return NaN;
	        }
	        var width = 2 - len % 2;
	        var idx = (len - width) / 2;
	        return mean(_slice(list).sort(function (a, b) {
	            return a < b ? -1 : a > b ? 1 : 0;
	        }).slice(idx, idx + width));
	    });

	    /**
	     * Create a new object with the own properties of the first object merged with
	     * the own properties of the second object. If a key exists in both objects,
	     * the value from the second object will be used.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> {k: v} -> {k: v}
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.mergeWith, R.mergeWithKey
	     * @example
	     *
	     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	     *      //=> { 'name': 'fred', 'age': 40 }
	     *
	     *      var resetToDefault = R.merge(R.__, {x: 0});
	     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	     */
	    var merge = mergeWith(function (l, r) {
	        return r;
	    });

	    /**
	     * Merges a list of objects together into one object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig [{k: v}] -> {k: v}
	     * @param {Array} list An array of objects
	     * @return {Object} A merged object.
	     * @see R.reduce
	     * @example
	     *
	     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	     */
	    var mergeAll = _curry1(function mergeAll(list) {
	        return reduce(merge, {}, list);
	    });

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /**
	     * Performs left-to-right composition of one or more Promise-returning
	     * functions. The leftmost function may have any arity; the remaining functions
	     * must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.composeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	     */
	    var pipeP = function pipeP() {
	        if (arguments.length === 0) {
	            throw new Error('pipeP requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	    };

	    /**
	     * Multiplies together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The product of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.product([2,4,6,8,100,1]); //=> 38400
	     */
	    var product = reduce(multiply, 1);

	    /**
	     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
	     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
	     * Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
	     * @param {Function} of
	     * @param {*} traversable
	     * @return {*}
	     * @see R.traverse
	     * @example
	     *
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
	     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
	     */
	    var sequence = _curry2(function sequence(of, traversable) {
	        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
	            return ap(map(prepend, x), acc);
	        }, of([]), traversable);
	    });

	    /**
	     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
	     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
	     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
	     * into an Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
	     * @param {Function} of
	     * @param {Function} f
	     * @param {*} traversable
	     * @return {*}
	     * @see R.sequence
	     * @example
	     *
	     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Just(3)]);   //=> Just([-1, -2, -3])
	     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      R.traverse(R.of, R.negate, Just([1, 2, 3])); //=> [Just(-1), Just(-2), Just(-3)]
	     *      R.traverse(R.of, R.negate, Nothing());       //=> [Nothing()]
	     */
	    var traverse = _curry3(function traverse(of, f, traversable) {
	        return sequence(of, map(f, traversable));
	    });

	    /**
	     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
	     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig Chain c => c (c a) -> c a
	     * @param {*} list
	     * @return {*}
	     * @see R.flatten, R.chain
	     * @example
	     *
	     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	     */
	    var unnest = chain(_identity);

	    var _contains = function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    };

	    var _stepCat = function () {
	        var _stepCatArray = {
	            '@@transducer/init': Array,
	            '@@transducer/step': function (xs, x) {
	                return _concat(xs, [x]);
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatString = {
	            '@@transducer/init': String,
	            '@@transducer/step': function (a, b) {
	                return a + b;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatObject = {
	            '@@transducer/init': Object,
	            '@@transducer/step': function (result, input) {
	                return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
	            },
	            '@@transducer/result': _identity
	        };
	        return function _stepCat(obj) {
	            if (_isTransformer(obj)) {
	                return obj;
	            }
	            if (isArrayLike(obj)) {
	                return _stepCatArray;
	            }
	            if (typeof obj === 'string') {
	                return _stepCatString;
	            }
	            if (typeof obj === 'object') {
	                return _stepCatObject;
	            }
	            throw new Error('Cannot create transformer for ' + obj);
	        };
	    }();

	    //  mapPairs :: (Object, [String]) -> [String]
	    var _toString = function _toString(x, seen) {
	        var recur = function recur(y) {
	            var xs = seen.concat([x]);
	            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	        };
	        //  mapPairs :: (Object, [String]) -> [String]
	        var mapPairs = function (obj, keys) {
	            return _map(function (k) {
	                return _quote(k) + ': ' + recur(obj[k]);
	            }, keys.slice().sort());
	        };
	        switch (Object.prototype.toString.call(x)) {
	        case '[object Arguments]':
	            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	        case '[object Array]':
	            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
	                return /^\d+$/.test(k);
	            }, keys(x)))).join(', ') + ']';
	        case '[object Boolean]':
	            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	        case '[object Date]':
	            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
	        case '[object Null]':
	            return 'null';
	        case '[object Number]':
	            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	        case '[object String]':
	            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	        case '[object Undefined]':
	            return 'undefined';
	        default:
	            if (typeof x.toString === 'function') {
	                var repr = x.toString();
	                if (repr !== '[object Object]') {
	                    return repr;
	                }
	            }
	            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
	        }
	    };

	    /**
	     * Turns a list of Functors into a Functor of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category List
	     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @see R.sequence
	     * @deprecated since v0.19.0
	     * @example
	     *
	     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
	     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
	     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
	     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commute = commuteMap(identity);

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the right-to-left Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.pipeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.composeK(
	     *        R.compose(Maybe.of, R.toUpper),
	     *        get('state'),
	     *        get('address'),
	     *        get('user'),
	     *        parseJson
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var composeK = function composeK() {
	        return compose.apply(this, prepend(identity, map(chain, arguments)));
	    };

	    /**
	     * Performs right-to-left composition of one or more Promise-returning
	     * functions. The rightmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
	     */
	    var composeP = function composeP() {
	        if (arguments.length === 0) {
	            throw new Error('composeP requires at least one argument');
	        }
	        return pipeP.apply(this, reverse(arguments));
	    };

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> {*}) -> (* -> {*})
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Constructor function
	     *      var Widget = config => {
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
	     */
	    var construct = _curry1(function construct(Fn) {
	        return constructN(Fn.length, Fn);
	    });

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
	     * least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     * @see R.any
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.differenceWith
	     * @example
	     *
	     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	     */
	    var difference = _curry2(function difference(first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. `R.equals`
	     * is used to determine equality.
	     *
	     * Dispatches to the `dropRepeats` method of the first argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	     */
	    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

	    /**
	     * Transforms the items of the list with the transducer and appends the
	     * transformed items to the accumulator using an appropriate iterator function
	     * based on the accumulator type.
	     *
	     * The accumulator can be an array, string, object or a transformer. Iterated
	     * items will be appended to arrays and concatenated to strings. Objects will
	     * be merged directly or 2-item arrays will be merged as key, value pairs.
	     *
	     * The accumulator can also be a transformer object that provides a 2-arity
	     * reducing iterator function, step, 0-arity initial value function, init, and
	     * 1-arity result extraction function result. The step function is used as the
	     * iterator function in reduce. The result function is used to convert the
	     * final accumulator into the return type and in most cases is R.identity. The
	     * init function is used to provide the initial accumulator.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig a -> (b -> b) -> [c] -> a
	     * @param {*} acc The initial accumulator value.
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.into([], transducer, numbers); //=> [2, 3]
	     *
	     *      var intoArray = R.into([]);
	     *      intoArray(transducer, numbers); //=> [2, 3]
	     */
	    var into = _curry3(function into(acc, xf, list) {
	        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
	    });

	    /**
	     * "lifts" a function of arity > 1 so that it may "map over" an Array or other
	     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.liftN
	     * @example
	     *
	     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
	     *
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     *
	     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
	     *
	     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	     */
	    var lift = _curry1(function lift(fn) {
	        return liftN(fn.length, fn);
	    });

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the left-to-right Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.composeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.pipeK(
	     *        parseJson,
	     *        get('user'),
	     *        get('address'),
	     *        get('state'),
	     *        R.compose(Maybe.of, R.toUpper)
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var pipeK = function pipeK() {
	        return composeK.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the string representation of the given value. `eval`'ing the output
	     * should result in a value equivalent to the input value. Many of the built-in
	     * `toString` methods do not satisfy this requirement.
	     *
	     * If the given value is an `[object Object]` with a `toString` method other
	     * than `Object.prototype.toString`, this method is invoked with no arguments
	     * to produce the return value. This means user-defined constructor functions
	     * can provide a suitable `toString` method. For example:
	     *
	     *     function Point(x, y) {
	     *       this.x = x;
	     *       this.y = y;
	     *     }
	     *
	     *     Point.prototype.toString = function() {
	     *       return 'new Point(' + this.x + ', ' + this.y + ')';
	     *     };
	     *
	     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category String
	     * @sig * -> String
	     * @param {*} val
	     * @return {String}
	     * @example
	     *
	     *      R.toString(42); //=> '42'
	     *      R.toString('abc'); //=> '"abc"'
	     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	     */
	    var toString = _curry1(function toString(val) {
	        return _toString(val, []);
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied function to
	     * each list element. Prefers the first item if the supplied function produces
	     * the same value on two items. `R.equals` is used for comparison.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> b) -> [a] -> [a]
	     * @param {Function} fn A function used to produce a value to use during comparisons.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	     */
	    /* globals Set */
	    // distinguishing between +0 and -0 is not supported by Set
	    /* falls through */
	    // these types can all utilise Set
	    // prevent scan for null by tracking as a boolean
	    /* falls through */
	    // scan through all previously applied items
	    var uniqBy = _curry2(/* globals Set */
	    typeof Set === 'undefined' ? function uniqBy(fn, list) {
	        var idx = 0;
	        var applied = [];
	        var result = [];
	        var appliedItem, item;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            if (!_contains(appliedItem, applied)) {
	                result.push(item);
	                applied.push(appliedItem);
	            }
	            idx += 1;
	        }
	        return result;
	    } : function uniqBySet(fn, list) {
	        var set = new Set();
	        var applied = [];
	        var prevSetSize = 0;
	        var result = [];
	        var nullExists = false;
	        var negZeroExists = false;
	        var idx = 0;
	        var appliedItem, item, newSetSize;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            switch (typeof appliedItem) {
	            case 'number':
	                // distinguishing between +0 and -0 is not supported by Set
	                if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {
	                    negZeroExists = true;
	                    result.push(item);
	                    break;
	                }
	            /* falls through */
	            case 'string':
	            case 'boolean':
	            case 'function':
	            case 'undefined':
	                // these types can all utilise Set
	                set.add(appliedItem);
	                newSetSize = set.size;
	                if (newSetSize > prevSetSize) {
	                    result.push(item);
	                    prevSetSize = newSetSize;
	                }
	                break;
	            case 'object':
	                if (appliedItem === null) {
	                    if (!nullExists) {
	                        // prevent scan for null by tracking as a boolean
	                        nullExists = true;
	                        result.push(null);
	                    }
	                    break;
	                }
	            /* falls through */
	            default:
	                // scan through all previously applied items
	                if (!_contains(appliedItem, applied)) {
	                    applied.push(appliedItem);
	                    result.push(item);
	                }
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a new list without values in the first argument.
	     * `R.equals` is used to determine equality.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The values to be removed from `list2`.
	     * @param {Array} list2 The array to remove values from.
	     * @return {Array} The new array without values in `list1`.
	     * @see R.transduce
	     * @example
	     *
	     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
	     */
	    var without = _curry2(function (xs, list) {
	        return reject(flip(_contains)(xs), list);
	    });

	    /**
	     * Takes a function `f` and returns a function `g` such that:
	     *
	     *   - applying `g` to zero or more arguments will give __true__ if applying
	     *     the same arguments to `f` gives a logical __false__ value; and
	     *
	     *   - applying `g` to zero or more arguments will give __false__ if applying
	     *     the same arguments to `f` gives a logical __true__ value.
	     *
	     * `R.complement` will work on all other functors as well.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> *) -> (*... -> Boolean)
	     * @param {Function} f
	     * @return {Function}
	     * @see R.not
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *      var isOdd = R.complement(isEven);
	     *      isOdd(21); //=> true
	     *      isOdd(42); //=> false
	     */
	    var complement = lift(not);

	    /**
	     * Turns a named method with a specified arity into a function that can be
	     * called directly supplied with arguments and a target object.
	     *
	     * The returned function is curried and accepts `arity + 1` parameters where
	     * the final parameter is the target object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	     * @param {Number} arity Number of arguments the returned function should take
	     *        before the target object.
	     * @param {String} method Name of the method to call.
	     * @return {Function} A new curried function.
	     * @example
	     *
	     *      var sliceFrom = R.invoker(1, 'slice');
	     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	     */
	    var invoker = _curry2(function invoker(arity, method) {
	        return curryN(arity + 1, function () {
	            var target = arguments[arity];
	            if (target != null && is(Function, target[method])) {
	                return target[method].apply(target, _slice(arguments, 0, arity));
	            }
	            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	        });
	    });

	    /**
	     * Returns a string made by inserting the `separator` between each element and
	     * concatenating all the elements into a single string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig String -> [a] -> String
	     * @param {Number|String} separator The string used to separate the elements.
	     * @param {Array} xs The elements to join into a string.
	     * @return {String} str The string made by concatenating `xs` with `separator`.
	     * @see R.split
	     * @example
	     *
	     *      var spacer = R.join(' ');
	     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	     */
	    var join = invoker(1, 'join');

	    /**
	     * Creates a new function that, when invoked, caches the result of calling `fn`
	     * for a given argument set and returns the result. Subsequent calls to the
	     * memoized `fn` with the same argument set will not result in an additional
	     * call to `fn`; instead, the cached result for that set of arguments will be
	     * returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (*... -> a) -> (*... -> a)
	     * @param {Function} fn The function to memoize.
	     * @return {Function} Memoized version of `fn`.
	     * @example
	     *
	     *      var count = 0;
	     *      var factorial = R.memoize(n => {
	     *        count += 1;
	     *        return R.product(R.range(1, n + 1));
	     *      });
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      count; //=> 1
	     */
	    var memoize = _curry1(function memoize(fn) {
	        var cache = {};
	        return _arity(fn.length, function () {
	            var key = toString(arguments);
	            if (!_has(key, cache)) {
	                cache[key] = fn.apply(this, arguments);
	            }
	            return cache[key];
	        });
	    });

	    /**
	     * Splits a string into an array of strings based on the given
	     * separator.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig (String | RegExp) -> String -> [String]
	     * @param {String|RegExp} sep The pattern.
	     * @param {String} str The string to separate into an array.
	     * @return {Array} The array of strings from `str` separated by `str`.
	     * @see R.join
	     * @example
	     *
	     *      var pathComponents = R.split('/');
	     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	     *
	     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	     */
	    var split = invoker(1, 'split');

	    /**
	     * Determines whether a given string matches a given regular expression.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category String
	     * @sig RegExp -> String -> Boolean
	     * @param {RegExp} pattern
	     * @param {String} str
	     * @return {Boolean}
	     * @see R.match
	     * @example
	     *
	     *      R.test(/^x/, 'xyz'); //=> true
	     *      R.test(/^y/, 'xyz'); //=> false
	     */
	    var test = _curry2(function test(pattern, str) {
	        if (!_isRegExp(pattern)) {
	            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
	        }
	        return _cloneRegExp(pattern).test(str);
	    });

	    /**
	     * The lower case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to lower case.
	     * @return {String} The lower case version of `str`.
	     * @see R.toUpper
	     * @example
	     *
	     *      R.toLower('XYZ'); //=> 'xyz'
	     */
	    var toLower = invoker(0, 'toLowerCase');

	    /**
	     * The upper case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to upper case.
	     * @return {String} The upper case version of `str`.
	     * @see R.toLower
	     * @example
	     *
	     *      R.toUpper('abc'); //=> 'ABC'
	     */
	    var toUpper = invoker(0, 'toUpperCase');

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list. `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	     *      R.uniq([1, '1']);     //=> [1, '1']
	     *      R.uniq([[42], [42]]); //=> [[42]]
	     */
	    var uniq = uniqBy(identity);

	    /**
	     * Returns the result of concatenating the given lists or strings.
	     *
	     * Dispatches to the `concat` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @sig String -> String -> String
	     * @param {Array|String} a
	     * @param {Array|String} b
	     * @return {Array|String}
	     *
	     * @example
	     *
	     *      R.concat([], []); //=> []
	     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	     */
	    var concat = flip(invoker(1, 'concat'));

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The list of elements found in both `list1` and `list2`.
	     * @see R.intersectionWith
	     * @example
	     *
	     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	     */
	    var intersection = _curry2(function intersection(list1, list2) {
	        return uniq(_filter(flip(_contains)(list1), list2));
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifferenceWith
	     * @example
	     *
	     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
	     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
	     */
	    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
	        return concat(difference(list1, list2), difference(list2, list1));
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both. Duplication is determined according to the value
	     * returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifference
	     * @example
	     *
	     *      var eqA = R.eqBy(R.prop('a'));
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
	     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
	     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
	     */
	    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
	        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @example
	     *
	     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	     */
	    var union = _curry2(compose(uniq, _concat));

	    var R = {
	        F: F,
	        T: T,
	        __: __,
	        add: add,
	        addIndex: addIndex,
	        adjust: adjust,
	        all: all,
	        allPass: allPass,
	        allUniq: allUniq,
	        always: always,
	        and: and,
	        any: any,
	        anyPass: anyPass,
	        ap: ap,
	        aperture: aperture,
	        append: append,
	        apply: apply,
	        assoc: assoc,
	        assocPath: assocPath,
	        binary: binary,
	        bind: bind,
	        both: both,
	        call: call,
	        chain: chain,
	        clone: clone,
	        commute: commute,
	        commuteMap: commuteMap,
	        comparator: comparator,
	        complement: complement,
	        compose: compose,
	        composeK: composeK,
	        composeP: composeP,
	        concat: concat,
	        cond: cond,
	        construct: construct,
	        constructN: constructN,
	        contains: contains,
	        converge: converge,
	        countBy: countBy,
	        curry: curry,
	        curryN: curryN,
	        dec: dec,
	        defaultTo: defaultTo,
	        difference: difference,
	        differenceWith: differenceWith,
	        dissoc: dissoc,
	        dissocPath: dissocPath,
	        divide: divide,
	        drop: drop,
	        dropLast: dropLast,
	        dropLastWhile: dropLastWhile,
	        dropRepeats: dropRepeats,
	        dropRepeatsWith: dropRepeatsWith,
	        dropWhile: dropWhile,
	        either: either,
	        empty: empty,
	        eqBy: eqBy,
	        eqProps: eqProps,
	        equals: equals,
	        evolve: evolve,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        findLast: findLast,
	        findLastIndex: findLastIndex,
	        flatten: flatten,
	        flip: flip,
	        forEach: forEach,
	        fromPairs: fromPairs,
	        groupBy: groupBy,
	        gt: gt,
	        gte: gte,
	        has: has,
	        hasIn: hasIn,
	        head: head,
	        identical: identical,
	        identity: identity,
	        ifElse: ifElse,
	        inc: inc,
	        indexBy: indexBy,
	        indexOf: indexOf,
	        init: init,
	        insert: insert,
	        insertAll: insertAll,
	        intersection: intersection,
	        intersectionWith: intersectionWith,
	        intersperse: intersperse,
	        into: into,
	        invert: invert,
	        invertObj: invertObj,
	        invoker: invoker,
	        is: is,
	        isArrayLike: isArrayLike,
	        isEmpty: isEmpty,
	        isNil: isNil,
	        join: join,
	        juxt: juxt,
	        keys: keys,
	        keysIn: keysIn,
	        last: last,
	        lastIndexOf: lastIndexOf,
	        length: length,
	        lens: lens,
	        lensIndex: lensIndex,
	        lensPath: lensPath,
	        lensProp: lensProp,
	        lift: lift,
	        liftN: liftN,
	        lt: lt,
	        lte: lte,
	        map: map,
	        mapAccum: mapAccum,
	        mapAccumRight: mapAccumRight,
	        mapObjIndexed: mapObjIndexed,
	        match: match,
	        mathMod: mathMod,
	        max: max,
	        maxBy: maxBy,
	        mean: mean,
	        median: median,
	        memoize: memoize,
	        merge: merge,
	        mergeAll: mergeAll,
	        mergeWith: mergeWith,
	        mergeWithKey: mergeWithKey,
	        min: min,
	        minBy: minBy,
	        modulo: modulo,
	        multiply: multiply,
	        nAry: nAry,
	        negate: negate,
	        none: none,
	        not: not,
	        nth: nth,
	        nthArg: nthArg,
	        objOf: objOf,
	        of: of,
	        omit: omit,
	        once: once,
	        or: or,
	        over: over,
	        pair: pair,
	        partial: partial,
	        partialRight: partialRight,
	        partition: partition,
	        path: path,
	        pathEq: pathEq,
	        pathOr: pathOr,
	        pathSatisfies: pathSatisfies,
	        pick: pick,
	        pickAll: pickAll,
	        pickBy: pickBy,
	        pipe: pipe,
	        pipeK: pipeK,
	        pipeP: pipeP,
	        pluck: pluck,
	        prepend: prepend,
	        product: product,
	        project: project,
	        prop: prop,
	        propEq: propEq,
	        propIs: propIs,
	        propOr: propOr,
	        propSatisfies: propSatisfies,
	        props: props,
	        range: range,
	        reduce: reduce,
	        reduceRight: reduceRight,
	        reduced: reduced,
	        reject: reject,
	        remove: remove,
	        repeat: repeat,
	        replace: replace,
	        reverse: reverse,
	        scan: scan,
	        sequence: sequence,
	        set: set,
	        slice: slice,
	        sort: sort,
	        sortBy: sortBy,
	        split: split,
	        splitAt: splitAt,
	        splitEvery: splitEvery,
	        splitWhen: splitWhen,
	        subtract: subtract,
	        sum: sum,
	        symmetricDifference: symmetricDifference,
	        symmetricDifferenceWith: symmetricDifferenceWith,
	        tail: tail,
	        take: take,
	        takeLast: takeLast,
	        takeLastWhile: takeLastWhile,
	        takeWhile: takeWhile,
	        tap: tap,
	        test: test,
	        times: times,
	        toLower: toLower,
	        toPairs: toPairs,
	        toPairsIn: toPairsIn,
	        toString: toString,
	        toUpper: toUpper,
	        transduce: transduce,
	        transpose: transpose,
	        traverse: traverse,
	        trim: trim,
	        type: type,
	        unapply: unapply,
	        unary: unary,
	        uncurryN: uncurryN,
	        unfold: unfold,
	        union: union,
	        unionWith: unionWith,
	        uniq: uniq,
	        uniqBy: uniqBy,
	        uniqWith: uniqWith,
	        unless: unless,
	        unnest: unnest,
	        update: update,
	        useWith: useWith,
	        values: values,
	        valuesIn: valuesIn,
	        view: view,
	        when: when,
	        where: where,
	        whereEq: whereEq,
	        without: without,
	        wrap: wrap,
	        xprod: xprod,
	        zip: zip,
	        zipObj: zipObj,
	        zipWith: zipWith
	    };
	  /* eslint-env amd */

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isImportDeclaration = exports.isCompiletimeStatement = exports.isCompiletimeDeclaration = exports.isSyntaxDeclarationStatement = exports.isExportSyntax = exports.isParenthesizedExpression = exports.isFunctionWithName = exports.isFunctionTerm = exports.isSyntaxrecDeclaration = exports.isSyntaxDeclaration = exports.isEOF = exports.isVariableDeclarator = exports.isVariableDeclaration = exports.isSyntaxTemplate = exports.isTemplateElement = exports.isSwitchDefault = exports.isSwitchCase = exports.isSuper = exports.isSpreadElement = exports.isScript = exports.isFunctionDeclaration = exports.isFunctionBody = exports.isFormalParameters = exports.isDirective = exports.isCatchClause = exports.isBlock = exports.isPragma = exports.isWithStatement = exports.isWhileStatement = exports.isVariableDeclarationStatement = exports.isTryFinallyStatement = exports.isTryCatchStatement = exports.isThrowStatement = exports.isSwitchStatementWithDefault = exports.isSwitchStatement = exports.isReturnStatement = exports.isLabeledStatement = exports.isIfStatement = exports.isForStatement = exports.isForOfStatement = exports.isForInStatement = exports.isExpressionStatement = exports.isEmptyStatement = exports.isDoWhileStatement = exports.isDebuggerStatement = exports.isCompoundAssignmentExpression = exports.isContinueStatement = exports.isBreakStatement = exports.isBlockStatement = exports.isYieldGeneratorExpression = exports.isYieldExpression = exports.isUpdateExpression = exports.isThisExpression = exports.isTemplateExpression = exports.isStaticMemberExpression = exports.isUnaryExpression = exports.isObjectExpression = exports.isNewTargetExpression = exports.isNewExpression = exports.isIdentifierExpression = exports.isFunctionExpression = exports.isConditionalExpression = exports.isComputedMemberExpression = exports.isComputedAssignmentExpression = exports.isCallExpression = exports.isBinaryExpression = exports.isAssignmentExpression = exports.isArrowExpression = exports.isArrayExpression = exports.isLiteralStringExpression = exports.isLiteralRegExpExpression = exports.isLiteralNumericExpression = exports.isLiteralNullExpression = exports.isLiteralInfinityExpression = exports.isLiteralBooleanExpression = exports.isStaticPropertyName = exports.isComputedPropertyName = exports.isShorthandProperty = exports.isDataProperty = exports.isSetter = exports.isGetter = exports.isMethod = exports.isExportSpecifier = exports.isExportDefault = exports.isExport = exports.isExportFrom = exports.isExportAllFrom = exports.isImportSpecifier = exports.isImportNamespace = exports.isImport = exports.isModule = exports.isClassElement = exports.isClassDeclaration = exports.isClassExpression = exports.isBindingPropertyProperty = exports.isBindingPropertyIdentifier = exports.isObjectBinding = exports.isArrayBinding = exports.isBindingIdentifier = exports.isBindingWithDefault = undefined;

	var _immutable = __webpack_require__(11);

	var _errors = __webpack_require__(13);

	var _utils = __webpack_require__(29);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramda = __webpack_require__(27);

	var R = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Term {
	  constructor(type_1189, props_1190) {
	    this.type = type_1189;
	    this.loc = null;
	    for (let prop of Object.keys(props_1190)) {
	      this[prop] = props_1190[prop];
	    }
	  }
	  extend(props_1191) {
	    let newProps_1192 = {};
	    for (let field of fieldsIn_1188(this)) {
	      if (props_1191.hasOwnProperty(field)) {
	        newProps_1192[field] = props_1191[field];
	      } else {
	        newProps_1192[field] = this[field];
	      }
	    }
	    return new Term(this.type, newProps_1192);
	  }
	  gen() {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? { includeImports: true } : arguments[0];

	    let includeImports = _ref.includeImports;

	    let next_1193 = {};
	    for (let field of fieldsIn_1188(this)) {
	      if (this[field] == null) {
	        next_1193[field] = null;
	      } else if (this[field] instanceof Term) {
	        next_1193[field] = this[field].gen(includeImports);
	      } else if (_immutable.List.isList(this[field])) {
	        let pred = includeImports ? R.complement(isCompiletimeStatement_1186) : R.both(R.complement(isImportDeclaration_1187), R.complement(isCompiletimeStatement_1186));
	        next_1193[field] = this[field].filter(pred).map(term_1194 => term_1194 instanceof Term ? term_1194.gen(includeImports) : term_1194);
	      } else {
	        next_1193[field] = this[field];
	      }
	    }
	    return new Term(this.type, next_1193);
	  }
	  visit(f_1195) {
	    let next_1196 = {};
	    for (let field of fieldsIn_1188(this)) {
	      if (this[field] == null) {
	        next_1196[field] = null;
	      } else if (_immutable.List.isList(this[field])) {
	        next_1196[field] = this[field].map(field_1197 => field_1197 != null ? f_1195(field_1197) : null);
	      } else {
	        next_1196[field] = f_1195(this[field]);
	      }
	    }
	    return this.extend(next_1196);
	  }
	  addScope(scope_1198, bindings_1199, phase_1200, options_1201) {
	    return this.visit(term_1202 => {
	      if (typeof term_1202.addScope === "function") {
	        return term_1202.addScope(scope_1198, bindings_1199, phase_1200, options_1201);
	      }
	      return term_1202;
	    });
	  }
	  removeScope(scope_1203, phase_1204) {
	    return this.visit(term_1205 => {
	      if (typeof term_1205.removeScope === "function") {
	        return term_1205.removeScope(scope_1203, phase_1204);
	      }
	      return term_1205;
	    });
	  }
	  lineNumber() {
	    for (let field of fieldsIn_1188(this)) {
	      if (typeof this[field] && this[field].lineNumber === "function") {
	        return this[field].lineNumber();
	      }
	    }
	  }
	  setLineNumber(line_1206) {
	    let next_1207 = {};
	    for (let field of fieldsIn_1188(this)) {
	      if (this[field] == null) {
	        next_1207[field] = null;
	      } else if (typeof this[field].setLineNumber === "function") {
	        next_1207[field] = this[field].setLineNumber(line_1206);
	      } else if (_immutable.List.isList(this[field])) {
	        next_1207[field] = this[field].map(f_1208 => f_1208.setLineNumber(line_1206));
	      } else {
	        next_1207[field] = this[field];
	      }
	    }
	    return new Term(this.type, next_1207);
	  }
	}
	exports.default = Term;
	const isBindingWithDefault_1088 = R.whereEq({ type: "BindingWithDefault" });
	;
	const isBindingIdentifier_1089 = R.whereEq({ type: "BindingIdentifier" });
	;
	const isArrayBinding_1090 = R.whereEq({ type: "ArrayBinding" });
	;
	const isObjectBinding_1091 = R.whereEq({ type: "ObjectBinding" });
	;
	const isBindingPropertyIdentifier_1092 = R.whereEq({ type: "BindingPropertyIdentifier" });
	;
	const isBindingPropertyProperty_1093 = R.whereEq({ type: "BindingPropertyIdentifier" });
	;
	const isClassExpression_1094 = R.whereEq({ type: "ClassExpression" });
	;
	const isClassDeclaration_1095 = R.whereEq({ type: "ClassDeclaration" });
	;
	const isClassElement_1096 = R.whereEq({ type: "ClassElement" });
	;
	const isModule_1097 = R.whereEq({ type: "Module" });
	;
	const isImport_1098 = R.whereEq({ type: "Import" });
	;
	const isImportNamespace_1099 = R.whereEq({ type: "ImportNamespace" });
	;
	const isImportSpecifier_1100 = R.whereEq({ type: "ImportSpecifier" });
	;
	const isExportAllFrom_1101 = R.whereEq({ type: "ExportAllFrom" });
	;
	const isExportFrom_1102 = R.whereEq({ type: "ExportFrom" });
	;
	const isExport_1103 = R.whereEq({ type: "Export" });
	;
	const isExportDefault_1104 = R.whereEq({ type: "ExportDefault" });
	;
	const isExportSpecifier_1105 = R.whereEq({ type: "ExportSpecifier" });
	;
	const isMethod_1106 = R.whereEq({ type: "Method" });
	;
	const isGetter_1107 = R.whereEq({ type: "Getter" });
	;
	const isSetter_1108 = R.whereEq({ type: "Setter" });
	;
	const isDataProperty_1109 = R.whereEq({ type: "DataProperty" });
	;
	const isShorthandProperty_1110 = R.whereEq({ type: "ShorthandProperty" });
	;
	const isComputedPropertyName_1111 = R.whereEq({ type: "ComputedPropertyName" });
	;
	const isStaticPropertyName_1112 = R.whereEq({ type: "StaticPropertyName" });
	;
	const isLiteralBooleanExpression_1113 = R.whereEq({ type: "LiteralBooleanExpression" });
	;
	const isLiteralInfinityExpression_1114 = R.whereEq({ type: "LiteralInfinityExpression" });
	;
	const isLiteralNullExpression_1115 = R.whereEq({ type: "LiteralNullExpression" });
	;
	const isLiteralNumericExpression_1116 = R.whereEq({ type: "LiteralNumericExpression" });
	;
	const isLiteralRegExpExpression_1117 = R.whereEq({ type: "LiteralRegExpExpression" });
	;
	const isLiteralStringExpression_1118 = R.whereEq({ type: "LiteralStringExpression" });
	;
	const isArrayExpression_1119 = R.whereEq({ type: "ArrayExpression" });
	;
	const isArrowExpression_1120 = R.whereEq({ type: "ArrowExpression" });
	;
	const isAssignmentExpression_1121 = R.whereEq({ type: "AssignmentExpression" });
	;
	const isBinaryExpression_1122 = R.whereEq({ type: "BinaryExpression" });
	;
	const isCallExpression_1123 = R.whereEq({ type: "CallExpression" });
	;
	const isComputedAssignmentExpression_1124 = R.whereEq({ type: "ComputedAssignmentExpression" });
	;
	const isComputedMemberExpression_1125 = R.whereEq({ type: "ComputedMemberExpression" });
	;
	const isConditionalExpression_1126 = R.whereEq({ type: "ConditionalExpression" });
	;
	const isFunctionExpression_1127 = R.whereEq({ type: "FunctionExpression" });
	;
	const isIdentifierExpression_1128 = R.whereEq({ type: "IdentifierExpression" });
	;
	const isNewExpression_1129 = R.whereEq({ type: "NewExpression" });
	;
	const isNewTargetExpression_1130 = R.whereEq({ type: "NewTargetExpression" });
	;
	const isObjectExpression_1131 = R.whereEq({ type: "ObjectExpression" });
	;
	const isUnaryExpression_1132 = R.whereEq({ type: "UnaryExpression" });
	;
	const isStaticMemberExpression_1133 = R.whereEq({ type: "StaticMemberExpression" });
	;
	const isTemplateExpression_1134 = R.whereEq({ type: "TemplateExpression" });
	;
	const isThisExpression_1135 = R.whereEq({ type: "ThisExpression" });
	;
	const isUpdateExpression_1136 = R.whereEq({ type: "UpdateExpression" });
	;
	const isYieldExpression_1137 = R.whereEq({ type: "YieldExpression" });
	;
	const isYieldGeneratorExpression_1138 = R.whereEq({ type: "YieldGeneratorExpression" });
	;
	const isBlockStatement_1139 = R.whereEq({ type: "BlockStatement" });
	;
	const isBreakStatement_1140 = R.whereEq({ type: "BreakStatement" });
	;
	const isContinueStatement_1141 = R.whereEq({ type: "ContinueStatement" });
	;
	const isCompoundAssignmentExpression_1142 = R.whereEq({ type: "CompoundAssignmentExpression" });
	;
	const isDebuggerStatement_1143 = R.whereEq({ type: "DebuggerStatement" });
	;
	const isDoWhileStatement_1144 = R.whereEq({ type: "DoWhileStatement" });
	;
	const isEmptyStatement_1145 = R.whereEq({ type: "EmptyStatement" });
	;
	const isExpressionStatement_1146 = R.whereEq({ type: "ExpressionStatement" });
	;
	const isForInStatement_1147 = R.whereEq({ type: "ForInStatement" });
	;
	const isForOfStatement_1148 = R.whereEq({ type: "ForOfStatement" });
	;
	const isForStatement_1149 = R.whereEq({ type: "ForStatement" });
	;
	const isIfStatement_1150 = R.whereEq({ type: "IfStatement" });
	;
	const isLabeledStatement_1151 = R.whereEq({ type: "LabeledStatement" });
	;
	const isReturnStatement_1152 = R.whereEq({ type: "ReturnStatement" });
	;
	const isSwitchStatement_1153 = R.whereEq({ type: "SwitchStatement" });
	;
	const isSwitchStatementWithDefault_1154 = R.whereEq({ type: "SwitchStatementWithDefault" });
	;
	const isThrowStatement_1155 = R.whereEq({ type: "ThrowStatement" });
	;
	const isTryCatchStatement_1156 = R.whereEq({ type: "TryCatchStatement" });
	;
	const isTryFinallyStatement_1157 = R.whereEq({ type: "TryFinallyStatement" });
	;
	const isVariableDeclarationStatement_1158 = R.whereEq({ type: "VariableDeclarationStatement" });
	;
	const isWhileStatement_1159 = R.whereEq({ type: "WhileStatement" });
	;
	const isWithStatement_1160 = R.whereEq({ type: "WithStatement" });
	;
	const isPragma_1161 = R.whereEq({ type: "Pragma" });
	;
	const isBlock_1162 = R.whereEq({ type: "Block" });
	;
	const isCatchClause_1163 = R.whereEq({ type: "CatchClause" });
	;
	const isDirective_1164 = R.whereEq({ type: "Directive" });
	;
	const isFormalParameters_1165 = R.whereEq({ type: "FormalParameters" });
	;
	const isFunctionBody_1166 = R.whereEq({ type: "FunctionBody" });
	;
	const isFunctionDeclaration_1167 = R.whereEq({ type: "FunctionDeclaration" });
	;
	const isScript_1168 = R.whereEq({ type: "Script" });
	;
	const isSpreadElement_1169 = R.whereEq({ type: "SpreadElement" });
	;
	const isSuper_1170 = R.whereEq({ type: "Super" });
	;
	const isSwitchCase_1171 = R.whereEq({ type: "SwitchCase" });
	;
	const isSwitchDefault_1172 = R.whereEq({ type: "SwitchDefault" });
	;
	const isTemplateElement_1173 = R.whereEq({ type: "TemplateElement" });
	;
	const isSyntaxTemplate_1174 = R.whereEq({ type: "SyntaxTemplate" });
	;
	const isVariableDeclaration_1175 = R.whereEq({ type: "VariableDeclaration" });
	;
	const isVariableDeclarator_1176 = R.whereEq({ type: "VariableDeclarator" });
	;
	const isEOF_1177 = R.whereEq({ type: "EOF" });
	;
	const isSyntaxDeclaration_1178 = R.both(isVariableDeclaration_1175, R.whereEq({ kind: "syntax" }));
	;
	const isSyntaxrecDeclaration_1179 = R.both(isVariableDeclaration_1175, R.whereEq({ kind: "syntaxrec" }));
	;
	const isFunctionTerm_1180 = R.either(isFunctionDeclaration_1167, isFunctionExpression_1127);
	;
	const isFunctionWithName_1181 = R.and(isFunctionTerm_1180, R.complement(R.where({ name: R.isNil })));
	;
	const isParenthesizedExpression_1182 = R.whereEq({ type: "ParenthesizedExpression" });
	;
	const isExportSyntax_1183 = R.both(isExport_1103, exp_1209 => R.or(isSyntaxDeclaration_1178(exp_1209.declaration), isSyntaxrecDeclaration_1179(exp_1209.declaration)));
	;
	const isSyntaxDeclarationStatement_1184 = R.both(isVariableDeclarationStatement_1158, decl_1210 => isCompiletimeDeclaration_1185(decl_1210.declaration));
	;
	const isCompiletimeDeclaration_1185 = R.either(isSyntaxDeclaration_1178, isSyntaxrecDeclaration_1179);
	;
	const isCompiletimeStatement_1186 = term_1211 => {
	  return term_1211 instanceof Term && isVariableDeclarationStatement_1158(term_1211) && isCompiletimeDeclaration_1185(term_1211.declaration);
	};
	;
	const isImportDeclaration_1187 = R.either(isImport_1098, isImportNamespace_1099);
	;
	const fieldsIn_1188 = R.cond([[isBindingWithDefault_1088, R.always(_immutable.List.of("binding", "init"))], [isBindingIdentifier_1089, R.always(_immutable.List.of("name"))], [isArrayBinding_1090, R.always(_immutable.List.of("elements", "restElement"))], [isObjectBinding_1091, R.always(_immutable.List.of("properties"))], [isBindingPropertyIdentifier_1092, R.always(_immutable.List.of("binding", "init"))], [isBindingPropertyProperty_1093, R.always(_immutable.List.of("name", "binding"))], [isClassExpression_1094, R.always(_immutable.List.of("name", "super", "elements"))], [isClassDeclaration_1095, R.always(_immutable.List.of("name", "super", "elements"))], [isClassElement_1096, R.always(_immutable.List.of("isStatic", "method"))], [isModule_1097, R.always(_immutable.List.of("directives", "items"))], [isImport_1098, R.always(_immutable.List.of("moduleSpecifier", "defaultBinding", "namedImports", "forSyntax"))], [isImportNamespace_1099, R.always(_immutable.List.of("moduleSpecifier", "defaultBinding", "namespaceBinding"))], [isImportSpecifier_1100, R.always(_immutable.List.of("name", "binding"))], [isExportAllFrom_1101, R.always(_immutable.List.of("moduleSpecifier"))], [isExportFrom_1102, R.always(_immutable.List.of("namedExports", "moduleSpecifier"))], [isExport_1103, R.always(_immutable.List.of("declaration"))], [isExportDefault_1104, R.always(_immutable.List.of("body"))], [isExportSpecifier_1105, R.always(_immutable.List.of("name", "exportedName"))], [isMethod_1106, R.always(_immutable.List.of("name", "body", "isGenerator", "params"))], [isGetter_1107, R.always(_immutable.List.of("name", "body"))], [isSetter_1108, R.always(_immutable.List.of("name", "body", "param"))], [isDataProperty_1109, R.always(_immutable.List.of("name", "expression"))], [isShorthandProperty_1110, R.always(_immutable.List.of("expression"))], [isStaticPropertyName_1112, R.always(_immutable.List.of("value"))], [isLiteralBooleanExpression_1113, R.always(_immutable.List.of("value"))], [isLiteralInfinityExpression_1114, R.always((0, _immutable.List)())], [isLiteralNullExpression_1115, R.always((0, _immutable.List)())], [isLiteralNumericExpression_1116, R.always(_immutable.List.of("value"))], [isLiteralRegExpExpression_1117, R.always(_immutable.List.of("pattern", "flags"))], [isLiteralStringExpression_1118, R.always(_immutable.List.of("value"))], [isArrayExpression_1119, R.always(_immutable.List.of("elements"))], [isArrowExpression_1120, R.always(_immutable.List.of("params", "body"))], [isAssignmentExpression_1121, R.always(_immutable.List.of("binding", "expression"))], [isBinaryExpression_1122, R.always(_immutable.List.of("operator", "left", "right"))], [isCallExpression_1123, R.always(_immutable.List.of("callee", "arguments"))], [isComputedAssignmentExpression_1124, R.always(_immutable.List.of("operator", "binding", "expression"))], [isComputedMemberExpression_1125, R.always(_immutable.List.of("object", "expression"))], [isConditionalExpression_1126, R.always(_immutable.List.of("test", "consequent", "alternate"))], [isFunctionExpression_1127, R.always(_immutable.List.of("name", "isGenerator", "params", "body"))], [isIdentifierExpression_1128, R.always(_immutable.List.of("name"))], [isNewExpression_1129, R.always(_immutable.List.of("callee", "arguments"))], [isNewTargetExpression_1130, R.always((0, _immutable.List)())], [isObjectExpression_1131, R.always(_immutable.List.of("properties"))], [isUnaryExpression_1132, R.always(_immutable.List.of("operator", "operand"))], [isStaticMemberExpression_1133, R.always(_immutable.List.of("object", "property"))], [isTemplateExpression_1134, R.always(_immutable.List.of("tag", "elements"))], [isThisExpression_1135, R.always((0, _immutable.List)())], [isUpdateExpression_1136, R.always(_immutable.List.of("isPrefix", "operator", "operand"))], [isYieldExpression_1137, R.always(_immutable.List.of("expression"))], [isYieldGeneratorExpression_1138, R.always(_immutable.List.of("expression"))], [isBlockStatement_1139, R.always(_immutable.List.of("block"))], [isBreakStatement_1140, R.always(_immutable.List.of("label"))], [isContinueStatement_1141, R.always(_immutable.List.of("label"))], [isCompoundAssignmentExpression_1142, R.always(_immutable.List.of("binding", "operator", "expression"))], [isDebuggerStatement_1143, R.always((0, _immutable.List)())], [isDoWhileStatement_1144, R.always(_immutable.List.of("test", "body"))], [isEmptyStatement_1145, R.always((0, _immutable.List)())], [isExpressionStatement_1146, R.always(_immutable.List.of("expression"))], [isForInStatement_1147, R.always(_immutable.List.of("left", "right", "body"))], [isForOfStatement_1148, R.always(_immutable.List.of("left", "right", "body"))], [isForStatement_1149, R.always(_immutable.List.of("init", "test", "update", "body"))], [isIfStatement_1150, R.always(_immutable.List.of("test", "consequent", "alternate"))], [isLabeledStatement_1151, R.always(_immutable.List.of("label", "body"))], [isReturnStatement_1152, R.always(_immutable.List.of("expression"))], [isSwitchStatement_1153, R.always(_immutable.List.of("discriminant", "cases"))], [isSwitchStatementWithDefault_1154, R.always(_immutable.List.of("discriminant", "preDefaultCases", "defaultCase", "postDefaultCases"))], [isThrowStatement_1155, R.always(_immutable.List.of("expression"))], [isTryCatchStatement_1156, R.always(_immutable.List.of("body", "catchClause"))], [isTryFinallyStatement_1157, R.always(_immutable.List.of("body", "catchClause", "finalizer"))], [isVariableDeclarationStatement_1158, R.always(_immutable.List.of("declaration"))], [isWithStatement_1160, R.always(_immutable.List.of("object", "body"))], [isWhileStatement_1159, R.always(_immutable.List.of("test", "body"))], [isPragma_1161, R.always(_immutable.List.of("kind", "items"))], [isBlock_1162, R.always(_immutable.List.of("statements"))], [isCatchClause_1163, R.always(_immutable.List.of("binding", "body"))], [isDirective_1164, R.always(_immutable.List.of("rawValue"))], [isFormalParameters_1165, R.always(_immutable.List.of("items", "rest"))], [isFunctionBody_1166, R.always(_immutable.List.of("directives", "statements"))], [isFunctionDeclaration_1167, R.always(_immutable.List.of("name", "isGenerator", "params", "body"))], [isScript_1168, R.always(_immutable.List.of("directives", "statements"))], [isSpreadElement_1169, R.always(_immutable.List.of("expression"))], [isSuper_1170, R.always((0, _immutable.List)())], [isSwitchCase_1171, R.always(_immutable.List.of("test", "consequent"))], [isSwitchDefault_1172, R.always(_immutable.List.of("consequent"))], [isTemplateElement_1173, R.always(_immutable.List.of("rawValue"))], [isSyntaxTemplate_1174, R.always(_immutable.List.of("template"))], [isVariableDeclaration_1175, R.always(_immutable.List.of("kind", "declarators"))], [isVariableDeclarator_1176, R.always(_immutable.List.of("binding", "init"))], [isParenthesizedExpression_1182, R.always(_immutable.List.of("inner"))], [R.T, type_1212 => (0, _errors.assert)(false, "Missing case in fields: " + type_1212.type)]]);
	exports.isBindingWithDefault = isBindingWithDefault_1088;
	exports.isBindingIdentifier = isBindingIdentifier_1089;
	exports.isArrayBinding = isArrayBinding_1090;
	exports.isObjectBinding = isObjectBinding_1091;
	exports.isBindingPropertyIdentifier = isBindingPropertyIdentifier_1092;
	exports.isBindingPropertyProperty = isBindingPropertyProperty_1093;
	exports.isClassExpression = isClassExpression_1094;
	exports.isClassDeclaration = isClassDeclaration_1095;
	exports.isClassElement = isClassElement_1096;
	exports.isModule = isModule_1097;
	exports.isImport = isImport_1098;
	exports.isImportNamespace = isImportNamespace_1099;
	exports.isImportSpecifier = isImportSpecifier_1100;
	exports.isExportAllFrom = isExportAllFrom_1101;
	exports.isExportFrom = isExportFrom_1102;
	exports.isExport = isExport_1103;
	exports.isExportDefault = isExportDefault_1104;
	exports.isExportSpecifier = isExportSpecifier_1105;
	exports.isMethod = isMethod_1106;
	exports.isGetter = isGetter_1107;
	exports.isSetter = isSetter_1108;
	exports.isDataProperty = isDataProperty_1109;
	exports.isShorthandProperty = isShorthandProperty_1110;
	exports.isComputedPropertyName = isComputedPropertyName_1111;
	exports.isStaticPropertyName = isStaticPropertyName_1112;
	exports.isLiteralBooleanExpression = isLiteralBooleanExpression_1113;
	exports.isLiteralInfinityExpression = isLiteralInfinityExpression_1114;
	exports.isLiteralNullExpression = isLiteralNullExpression_1115;
	exports.isLiteralNumericExpression = isLiteralNumericExpression_1116;
	exports.isLiteralRegExpExpression = isLiteralRegExpExpression_1117;
	exports.isLiteralStringExpression = isLiteralStringExpression_1118;
	exports.isArrayExpression = isArrayExpression_1119;
	exports.isArrowExpression = isArrowExpression_1120;
	exports.isAssignmentExpression = isAssignmentExpression_1121;
	exports.isBinaryExpression = isBinaryExpression_1122;
	exports.isCallExpression = isCallExpression_1123;
	exports.isComputedAssignmentExpression = isComputedAssignmentExpression_1124;
	exports.isComputedMemberExpression = isComputedMemberExpression_1125;
	exports.isConditionalExpression = isConditionalExpression_1126;
	exports.isFunctionExpression = isFunctionExpression_1127;
	exports.isIdentifierExpression = isIdentifierExpression_1128;
	exports.isNewExpression = isNewExpression_1129;
	exports.isNewTargetExpression = isNewTargetExpression_1130;
	exports.isObjectExpression = isObjectExpression_1131;
	exports.isUnaryExpression = isUnaryExpression_1132;
	exports.isStaticMemberExpression = isStaticMemberExpression_1133;
	exports.isTemplateExpression = isTemplateExpression_1134;
	exports.isThisExpression = isThisExpression_1135;
	exports.isUpdateExpression = isUpdateExpression_1136;
	exports.isYieldExpression = isYieldExpression_1137;
	exports.isYieldGeneratorExpression = isYieldGeneratorExpression_1138;
	exports.isBlockStatement = isBlockStatement_1139;
	exports.isBreakStatement = isBreakStatement_1140;
	exports.isContinueStatement = isContinueStatement_1141;
	exports.isCompoundAssignmentExpression = isCompoundAssignmentExpression_1142;
	exports.isDebuggerStatement = isDebuggerStatement_1143;
	exports.isDoWhileStatement = isDoWhileStatement_1144;
	exports.isEmptyStatement = isEmptyStatement_1145;
	exports.isExpressionStatement = isExpressionStatement_1146;
	exports.isForInStatement = isForInStatement_1147;
	exports.isForOfStatement = isForOfStatement_1148;
	exports.isForStatement = isForStatement_1149;
	exports.isIfStatement = isIfStatement_1150;
	exports.isLabeledStatement = isLabeledStatement_1151;
	exports.isReturnStatement = isReturnStatement_1152;
	exports.isSwitchStatement = isSwitchStatement_1153;
	exports.isSwitchStatementWithDefault = isSwitchStatementWithDefault_1154;
	exports.isThrowStatement = isThrowStatement_1155;
	exports.isTryCatchStatement = isTryCatchStatement_1156;
	exports.isTryFinallyStatement = isTryFinallyStatement_1157;
	exports.isVariableDeclarationStatement = isVariableDeclarationStatement_1158;
	exports.isWhileStatement = isWhileStatement_1159;
	exports.isWithStatement = isWithStatement_1160;
	exports.isPragma = isPragma_1161;
	exports.isBlock = isBlock_1162;
	exports.isCatchClause = isCatchClause_1163;
	exports.isDirective = isDirective_1164;
	exports.isFormalParameters = isFormalParameters_1165;
	exports.isFunctionBody = isFunctionBody_1166;
	exports.isFunctionDeclaration = isFunctionDeclaration_1167;
	exports.isScript = isScript_1168;
	exports.isSpreadElement = isSpreadElement_1169;
	exports.isSuper = isSuper_1170;
	exports.isSwitchCase = isSwitchCase_1171;
	exports.isSwitchDefault = isSwitchDefault_1172;
	exports.isTemplateElement = isTemplateElement_1173;
	exports.isSyntaxTemplate = isSyntaxTemplate_1174;
	exports.isVariableDeclaration = isVariableDeclaration_1175;
	exports.isVariableDeclarator = isVariableDeclarator_1176;
	exports.isEOF = isEOF_1177;
	exports.isSyntaxDeclaration = isSyntaxDeclaration_1178;
	exports.isSyntaxrecDeclaration = isSyntaxrecDeclaration_1179;
	exports.isFunctionTerm = isFunctionTerm_1180;
	exports.isFunctionWithName = isFunctionWithName_1181;
	exports.isParenthesizedExpression = isParenthesizedExpression_1182;
	exports.isExportSyntax = isExportSyntax_1183;
	exports.isSyntaxDeclarationStatement = isSyntaxDeclarationStatement_1184;
	exports.isCompiletimeDeclaration = isCompiletimeDeclaration_1185;
	exports.isCompiletimeStatement = isCompiletimeStatement_1186;
	exports.isImportDeclaration = isImportDeclaration_1187;
	//# sourceMappingURL=data:application/json;base64,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O1FBQ2tDLHlCLEdBQWxDLDhCO1FBQ2tDLHlCLEdBQWxDLDhCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQytCLHNCLEdBQS9CLDJCO1FBQzJCLGtCLEdBQTNCLHVCO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQ3VDLDhCLEdBQXZDLG1DO1FBQ21DLDBCLEdBQW5DLCtCO1FBQ2dDLHVCLEdBQWhDLDRCO1FBQzZCLG9CLEdBQTdCLHlCO1FBQytCLHNCLEdBQS9CLDJCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDOEIscUIsR0FBOUIsMEI7UUFDMkIsa0IsR0FBM0IsdUI7UUFDMEIsaUIsR0FBMUIsc0I7UUFDaUMsd0IsR0FBakMsNkI7UUFDNkIsb0IsR0FBN0IseUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDMkIsa0IsR0FBM0IsdUI7UUFDMEIsaUIsR0FBMUIsc0I7UUFDbUMsMEIsR0FBbkMsK0I7UUFDeUIsZ0IsR0FBekIscUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDdUMsOEIsR0FBdkMsbUM7UUFDNEIsbUIsR0FBNUIsd0I7UUFDMkIsa0IsR0FBM0IsdUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDOEIscUIsR0FBOUIsMEI7UUFDeUIsZ0IsR0FBekIscUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDdUIsYyxHQUF2QixtQjtRQUNzQixhLEdBQXRCLGtCO1FBQzJCLGtCLEdBQTNCLHVCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQ3FDLDRCLEdBQXJDLGlDO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQzRCLG1CLEdBQTVCLHdCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQ3VDLDhCLEdBQXZDLG1DO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDaUIsUSxHQUFqQixhO1FBQ2dCLE8sR0FBaEIsWTtRQUNzQixhLEdBQXRCLGtCO1FBQ29CLFcsR0FBcEIsZ0I7UUFDMkIsa0IsR0FBM0IsdUI7UUFDdUIsYyxHQUF2QixtQjtRQUM4QixxQixHQUE5QiwwQjtRQUNpQixRLEdBQWpCLGE7UUFDd0IsZSxHQUF4QixvQjtRQUNnQixPLEdBQWhCLFk7UUFDcUIsWSxHQUFyQixpQjtRQUN3QixlLEdBQXhCLG9CO1FBQzBCLGlCLEdBQTFCLHNCO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQzZCLG9CLEdBQTdCLHlCO1FBQ2MsSyxHQUFkLFU7UUFDNEIsbUIsR0FBNUIsd0I7UUFDK0Isc0IsR0FBL0IsMkI7UUFDdUIsYyxHQUF2QixtQjtRQUMyQixrQixHQUEzQix1QjtRQUNrQyx5QixHQUFsQyw4QjtRQUN1QixjLEdBQXZCLG1CO1FBQ3FDLDRCLEdBQXJDLGlDO1FBQ2lDLHdCLEdBQWpDLDZCO1FBQytCLHNCLEdBQS9CLDJCO1FBQzRCLG1CLEdBQTVCLHdCIiwiZmlsZSI6InRlcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQge2Fzc2VydCwgZXhwZWN0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7bWl4aW59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgU3ludGF4IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0ICAqIGFzIFIgZnJvbSBcInJhbWRhXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtIHtcbiAgY29uc3RydWN0b3IodHlwZV8xMTg5LCBwcm9wc18xMTkwKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZV8xMTg5O1xuICAgIHRoaXMubG9jID0gbnVsbDtcbiAgICBmb3IgKGxldCBwcm9wIG9mIE9iamVjdC5rZXlzKHByb3BzXzExOTApKSB7XG4gICAgICB0aGlzW3Byb3BdID0gcHJvcHNfMTE5MFtwcm9wXTtcbiAgICB9XG4gIH1cbiAgZXh0ZW5kKHByb3BzXzExOTEpIHtcbiAgICBsZXQgbmV3UHJvcHNfMTE5MiA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODgodGhpcykpIHtcbiAgICAgIGlmIChwcm9wc18xMTkxLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICBuZXdQcm9wc18xMTkyW2ZpZWxkXSA9IHByb3BzXzExOTFbZmllbGRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3UHJvcHNfMTE5MltmaWVsZF0gPSB0aGlzW2ZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKHRoaXMudHlwZSwgbmV3UHJvcHNfMTE5Mik7XG4gIH1cbiAgZ2VuKHtpbmNsdWRlSW1wb3J0c30gPSB7aW5jbHVkZUltcG9ydHM6IHRydWV9KSB7XG4gICAgbGV0IG5leHRfMTE5MyA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODgodGhpcykpIHtcbiAgICAgIGlmICh0aGlzW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICAgIG5leHRfMTE5M1tmaWVsZF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzW2ZpZWxkXSBpbnN0YW5jZW9mIFRlcm0pIHtcbiAgICAgICAgbmV4dF8xMTkzW2ZpZWxkXSA9IHRoaXNbZmllbGRdLmdlbihpbmNsdWRlSW1wb3J0cyk7XG4gICAgICB9IGVsc2UgaWYgKExpc3QuaXNMaXN0KHRoaXNbZmllbGRdKSkge1xuICAgICAgICBsZXQgcHJlZCA9IGluY2x1ZGVJbXBvcnRzID8gUi5jb21wbGVtZW50KGlzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE4NikgOiBSLmJvdGgoUi5jb21wbGVtZW50KGlzSW1wb3J0RGVjbGFyYXRpb25fMTE4NyksIFIuY29tcGxlbWVudChpc0NvbXBpbGV0aW1lU3RhdGVtZW50XzExODYpKTtcbiAgICAgICAgbmV4dF8xMTkzW2ZpZWxkXSA9IHRoaXNbZmllbGRdLmZpbHRlcihwcmVkKS5tYXAodGVybV8xMTk0ID0+IHRlcm1fMTE5NCBpbnN0YW5jZW9mIFRlcm0gPyB0ZXJtXzExOTQuZ2VuKGluY2x1ZGVJbXBvcnRzKSA6IHRlcm1fMTE5NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0XzExOTNbZmllbGRdID0gdGhpc1tmaWVsZF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybSh0aGlzLnR5cGUsIG5leHRfMTE5Myk7XG4gIH1cbiAgdmlzaXQoZl8xMTk1KSB7XG4gICAgbGV0IG5leHRfMTE5NiA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODgodGhpcykpIHtcbiAgICAgIGlmICh0aGlzW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICAgIG5leHRfMTE5NltmaWVsZF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChMaXN0LmlzTGlzdCh0aGlzW2ZpZWxkXSkpIHtcbiAgICAgICAgbmV4dF8xMTk2W2ZpZWxkXSA9IHRoaXNbZmllbGRdLm1hcChmaWVsZF8xMTk3ID0+IGZpZWxkXzExOTcgIT0gbnVsbCA/IGZfMTE5NShmaWVsZF8xMTk3KSA6IG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dF8xMTk2W2ZpZWxkXSA9IGZfMTE5NSh0aGlzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZChuZXh0XzExOTYpO1xuICB9XG4gIGFkZFNjb3BlKHNjb3BlXzExOTgsIGJpbmRpbmdzXzExOTksIHBoYXNlXzEyMDAsIG9wdGlvbnNfMTIwMSkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KHRlcm1fMTIwMiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRlcm1fMTIwMi5hZGRTY29wZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0ZXJtXzEyMDIuYWRkU2NvcGUoc2NvcGVfMTE5OCwgYmluZGluZ3NfMTE5OSwgcGhhc2VfMTIwMCwgb3B0aW9uc18xMjAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXJtXzEyMDI7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlU2NvcGUoc2NvcGVfMTIwMywgcGhhc2VfMTIwNCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KHRlcm1fMTIwNSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRlcm1fMTIwNS5yZW1vdmVTY29wZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0ZXJtXzEyMDUucmVtb3ZlU2NvcGUoc2NvcGVfMTIwMywgcGhhc2VfMTIwNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVybV8xMjA1O1xuICAgIH0pO1xuICB9XG4gIGxpbmVOdW1iZXIoKSB7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzSW5fMTE4OCh0aGlzKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXSAmJiB0aGlzW2ZpZWxkXS5saW5lTnVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZmllbGRdLmxpbmVOdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0TGluZU51bWJlcihsaW5lXzEyMDYpIHtcbiAgICBsZXQgbmV4dF8xMjA3ID0ge307XG4gICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzSW5fMTE4OCh0aGlzKSkge1xuICAgICAgaWYgKHRoaXNbZmllbGRdID09IG51bGwpIHtcbiAgICAgICAgbmV4dF8xMjA3W2ZpZWxkXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXS5zZXRMaW5lTnVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbmV4dF8xMjA3W2ZpZWxkXSA9IHRoaXNbZmllbGRdLnNldExpbmVOdW1iZXIobGluZV8xMjA2KTtcbiAgICAgIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodGhpc1tmaWVsZF0pKSB7XG4gICAgICAgIG5leHRfMTIwN1tmaWVsZF0gPSB0aGlzW2ZpZWxkXS5tYXAoZl8xMjA4ID0+IGZfMTIwOC5zZXRMaW5lTnVtYmVyKGxpbmVfMTIwNikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dF8xMjA3W2ZpZWxkXSA9IHRoaXNbZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0odGhpcy50eXBlLCBuZXh0XzEyMDcpO1xuICB9XG59XG5jb25zdCBpc0JpbmRpbmdXaXRoRGVmYXVsdF8xMDg4ID0gUi53aGVyZUVxKHt0eXBlOiBcIkJpbmRpbmdXaXRoRGVmYXVsdFwifSk7XG47XG5jb25zdCBpc0JpbmRpbmdJZGVudGlmaWVyXzEwODkgPSBSLndoZXJlRXEoe3R5cGU6IFwiQmluZGluZ0lkZW50aWZpZXJcIn0pO1xuO1xuY29uc3QgaXNBcnJheUJpbmRpbmdfMTA5MCA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJheUJpbmRpbmdcIn0pO1xuO1xuY29uc3QgaXNPYmplY3RCaW5kaW5nXzEwOTEgPSBSLndoZXJlRXEoe3R5cGU6IFwiT2JqZWN0QmluZGluZ1wifSk7XG47XG5jb25zdCBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJfMTA5MiA9IFIud2hlcmVFcSh7dHlwZTogXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCJ9KTtcbjtcbmNvbnN0IGlzQmluZGluZ1Byb3BlcnR5UHJvcGVydHlfMTA5MyA9IFIud2hlcmVFcSh7dHlwZTogXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCJ9KTtcbjtcbmNvbnN0IGlzQ2xhc3NFeHByZXNzaW9uXzEwOTQgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ2xhc3NFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQ2xhc3NEZWNsYXJhdGlvbl8xMDk1ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNsYXNzRGVjbGFyYXRpb25cIn0pO1xuO1xuY29uc3QgaXNDbGFzc0VsZW1lbnRfMTA5NiA9IFIud2hlcmVFcSh7dHlwZTogXCJDbGFzc0VsZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNNb2R1bGVfMTA5NyA9IFIud2hlcmVFcSh7dHlwZTogXCJNb2R1bGVcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnRfMTA5OCA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnRcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnROYW1lc3BhY2VfMTA5OSA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnROYW1lc3BhY2VcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnRTcGVjaWZpZXJfMTEwMCA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnRTcGVjaWZpZXJcIn0pO1xuO1xuY29uc3QgaXNFeHBvcnRBbGxGcm9tXzExMDEgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwb3J0QWxsRnJvbVwifSk7XG47XG5jb25zdCBpc0V4cG9ydEZyb21fMTEwMiA9IFIud2hlcmVFcSh7dHlwZTogXCJFeHBvcnRGcm9tXCJ9KTtcbjtcbmNvbnN0IGlzRXhwb3J0XzExMDMgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwb3J0XCJ9KTtcbjtcbmNvbnN0IGlzRXhwb3J0RGVmYXVsdF8xMTA0ID0gUi53aGVyZUVxKHt0eXBlOiBcIkV4cG9ydERlZmF1bHRcIn0pO1xuO1xuY29uc3QgaXNFeHBvcnRTcGVjaWZpZXJfMTEwNSA9IFIud2hlcmVFcSh7dHlwZTogXCJFeHBvcnRTcGVjaWZpZXJcIn0pO1xuO1xuY29uc3QgaXNNZXRob2RfMTEwNiA9IFIud2hlcmVFcSh7dHlwZTogXCJNZXRob2RcIn0pO1xuO1xuY29uc3QgaXNHZXR0ZXJfMTEwNyA9IFIud2hlcmVFcSh7dHlwZTogXCJHZXR0ZXJcIn0pO1xuO1xuY29uc3QgaXNTZXR0ZXJfMTEwOCA9IFIud2hlcmVFcSh7dHlwZTogXCJTZXR0ZXJcIn0pO1xuO1xuY29uc3QgaXNEYXRhUHJvcGVydHlfMTEwOSA9IFIud2hlcmVFcSh7dHlwZTogXCJEYXRhUHJvcGVydHlcIn0pO1xuO1xuY29uc3QgaXNTaG9ydGhhbmRQcm9wZXJ0eV8xMTEwID0gUi53aGVyZUVxKHt0eXBlOiBcIlNob3J0aGFuZFByb3BlcnR5XCJ9KTtcbjtcbmNvbnN0IGlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWVfMTExMSA9IFIud2hlcmVFcSh7dHlwZTogXCJDb21wdXRlZFByb3BlcnR5TmFtZVwifSk7XG47XG5jb25zdCBpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTEyID0gUi53aGVyZUVxKHt0eXBlOiBcIlN0YXRpY1Byb3BlcnR5TmFtZVwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxCb29sZWFuRXhwcmVzc2lvbl8xMTEzID0gUi53aGVyZUVxKHt0eXBlOiBcIkxpdGVyYWxCb29sZWFuRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxJbmZpbml0eUV4cHJlc3Npb25fMTExNCA9IFIud2hlcmVFcSh7dHlwZTogXCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbE51bGxFeHByZXNzaW9uXzExMTUgPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbE51bGxFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXzExMTYgPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25fMTExNyA9IFIud2hlcmVFcSh7dHlwZTogXCJMaXRlcmFsUmVnRXhwRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uXzExMTggPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBcnJheUV4cHJlc3Npb25fMTExOSA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJheUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBcnJvd0V4cHJlc3Npb25fMTEyMCA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJvd0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTIxID0gUi53aGVyZUVxKHt0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQmluYXJ5RXhwcmVzc2lvbl8xMTIyID0gUi53aGVyZUVxKHt0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDYWxsRXhwcmVzc2lvbl8xMTIzID0gUi53aGVyZUVxKHt0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTI0ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNvbXB1dGVkQXNzaWdubWVudEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb25fMTEyNSA9IFIud2hlcmVFcSh7dHlwZTogXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDb25kaXRpb25hbEV4cHJlc3Npb25fMTEyNiA9IFIud2hlcmVFcSh7dHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyNyA9IFIud2hlcmVFcSh7dHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNJZGVudGlmaWVyRXhwcmVzc2lvbl8xMTI4ID0gUi53aGVyZUVxKHt0eXBlOiBcIklkZW50aWZpZXJFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTmV3RXhwcmVzc2lvbl8xMTI5ID0gUi53aGVyZUVxKHt0eXBlOiBcIk5ld0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNOZXdUYXJnZXRFeHByZXNzaW9uXzExMzAgPSBSLndoZXJlRXEoe3R5cGU6IFwiTmV3VGFyZ2V0RXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc09iamVjdEV4cHJlc3Npb25fMTEzMSA9IFIud2hlcmVFcSh7dHlwZTogXCJPYmplY3RFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzVW5hcnlFeHByZXNzaW9uXzExMzIgPSBSLndoZXJlRXEoe3R5cGU6IFwiVW5hcnlFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTMzID0gUi53aGVyZUVxKHt0eXBlOiBcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNUZW1wbGF0ZUV4cHJlc3Npb25fMTEzNCA9IFIud2hlcmVFcSh7dHlwZTogXCJUZW1wbGF0ZUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNUaGlzRXhwcmVzc2lvbl8xMTM1ID0gUi53aGVyZUVxKHt0eXBlOiBcIlRoaXNFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzVXBkYXRlRXhwcmVzc2lvbl8xMTM2ID0gUi53aGVyZUVxKHt0eXBlOiBcIlVwZGF0ZUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNZaWVsZEV4cHJlc3Npb25fMTEzNyA9IFIud2hlcmVFcSh7dHlwZTogXCJZaWVsZEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25fMTEzOCA9IFIud2hlcmVFcSh7dHlwZTogXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNCbG9ja1N0YXRlbWVudF8xMTM5ID0gUi53aGVyZUVxKHt0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzQnJlYWtTdGF0ZW1lbnRfMTE0MCA9IFIud2hlcmVFcSh7dHlwZTogXCJCcmVha1N0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0NvbnRpbnVlU3RhdGVtZW50XzExNDEgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExNDIgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0RlYnVnZ2VyU3RhdGVtZW50XzExNDMgPSBSLndoZXJlRXEoe3R5cGU6IFwiRGVidWdnZXJTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNEb1doaWxlU3RhdGVtZW50XzExNDQgPSBSLndoZXJlRXEoe3R5cGU6IFwiRG9XaGlsZVN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0VtcHR5U3RhdGVtZW50XzExNDUgPSBSLndoZXJlRXEoe3R5cGU6IFwiRW1wdHlTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNFeHByZXNzaW9uU3RhdGVtZW50XzExNDYgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0ZvckluU3RhdGVtZW50XzExNDcgPSBSLndoZXJlRXEoe3R5cGU6IFwiRm9ySW5TdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNGb3JPZlN0YXRlbWVudF8xMTQ4ID0gUi53aGVyZUVxKHt0eXBlOiBcIkZvck9mU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzRm9yU3RhdGVtZW50XzExNDkgPSBSLndoZXJlRXEoe3R5cGU6IFwiRm9yU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzSWZTdGF0ZW1lbnRfMTE1MCA9IFIud2hlcmVFcSh7dHlwZTogXCJJZlN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0xhYmVsZWRTdGF0ZW1lbnRfMTE1MSA9IFIud2hlcmVFcSh7dHlwZTogXCJMYWJlbGVkU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzUmV0dXJuU3RhdGVtZW50XzExNTIgPSBSLndoZXJlRXEoe3R5cGU6IFwiUmV0dXJuU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoU3RhdGVtZW50XzExNTMgPSBSLndoZXJlRXEoe3R5cGU6IFwiU3dpdGNoU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHRfMTE1NCA9IFIud2hlcmVFcSh7dHlwZTogXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwifSk7XG47XG5jb25zdCBpc1Rocm93U3RhdGVtZW50XzExNTUgPSBSLndoZXJlRXEoe3R5cGU6IFwiVGhyb3dTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNUcnlDYXRjaFN0YXRlbWVudF8xMTU2ID0gUi53aGVyZUVxKHt0eXBlOiBcIlRyeUNhdGNoU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzVHJ5RmluYWxseVN0YXRlbWVudF8xMTU3ID0gUi53aGVyZUVxKHt0eXBlOiBcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XzExNTggPSBSLndoZXJlRXEoe3R5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc1doaWxlU3RhdGVtZW50XzExNTkgPSBSLndoZXJlRXEoe3R5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNXaXRoU3RhdGVtZW50XzExNjAgPSBSLndoZXJlRXEoe3R5cGU6IFwiV2l0aFN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc1ByYWdtYV8xMTYxID0gUi53aGVyZUVxKHt0eXBlOiBcIlByYWdtYVwifSk7XG47XG5jb25zdCBpc0Jsb2NrXzExNjIgPSBSLndoZXJlRXEoe3R5cGU6IFwiQmxvY2tcIn0pO1xuO1xuY29uc3QgaXNDYXRjaENsYXVzZV8xMTYzID0gUi53aGVyZUVxKHt0eXBlOiBcIkNhdGNoQ2xhdXNlXCJ9KTtcbjtcbmNvbnN0IGlzRGlyZWN0aXZlXzExNjQgPSBSLndoZXJlRXEoe3R5cGU6IFwiRGlyZWN0aXZlXCJ9KTtcbjtcbmNvbnN0IGlzRm9ybWFsUGFyYW1ldGVyc18xMTY1ID0gUi53aGVyZUVxKHt0eXBlOiBcIkZvcm1hbFBhcmFtZXRlcnNcIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkJvZHlfMTE2NiA9IFIud2hlcmVFcSh7dHlwZTogXCJGdW5jdGlvbkJvZHlcIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uXzExNjcgPSBSLndoZXJlRXEoe3R5cGU6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwifSk7XG47XG5jb25zdCBpc1NjcmlwdF8xMTY4ID0gUi53aGVyZUVxKHt0eXBlOiBcIlNjcmlwdFwifSk7XG47XG5jb25zdCBpc1NwcmVhZEVsZW1lbnRfMTE2OSA9IFIud2hlcmVFcSh7dHlwZTogXCJTcHJlYWRFbGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3VwZXJfMTE3MCA9IFIud2hlcmVFcSh7dHlwZTogXCJTdXBlclwifSk7XG47XG5jb25zdCBpc1N3aXRjaENhc2VfMTE3MSA9IFIud2hlcmVFcSh7dHlwZTogXCJTd2l0Y2hDYXNlXCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoRGVmYXVsdF8xMTcyID0gUi53aGVyZUVxKHt0eXBlOiBcIlN3aXRjaERlZmF1bHRcIn0pO1xuO1xuY29uc3QgaXNUZW1wbGF0ZUVsZW1lbnRfMTE3MyA9IFIud2hlcmVFcSh7dHlwZTogXCJUZW1wbGF0ZUVsZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNTeW50YXhUZW1wbGF0ZV8xMTc0ID0gUi53aGVyZUVxKHt0eXBlOiBcIlN5bnRheFRlbXBsYXRlXCJ9KTtcbjtcbmNvbnN0IGlzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTc1ID0gUi53aGVyZUVxKHt0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIn0pO1xuO1xuY29uc3QgaXNWYXJpYWJsZURlY2xhcmF0b3JfMTE3NiA9IFIud2hlcmVFcSh7dHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIn0pO1xuO1xuY29uc3QgaXNFT0ZfMTE3NyA9IFIud2hlcmVFcSh7dHlwZTogXCJFT0ZcIn0pO1xuO1xuY29uc3QgaXNTeW50YXhEZWNsYXJhdGlvbl8xMTc4ID0gUi5ib3RoKGlzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTc1LCBSLndoZXJlRXEoe2tpbmQ6IFwic3ludGF4XCJ9KSk7XG47XG5jb25zdCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uXzExNzkgPSBSLmJvdGgoaXNWYXJpYWJsZURlY2xhcmF0aW9uXzExNzUsIFIud2hlcmVFcSh7a2luZDogXCJzeW50YXhyZWNcIn0pKTtcbjtcbmNvbnN0IGlzRnVuY3Rpb25UZXJtXzExODAgPSBSLmVpdGhlcihpc0Z1bmN0aW9uRGVjbGFyYXRpb25fMTE2NywgaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyNyk7XG47XG5jb25zdCBpc0Z1bmN0aW9uV2l0aE5hbWVfMTE4MSA9IFIuYW5kKGlzRnVuY3Rpb25UZXJtXzExODAsIFIuY29tcGxlbWVudChSLndoZXJlKHtuYW1lOiBSLmlzTmlsfSkpKTtcbjtcbmNvbnN0IGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25fMTE4MiA9IFIud2hlcmVFcSh7dHlwZTogXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0V4cG9ydFN5bnRheF8xMTgzID0gUi5ib3RoKGlzRXhwb3J0XzExMDMsIGV4cF8xMjA5ID0+IFIub3IoaXNTeW50YXhEZWNsYXJhdGlvbl8xMTc4KGV4cF8xMjA5LmRlY2xhcmF0aW9uKSwgaXNTeW50YXhyZWNEZWNsYXJhdGlvbl8xMTc5KGV4cF8xMjA5LmRlY2xhcmF0aW9uKSkpO1xuO1xuY29uc3QgaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudF8xMTg0ID0gUi5ib3RoKGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTU4LCBkZWNsXzEyMTAgPT4gaXNDb21waWxldGltZURlY2xhcmF0aW9uXzExODUoZGVjbF8xMjEwLmRlY2xhcmF0aW9uKSk7XG47XG5jb25zdCBpc0NvbXBpbGV0aW1lRGVjbGFyYXRpb25fMTE4NSA9IFIuZWl0aGVyKGlzU3ludGF4RGVjbGFyYXRpb25fMTE3OCwgaXNTeW50YXhyZWNEZWNsYXJhdGlvbl8xMTc5KTtcbjtcbmNvbnN0IGlzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE4NiA9IHRlcm1fMTIxMSA9PiB7XG4gIHJldHVybiB0ZXJtXzEyMTEgaW5zdGFuY2VvZiBUZXJtICYmIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTU4KHRlcm1fMTIxMSkgJiYgaXNDb21waWxldGltZURlY2xhcmF0aW9uXzExODUodGVybV8xMjExLmRlY2xhcmF0aW9uKTtcbn07XG47XG5jb25zdCBpc0ltcG9ydERlY2xhcmF0aW9uXzExODcgPSBSLmVpdGhlcihpc0ltcG9ydF8xMDk4LCBpc0ltcG9ydE5hbWVzcGFjZV8xMDk5KTtcbjtcbmNvbnN0IGZpZWxkc0luXzExODggPSBSLmNvbmQoW1tpc0JpbmRpbmdXaXRoRGVmYXVsdF8xMDg4LCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzQmluZGluZ0lkZW50aWZpZXJfMTA4OSwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIikpXSwgW2lzQXJyYXlCaW5kaW5nXzEwOTAsIFIuYWx3YXlzKExpc3Qub2YoXCJlbGVtZW50c1wiLCBcInJlc3RFbGVtZW50XCIpKV0sIFtpc09iamVjdEJpbmRpbmdfMTA5MSwgUi5hbHdheXMoTGlzdC5vZihcInByb3BlcnRpZXNcIikpXSwgW2lzQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcl8xMDkyLCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzQmluZGluZ1Byb3BlcnR5UHJvcGVydHlfMTA5MywgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJiaW5kaW5nXCIpKV0sIFtpc0NsYXNzRXhwcmVzc2lvbl8xMDk0LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcInN1cGVyXCIsIFwiZWxlbWVudHNcIikpXSwgW2lzQ2xhc3NEZWNsYXJhdGlvbl8xMDk1LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcInN1cGVyXCIsIFwiZWxlbWVudHNcIikpXSwgW2lzQ2xhc3NFbGVtZW50XzEwOTYsIFIuYWx3YXlzKExpc3Qub2YoXCJpc1N0YXRpY1wiLCBcIm1ldGhvZFwiKSldLCBbaXNNb2R1bGVfMTA5NywgUi5hbHdheXMoTGlzdC5vZihcImRpcmVjdGl2ZXNcIiwgXCJpdGVtc1wiKSldLCBbaXNJbXBvcnRfMTA5OCwgUi5hbHdheXMoTGlzdC5vZihcIm1vZHVsZVNwZWNpZmllclwiLCBcImRlZmF1bHRCaW5kaW5nXCIsIFwibmFtZWRJbXBvcnRzXCIsIFwiZm9yU3ludGF4XCIpKV0sIFtpc0ltcG9ydE5hbWVzcGFjZV8xMDk5LCBSLmFsd2F5cyhMaXN0Lm9mKFwibW9kdWxlU3BlY2lmaWVyXCIsIFwiZGVmYXVsdEJpbmRpbmdcIiwgXCJuYW1lc3BhY2VCaW5kaW5nXCIpKV0sIFtpc0ltcG9ydFNwZWNpZmllcl8xMTAwLCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJpbmRpbmdcIikpXSwgW2lzRXhwb3J0QWxsRnJvbV8xMTAxLCBSLmFsd2F5cyhMaXN0Lm9mKFwibW9kdWxlU3BlY2lmaWVyXCIpKV0sIFtpc0V4cG9ydEZyb21fMTEwMiwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVkRXhwb3J0c1wiLCBcIm1vZHVsZVNwZWNpZmllclwiKSldLCBbaXNFeHBvcnRfMTEwMywgUi5hbHdheXMoTGlzdC5vZihcImRlY2xhcmF0aW9uXCIpKV0sIFtpc0V4cG9ydERlZmF1bHRfMTEwNCwgUi5hbHdheXMoTGlzdC5vZihcImJvZHlcIikpXSwgW2lzRXhwb3J0U3BlY2lmaWVyXzExMDUsIFIuYWx3YXlzKExpc3Qub2YoXCJuYW1lXCIsIFwiZXhwb3J0ZWROYW1lXCIpKV0sIFtpc01ldGhvZF8xMTA2LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJvZHlcIiwgXCJpc0dlbmVyYXRvclwiLCBcInBhcmFtc1wiKSldLCBbaXNHZXR0ZXJfMTEwNywgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJib2R5XCIpKV0sIFtpc1NldHRlcl8xMTA4LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJvZHlcIiwgXCJwYXJhbVwiKSldLCBbaXNEYXRhUHJvcGVydHlfMTEwOSwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc1Nob3J0aGFuZFByb3BlcnR5XzExMTAsIFIuYWx3YXlzKExpc3Qub2YoXCJleHByZXNzaW9uXCIpKV0sIFtpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTEyLCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uXzExMTMsIFIuYWx3YXlzKExpc3Qub2YoXCJ2YWx1ZVwiKSldLCBbaXNMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXzExMTQsIFIuYWx3YXlzKExpc3QoKSldLCBbaXNMaXRlcmFsTnVsbEV4cHJlc3Npb25fMTExNSwgUi5hbHdheXMoTGlzdCgpKV0sIFtpc0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbl8xMTE2LCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25fMTExNywgUi5hbHdheXMoTGlzdC5vZihcInBhdHRlcm5cIiwgXCJmbGFnc1wiKSldLCBbaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbl8xMTE4LCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzQXJyYXlFeHByZXNzaW9uXzExMTksIFIuYWx3YXlzKExpc3Qub2YoXCJlbGVtZW50c1wiKSldLCBbaXNBcnJvd0V4cHJlc3Npb25fMTEyMCwgUi5hbHdheXMoTGlzdC5vZihcInBhcmFtc1wiLCBcImJvZHlcIikpXSwgW2lzQXNzaWdubWVudEV4cHJlc3Npb25fMTEyMSwgUi5hbHdheXMoTGlzdC5vZihcImJpbmRpbmdcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc0JpbmFyeUV4cHJlc3Npb25fMTEyMiwgUi5hbHdheXMoTGlzdC5vZihcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIpKV0sIFtpc0NhbGxFeHByZXNzaW9uXzExMjMsIFIuYWx3YXlzKExpc3Qub2YoXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIikpXSwgW2lzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTI0LCBSLmFsd2F5cyhMaXN0Lm9mKFwib3BlcmF0b3JcIiwgXCJiaW5kaW5nXCIsIFwiZXhwcmVzc2lvblwiKSldLCBbaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb25fMTEyNSwgUi5hbHdheXMoTGlzdC5vZihcIm9iamVjdFwiLCBcImV4cHJlc3Npb25cIikpXSwgW2lzQ29uZGl0aW9uYWxFeHByZXNzaW9uXzExMjYsIFIuYWx3YXlzKExpc3Qub2YoXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiKSldLCBbaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyNywgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJpc0dlbmVyYXRvclwiLCBcInBhcmFtc1wiLCBcImJvZHlcIikpXSwgW2lzSWRlbnRpZmllckV4cHJlc3Npb25fMTEyOCwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIikpXSwgW2lzTmV3RXhwcmVzc2lvbl8xMTI5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIpKV0sIFtpc05ld1RhcmdldEV4cHJlc3Npb25fMTEzMCwgUi5hbHdheXMoTGlzdCgpKV0sIFtpc09iamVjdEV4cHJlc3Npb25fMTEzMSwgUi5hbHdheXMoTGlzdC5vZihcInByb3BlcnRpZXNcIikpXSwgW2lzVW5hcnlFeHByZXNzaW9uXzExMzIsIFIuYWx3YXlzKExpc3Qub2YoXCJvcGVyYXRvclwiLCBcIm9wZXJhbmRcIikpXSwgW2lzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTMzLCBSLmFsd2F5cyhMaXN0Lm9mKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIikpXSwgW2lzVGVtcGxhdGVFeHByZXNzaW9uXzExMzQsIFIuYWx3YXlzKExpc3Qub2YoXCJ0YWdcIiwgXCJlbGVtZW50c1wiKSldLCBbaXNUaGlzRXhwcmVzc2lvbl8xMTM1LCBSLmFsd2F5cyhMaXN0KCkpXSwgW2lzVXBkYXRlRXhwcmVzc2lvbl8xMTM2LCBSLmFsd2F5cyhMaXN0Lm9mKFwiaXNQcmVmaXhcIiwgXCJvcGVyYXRvclwiLCBcIm9wZXJhbmRcIikpXSwgW2lzWWllbGRFeHByZXNzaW9uXzExMzcsIFIuYWx3YXlzKExpc3Qub2YoXCJleHByZXNzaW9uXCIpKV0sIFtpc1lpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbl8xMTM4LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNCbG9ja1N0YXRlbWVudF8xMTM5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmxvY2tcIikpXSwgW2lzQnJlYWtTdGF0ZW1lbnRfMTE0MCwgUi5hbHdheXMoTGlzdC5vZihcImxhYmVsXCIpKV0sIFtpc0NvbnRpbnVlU3RhdGVtZW50XzExNDEsIFIuYWx3YXlzKExpc3Qub2YoXCJsYWJlbFwiKSldLCBbaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExNDIsIFIuYWx3YXlzKExpc3Qub2YoXCJiaW5kaW5nXCIsIFwib3BlcmF0b3JcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc0RlYnVnZ2VyU3RhdGVtZW50XzExNDMsIFIuYWx3YXlzKExpc3QoKSldLCBbaXNEb1doaWxlU3RhdGVtZW50XzExNDQsIFIuYWx3YXlzKExpc3Qub2YoXCJ0ZXN0XCIsIFwiYm9keVwiKSldLCBbaXNFbXB0eVN0YXRlbWVudF8xMTQ1LCBSLmFsd2F5cyhMaXN0KCkpXSwgW2lzRXhwcmVzc2lvblN0YXRlbWVudF8xMTQ2LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNGb3JJblN0YXRlbWVudF8xMTQ3LCBSLmFsd2F5cyhMaXN0Lm9mKFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiKSldLCBbaXNGb3JPZlN0YXRlbWVudF8xMTQ4LCBSLmFsd2F5cyhMaXN0Lm9mKFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiKSldLCBbaXNGb3JTdGF0ZW1lbnRfMTE0OSwgUi5hbHdheXMoTGlzdC5vZihcImluaXRcIiwgXCJ0ZXN0XCIsIFwidXBkYXRlXCIsIFwiYm9keVwiKSldLCBbaXNJZlN0YXRlbWVudF8xMTUwLCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIikpXSwgW2lzTGFiZWxlZFN0YXRlbWVudF8xMTUxLCBSLmFsd2F5cyhMaXN0Lm9mKFwibGFiZWxcIiwgXCJib2R5XCIpKV0sIFtpc1JldHVyblN0YXRlbWVudF8xMTUyLCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNTd2l0Y2hTdGF0ZW1lbnRfMTE1MywgUi5hbHdheXMoTGlzdC5vZihcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCIpKV0sIFtpc1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0XzExNTQsIFIuYWx3YXlzKExpc3Qub2YoXCJkaXNjcmltaW5hbnRcIiwgXCJwcmVEZWZhdWx0Q2FzZXNcIiwgXCJkZWZhdWx0Q2FzZVwiLCBcInBvc3REZWZhdWx0Q2FzZXNcIikpXSwgW2lzVGhyb3dTdGF0ZW1lbnRfMTE1NSwgUi5hbHdheXMoTGlzdC5vZihcImV4cHJlc3Npb25cIikpXSwgW2lzVHJ5Q2F0Y2hTdGF0ZW1lbnRfMTE1NiwgUi5hbHdheXMoTGlzdC5vZihcImJvZHlcIiwgXCJjYXRjaENsYXVzZVwiKSldLCBbaXNUcnlGaW5hbGx5U3RhdGVtZW50XzExNTcsIFIuYWx3YXlzKExpc3Qub2YoXCJib2R5XCIsIFwiY2F0Y2hDbGF1c2VcIiwgXCJmaW5hbGl6ZXJcIikpXSwgW2lzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTU4LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZGVjbGFyYXRpb25cIikpXSwgW2lzV2l0aFN0YXRlbWVudF8xMTYwLCBSLmFsd2F5cyhMaXN0Lm9mKFwib2JqZWN0XCIsIFwiYm9keVwiKSldLCBbaXNXaGlsZVN0YXRlbWVudF8xMTU5LCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVzdFwiLCBcImJvZHlcIikpXSwgW2lzUHJhZ21hXzExNjEsIFIuYWx3YXlzKExpc3Qub2YoXCJraW5kXCIsIFwiaXRlbXNcIikpXSwgW2lzQmxvY2tfMTE2MiwgUi5hbHdheXMoTGlzdC5vZihcInN0YXRlbWVudHNcIikpXSwgW2lzQ2F0Y2hDbGF1c2VfMTE2MywgUi5hbHdheXMoTGlzdC5vZihcImJpbmRpbmdcIiwgXCJib2R5XCIpKV0sIFtpc0RpcmVjdGl2ZV8xMTY0LCBSLmFsd2F5cyhMaXN0Lm9mKFwicmF3VmFsdWVcIikpXSwgW2lzRm9ybWFsUGFyYW1ldGVyc18xMTY1LCBSLmFsd2F5cyhMaXN0Lm9mKFwiaXRlbXNcIiwgXCJyZXN0XCIpKV0sIFtpc0Z1bmN0aW9uQm9keV8xMTY2LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZGlyZWN0aXZlc1wiLCBcInN0YXRlbWVudHNcIikpXSwgW2lzRnVuY3Rpb25EZWNsYXJhdGlvbl8xMTY3LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImlzR2VuZXJhdG9yXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiKSldLCBbaXNTY3JpcHRfMTE2OCwgUi5hbHdheXMoTGlzdC5vZihcImRpcmVjdGl2ZXNcIiwgXCJzdGF0ZW1lbnRzXCIpKV0sIFtpc1NwcmVhZEVsZW1lbnRfMTE2OSwgUi5hbHdheXMoTGlzdC5vZihcImV4cHJlc3Npb25cIikpXSwgW2lzU3VwZXJfMTE3MCwgUi5hbHdheXMoTGlzdCgpKV0sIFtpc1N3aXRjaENhc2VfMTE3MSwgUi5hbHdheXMoTGlzdC5vZihcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIpKV0sIFtpc1N3aXRjaERlZmF1bHRfMTE3MiwgUi5hbHdheXMoTGlzdC5vZihcImNvbnNlcXVlbnRcIikpXSwgW2lzVGVtcGxhdGVFbGVtZW50XzExNzMsIFIuYWx3YXlzKExpc3Qub2YoXCJyYXdWYWx1ZVwiKSldLCBbaXNTeW50YXhUZW1wbGF0ZV8xMTc0LCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVtcGxhdGVcIikpXSwgW2lzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTc1LCBSLmFsd2F5cyhMaXN0Lm9mKFwia2luZFwiLCBcImRlY2xhcmF0b3JzXCIpKV0sIFtpc1ZhcmlhYmxlRGVjbGFyYXRvcl8xMTc2LCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzUGFyZW50aGVzaXplZEV4cHJlc3Npb25fMTE4MiwgUi5hbHdheXMoTGlzdC5vZihcImlubmVyXCIpKV0sIFtSLlQsIHR5cGVfMTIxMiA9PiBhc3NlcnQoZmFsc2UsIFwiTWlzc2luZyBjYXNlIGluIGZpZWxkczogXCIgKyB0eXBlXzEyMTIudHlwZSldXSk7XG5leHBvcnQge2lzQmluZGluZ1dpdGhEZWZhdWx0XzEwODggYXMgaXNCaW5kaW5nV2l0aERlZmF1bHR9O1xuZXhwb3J0IHtpc0JpbmRpbmdJZGVudGlmaWVyXzEwODkgYXMgaXNCaW5kaW5nSWRlbnRpZmllcn07XG5leHBvcnQge2lzQXJyYXlCaW5kaW5nXzEwOTAgYXMgaXNBcnJheUJpbmRpbmd9O1xuZXhwb3J0IHtpc09iamVjdEJpbmRpbmdfMTA5MSBhcyBpc09iamVjdEJpbmRpbmd9O1xuZXhwb3J0IHtpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJfMTA5MiBhcyBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJ9O1xuZXhwb3J0IHtpc0JpbmRpbmdQcm9wZXJ0eVByb3BlcnR5XzEwOTMgYXMgaXNCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eX07XG5leHBvcnQge2lzQ2xhc3NFeHByZXNzaW9uXzEwOTQgYXMgaXNDbGFzc0V4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NsYXNzRGVjbGFyYXRpb25fMTA5NSBhcyBpc0NsYXNzRGVjbGFyYXRpb259O1xuZXhwb3J0IHtpc0NsYXNzRWxlbWVudF8xMDk2IGFzIGlzQ2xhc3NFbGVtZW50fTtcbmV4cG9ydCB7aXNNb2R1bGVfMTA5NyBhcyBpc01vZHVsZX07XG5leHBvcnQge2lzSW1wb3J0XzEwOTggYXMgaXNJbXBvcnR9O1xuZXhwb3J0IHtpc0ltcG9ydE5hbWVzcGFjZV8xMDk5IGFzIGlzSW1wb3J0TmFtZXNwYWNlfTtcbmV4cG9ydCB7aXNJbXBvcnRTcGVjaWZpZXJfMTEwMCBhcyBpc0ltcG9ydFNwZWNpZmllcn07XG5leHBvcnQge2lzRXhwb3J0QWxsRnJvbV8xMTAxIGFzIGlzRXhwb3J0QWxsRnJvbX07XG5leHBvcnQge2lzRXhwb3J0RnJvbV8xMTAyIGFzIGlzRXhwb3J0RnJvbX07XG5leHBvcnQge2lzRXhwb3J0XzExMDMgYXMgaXNFeHBvcnR9O1xuZXhwb3J0IHtpc0V4cG9ydERlZmF1bHRfMTEwNCBhcyBpc0V4cG9ydERlZmF1bHR9O1xuZXhwb3J0IHtpc0V4cG9ydFNwZWNpZmllcl8xMTA1IGFzIGlzRXhwb3J0U3BlY2lmaWVyfTtcbmV4cG9ydCB7aXNNZXRob2RfMTEwNiBhcyBpc01ldGhvZH07XG5leHBvcnQge2lzR2V0dGVyXzExMDcgYXMgaXNHZXR0ZXJ9O1xuZXhwb3J0IHtpc1NldHRlcl8xMTA4IGFzIGlzU2V0dGVyfTtcbmV4cG9ydCB7aXNEYXRhUHJvcGVydHlfMTEwOSBhcyBpc0RhdGFQcm9wZXJ0eX07XG5leHBvcnQge2lzU2hvcnRoYW5kUHJvcGVydHlfMTExMCBhcyBpc1Nob3J0aGFuZFByb3BlcnR5fTtcbmV4cG9ydCB7aXNDb21wdXRlZFByb3BlcnR5TmFtZV8xMTExIGFzIGlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWV9O1xuZXhwb3J0IHtpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTEyIGFzIGlzU3RhdGljUHJvcGVydHlOYW1lfTtcbmV4cG9ydCB7aXNMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb25fMTExMyBhcyBpc0xpdGVyYWxCb29sZWFuRXhwcmVzc2lvbn07XG5leHBvcnQge2lzTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbl8xMTE0IGFzIGlzTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbn07XG5leHBvcnQge2lzTGl0ZXJhbE51bGxFeHByZXNzaW9uXzExMTUgYXMgaXNMaXRlcmFsTnVsbEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbl8xMTE2IGFzIGlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbl8xMTE3IGFzIGlzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uXzExMTggYXMgaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbn07XG5leHBvcnQge2lzQXJyYXlFeHByZXNzaW9uXzExMTkgYXMgaXNBcnJheUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0Fycm93RXhwcmVzc2lvbl8xMTIwIGFzIGlzQXJyb3dFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTIxIGFzIGlzQXNzaWdubWVudEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0JpbmFyeUV4cHJlc3Npb25fMTEyMiBhcyBpc0JpbmFyeUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NhbGxFeHByZXNzaW9uXzExMjMgYXMgaXNDYWxsRXhwcmVzc2lvbn07XG5leHBvcnQge2lzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTI0IGFzIGlzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbn07XG5leHBvcnQge2lzQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uXzExMjUgYXMgaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NvbmRpdGlvbmFsRXhwcmVzc2lvbl8xMTI2IGFzIGlzQ29uZGl0aW9uYWxFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyNyBhcyBpc0Z1bmN0aW9uRXhwcmVzc2lvbn07XG5leHBvcnQge2lzSWRlbnRpZmllckV4cHJlc3Npb25fMTEyOCBhcyBpc0lkZW50aWZpZXJFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNOZXdFeHByZXNzaW9uXzExMjkgYXMgaXNOZXdFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNOZXdUYXJnZXRFeHByZXNzaW9uXzExMzAgYXMgaXNOZXdUYXJnZXRFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNPYmplY3RFeHByZXNzaW9uXzExMzEgYXMgaXNPYmplY3RFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNVbmFyeUV4cHJlc3Npb25fMTEzMiBhcyBpc1VuYXJ5RXhwcmVzc2lvbn07XG5leHBvcnQge2lzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTMzIGFzIGlzU3RhdGljTWVtYmVyRXhwcmVzc2lvbn07XG5leHBvcnQge2lzVGVtcGxhdGVFeHByZXNzaW9uXzExMzQgYXMgaXNUZW1wbGF0ZUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc1RoaXNFeHByZXNzaW9uXzExMzUgYXMgaXNUaGlzRXhwcmVzc2lvbn07XG5leHBvcnQge2lzVXBkYXRlRXhwcmVzc2lvbl8xMTM2IGFzIGlzVXBkYXRlRXhwcmVzc2lvbn07XG5leHBvcnQge2lzWWllbGRFeHByZXNzaW9uXzExMzcgYXMgaXNZaWVsZEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc1lpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbl8xMTM4IGFzIGlzWWllbGRHZW5lcmF0b3JFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNCbG9ja1N0YXRlbWVudF8xMTM5IGFzIGlzQmxvY2tTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0JyZWFrU3RhdGVtZW50XzExNDAgYXMgaXNCcmVha1N0YXRlbWVudH07XG5leHBvcnQge2lzQ29udGludWVTdGF0ZW1lbnRfMTE0MSBhcyBpc0NvbnRpbnVlU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExNDIgYXMgaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNEZWJ1Z2dlclN0YXRlbWVudF8xMTQzIGFzIGlzRGVidWdnZXJTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0RvV2hpbGVTdGF0ZW1lbnRfMTE0NCBhcyBpc0RvV2hpbGVTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0VtcHR5U3RhdGVtZW50XzExNDUgYXMgaXNFbXB0eVN0YXRlbWVudH07XG5leHBvcnQge2lzRXhwcmVzc2lvblN0YXRlbWVudF8xMTQ2IGFzIGlzRXhwcmVzc2lvblN0YXRlbWVudH07XG5leHBvcnQge2lzRm9ySW5TdGF0ZW1lbnRfMTE0NyBhcyBpc0ZvckluU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNGb3JPZlN0YXRlbWVudF8xMTQ4IGFzIGlzRm9yT2ZTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0ZvclN0YXRlbWVudF8xMTQ5IGFzIGlzRm9yU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNJZlN0YXRlbWVudF8xMTUwIGFzIGlzSWZTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0xhYmVsZWRTdGF0ZW1lbnRfMTE1MSBhcyBpc0xhYmVsZWRTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc1JldHVyblN0YXRlbWVudF8xMTUyIGFzIGlzUmV0dXJuU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNTd2l0Y2hTdGF0ZW1lbnRfMTE1MyBhcyBpc1N3aXRjaFN0YXRlbWVudH07XG5leHBvcnQge2lzU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHRfMTE1NCBhcyBpc1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0fTtcbmV4cG9ydCB7aXNUaHJvd1N0YXRlbWVudF8xMTU1IGFzIGlzVGhyb3dTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc1RyeUNhdGNoU3RhdGVtZW50XzExNTYgYXMgaXNUcnlDYXRjaFN0YXRlbWVudH07XG5leHBvcnQge2lzVHJ5RmluYWxseVN0YXRlbWVudF8xMTU3IGFzIGlzVHJ5RmluYWxseVN0YXRlbWVudH07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTU4IGFzIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudH07XG5leHBvcnQge2lzV2hpbGVTdGF0ZW1lbnRfMTE1OSBhcyBpc1doaWxlU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNXaXRoU3RhdGVtZW50XzExNjAgYXMgaXNXaXRoU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNQcmFnbWFfMTE2MSBhcyBpc1ByYWdtYX07XG5leHBvcnQge2lzQmxvY2tfMTE2MiBhcyBpc0Jsb2NrfTtcbmV4cG9ydCB7aXNDYXRjaENsYXVzZV8xMTYzIGFzIGlzQ2F0Y2hDbGF1c2V9O1xuZXhwb3J0IHtpc0RpcmVjdGl2ZV8xMTY0IGFzIGlzRGlyZWN0aXZlfTtcbmV4cG9ydCB7aXNGb3JtYWxQYXJhbWV0ZXJzXzExNjUgYXMgaXNGb3JtYWxQYXJhbWV0ZXJzfTtcbmV4cG9ydCB7aXNGdW5jdGlvbkJvZHlfMTE2NiBhcyBpc0Z1bmN0aW9uQm9keX07XG5leHBvcnQge2lzRnVuY3Rpb25EZWNsYXJhdGlvbl8xMTY3IGFzIGlzRnVuY3Rpb25EZWNsYXJhdGlvbn07XG5leHBvcnQge2lzU2NyaXB0XzExNjggYXMgaXNTY3JpcHR9O1xuZXhwb3J0IHtpc1NwcmVhZEVsZW1lbnRfMTE2OSBhcyBpc1NwcmVhZEVsZW1lbnR9O1xuZXhwb3J0IHtpc1N1cGVyXzExNzAgYXMgaXNTdXBlcn07XG5leHBvcnQge2lzU3dpdGNoQ2FzZV8xMTcxIGFzIGlzU3dpdGNoQ2FzZX07XG5leHBvcnQge2lzU3dpdGNoRGVmYXVsdF8xMTcyIGFzIGlzU3dpdGNoRGVmYXVsdH07XG5leHBvcnQge2lzVGVtcGxhdGVFbGVtZW50XzExNzMgYXMgaXNUZW1wbGF0ZUVsZW1lbnR9O1xuZXhwb3J0IHtpc1N5bnRheFRlbXBsYXRlXzExNzQgYXMgaXNTeW50YXhUZW1wbGF0ZX07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTc1IGFzIGlzVmFyaWFibGVEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdG9yXzExNzYgYXMgaXNWYXJpYWJsZURlY2xhcmF0b3J9O1xuZXhwb3J0IHtpc0VPRl8xMTc3IGFzIGlzRU9GfTtcbmV4cG9ydCB7aXNTeW50YXhEZWNsYXJhdGlvbl8xMTc4IGFzIGlzU3ludGF4RGVjbGFyYXRpb259O1xuZXhwb3J0IHtpc1N5bnRheHJlY0RlY2xhcmF0aW9uXzExNzkgYXMgaXNTeW50YXhyZWNEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzRnVuY3Rpb25UZXJtXzExODAgYXMgaXNGdW5jdGlvblRlcm19O1xuZXhwb3J0IHtpc0Z1bmN0aW9uV2l0aE5hbWVfMTE4MSBhcyBpc0Z1bmN0aW9uV2l0aE5hbWV9O1xuZXhwb3J0IHtpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uXzExODIgYXMgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbn07XG5leHBvcnQge2lzRXhwb3J0U3ludGF4XzExODMgYXMgaXNFeHBvcnRTeW50YXh9O1xuZXhwb3J0IHtpc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50XzExODQgYXMgaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudH07XG5leHBvcnQge2lzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbl8xMTg1IGFzIGlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE4NiBhcyBpc0NvbXBpbGV0aW1lU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNJbXBvcnREZWNsYXJhdGlvbl8xMTg3IGFzIGlzSW1wb3J0RGVjbGFyYXRpb259Il19

/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function mixin_1298(target_1299, source_1300) {
	  class F extends target_1299 {}
	  Object.getOwnPropertyNames(source_1300.prototype).forEach(name_1301 => {
	    if (name_1301 !== "constructor") {
	      let newProp = Object.getOwnPropertyDescriptor(source_1300.prototype, name_1301);
	      Object.defineProperty(F.prototype, name_1301, newProp);
	    }
	  });
	  return F;
	}
	exports.mixin = mixin_1298;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBUyxVQUFULENBQW9CLFdBQXBCLEVBQWlDLFdBQWpDLEVBQThDO0FBQzVDLFFBQU0sQ0FBTixTQUFnQixXQUFoQixDQUE0QjtBQUM1QixTQUFPLG1CQUFQLENBQTJCLFlBQVksU0FBdkMsRUFBa0QsT0FBbEQsQ0FBMEQsYUFBYTtBQUNyRSxRQUFJLGNBQWMsYUFBbEIsRUFBaUM7QUFDL0IsVUFBSSxVQUFVLE9BQU8sd0JBQVAsQ0FBZ0MsWUFBWSxTQUE1QyxFQUF1RCxTQUF2RCxDQUFkO0FBQ0EsYUFBTyxjQUFQLENBQXNCLEVBQUUsU0FBeEIsRUFBbUMsU0FBbkMsRUFBOEMsT0FBOUM7QUFDRDtBQUNGLEdBTEQ7QUFNQSxTQUFPLENBQVA7QUFDRDtRQUNxQixLLEdBQWQsVSIsImZpbGUiOiJ1dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1peGluXzEyOTgodGFyZ2V0XzEyOTksIHNvdXJjZV8xMzAwKSB7XG4gIGNsYXNzIEYgZXh0ZW5kcyB0YXJnZXRfMTI5OSB7fVxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VfMTMwMC5wcm90b3R5cGUpLmZvckVhY2gobmFtZV8xMzAxID0+IHtcbiAgICBpZiAobmFtZV8xMzAxICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGxldCBuZXdQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VfMTMwMC5wcm90b3R5cGUsIG5hbWVfMTMwMSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRi5wcm90b3R5cGUsIG5hbWVfMTMwMSwgbmV3UHJvcCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEY7XG59XG5leHBvcnQge21peGluXzEyOTggYXMgbWl4aW59Il19

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _transforms = __webpack_require__(31);

	class Env {
	  constructor() {
	    this.map = new Map();
	    this.map.set("function", _transforms.FunctionDeclTransform);
	    this.map.set("var", _transforms.VariableDeclTransform);
	    this.map.set("let", _transforms.LetDeclTransform);
	    this.map.set("const", _transforms.ConstDeclTransform);
	    this.map.set("syntaxQuote", _transforms.SyntaxQuoteTransform);
	    this.map.set("syntaxrec", _transforms.SyntaxrecDeclTransform);
	    this.map.set("syntax", _transforms.SyntaxDeclTransform);
	    this.map.set("return", _transforms.ReturnStatementTransform);
	    this.map.set("while", _transforms.WhileTransform);
	    this.map.set("if", _transforms.IfTransform);
	    this.map.set("for", _transforms.ForTransform);
	    this.map.set("switch", _transforms.SwitchTransform);
	    this.map.set("break", _transforms.BreakTransform);
	    this.map.set("continue", _transforms.ContinueTransform);
	    this.map.set("do", _transforms.DoTransform);
	    this.map.set("debugger", _transforms.DebuggerTransform);
	    this.map.set("with", _transforms.WithTransform);
	    this.map.set("try", _transforms.TryTransform);
	    this.map.set("throw", _transforms.ThrowTransform);
	    this.map.set("new", _transforms.NewTransform);
	  }
	  has(key_312) {
	    return this.map.has(key_312);
	  }
	  get(key_313) {
	    return this.map.get(key_313);
	  }
	  set(key_314, val_315) {
	    return this.map.set(key_314, val_315);
	  }
	}
	exports.default = Env;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2Vudi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFDZSxNQUFNLEdBQU4sQ0FBVTtBQUN2QixnQkFBYztBQUNaLFNBQUssR0FBTCxHQUFXLElBQUksR0FBSixFQUFYO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsYUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxXQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFFBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsUUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxRQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsVUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxJQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsTUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNEO0FBQ0QsTUFBSSxPQUFKLEVBQWE7QUFDWCxXQUFPLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiLENBQVA7QUFDRDtBQUNELE1BQUksT0FBSixFQUFhO0FBQ1gsV0FBTyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsT0FBYixDQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQUosRUFBYSxPQUFiLEVBQXNCO0FBQ3BCLFdBQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBUDtBQUNEO0FBaENzQjtrQkFBSixHIiwiZmlsZSI6ImVudi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtLCBWYXJpYWJsZURlY2xUcmFuc2Zvcm0sIExldERlY2xUcmFuc2Zvcm0sIENvbnN0RGVjbFRyYW5zZm9ybSwgU3ludGF4RGVjbFRyYW5zZm9ybSwgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSwgU3ludGF4UXVvdGVUcmFuc2Zvcm0sIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSwgSWZUcmFuc2Zvcm0sIEZvclRyYW5zZm9ybSwgU3dpdGNoVHJhbnNmb3JtLCBCcmVha1RyYW5zZm9ybSwgQ29udGludWVUcmFuc2Zvcm0sIERvVHJhbnNmb3JtLCBEZWJ1Z2dlclRyYW5zZm9ybSwgV2l0aFRyYW5zZm9ybSwgVHJ5VHJhbnNmb3JtLCBUaHJvd1RyYW5zZm9ybSwgTmV3VHJhbnNmb3JtLCBXaGlsZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW52IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwO1xuICAgIHRoaXMubWFwLnNldChcImZ1bmN0aW9uXCIsIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwidmFyXCIsIFZhcmlhYmxlRGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwibGV0XCIsIExldERlY2xUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImNvbnN0XCIsIENvbnN0RGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwic3ludGF4UXVvdGVcIiwgU3ludGF4UXVvdGVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcInN5bnRheHJlY1wiLCBTeW50YXhyZWNEZWNsVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJzeW50YXhcIiwgU3ludGF4RGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwicmV0dXJuXCIsIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwid2hpbGVcIiwgV2hpbGVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImlmXCIsIElmVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJmb3JcIiwgRm9yVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJzd2l0Y2hcIiwgU3dpdGNoVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJicmVha1wiLCBCcmVha1RyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwiY29udGludWVcIiwgQ29udGludWVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImRvXCIsIERvVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJkZWJ1Z2dlclwiLCBEZWJ1Z2dlclRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwid2l0aFwiLCBXaXRoVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJ0cnlcIiwgVHJ5VHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJ0aHJvd1wiLCBUaHJvd1RyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwibmV3XCIsIE5ld1RyYW5zZm9ybSk7XG4gIH1cbiAgaGFzKGtleV8zMTIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleV8zMTIpO1xuICB9XG4gIGdldChrZXlfMzEzKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXlfMzEzKTtcbiAgfVxuICBzZXQoa2V5XzMxNCwgdmFsXzMxNSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5zZXQoa2V5XzMxNCwgdmFsXzMxNSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class FunctionDeclTransform_1274 {}
	class VariableDeclTransform_1275 {}
	class NewTransform_1276 {}
	class ThrowTransform_1277 {}
	class LetDeclTransform_1278 {}
	class ConstDeclTransform_1279 {}
	class TryTransform_1280 {}
	class WhileTransform_1281 {}
	class IfTransform_1282 {}
	class ForTransform_1283 {}
	class SwitchTransform_1284 {}
	class BreakTransform_1285 {}
	class ContinueTransform_1286 {}
	class DoTransform_1287 {}
	class WithTransform_1288 {}
	class DebuggerTransform_1289 {}
	class SyntaxrecDeclTransform_1290 {}
	class SyntaxDeclTransform_1291 {}
	class SyntaxQuoteTransform_1292 {}
	class ReturnStatementTransform_1293 {}
	class VarBindingTransform_1294 {
	  constructor(id_1296) {
	    this.id = id_1296;
	  }
	}
	class CompiletimeTransform_1295 {
	  constructor(value_1297) {
	    this.value = value_1297;
	  }
	}
	exports.FunctionDeclTransform = FunctionDeclTransform_1274;
	exports.VariableDeclTransform = VariableDeclTransform_1275;
	exports.NewTransform = NewTransform_1276;
	exports.ThrowTransform = ThrowTransform_1277;
	exports.LetDeclTransform = LetDeclTransform_1278;
	exports.ConstDeclTransform = ConstDeclTransform_1279;
	exports.TryTransform = TryTransform_1280;
	exports.WhileTransform = WhileTransform_1281;
	exports.IfTransform = IfTransform_1282;
	exports.ForTransform = ForTransform_1283;
	exports.SwitchTransform = SwitchTransform_1284;
	exports.BreakTransform = BreakTransform_1285;
	exports.ContinueTransform = ContinueTransform_1286;
	exports.DoTransform = DoTransform_1287;
	exports.WithTransform = WithTransform_1288;
	exports.DebuggerTransform = DebuggerTransform_1289;
	exports.SyntaxrecDeclTransform = SyntaxrecDeclTransform_1290;
	exports.SyntaxDeclTransform = SyntaxDeclTransform_1291;
	exports.SyntaxQuoteTransform = SyntaxQuoteTransform_1292;
	exports.ReturnStatementTransform = ReturnStatementTransform_1293;
	exports.VarBindingTransform = VarBindingTransform_1294;
	exports.CompiletimeTransform = CompiletimeTransform_1295;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3RyYW5zZm9ybXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNLDBCQUFOLENBQWlDO0FBQ2pDLE1BQU0sMEJBQU4sQ0FBaUM7QUFDakMsTUFBTSxpQkFBTixDQUF3QjtBQUN4QixNQUFNLG1CQUFOLENBQTBCO0FBQzFCLE1BQU0scUJBQU4sQ0FBNEI7QUFDNUIsTUFBTSx1QkFBTixDQUE4QjtBQUM5QixNQUFNLGlCQUFOLENBQXdCO0FBQ3hCLE1BQU0sbUJBQU4sQ0FBMEI7QUFDMUIsTUFBTSxnQkFBTixDQUF1QjtBQUN2QixNQUFNLGlCQUFOLENBQXdCO0FBQ3hCLE1BQU0sb0JBQU4sQ0FBMkI7QUFDM0IsTUFBTSxtQkFBTixDQUEwQjtBQUMxQixNQUFNLHNCQUFOLENBQTZCO0FBQzdCLE1BQU0sZ0JBQU4sQ0FBdUI7QUFDdkIsTUFBTSxrQkFBTixDQUF5QjtBQUN6QixNQUFNLHNCQUFOLENBQTZCO0FBQzdCLE1BQU0sMkJBQU4sQ0FBa0M7QUFDbEMsTUFBTSx3QkFBTixDQUErQjtBQUMvQixNQUFNLHlCQUFOLENBQWdDO0FBQ2hDLE1BQU0sNkJBQU4sQ0FBb0M7QUFDcEMsTUFBTSx3QkFBTixDQUErQjtBQUM3QixjQUFZLE9BQVosRUFBcUI7QUFDbkIsU0FBSyxFQUFMLEdBQVUsT0FBVjtBQUNEO0FBSDRCO0FBSy9CLE1BQU0seUJBQU4sQ0FBZ0M7QUFDOUIsY0FBWSxVQUFaLEVBQXdCO0FBQ3RCLFNBQUssS0FBTCxHQUFhLFVBQWI7QUFDRDtBQUg2QjtRQUtNLHFCLEdBQTlCLDBCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQ3FCLFksR0FBckIsaUI7UUFDdUIsYyxHQUF2QixtQjtRQUN5QixnQixHQUF6QixxQjtRQUMyQixrQixHQUEzQix1QjtRQUNxQixZLEdBQXJCLGlCO1FBQ3VCLGMsR0FBdkIsbUI7UUFDb0IsVyxHQUFwQixnQjtRQUNxQixZLEdBQXJCLGlCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDdUIsYyxHQUF2QixtQjtRQUMwQixpQixHQUExQixzQjtRQUNvQixXLEdBQXBCLGdCO1FBQ3NCLGEsR0FBdEIsa0I7UUFDMEIsaUIsR0FBMUIsc0I7UUFDK0Isc0IsR0FBL0IsMkI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDNkIsb0IsR0FBN0IseUI7UUFDaUMsd0IsR0FBakMsNkI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDNkIsb0IsR0FBN0IseUIiLCJmaWxlIjoidHJhbnNmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybV8xMjc0IHt9XG5jbGFzcyBWYXJpYWJsZURlY2xUcmFuc2Zvcm1fMTI3NSB7fVxuY2xhc3MgTmV3VHJhbnNmb3JtXzEyNzYge31cbmNsYXNzIFRocm93VHJhbnNmb3JtXzEyNzcge31cbmNsYXNzIExldERlY2xUcmFuc2Zvcm1fMTI3OCB7fVxuY2xhc3MgQ29uc3REZWNsVHJhbnNmb3JtXzEyNzkge31cbmNsYXNzIFRyeVRyYW5zZm9ybV8xMjgwIHt9XG5jbGFzcyBXaGlsZVRyYW5zZm9ybV8xMjgxIHt9XG5jbGFzcyBJZlRyYW5zZm9ybV8xMjgyIHt9XG5jbGFzcyBGb3JUcmFuc2Zvcm1fMTI4MyB7fVxuY2xhc3MgU3dpdGNoVHJhbnNmb3JtXzEyODQge31cbmNsYXNzIEJyZWFrVHJhbnNmb3JtXzEyODUge31cbmNsYXNzIENvbnRpbnVlVHJhbnNmb3JtXzEyODYge31cbmNsYXNzIERvVHJhbnNmb3JtXzEyODcge31cbmNsYXNzIFdpdGhUcmFuc2Zvcm1fMTI4OCB7fVxuY2xhc3MgRGVidWdnZXJUcmFuc2Zvcm1fMTI4OSB7fVxuY2xhc3MgU3ludGF4cmVjRGVjbFRyYW5zZm9ybV8xMjkwIHt9XG5jbGFzcyBTeW50YXhEZWNsVHJhbnNmb3JtXzEyOTEge31cbmNsYXNzIFN5bnRheFF1b3RlVHJhbnNmb3JtXzEyOTIge31cbmNsYXNzIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybV8xMjkzIHt9XG5jbGFzcyBWYXJCaW5kaW5nVHJhbnNmb3JtXzEyOTQge1xuICBjb25zdHJ1Y3RvcihpZF8xMjk2KSB7XG4gICAgdGhpcy5pZCA9IGlkXzEyOTY7XG4gIH1cbn1cbmNsYXNzIENvbXBpbGV0aW1lVHJhbnNmb3JtXzEyOTUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZV8xMjk3KSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXzEyOTc7XG4gIH1cbn1cbmV4cG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtXzEyNzQgYXMgRnVuY3Rpb25EZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7VmFyaWFibGVEZWNsVHJhbnNmb3JtXzEyNzUgYXMgVmFyaWFibGVEZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7TmV3VHJhbnNmb3JtXzEyNzYgYXMgTmV3VHJhbnNmb3JtfTtcbmV4cG9ydCB7VGhyb3dUcmFuc2Zvcm1fMTI3NyBhcyBUaHJvd1RyYW5zZm9ybX07XG5leHBvcnQge0xldERlY2xUcmFuc2Zvcm1fMTI3OCBhcyBMZXREZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29uc3REZWNsVHJhbnNmb3JtXzEyNzkgYXMgQ29uc3REZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7VHJ5VHJhbnNmb3JtXzEyODAgYXMgVHJ5VHJhbnNmb3JtfTtcbmV4cG9ydCB7V2hpbGVUcmFuc2Zvcm1fMTI4MSBhcyBXaGlsZVRyYW5zZm9ybX07XG5leHBvcnQge0lmVHJhbnNmb3JtXzEyODIgYXMgSWZUcmFuc2Zvcm19O1xuZXhwb3J0IHtGb3JUcmFuc2Zvcm1fMTI4MyBhcyBGb3JUcmFuc2Zvcm19O1xuZXhwb3J0IHtTd2l0Y2hUcmFuc2Zvcm1fMTI4NCBhcyBTd2l0Y2hUcmFuc2Zvcm19O1xuZXhwb3J0IHtCcmVha1RyYW5zZm9ybV8xMjg1IGFzIEJyZWFrVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29udGludWVUcmFuc2Zvcm1fMTI4NiBhcyBDb250aW51ZVRyYW5zZm9ybX07XG5leHBvcnQge0RvVHJhbnNmb3JtXzEyODcgYXMgRG9UcmFuc2Zvcm19O1xuZXhwb3J0IHtXaXRoVHJhbnNmb3JtXzEyODggYXMgV2l0aFRyYW5zZm9ybX07XG5leHBvcnQge0RlYnVnZ2VyVHJhbnNmb3JtXzEyODkgYXMgRGVidWdnZXJUcmFuc2Zvcm19O1xuZXhwb3J0IHtTeW50YXhyZWNEZWNsVHJhbnNmb3JtXzEyOTAgYXMgU3ludGF4cmVjRGVjbFRyYW5zZm9ybX07XG5leHBvcnQge1N5bnRheERlY2xUcmFuc2Zvcm1fMTI5MSBhcyBTeW50YXhEZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7U3ludGF4UXVvdGVUcmFuc2Zvcm1fMTI5MiBhcyBTeW50YXhRdW90ZVRyYW5zZm9ybX07XG5leHBvcnQge1JldHVyblN0YXRlbWVudFRyYW5zZm9ybV8xMjkzIGFzIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybX07XG5leHBvcnQge1ZhckJpbmRpbmdUcmFuc2Zvcm1fMTI5NCBhcyBWYXJCaW5kaW5nVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29tcGlsZXRpbWVUcmFuc2Zvcm1fMTI5NSBhcyBDb21waWxldGltZVRyYW5zZm9ybX0iXX0=

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MonoidalReducer = exports.CloneReducer = undefined;
	exports.default = reduce;

	var _cloneReducer = __webpack_require__(33);

	Object.defineProperty(exports, "CloneReducer", {
	  enumerable: true,
	  get: function get() {
	    return _cloneReducer.default;
	  }
	});

	var _monoidalReducer = __webpack_require__(35);

	Object.defineProperty(exports, "MonoidalReducer", {
	  enumerable: true,
	  get: function get() {
	    return _monoidalReducer.default;
	  }
	});

	var _shiftSpec = __webpack_require__(34);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function transformWithSpec(transformer, node, spec) {
	  switch (spec.typeName) {
	    case "Enum":
	    case "String":
	    case "Number":
	    case "Boolean":
	    case "SourceSpan":
	      return node;
	    case "Const":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, spec.argument);
	    case "Maybe":
	      return node && transformWithSpec(transformer, node, spec.argument);
	    case "List":
	      return node.map(function (e) {
	        return transformWithSpec(transformer, e, spec.argument);
	      });
	    case "Union":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, _shiftSpec2.default[node.type]);
	    default:
	      var state = {};
	      spec.fields.forEach(function (field) {
	        var v = transformWithSpec(transformer, node[field.name], field.type);
	        state[field.name] = v == null ? null : v;
	      });
	      if (typeof transformer["reduce" + node.type] !== "function") {
	        throw new Error("Encountered " + node.type + ", which the provided reducer does not handle.");
	      }
	      return transformer["reduce" + node.type](node, state);
	  }
	} /**
	   * Copyright 2014 Shape Security, Inc.
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License")
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   */

	function reduce(reducer, reducible) {
	  return transformWithSpec(reducer, reducible, _shiftSpec2.default[reducible.type]);
	}

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(34);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                           * you may not use this file except in compliance with the License.
	                                                                                                                                                           * You may obtain a copy of the License at
	                                                                                                                                                           *
	                                                                                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                           *
	                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                           * See the License for the specific language governing permissions and
	                                                                                                                                                           * limitations under the License.
	                                                                                                                                                           */

	var CloneReducer = function CloneReducer() {
	  _classCallCheck(this, CloneReducer);
	};

	exports.default = CloneReducer;

	for (var typeName in _shiftSpec2.default) {
	  var type = _shiftSpec2.default[typeName];
	  Object.defineProperty(CloneReducer.prototype, "reduce" + typeName, {
	    value: function value(node, state) {
	      return state;
	    }
	  });
	}

/***/ },
/* 34 */
/***/ function(module, exports) {

	// Generated by src/generate-spec.js. 

	/**
	 * Copyright 2015 Shape Security, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	// Hack to make Babel6 import this as a module.
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Meta data generated from spec.idl.
	exports.default = (function() {
	  var SPEC = {};

	  var BOOLEAN = { typeName: "Boolean" };
	  var DOUBLE = { typeName: "Number" };
	  var STRING = { typeName: "String" };
	  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
	  function List(arg) { return { typeName: "List", argument: arg }; }
	  function Const(arg) { return { typeName: "Const", argument: arg }; }
	  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }

	  var TYPE_INDICATOR = {
	    typeName: "Enum",
	    values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
	  };

	  var VariableDeclarationKind = {
	    typeName: "Enum",
	    values: ["var", "let", "const"]
	  };

	  var CompoundAssignmentOperator = {
	    typeName: "Enum",
	    values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
	  };

	  var BinaryOperator = {
	    typeName: "Enum",
	    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
	  };

	  var UnaryOperator = {
	    typeName: "Enum",
	    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
	  };

	  var UpdateOperator = {
	    typeName: "Enum",
	    values: ["++", "--"]
	  };

	  var SourceLocation = SPEC.SourceLocation = {};
	  var SourceSpan = SPEC.SourceSpan = {};
	  var BindingWithDefault = SPEC.BindingWithDefault = {};
	  var BindingIdentifier = SPEC.BindingIdentifier = {};
	  var ArrayBinding = SPEC.ArrayBinding = {};
	  var ObjectBinding = SPEC.ObjectBinding = {};
	  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
	  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
	  var ClassExpression = SPEC.ClassExpression = {};
	  var ClassDeclaration = SPEC.ClassDeclaration = {};
	  var ClassElement = SPEC.ClassElement = {};
	  var Module = SPEC.Module = {};
	  var Import = SPEC.Import = {};
	  var ImportNamespace = SPEC.ImportNamespace = {};
	  var ImportSpecifier = SPEC.ImportSpecifier = {};
	  var ExportAllFrom = SPEC.ExportAllFrom = {};
	  var ExportFrom = SPEC.ExportFrom = {};
	  var Export = SPEC.Export = {};
	  var ExportDefault = SPEC.ExportDefault = {};
	  var ExportSpecifier = SPEC.ExportSpecifier = {};
	  var Method = SPEC.Method = {};
	  var Getter = SPEC.Getter = {};
	  var Setter = SPEC.Setter = {};
	  var DataProperty = SPEC.DataProperty = {};
	  var ShorthandProperty = SPEC.ShorthandProperty = {};
	  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
	  var StaticPropertyName = SPEC.StaticPropertyName = {};
	  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
	  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
	  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
	  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
	  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
	  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
	  var ArrayExpression = SPEC.ArrayExpression = {};
	  var ArrowExpression = SPEC.ArrowExpression = {};
	  var AssignmentExpression = SPEC.AssignmentExpression = {};
	  var BinaryExpression = SPEC.BinaryExpression = {};
	  var CallExpression = SPEC.CallExpression = {};
	  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
	  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
	  var ConditionalExpression = SPEC.ConditionalExpression = {};
	  var FunctionExpression = SPEC.FunctionExpression = {};
	  var IdentifierExpression = SPEC.IdentifierExpression = {};
	  var NewExpression = SPEC.NewExpression = {};
	  var NewTargetExpression = SPEC.NewTargetExpression = {};
	  var ObjectExpression = SPEC.ObjectExpression = {};
	  var UnaryExpression = SPEC.UnaryExpression = {};
	  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
	  var TemplateExpression = SPEC.TemplateExpression = {};
	  var ThisExpression = SPEC.ThisExpression = {};
	  var UpdateExpression = SPEC.UpdateExpression = {};
	  var YieldExpression = SPEC.YieldExpression = {};
	  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
	  var BlockStatement = SPEC.BlockStatement = {};
	  var BreakStatement = SPEC.BreakStatement = {};
	  var ContinueStatement = SPEC.ContinueStatement = {};
	  var DebuggerStatement = SPEC.DebuggerStatement = {};
	  var DoWhileStatement = SPEC.DoWhileStatement = {};
	  var EmptyStatement = SPEC.EmptyStatement = {};
	  var ExpressionStatement = SPEC.ExpressionStatement = {};
	  var ForInStatement = SPEC.ForInStatement = {};
	  var ForOfStatement = SPEC.ForOfStatement = {};
	  var ForStatement = SPEC.ForStatement = {};
	  var IfStatement = SPEC.IfStatement = {};
	  var LabeledStatement = SPEC.LabeledStatement = {};
	  var ReturnStatement = SPEC.ReturnStatement = {};
	  var SwitchStatement = SPEC.SwitchStatement = {};
	  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
	  var ThrowStatement = SPEC.ThrowStatement = {};
	  var TryCatchStatement = SPEC.TryCatchStatement = {};
	  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
	  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
	  var WhileStatement = SPEC.WhileStatement = {};
	  var WithStatement = SPEC.WithStatement = {};
	  var Block = SPEC.Block = {};
	  var CatchClause = SPEC.CatchClause = {};
	  var Directive = SPEC.Directive = {};
	  var FormalParameters = SPEC.FormalParameters = {};
	  var FunctionBody = SPEC.FunctionBody = {};
	  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
	  var Script = SPEC.Script = {};
	  var SpreadElement = SPEC.SpreadElement = {};
	  var Super = SPEC.Super = {};
	  var SwitchCase = SPEC.SwitchCase = {};
	  var SwitchDefault = SPEC.SwitchDefault = {};
	  var TemplateElement = SPEC.TemplateElement = {};
	  var VariableDeclaration = SPEC.VariableDeclaration = {};
	  var VariableDeclarator = SPEC.VariableDeclarator = {};

	  var Class = Union(ClassExpression, ClassDeclaration);
	  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
	  var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
	  var ImportDeclaration = Union(Import, ImportNamespace);
	  var MethodDefinition = Union(Method, Getter, Setter);
	  var NamedObjectProperty = Union(MethodDefinition, DataProperty);
	  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
	  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
	  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
	  var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
	  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
	  var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
	  var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
	  var Function = Union(FunctionExpression, FunctionDeclaration);

	  SourceLocation.typeName = "SourceLocation";
	  SourceLocation.fields = [
	    { name: "line", type: DOUBLE },
	    { name: "column", type: DOUBLE },
	    { name: "offset", type: DOUBLE },
	  ];

	  SourceSpan.typeName = "SourceSpan";
	  SourceSpan.fields = [
	    { name: "source", type: Maybe(STRING) },
	    { name: "start", type: SourceLocation },
	    { name: "end", type: SourceLocation },
	  ];

	  BindingWithDefault.typeName = "BindingWithDefault";
	  BindingWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Expression },
	  ];

	  BindingIdentifier.typeName = "BindingIdentifier";
	  BindingIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ArrayBinding.typeName = "ArrayBinding";
	  ArrayBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) },
	    { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) },
	  ];

	  ObjectBinding.typeName = "ObjectBinding";
	  ObjectBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(BindingProperty) },
	  ];

	  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
	  BindingPropertyIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: BindingIdentifier },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  BindingPropertyProperty.typeName = "BindingPropertyProperty";
	  BindingPropertyProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	  ];

	  ClassExpression.typeName = "ClassExpression";
	  ClassExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassDeclaration.typeName = "ClassDeclaration";
	  ClassDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: BindingIdentifier },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassElement.typeName = "ClassElement";
	  ClassElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isStatic", type: BOOLEAN },
	    { name: "method", type: MethodDefinition },
	  ];

	  Module.typeName = "Module";
	  Module.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) },
	  ];

	  Import.typeName = "Import";
	  Import.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namedImports", type: List(ImportSpecifier) },
	  ];

	  ImportNamespace.typeName = "ImportNamespace";
	  ImportNamespace.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namespaceBinding", type: BindingIdentifier },
	  ];

	  ImportSpecifier.typeName = "ImportSpecifier";
	  ImportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "binding", type: BindingIdentifier },
	  ];

	  ExportAllFrom.typeName = "ExportAllFrom";
	  ExportAllFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	  ];

	  ExportFrom.typeName = "ExportFrom";
	  ExportFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "namedExports", type: List(ExportSpecifier) },
	    { name: "moduleSpecifier", type: Maybe(STRING) },
	  ];

	  Export.typeName = "Export";
	  Export.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) },
	  ];

	  ExportDefault.typeName = "ExportDefault";
	  ExportDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) },
	  ];

	  ExportSpecifier.typeName = "ExportSpecifier";
	  ExportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "exportedName", type: STRING },
	  ];

	  Method.typeName = "Method";
	  Method.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Getter.typeName = "Getter";
	  Getter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "body", type: FunctionBody },
	  ];

	  Setter.typeName = "Setter";
	  Setter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	    { name: "body", type: FunctionBody },
	  ];

	  DataProperty.typeName = "DataProperty";
	  DataProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "expression", type: Expression },
	  ];

	  ShorthandProperty.typeName = "ShorthandProperty";
	  ShorthandProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ComputedPropertyName.typeName = "ComputedPropertyName";
	  ComputedPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  StaticPropertyName.typeName = "StaticPropertyName";
	  StaticPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
	  LiteralBooleanExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: BOOLEAN },
	  ];

	  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
	  LiteralInfinityExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNullExpression.typeName = "LiteralNullExpression";
	  LiteralNullExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNumericExpression.typeName = "LiteralNumericExpression";
	  LiteralNumericExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: DOUBLE },
	  ];

	  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
	  LiteralRegExpExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "pattern", type: STRING },
	    { name: "flags", type: STRING },
	  ];

	  LiteralStringExpression.typeName = "LiteralStringExpression";
	  LiteralStringExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  ArrayExpression.typeName = "ArrayExpression";
	  ArrayExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) },
	  ];

	  ArrowExpression.typeName = "ArrowExpression";
	  ArrowExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: Union(FunctionBody, Expression) },
	  ];

	  AssignmentExpression.typeName = "AssignmentExpression";
	  AssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  BinaryExpression.typeName = "BinaryExpression";
	  BinaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: BinaryOperator },
	    { name: "left", type: Expression },
	    { name: "right", type: Expression },
	  ];

	  CallExpression.typeName = "CallExpression";
	  CallExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Union(Expression, Super) },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
	  CompoundAssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: CompoundAssignmentOperator },
	    { name: "binding", type: Union(BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  ComputedMemberExpression.typeName = "ComputedMemberExpression";
	  ComputedMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "expression", type: Expression },
	  ];

	  ConditionalExpression.typeName = "ConditionalExpression";
	  ConditionalExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Expression },
	    { name: "alternate", type: Expression },
	  ];

	  FunctionExpression.typeName = "FunctionExpression";
	  FunctionExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  IdentifierExpression.typeName = "IdentifierExpression";
	  IdentifierExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  NewExpression.typeName = "NewExpression";
	  NewExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Expression },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  NewTargetExpression.typeName = "NewTargetExpression";
	  NewTargetExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ObjectExpression.typeName = "ObjectExpression";
	  ObjectExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(ObjectProperty) },
	  ];

	  UnaryExpression.typeName = "UnaryExpression";
	  UnaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: UnaryOperator },
	    { name: "operand", type: Expression },
	  ];

	  StaticMemberExpression.typeName = "StaticMemberExpression";
	  StaticMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "property", type: STRING },
	  ];

	  TemplateExpression.typeName = "TemplateExpression";
	  TemplateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "tag", type: Maybe(Expression) },
	    { name: "elements", type: List(Union(Expression, TemplateElement)) },
	  ];

	  ThisExpression.typeName = "ThisExpression";
	  ThisExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  UpdateExpression.typeName = "UpdateExpression";
	  UpdateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isPrefix", type: BOOLEAN },
	    { name: "operator", type: UpdateOperator },
	    { name: "operand", type: Union(BindingIdentifier, MemberExpression) },
	  ];

	  YieldExpression.typeName = "YieldExpression";
	  YieldExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
	  YieldGeneratorExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  BlockStatement.typeName = "BlockStatement";
	  BlockStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "block", type: Block },
	  ];

	  BreakStatement.typeName = "BreakStatement";
	  BreakStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  ContinueStatement.typeName = "ContinueStatement";
	  ContinueStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  DebuggerStatement.typeName = "DebuggerStatement";
	  DebuggerStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  DoWhileStatement.typeName = "DoWhileStatement";
	  DoWhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Statement },
	    { name: "test", type: Expression },
	  ];

	  EmptyStatement.typeName = "EmptyStatement";
	  EmptyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ExpressionStatement.typeName = "ExpressionStatement";
	  ExpressionStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  ForInStatement.typeName = "ForInStatement";
	  ForInStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForOfStatement.typeName = "ForOfStatement";
	  ForOfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForStatement.typeName = "ForStatement";
	  ForStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) },
	    { name: "test", type: Maybe(Expression) },
	    { name: "update", type: Maybe(Expression) },
	    { name: "body", type: Statement },
	  ];

	  IfStatement.typeName = "IfStatement";
	  IfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Statement },
	    { name: "alternate", type: Maybe(Statement) },
	  ];

	  LabeledStatement.typeName = "LabeledStatement";
	  LabeledStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: STRING },
	    { name: "body", type: Statement },
	  ];

	  ReturnStatement.typeName = "ReturnStatement";
	  ReturnStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  SwitchStatement.typeName = "SwitchStatement";
	  SwitchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "cases", type: List(SwitchCase) },
	  ];

	  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
	  SwitchStatementWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "preDefaultCases", type: List(SwitchCase) },
	    { name: "defaultCase", type: SwitchDefault },
	    { name: "postDefaultCases", type: List(SwitchCase) },
	  ];

	  ThrowStatement.typeName = "ThrowStatement";
	  ThrowStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  TryCatchStatement.typeName = "TryCatchStatement";
	  TryCatchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: CatchClause },
	  ];

	  TryFinallyStatement.typeName = "TryFinallyStatement";
	  TryFinallyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: Maybe(CatchClause) },
	    { name: "finalizer", type: Block },
	  ];

	  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
	  VariableDeclarationStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: VariableDeclaration },
	  ];

	  WhileStatement.typeName = "WhileStatement";
	  WhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  WithStatement.typeName = "WithStatement";
	  WithStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  Block.typeName = "Block";
	  Block.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "statements", type: List(Statement) },
	  ];

	  CatchClause.typeName = "CatchClause";
	  CatchClause.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "body", type: Block },
	  ];

	  Directive.typeName = "Directive";
	  Directive.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  FormalParameters.typeName = "FormalParameters";
	  FormalParameters.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) },
	    { name: "rest", type: Maybe(BindingIdentifier) },
	  ];

	  FunctionBody.typeName = "FunctionBody";
	  FunctionBody.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  FunctionDeclaration.typeName = "FunctionDeclaration";
	  FunctionDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: BindingIdentifier },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Script.typeName = "Script";
	  Script.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  SpreadElement.typeName = "SpreadElement";
	  SpreadElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  Super.typeName = "Super";
	  Super.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  SwitchCase.typeName = "SwitchCase";
	  SwitchCase.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: List(Statement) },
	  ];

	  SwitchDefault.typeName = "SwitchDefault";
	  SwitchDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "consequent", type: List(Statement) },
	  ];

	  TemplateElement.typeName = "TemplateElement";
	  TemplateElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  VariableDeclaration.typeName = "VariableDeclaration";
	  VariableDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "kind", type: VariableDeclarationKind },
	    { name: "declarators", type: List(VariableDeclarator) },
	  ];

	  VariableDeclarator.typeName = "VariableDeclarator";
	  VariableDeclarator.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  return SPEC;
	}());


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                   * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                   * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                   * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                   * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                   * limitations under the License.
	                                                                                                                                                                                                                                                   */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(34);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var methods = {};

	function id(x) {
	  return x;
	}

	function handlerForFieldOfType(type) {
	  switch (type.typeName) {
	    case "Enum":
	    case "String":
	    case "Boolean":
	    case "Number":
	    case "SourceSpan":
	      return null;
	    case "Const":
	      return handlerForFieldOfType(type.argument);
	    case "Maybe":
	      {
	        var _ret = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              return t == null ? this.identity : subHandler.call(this, t);
	            }
	          };
	        }();

	        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	      }
	    case "List":
	      {
	        var _ret2 = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              var _this = this;

	              return this.fold(t.map(function (x) {
	                return subHandler.call(_this, x);
	              }));
	            }
	          };
	        }();

	        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
	      }
	    default:
	      return id;
	  }
	}

	var _loop = function _loop(typeName) {
	  var type = _shiftSpec2.default[typeName];

	  var handlers = {};
	  type.fields.forEach(function (field) {
	    var handler = handlerForFieldOfType(field.type);
	    if (handler != null) handlers[field.name] = handler;
	  });
	  var fieldNames = Object.keys(handlers);

	  methods["reduce" + typeName] = {
	    value: function value(node, state) {
	      var _this3 = this;

	      return this.fold(fieldNames.map(function (fieldName) {
	        return handlers[fieldName].call(_this3, state[fieldName]);
	      }));
	    }
	  };
	};

	for (var typeName in _shiftSpec2.default) {
	  _loop(typeName);
	}

	var MonoidalReducer = function () {
	  function MonoidalReducer(monoid) {
	    _classCallCheck(this, MonoidalReducer);

	    this.identity = monoid.empty();
	    var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
	    this.append = function (a, b) {
	      return concat.call(a, b);
	    };
	  }

	  _createClass(MonoidalReducer, [{
	    key: "fold",
	    value: function fold(list, a) {
	      var _this2 = this;

	      return list.reduce(function (memo, x) {
	        return _this2.append(memo, x);
	      }, a == null ? this.identity : a);
	    }
	  }]);

	  return MonoidalReducer;
	}();

	exports.default = MonoidalReducer;

	Object.defineProperties(MonoidalReducer.prototype, methods);

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReducer = __webpack_require__(32);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class ParseReducer extends _shiftReducer.CloneReducer {
	  constructor(context_534) {
	    super();
	    this.context = context_534;
	  }
	  reduceModule(node_535, state_536) {
	    return new _terms2.default("Module", { directives: state_536.directives.toArray(), items: state_536.items.toArray() });
	  }
	  reduceImport(node_537, state_538) {
	    let moduleSpecifier_539 = state_538.moduleSpecifier ? state_538.moduleSpecifier.val() : null;
	    return new _terms2.default("Import", { defaultBinding: state_538.defaultBinding, namedImports: state_538.namedImports.toArray(), moduleSpecifier: moduleSpecifier_539, forSyntax: node_537.forSyntax });
	  }
	  reduceImportNamespace(node_540, state_541) {
	    let moduleSpecifier_542 = state_541.moduleSpecifier ? state_541.moduleSpecifier.val() : null;
	    return new _terms2.default("ImportNamespace", { defaultBinding: state_541.defaultBinding, namespaceBinding: state_541.namespaceBinding, moduleSpecifier: moduleSpecifier_542, forSyntax: node_540.forSyntax });
	  }
	  reduceExport(node_543, state_544) {
	    return new _terms2.default("Export", { declaration: state_544.declaration });
	  }
	  reduceExportAllFrom(node_545, state_546) {
	    let moduleSpecifier_547 = state_546.moduleSpecifier ? state_546.moduleSpecifier.val() : null;
	    return new _terms2.default("ExportAllFrom", { moduleSpecifier: moduleSpecifier_547 });
	  }
	  reduceExportFrom(node_548, state_549) {
	    let moduleSpecifier_550 = state_549.moduleSpecifier ? state_549.moduleSpecifier.val() : null;
	    return new _terms2.default("ExportFrom", { moduleSpecifier: moduleSpecifier_550, namedExports: state_549.namedExports.toArray() });
	  }
	  reduceExportSpecifier(node_551, state_552) {
	    let name_553 = state_552.name,
	        exportedName_554 = state_552.exportedName;
	    if (name_553 == null) {
	      name_553 = exportedName_554.resolve(this.context.phase);
	      exportedName_554 = exportedName_554.val();
	    } else {
	      name_553 = name_553.resolve(this.context.phase);
	      exportedName_554 = exportedName_554.val();
	    }
	    return new _terms2.default("ExportSpecifier", { name: name_553, exportedName: exportedName_554 });
	  }
	  reduceImportSpecifier(node_555, state_556) {
	    let name_557 = state_556.name ? state_556.name.resolve(this.context.phase) : null;
	    return new _terms2.default("ImportSpecifier", { name: name_557, binding: state_556.binding });
	  }
	  reduceIdentifierExpression(node_558, state_559) {
	    return new _terms2.default("IdentifierExpression", { name: node_558.name.resolve(this.context.phase) });
	  }
	  reduceLiteralNumericExpression(node_560, state_561) {
	    return new _terms2.default("LiteralNumericExpression", { value: node_560.value.val() });
	  }
	  reduceLiteralBooleanExpression(node_562, state_563) {
	    return new _terms2.default("LiteralBooleanExpression", { value: node_562.value.val() === "true" });
	  }
	  reduceLiteralStringExpression(node_564, state_565) {
	    return new _terms2.default("LiteralStringExpression", { value: node_564.value.token.str });
	  }
	  reduceCallExpression(node_566, state_567) {
	    return new _terms2.default("CallExpression", { callee: state_567.callee, arguments: state_567.arguments.toArray() });
	  }
	  reduceFunctionBody(node_568, state_569) {
	    return new _terms2.default("FunctionBody", { directives: state_569.directives.toArray(), statements: state_569.statements.toArray() });
	  }
	  reduceFormalParameters(node_570, state_571) {
	    return new _terms2.default("FormalParameters", { items: state_571.items.toArray(), rest: state_571.rest });
	  }
	  reduceBindingIdentifier(node_572, state_573) {
	    return new _terms2.default("BindingIdentifier", { name: node_572.name.resolve(this.context.phase) });
	  }
	  reduceBinaryExpression(node_574, state_575) {
	    return new _terms2.default("BinaryExpression", { left: state_575.left, operator: node_574.operator.val(), right: state_575.right });
	  }
	  reduceObjectExpression(node_576, state_577) {
	    return new _terms2.default("ObjectExpression", { properties: state_577.properties.toArray() });
	  }
	  reduceVariableDeclaration(node_578, state_579) {
	    return new _terms2.default("VariableDeclaration", { kind: state_579.kind, declarators: state_579.declarators.toArray() });
	  }
	  reduceStaticPropertyName(node_580, state_581) {
	    return new _terms2.default("StaticPropertyName", { value: node_580.value.val().toString() });
	  }
	  reduceArrayExpression(node_582, state_583) {
	    return new _terms2.default("ArrayExpression", { elements: state_583.elements.toArray() });
	  }
	  reduceStaticMemberExpression(node_584, state_585) {
	    return new _terms2.default("StaticMemberExpression", { object: state_585.object, property: state_585.property.val() });
	  }
	}
	exports.default = ParseReducer;
	//# sourceMappingURL=data:application/json;base64,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aUJBQVQsRUFBNEIsRUFBQyxVQUFVLFVBQVUsUUFBVixDQUFtQixPQUFuQixFQUFYLEVBQTVCLENBQVA7QUFDRDtBQUNELCtCQUE2QixRQUE3QixFQUF1QyxTQUF2QyxFQUFrRDtBQUNoRCxXQUFPLG9CQUFTLHdCQUFULEVBQW1DLEVBQUMsUUFBUSxVQUFVLE1BQW5CLEVBQTJCLFVBQVUsVUFBVSxRQUFWLENBQW1CLEdBQW5CLEVBQXJDLEVBQW5DLENBQVA7QUFDRDtBQW5Gb0Q7a0JBQWxDLFkiLCJmaWxlIjoicGFyc2UtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge0Nsb25lUmVkdWNlcn0gZnJvbSBcInNoaWZ0LXJlZHVjZXJcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlUmVkdWNlciBleHRlbmRzIENsb25lUmVkdWNlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHRfNTM0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XzUzNDtcbiAgfVxuICByZWR1Y2VNb2R1bGUobm9kZV81MzUsIHN0YXRlXzUzNikge1xuICAgIHJldHVybiBuZXcgVGVybShcIk1vZHVsZVwiLCB7ZGlyZWN0aXZlczogc3RhdGVfNTM2LmRpcmVjdGl2ZXMudG9BcnJheSgpLCBpdGVtczogc3RhdGVfNTM2Lml0ZW1zLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZUltcG9ydChub2RlXzUzNywgc3RhdGVfNTM4KSB7XG4gICAgbGV0IG1vZHVsZVNwZWNpZmllcl81MzkgPSBzdGF0ZV81MzgubW9kdWxlU3BlY2lmaWVyID8gc3RhdGVfNTM4Lm1vZHVsZVNwZWNpZmllci52YWwoKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0XCIsIHtkZWZhdWx0QmluZGluZzogc3RhdGVfNTM4LmRlZmF1bHRCaW5kaW5nLCBuYW1lZEltcG9ydHM6IHN0YXRlXzUzOC5uYW1lZEltcG9ydHMudG9BcnJheSgpLCBtb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcl81MzksIGZvclN5bnRheDogbm9kZV81MzcuZm9yU3ludGF4fSk7XG4gIH1cbiAgcmVkdWNlSW1wb3J0TmFtZXNwYWNlKG5vZGVfNTQwLCBzdGF0ZV81NDEpIHtcbiAgICBsZXQgbW9kdWxlU3BlY2lmaWVyXzU0MiA9IHN0YXRlXzU0MS5tb2R1bGVTcGVjaWZpZXIgPyBzdGF0ZV81NDEubW9kdWxlU3BlY2lmaWVyLnZhbCgpIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnROYW1lc3BhY2VcIiwge2RlZmF1bHRCaW5kaW5nOiBzdGF0ZV81NDEuZGVmYXVsdEJpbmRpbmcsIG5hbWVzcGFjZUJpbmRpbmc6IHN0YXRlXzU0MS5uYW1lc3BhY2VCaW5kaW5nLCBtb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcl81NDIsIGZvclN5bnRheDogbm9kZV81NDAuZm9yU3ludGF4fSk7XG4gIH1cbiAgcmVkdWNlRXhwb3J0KG5vZGVfNTQzLCBzdGF0ZV81NDQpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRcIiwge2RlY2xhcmF0aW9uOiBzdGF0ZV81NDQuZGVjbGFyYXRpb259KTtcbiAgfVxuICByZWR1Y2VFeHBvcnRBbGxGcm9tKG5vZGVfNTQ1LCBzdGF0ZV81NDYpIHtcbiAgICBsZXQgbW9kdWxlU3BlY2lmaWVyXzU0NyA9IHN0YXRlXzU0Ni5tb2R1bGVTcGVjaWZpZXIgPyBzdGF0ZV81NDYubW9kdWxlU3BlY2lmaWVyLnZhbCgpIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRBbGxGcm9tXCIsIHttb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcl81NDd9KTtcbiAgfVxuICByZWR1Y2VFeHBvcnRGcm9tKG5vZGVfNTQ4LCBzdGF0ZV81NDkpIHtcbiAgICBsZXQgbW9kdWxlU3BlY2lmaWVyXzU1MCA9IHN0YXRlXzU0OS5tb2R1bGVTcGVjaWZpZXIgPyBzdGF0ZV81NDkubW9kdWxlU3BlY2lmaWVyLnZhbCgpIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRGcm9tXCIsIHttb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcl81NTAsIG5hbWVkRXhwb3J0czogc3RhdGVfNTQ5Lm5hbWVkRXhwb3J0cy50b0FycmF5KCl9KTtcbiAgfVxuICByZWR1Y2VFeHBvcnRTcGVjaWZpZXIobm9kZV81NTEsIHN0YXRlXzU1Mikge1xuICAgIGxldCBuYW1lXzU1MyA9IHN0YXRlXzU1Mi5uYW1lLCBleHBvcnRlZE5hbWVfNTU0ID0gc3RhdGVfNTUyLmV4cG9ydGVkTmFtZTtcbiAgICBpZiAobmFtZV81NTMgPT0gbnVsbCkge1xuICAgICAgbmFtZV81NTMgPSBleHBvcnRlZE5hbWVfNTU0LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKTtcbiAgICAgIGV4cG9ydGVkTmFtZV81NTQgPSBleHBvcnRlZE5hbWVfNTU0LnZhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lXzU1MyA9IG5hbWVfNTUzLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKTtcbiAgICAgIGV4cG9ydGVkTmFtZV81NTQgPSBleHBvcnRlZE5hbWVfNTU0LnZhbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNTUzLCBleHBvcnRlZE5hbWU6IGV4cG9ydGVkTmFtZV81NTR9KTtcbiAgfVxuICByZWR1Y2VJbXBvcnRTcGVjaWZpZXIobm9kZV81NTUsIHN0YXRlXzU1Nikge1xuICAgIGxldCBuYW1lXzU1NyA9IHN0YXRlXzU1Ni5uYW1lID8gc3RhdGVfNTU2Lm5hbWUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNTU3LCBiaW5kaW5nOiBzdGF0ZV81NTYuYmluZGluZ30pO1xuICB9XG4gIHJlZHVjZUlkZW50aWZpZXJFeHByZXNzaW9uKG5vZGVfNTU4LCBzdGF0ZV81NTkpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJZGVudGlmaWVyRXhwcmVzc2lvblwiLCB7bmFtZTogbm9kZV81NTgubmFtZS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSl9KTtcbiAgfVxuICByZWR1Y2VMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24obm9kZV81NjAsIHN0YXRlXzU2MSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxOdW1lcmljRXhwcmVzc2lvblwiLCB7dmFsdWU6IG5vZGVfNTYwLnZhbHVlLnZhbCgpfSk7XG4gIH1cbiAgcmVkdWNlTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uKG5vZGVfNTYyLCBzdGF0ZV81NjMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb25cIiwge3ZhbHVlOiBub2RlXzU2Mi52YWx1ZS52YWwoKSA9PT0gXCJ0cnVlXCJ9KTtcbiAgfVxuICByZWR1Y2VMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbihub2RlXzU2NCwgc3RhdGVfNTY1KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb25cIiwge3ZhbHVlOiBub2RlXzU2NC52YWx1ZS50b2tlbi5zdHJ9KTtcbiAgfVxuICByZWR1Y2VDYWxsRXhwcmVzc2lvbihub2RlXzU2Niwgc3RhdGVfNTY3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ2FsbEV4cHJlc3Npb25cIiwge2NhbGxlZTogc3RhdGVfNTY3LmNhbGxlZSwgYXJndW1lbnRzOiBzdGF0ZV81NjcuYXJndW1lbnRzLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZUZ1bmN0aW9uQm9keShub2RlXzU2OCwgc3RhdGVfNTY5KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRnVuY3Rpb25Cb2R5XCIsIHtkaXJlY3RpdmVzOiBzdGF0ZV81NjkuZGlyZWN0aXZlcy50b0FycmF5KCksIHN0YXRlbWVudHM6IHN0YXRlXzU2OS5zdGF0ZW1lbnRzLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZUZvcm1hbFBhcmFtZXRlcnMobm9kZV81NzAsIHN0YXRlXzU3MSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiBzdGF0ZV81NzEuaXRlbXMudG9BcnJheSgpLCByZXN0OiBzdGF0ZV81NzEucmVzdH0pO1xuICB9XG4gIHJlZHVjZUJpbmRpbmdJZGVudGlmaWVyKG5vZGVfNTcyLCBzdGF0ZV81NzMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogbm9kZV81NzIubmFtZS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSl9KTtcbiAgfVxuICByZWR1Y2VCaW5hcnlFeHByZXNzaW9uKG5vZGVfNTc0LCBzdGF0ZV81NzUpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5hcnlFeHByZXNzaW9uXCIsIHtsZWZ0OiBzdGF0ZV81NzUubGVmdCwgb3BlcmF0b3I6IG5vZGVfNTc0Lm9wZXJhdG9yLnZhbCgpLCByaWdodDogc3RhdGVfNTc1LnJpZ2h0fSk7XG4gIH1cbiAgcmVkdWNlT2JqZWN0RXhwcmVzc2lvbihub2RlXzU3Niwgc3RhdGVfNTc3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiT2JqZWN0RXhwcmVzc2lvblwiLCB7cHJvcGVydGllczogc3RhdGVfNTc3LnByb3BlcnRpZXMudG9BcnJheSgpfSk7XG4gIH1cbiAgcmVkdWNlVmFyaWFibGVEZWNsYXJhdGlvbihub2RlXzU3OCwgc3RhdGVfNTc5KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCB7a2luZDogc3RhdGVfNTc5LmtpbmQsIGRlY2xhcmF0b3JzOiBzdGF0ZV81NzkuZGVjbGFyYXRvcnMudG9BcnJheSgpfSk7XG4gIH1cbiAgcmVkdWNlU3RhdGljUHJvcGVydHlOYW1lKG5vZGVfNTgwLCBzdGF0ZV81ODEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTdGF0aWNQcm9wZXJ0eU5hbWVcIiwge3ZhbHVlOiBub2RlXzU4MC52YWx1ZS52YWwoKS50b1N0cmluZygpfSk7XG4gIH1cbiAgcmVkdWNlQXJyYXlFeHByZXNzaW9uKG5vZGVfNTgyLCBzdGF0ZV81ODMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUV4cHJlc3Npb25cIiwge2VsZW1lbnRzOiBzdGF0ZV81ODMuZWxlbWVudHMudG9BcnJheSgpfSk7XG4gIH1cbiAgcmVkdWNlU3RhdGljTWVtYmVyRXhwcmVzc2lvbihub2RlXzU4NCwgc3RhdGVfNTg1KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3RhdGljTWVtYmVyRXhwcmVzc2lvblwiLCB7b2JqZWN0OiBzdGF0ZV81ODUub2JqZWN0LCBwcm9wZXJ0eTogc3RhdGVfNTg1LnByb3BlcnR5LnZhbCgpfSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SemiOp = exports.CommaSep = exports.Semi = exports.Seq = exports.ContainsIn = exports.NoIn = exports.Brace = exports.Bracket = exports.Paren = exports.NumberCodeRep = exports.Token = exports.Empty = exports.CodeRep = exports.escapeStringLiteral = exports.getPrecedence = exports.Precedence = exports.Sep = exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.MinimalCodeGen = undefined;
	exports.default = codeGen;

	var _minimalCodegen = __webpack_require__(38);

	Object.defineProperty(exports, "MinimalCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _minimalCodegen.default;
	  }
	});

	var _formattedCodegen = __webpack_require__(41);

	Object.defineProperty(exports, "ExtensibleCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.ExtensibleCodeGen;
	  }
	});
	Object.defineProperty(exports, "FormattedCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.FormattedCodeGen;
	  }
	});
	Object.defineProperty(exports, "Sep", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.Sep;
	  }
	});

	var _coderep = __webpack_require__(40);

	Object.defineProperty(exports, "Precedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Precedence;
	  }
	});
	Object.defineProperty(exports, "getPrecedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.getPrecedence;
	  }
	});
	Object.defineProperty(exports, "escapeStringLiteral", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.escapeStringLiteral;
	  }
	});
	Object.defineProperty(exports, "CodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CodeRep;
	  }
	});
	Object.defineProperty(exports, "Empty", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Empty;
	  }
	});
	Object.defineProperty(exports, "Token", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Token;
	  }
	});
	Object.defineProperty(exports, "NumberCodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NumberCodeRep;
	  }
	});
	Object.defineProperty(exports, "Paren", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Paren;
	  }
	});
	Object.defineProperty(exports, "Bracket", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Bracket;
	  }
	});
	Object.defineProperty(exports, "Brace", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Brace;
	  }
	});
	Object.defineProperty(exports, "NoIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NoIn;
	  }
	});
	Object.defineProperty(exports, "ContainsIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.ContainsIn;
	  }
	});
	Object.defineProperty(exports, "Seq", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Seq;
	  }
	});
	Object.defineProperty(exports, "Semi", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Semi;
	  }
	});
	Object.defineProperty(exports, "CommaSep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CommaSep;
	  }
	});
	Object.defineProperty(exports, "SemiOp", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.SemiOp;
	  }
	});

	var _shiftReducer = __webpack_require__(32);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _token_stream = __webpack_require__(42);

	var _minimalCodegen2 = _interopRequireDefault(_minimalCodegen);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function codeGen(script) {
	  var generator = arguments.length <= 1 || arguments[1] === undefined ? new _minimalCodegen2.default() : arguments[1];

	  var ts = new _token_stream.TokenStream();
	  var rep = (0, _shiftReducer2.default)(generator, script);
	  rep.emit(ts);
	  return ts.result;
	}

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _objectAssign = __webpack_require__(39);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(6);

	var _coderep = __webpack_require__(40);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function p(node, precedence, a) {
	  return (0, _coderep.getPrecedence)(node) < precedence ? paren(a) : a;
	}

	function t(token) {
	  return new _coderep.Token(token);
	}

	function paren(rep) {
	  return new _coderep.Paren(rep);
	}

	function brace(rep) {
	  return new _coderep.Brace(rep);
	}

	function bracket(rep) {
	  return new _coderep.Bracket(rep);
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function semi() {
	  return new _coderep.Semi();
	}

	function semiOp() {
	  return new _coderep.SemiOp();
	}

	function empty() {
	  return new _coderep.Empty();
	}

	function commaSep(pieces) {
	  return new _coderep.CommaSep(pieces);
	}

	function getAssignmentExpr(state) {
	  return state ? state.containsGroup ? paren(state) : state : empty();
	}

	var MinimalCodeGen = function () {
	  function MinimalCodeGen() {
	    _classCallCheck(this, MinimalCodeGen);
	  }

	  _createClass(MinimalCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(paren(original.children[0]), semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return bracket(empty());
	      }

	      var content = commaSep(elements.map(getAssignmentExpr));
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, t(","));
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(t("..."), p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t("="), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = paren(leftCode);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(t("..."), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(t("..."), restElement)]);
	        content = commaSep(elements.map(getAssignmentExpr));
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, t(","));
	        }
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, t(":"), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return brace(seq.apply(undefined, _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return block;
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(t("break"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(p(node.callee, (0, _coderep.getPrecedence)(node), callee), paren(commaSep(args))), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(t("catch"), paren(binding), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(t("class"), name);
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = t("class");
	      if (name != null) {
	        state = seq(state, name);
	      }
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      if (!node.isStatic) return method;
	      return seq(t("static"), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return bracket(expression);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(p(node.test, _coderep.Precedence.LogicalOR, test), t("?"), p(node.consequent, _coderep.Precedence.Assignment, consequent), t(":"), p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(t("continue"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, t(":"), getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(t("debugger"), semiOp());
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(t("do"), body, t("while"), paren(test), semiOp());
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return semi();
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? paren(expression) : expression, semiOp());
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = paren(left);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(leftP, t("in"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(left.startsWithLet ? paren(left) : left, t("of"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(init ? noIn(markContainsIn(init)) : empty(), semi(), test || empty(), semi(), update || empty())), body), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(t("function"), node.isGenerator ? t("*") : empty(), node.name.name === "*default*" ? empty() : name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(t("function"), node.isGenerator ? t("*") : empty(), name ? name : empty(), paren(params), brace(body));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return commaSep(items.concat(rest == null ? [] : [seq(t("..."), rest)]));
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = paren(params);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = brace(body);
	      } else if (body.startsWithCurly) {
	        body = paren(body);
	      }
	      return seq(params, t("=>"), p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(t("get"), name, paren(empty()), brace(body));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = brace(consequent);
	      }
	      return (0, _objectAssign2.default)(seq(t("if"), paren(test), consequent, alternate ? seq(t("else"), alternate) : empty()), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(brace(commaSep(namedImports)));
	      }
	      if (bindings.length === 0) {
	        return seq(t("import"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	      }
	      return seq(t("import"), commaSep(bindings), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(t("import"), defaultBinding == null ? empty() : seq(defaultBinding, t(",")), t("*"), t("as"), namespaceBinding, t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(t(node.name), t("as"), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(t("export"), t("*"), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(t("export"), brace(commaSep(namedExports)), node.moduleSpecifier == null ? empty() : seq(t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp()));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, semiOp());
	      }
	      return seq(t("export"), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? paren(body) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, semiOp());
	      }
	      return seq(t("export default"), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return t(node.exportedName);
	      return seq(t(node.name), t("as"), t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(t(label + ":"), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? t("*") : empty(), name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? paren(callee) : p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(t("new"), calleeRep, args.length === 0 ? empty() : paren(commaSep(args)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return t("new.target");
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(p(node.operand, _coderep.Precedence.New, operand), t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(t(node.operator), p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(t("return"), expression || empty(), semiOp());
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(t("set"), name, paren(param), brace(body));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(t("case"), test, t(":"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(t("default:"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(cases))));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases)))));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : p(node.tag, (0, _coderep.getPrecedence)(node), tag);
	      var templateData = "";
	      state = seq(state, t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, t(d));
	        } else {
	          state = seq(state, elements[i]);
	        }
	      }
	      state = seq(state, t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(t("throw"), expression, semiOp());
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(t("try"), body, catchClause);
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(t("try"), body, catchClause || empty(), t("finally"), finalizer);
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return t("yield");
	      return seq(t("yield"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(t("yield"), t("*"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(t(delim + node.rawValue + delim), semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(t(node.kind), commaSep(declarators));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = paren(init);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, t("="), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(t("while"), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(t("with"), paren(object), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return MinimalCodeGen;
	}();

	exports.default = MinimalCodeGen;

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function ownEnumerableKeys(obj) {
		var keys = Object.getOwnPropertyNames(obj);

		if (Object.getOwnPropertySymbols) {
			keys = keys.concat(Object.getOwnPropertySymbols(obj));
		}

		return keys.filter(function (key) {
			return propIsEnumerable.call(obj, key);
		});
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = ownEnumerableKeys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrecedence = getPrecedence;
	exports.escapeStringLiteral = escapeStringLiteral;

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Precedence = {
	  Sequence: 0,
	  Yield: 1,
	  Assignment: 1,
	  Conditional: 2,
	  ArrowFunction: 2,
	  LogicalOR: 3,
	  LogicalAND: 4,
	  BitwiseOR: 5,
	  BitwiseXOR: 6,
	  BitwiseAND: 7,
	  Equality: 8,
	  Relational: 9,
	  BitwiseSHIFT: 10,
	  Additive: 11,
	  Multiplicative: 12,
	  Prefix: 13,
	  Postfix: 14,
	  New: 15,
	  Call: 16,
	  TaggedTemplate: 17,
	  Member: 18,
	  Primary: 19
	};

	exports.Precedence = Precedence;

	var BinaryPrecedence = {
	  ",": Precedence.Sequence,
	  "||": Precedence.LogicalOR,
	  "&&": Precedence.LogicalAND,
	  "|": Precedence.BitwiseOR,
	  "^": Precedence.BitwiseXOR,
	  "&": Precedence.BitwiseAND,
	  "==": Precedence.Equality,
	  "!=": Precedence.Equality,
	  "===": Precedence.Equality,
	  "!==": Precedence.Equality,
	  "<": Precedence.Relational,
	  ">": Precedence.Relational,
	  "<=": Precedence.Relational,
	  ">=": Precedence.Relational,
	  "in": Precedence.Relational,
	  "instanceof": Precedence.Relational,
	  "<<": Precedence.BitwiseSHIFT,
	  ">>": Precedence.BitwiseSHIFT,
	  ">>>": Precedence.BitwiseSHIFT,
	  "+": Precedence.Additive,
	  "-": Precedence.Additive,
	  "*": Precedence.Multiplicative,
	  "%": Precedence.Multiplicative,
	  "/": Precedence.Multiplicative
	};

	function getPrecedence(node) {
	  switch (node.type) {
	    case "ArrayExpression":
	    case "FunctionExpression":
	    case "IdentifierExpression":
	    case "LiteralBooleanExpression":
	    case "LiteralNullExpression":
	    case "LiteralNumericExpression":
	    case "LiteralInfinityExpression":
	    case "LiteralRegExpExpression":
	    case "LiteralStringExpression":
	    case "ObjectExpression":
	    case "ThisExpression":
	      return Precedence.Primary;

	    case "ArrowExpression":
	    case "AssignmentExpression":
	    case "CompoundAssignmentExpression":
	    case "YieldExpression":
	    case "YieldGeneratorExpression":
	      return Precedence.Assignment;

	    case "ConditionalExpression":
	      return Precedence.Conditional;

	    case "ComputedMemberExpression":
	    case "StaticMemberExpression":
	      switch (node.object.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.object);
	        default:
	          return Precedence.Member;
	      }

	    case "TemplateExpression":
	      if (node.tag == null) return Precedence.Member;
	      switch (node.tag.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.tag);
	        default:
	          return Precedence.Member;
	      }

	    case "BinaryExpression":
	      return BinaryPrecedence[node.operator];

	    case "CallExpression":
	      return Precedence.Call;
	    case "NewExpression":
	      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;
	    case "UpdateExpression":
	      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;
	    case "UnaryExpression":
	      return Precedence.Prefix;
	  }
	}

	function escapeStringLiteral(stringValue) {
	  var result = "";
	  var nSingle = 0,
	      nDouble = 0;
	  for (var i = 0, l = stringValue.length; i < l; ++i) {
	    var ch = stringValue[i];
	    if (ch === "\"") {
	      ++nDouble;
	    } else if (ch === "'") {
	      ++nSingle;
	    }
	  }
	  var delim = nDouble > nSingle ? "'" : "\"";
	  result += delim;
	  for (var i = 0; i < stringValue.length; i++) {
	    var ch = stringValue.charAt(i);
	    switch (ch) {
	      case delim:
	        result += "\\" + delim;
	        break;
	      case "\b":
	        result += "\\b";
	        break;
	      case "\t":
	        result += "\\t";
	        break;
	      case "\n":
	        result += "\\n";
	        break;
	      case "\u000b":
	        result += "\\v";
	        break;
	      case "\f":
	        result += "\\f";
	        break;
	      case "\r":
	        result += "\\r";
	        break;
	      case "\\":
	        result += "\\\\";
	        break;
	      case "\u2028":
	        result += "\\u2028";
	        break;
	      case "\u2029":
	        result += "\\u2029";
	        break;
	      default:
	        result += ch;
	        break;
	    }
	  }
	  result += delim;
	  return result;
	}

	var CodeRep = exports.CodeRep = function () {
	  function CodeRep() {
	    _classCallCheck(this, CodeRep);

	    this.containsIn = false;
	    this.containsGroup = false;
	    // restricted lookaheads: {, function, class, let, let [
	    this.startsWithCurly = false;
	    this.startsWithFunctionOrClass = false;
	    this.startsWithLet = false;
	    this.startsWithLetSquareBracket = false;
	    this.endsWithMissingElse = false;
	  }

	  _createClass(CodeRep, [{
	    key: "forEach",
	    value: function forEach(f) {
	      // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.
	      f(this);
	    }
	  }]);

	  return CodeRep;
	}();

	var Empty = exports.Empty = function (_CodeRep) {
	  _inherits(Empty, _CodeRep);

	  function Empty() {
	    _classCallCheck(this, Empty);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Empty).call(this));
	  }

	  _createClass(Empty, [{
	    key: "emit",
	    value: function emit() {}
	  }]);

	  return Empty;
	}(CodeRep);

	var Token = exports.Token = function (_CodeRep2) {
	  _inherits(Token, _CodeRep2);

	  function Token(token) {
	    _classCallCheck(this, Token);

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Token).call(this));

	    _this2.token = token;
	    return _this2;
	  }

	  _createClass(Token, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put(this.token);
	    }
	  }]);

	  return Token;
	}(CodeRep);

	var NumberCodeRep = exports.NumberCodeRep = function (_CodeRep3) {
	  _inherits(NumberCodeRep, _CodeRep3);

	  function NumberCodeRep(number) {
	    _classCallCheck(this, NumberCodeRep);

	    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberCodeRep).call(this));

	    _this3.number = number;
	    return _this3;
	  }

	  _createClass(NumberCodeRep, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putNumber(this.number);
	    }
	  }]);

	  return NumberCodeRep;
	}(CodeRep);

	var Paren = exports.Paren = function (_CodeRep4) {
	  _inherits(Paren, _CodeRep4);

	  function Paren(expr) {
	    _classCallCheck(this, Paren);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Paren).call(this));

	    _this4.expr = expr;
	    return _this4;
	  }

	  _createClass(Paren, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("(");
	      this.expr.emit(ts, false);
	      ts.put(")");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Paren;
	}(CodeRep);

	var Bracket = exports.Bracket = function (_CodeRep5) {
	  _inherits(Bracket, _CodeRep5);

	  function Bracket(expr) {
	    _classCallCheck(this, Bracket);

	    var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Bracket).call(this));

	    _this5.expr = expr;
	    return _this5;
	  }

	  _createClass(Bracket, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("[");
	      this.expr.emit(ts, false);
	      ts.put("]");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Bracket;
	}(CodeRep);

	var Brace = exports.Brace = function (_CodeRep6) {
	  _inherits(Brace, _CodeRep6);

	  function Brace(expr) {
	    _classCallCheck(this, Brace);

	    var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(Brace).call(this));

	    _this6.expr = expr;
	    return _this6;
	  }

	  _createClass(Brace, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("{");
	      this.expr.emit(ts, false);
	      ts.put("}");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Brace;
	}(CodeRep);

	var NoIn = exports.NoIn = function (_CodeRep7) {
	  _inherits(NoIn, _CodeRep7);

	  function NoIn(expr) {
	    _classCallCheck(this, NoIn);

	    var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(NoIn).call(this));

	    _this7.expr = expr;
	    return _this7;
	  }

	  _createClass(NoIn, [{
	    key: "emit",
	    value: function emit(ts) {
	      this.expr.emit(ts, true);
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return NoIn;
	}(CodeRep);

	var ContainsIn = exports.ContainsIn = function (_CodeRep8) {
	  _inherits(ContainsIn, _CodeRep8);

	  function ContainsIn(expr) {
	    _classCallCheck(this, ContainsIn);

	    var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainsIn).call(this));

	    _this8.expr = expr;
	    return _this8;
	  }

	  _createClass(ContainsIn, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      if (noIn) {
	        ts.put("(");
	        this.expr.emit(ts, false);
	        ts.put(")");
	      } else {
	        this.expr.emit(ts, false);
	      }
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return ContainsIn;
	}(CodeRep);

	var Seq = exports.Seq = function (_CodeRep9) {
	  _inherits(Seq, _CodeRep9);

	  function Seq(children) {
	    _classCallCheck(this, Seq);

	    var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(Seq).call(this));

	    _this9.children = children;
	    return _this9;
	  }

	  _createClass(Seq, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      this.children.forEach(function (cr) {
	        return cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return Seq;
	}(CodeRep);

	var Semi = exports.Semi = function (_Token) {
	  _inherits(Semi, _Token);

	  function Semi() {
	    _classCallCheck(this, Semi);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Semi).call(this, ";"));
	  }

	  return Semi;
	}(Token);

	var CommaSep = exports.CommaSep = function (_CodeRep10) {
	  _inherits(CommaSep, _CodeRep10);

	  function CommaSep(children) {
	    _classCallCheck(this, CommaSep);

	    var _this11 = _possibleConstructorReturn(this, Object.getPrototypeOf(CommaSep).call(this));

	    _this11.children = children;
	    return _this11;
	  }

	  _createClass(CommaSep, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      var first = true;
	      this.children.forEach(function (cr) {
	        if (first) {
	          first = false;
	        } else {
	          ts.put(",");
	        }
	        cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return CommaSep;
	}(CodeRep);

	var SemiOp = exports.SemiOp = function (_CodeRep11) {
	  _inherits(SemiOp, _CodeRep11);

	  function SemiOp() {
	    _classCallCheck(this, SemiOp);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SemiOp).call(this));
	  }

	  _createClass(SemiOp, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putOptionalSemi();
	    }
	  }]);

	  return SemiOp;
	}(CodeRep);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.Sep = undefined;

	var _objectAssign = __webpack_require__(39);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(6);

	var _coderep = __webpack_require__(40);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function empty() {
	  return new _coderep.Empty();
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function isEmpty(codeRep) {
	  return codeRep instanceof _coderep.Empty || codeRep instanceof Linebreak || codeRep instanceof _coderep.Seq && codeRep.children.every(isEmpty);
	}

	var Sep = {};
	var separatorNames = ["ARRAY_EMPTY", "ARRAY_BEFORE_COMMA", "ARRAY_AFTER_COMMA", "SPREAD", "BEFORE_DEFAULT_EQUALS", "AFTER_DEFAULT_EQUALS", "REST", "OBJECT_BEFORE_COMMA", "OBJECT_AFTER_COMMA", "BEFORE_PROP", "AFTER_PROP", "BEFORE_JUMP_LABEL", "ARGS_BEFORE_COMMA", "ARGS_AFTER_COMMA", "CALL", "BEFORE_CATCH_BINDING", "AFTER_CATCH_BINDING", "BEFORE_CLASS_NAME", "BEFORE_EXTENDS", "AFTER_EXTENDS", "BEFORE_CLASS_DECLARATION_ELEMENTS", "BEFORE_CLASS_EXPRESSION_ELEMENTS", "AFTER_STATIC", "BEFORE_CLASS_ELEMENT", "AFTER_CLASS_ELEMENT", "BEFORE_TERNARY_QUESTION", "AFTER_TERNARY_QUESTION", "BEFORE_TERNARY_COLON", "AFTER_TERNARY_COLON", "COMPUTED_MEMBER_EXPRESSION", "AFTER_DO", "BEFORE_DOWHILE_WHILE", "AFTER_DOWHILE_WHILE", "AFTER_FORIN_FOR", "BEFORE_FORIN_IN", "AFTER_FORIN_FOR", "BEFORE_FORIN_BODY", "AFTER_FOROF_FOR", "BEFORE_FOROF_OF", "AFTER_FOROF_FOR", "BEFORE_FOROF_BODY", "AFTER_FOR_FOR", "BEFORE_FOR_INIT", "AFTER_FOR_INIT", "EMPTY_FOR_INIT", "BEFORE_FOR_TEST", "AFTER_FOR_TEST", "EMPTY_FOR_TEST", "BEFORE_FOR_UPDATE", "AFTER_FOR_UPDATE", "EMPTY_FOR_UPDATE", "BEFORE_FOR_BODY", "BEFORE_GENERATOR_STAR", "AFTER_GENERATOR_STAR", "BEFORE_FUNCTION_PARAMS", "BEFORE_FUNCTION_DECLARATION_BODY", "BEFORE_FUNCTION_EXPRESSION_BODY", "AFTER_FUNCTION_DIRECTIVES", "BEFORE_ARROW", "AFTER_ARROW", "AFTER_GET", "BEFORE_GET_PARAMS", "BEFORE_GET_BODY", "AFTER_IF", "AFTER_IF_TEST", "BEFORE_ELSE", "AFTER_ELSE", "PARAMETER_BEFORE_COMMA", "PARAMETER_AFTER_COMMA", "NAMED_IMPORT_BEFORE_COMMA", "NAMED_IMPORT_AFTER_COMMA", "IMPORT_BEFORE_COMMA", "IMPORT_AFTER_COMMA", "BEFORE_IMPORT_BINDINGS", "BEFORE_IMPORT_MODULE", "AFTER_IMPORT_BINDINGS", "AFTER_FROM", "BEFORE_IMPORT_NAMESPACE", "BEFORE_IMPORT_STAR", "AFTER_IMPORT_STAR", "AFTER_IMPORT_AS", "AFTER_NAMESPACE_BINDING", "BEFORE_IMPORT_AS", "AFTER_IMPORT_AS", "EXPORTS_BEFORE_COMMA", "EXPORTS_AFTER_COMMA", "BEFORE_EXPORT_STAR", "AFTER_EXPORT_STAR", "BEFORE_EXPORT_BINDINGS", "AFTER_EXPORT_BINDINGS", "AFTER_EXPORT", "EXPORT_DEFAULT", "AFTER_EXPORT_DEFAULT", "BEFORE_EXPORT_AS", "AFTER_EXPORT_AS", "BEFORE_LABEL_COLON", "AFTER_LABEL_COLON", "AFTER_METHOD_GENERATOR_STAR", "AFTER_METHOD_NAME", "BEFORE_METHOD_BODY", "AFTER_MODULE_DIRECTIVES", "AFTER_NEW", "BEFORE_NEW_ARGS", "EMPTY_NEW_CALL", "NEW_TARGET_BEFORE_DOT", "NEW_TARGET_AFTER_DOT", "RETURN", "AFTER_SET", "BEFORE_SET_PARAMS", "BEFORE_SET_BODY", "AFTER_SCRIPT_DIRECTIVES", "BEFORE_STATIC_MEMBER_DOT", "AFTER_STATIC_MEMBER_DOT", "BEFORE_CASE_TEST", "AFTER_CASE_TEST", "BEFORE_CASE_BODY", "AFTER_CASE_BODY", "DEFAULT", "AFTER_DEFAULT_BODY", "BEFORE_SWITCH_DISCRIM", "BEFORE_SWITCH_BODY", "TEMPLATE_TAG", "BEFORE_TEMPLATE_EXPRESSION", "AFTER_TEMPLATE_EXPRESSION", "THROW", "AFTER_TRY", "BEFORE_CATCH", "BEFORE_FINALLY", "AFTER_FINALLY", "VARIABLE_DECLARATION", "YIELD", "BEFORE_YIELD_STAR", "AFTER_YIELD_STAR", "DECLARATORS_BEFORE_COMMA", "DECLARATORS_AFTER_COMMA", "BEFORE_INIT_EQUALS", "AFTER_INIT_EQUALS", "AFTER_WHILE", "BEFORE_WHILE_BODY", "AFTER_WITH", "BEFORE_WITH_BODY", "PAREN_AVOIDING_DIRECTIVE_BEFORE", "PAREN_AVOIDING_DIRECTIVE_AFTER", "PRECEDENCE_BEFORE", "PRECEDENCE_AFTER", "EXPRESSION_PAREN_BEFORE", "EXPRESSION_PAREN_AFTER", "CALL_PAREN_BEFORE", "CALL_PAREN_AFTER", "CALL_PAREN_EMPTY", "CATCH_PAREN_BEFORE", "CATCH_PAREN_AFTER", "DO_WHILE_TEST_PAREN_BEFORE", "DO_WHILE_TEST_PAREN_AFTER", "EXPRESSION_STATEMENT_PAREN_BEFORE", "EXPRESSION_STATEMENT_PAREN_AFTER", "FOR_IN_LET_PAREN_BEFORE", "FOR_IN_LET_PAREN_AFTER", "FOR_IN_PAREN_BEFORE", "FOR_IN_PAREN_AFTER", "FOR_OF_LET_PAREN_BEFORE", "FOR_OF_LET_PAREN_AFTER", "FOR_OF_PAREN_BEFORE", "FOR_OF_PAREN_AFTER", "PARAMETERS_PAREN_BEFORE", "PARAMETERS_PAREN_AFTER", "PARAMETERS_PAREN_EMPTY", "ARROW_PARAMETERS_PAREN_BEFORE", "ARROW_PARAMETERS_PAREN_AFTER", "ARROW_PARAMETERS_PAREN_EMPTY", "ARROW_BODY_PAREN_BEFORE", "ARROW_BODY_PAREN_AFTER", "GETTER_PARAMS", "IF_PAREN_BEFORE", "IF_PAREN_AFTER", "EXPORT_PAREN_BEFORE", "EXPORT_PAREN_AFTER", "NEW_CALLEE_PAREN_BEFORE", "NEW_CALLEE_PAREN_AFTER", "NEW_PAREN_BEFORE", "NEW_PAREN_AFTER", "NEW_PAREN_EMPTY", "SETTER_PARAM_BEFORE", "SETTER_PARAM_AFTER", "SWITCH_DISCRIM_PAREN_BEFORE", "SWITCH_DISCRIM_PAREN_AFTER", "WHILE_TEST_PAREN_BEFORE", "WHILE_TEST_PAREN_AFTER", "WITH_PAREN_BEFORE", "WITH_PAREN_AFTER", "OBJECT_BRACE_INITIAL", "OBJECT_BRACE_FINAL", "OBJECT_EMPTY", "BLOCK_BRACE_INITIAL", "BLOCK_BRACE_FINAL", "BLOCK_EMPTY", "CLASS_BRACE_INITIAL", "CLASS_BRACE_FINAL", "CLASS_EMPTY", "CLASS_EXPRESSION_BRACE_INITIAL", "CLASS_EXPRESSION_BRACE_FINAL", "CLASS_EXPRESSION_BRACE_EMPTY", "FUNCTION_BRACE_INITIAL", "FUNCTION_BRACE_FINAL", "FUNCTION_EMPTY", "FUNCTION_EXPRESSION_BRACE_INITIAL", "FUNCTION_EXPRESSION_BRACE_FINAL", "FUNCTION_EXPRESSION_EMPTY", "ARROW_BRACE_INITIAL", "ARROW_BRACE_FINAL", "ARROW_BRACE_EMPTY", "GET_BRACE_INTIAL", "GET_BRACE_FINAL", "GET_BRACE_EMPTY", "MISSING_ELSE_INTIIAL", "MISSING_ELSE_FINAL", "MISSING_ELSE_EMPTY", "IMPORT_BRACE_INTIAL", "IMPORT_BRACE_FINAL", "IMPORT_BRACE_EMPTY", "EXPORT_BRACE_INITIAL", "EXPORT_BRACE_FINAL", "EXPORT_BRACE_EMPTY", "METHOD_BRACE_INTIAL", "METHOD_BRACE_FINAL", "METHOD_BRACE_EMPTY", "SET_BRACE_INTIIAL", "SET_BRACE_FINAL", "SET_BRACE_EMPTY", "SWITCH_BRACE_INTIAL", "SWITCH_BRACE_FINAL", "SWITCH_BRACE_EMPTY", "ARRAY_INITIAL", "ARRAY_FINAL", "COMPUTED_MEMBER_BRACKET_INTIAL", "COMPUTED_MEMBER_BRACKET_FINAL", "COMPUTED_PROPERTY_BRACKET_INTIAL", "COMPUTED_PROPERTY_BRACKET_FINAL"];
	for (var i = 0; i < separatorNames.length; ++i) {
	  Sep[separatorNames[i]] = { type: separatorNames[i] };
	}

	Sep.BEFORE_ASSIGN_OP = function (op) {
	  return {
	    type: "BEFORE_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.AFTER_ASSIGN_OP = function (op) {
	  return {
	    type: "AFTER_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.BEFORE_BINOP = function (op) {
	  return {
	    type: "BEFORE_BINOP",
	    op: op
	  };
	};

	Sep.AFTER_BINOP = function (op) {
	  return {
	    type: "AFTER_BINOP",
	    op: op
	  };
	};

	Sep.BEFORE_POSTFIX = function (op) {
	  return {
	    type: "BEFORE_POSTFIX",
	    op: op
	  };
	};

	Sep.UNARY = function (op) {
	  return {
	    type: "UNARY",
	    op: op
	  };
	};

	Sep.AFTER_STATEMENT = function (node) {
	  return {
	    type: "AFTER_STATEMENT",
	    node: node
	  };
	};

	Sep.BEFORE_FUNCTION_NAME = function (node) {
	  return {
	    type: "BEFORE_FUNCTION_NAME",
	    node: node
	  };
	};
	exports.Sep = Sep;

	var ExtensibleCodeGen = exports.ExtensibleCodeGen = function () {
	  function ExtensibleCodeGen() {
	    _classCallCheck(this, ExtensibleCodeGen);
	  }

	  _createClass(ExtensibleCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "t",
	    value: function t(token) {
	      return new _coderep.Token(token);
	    }
	  }, {
	    key: "p",
	    value: function p(node, precedence, a) {
	      return (0, _coderep.getPrecedence)(node) < precedence ? this.paren(a, Sep.PRECEDENCE_BEFORE, Sep.PRECEDENCE_AFTER) : a;
	    }
	  }, {
	    key: "getAssignmentExpr",
	    value: function getAssignmentExpr(state) {
	      return state ? state.containsGroup ? this.paren(state, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER) : state : empty();
	    }
	  }, {
	    key: "paren",
	    value: function paren(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Paren(this.sep(empty));
	      }
	      return new _coderep.Paren(seq(first ? this.sep(first) : new _coderep.Empty(), rep, last ? this.sep(last) : new _coderep.Empty()));
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Brace(this.sep(empty));
	      }
	      return new _coderep.Brace(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "bracket",
	    value: function bracket(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Bracket(this.sep(empty));
	      }
	      return new _coderep.Bracket(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "commaSep",
	    value: function commaSep(pieces, before, after) {
	      var _this = this;

	      var first = true;
	      pieces = pieces.map(function (p) {
	        if (first) {
	          first = false;
	          return p;
	        } else {
	          return seq(_this.sep(before), _this.t(","), _this.sep(after), p);
	        }
	      });
	      return seq.apply(undefined, _toConsumableArray(pieces));
	    }
	  }, {
	    key: "semiOp",
	    value: function semiOp() {
	      return new _coderep.SemiOp();
	    }
	  }, {
	    key: "sep",
	    value: function sep(kind) {
	      return new _coderep.Empty();
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var _this2 = this;

	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return this.bracket(empty(), null, null, Sep.ARRAY_EMPTY);
	      }

	      var content = this.commaSep(elements.map(function (e) {
	        return _this2.getAssignmentExpr(e);
	      }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(this.t("..."), this.sep(Sep.SPREAD), this.p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP("=")), this.t("="), this.sep(Sep.AFTER_ASSIGN_OP("=")), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_ASSIGN_OP(node.operator)), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = this.paren(leftCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_BINOP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_BINOP(node.operator)), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var _this3 = this;

	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), restElement)]);
	        content = this.commaSep(elements.map(function (e) {
	          return _this3.getAssignmentExpr(e);
	        }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	        }
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return this.brace(seq.apply(undefined, _toConsumableArray(statements)), node, Sep.BLOCK_BRACE_INITIAL, Sep.BLOCK_BRACE_FINAL, Sep.BLOCK_EMPTY);
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return seq(block, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(this.t("break"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(this.p(node.callee, (0, _coderep.getPrecedence)(node), callee), this.sep(Sep.CALL), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.CALL_PAREN_BEFORE, Sep.CALL_PAREN_AFTER, Sep.CALL_PAREN_EMPTY)), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(this.t("catch"), this.sep(Sep.BEFORE_CATCH_BINDING), this.paren(binding, Sep.CATCH_PAREN_BEFORE, Sep.CATCH_PAREN_AFTER), this.sep(Sep.AFTER_CATCH_BINDING), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(this.t("class"), this.sep(Sep.BEFORE_CLASS_NAME), name);
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_DECLARATION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_BRACE_INITIAL, Sep.CLASS_BRACE_FINAL, Sep.CLASS_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = this.t("class");
	      if (name != null) {
	        state = seq(state, this.sep(Sep.BEFORE_CLASS_NAME), name);
	      }
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_EXPRESSION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_EXPRESSION_BRACE_INITIAL, Sep.CLASS_EXPRESSION_BRACE_FINAL, Sep.CLASS_EXPRESSION_BRACE_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      method = seq(this.sep(Sep.BEFORE_CLASS_ELEMENT), method, this.sep(Sep.AFTER_CLASS_ELEMENT));
	      if (!node.isStatic) return method;
	      return seq(this.t("static"), this.sep(Sep.AFTER_STATIC), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_EXPRESSION), this.bracket(expression, Sep.COMPUTED_MEMBER_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_BRACKET_FINAL)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return this.bracket(expression, Sep.COMPUTED_PROPERTY_BRACKET_INTIAL, Sep.COMPUTED_PROPERTY_BRACKET_FINAL);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(this.p(node.test, _coderep.Precedence.LogicalOR, test), this.sep(Sep.BEFORE_TERNARY_QUESTION), this.t("?"), this.sep(Sep.AFTER_TERNARY_QUESTION), this.p(node.consequent, _coderep.Precedence.Assignment, consequent), this.sep(Sep.BEFORE_TERNARY_COLON), this.t(":"), this.sep(Sep.AFTER_TERNARY_COLON), this.p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(this.t("continue"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), this.getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(this.t("debugger"), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), body, this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return seq(this.t(";"), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? this.paren(expression, Sep.EXPRESSION_STATEMENT_PAREN_BEFORE, Sep.EXPRESSION_STATEMENT_PAREN_AFTER) : expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = this.paren(left, Sep.FOR_IN_LET_PAREN_BEFORE, Sep.FOR_IN_LET_PAREN_BEFORE);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FORIN_FOR), this.paren(seq(leftP, this.sep(Sep.BEFORE_FORIN_IN), this.t("in"), this.sep(Sep.AFTER_FORIN_FOR), right), Sep.FOR_IN_PAREN_BEFORE, Sep.FOR_IN_PAREN_AFTER), this.sep(Sep.BEFORE_FORIN_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOROF_FOR), this.paren(seq(left.startsWithLet ? this.paren(left, Sep.FOR_OF_LET_PAREN_BEFORE, Sep.FOR_OF_LET_PAREN_AFTER) : left, this.sep(Sep.BEFORE_FOROF_OF), this.t("of"), this.sep(Sep.AFTER_FOROF_FOR), right), Sep.FOR_OF_PAREN_BEFORE, Sep.FOR_OF_PAREN_AFTER), this.sep(Sep.BEFORE_FOROF_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOR_FOR), this.paren(seq(init ? seq(this.sep(Sep.BEFORE_FOR_INIT), noIn(markContainsIn(init)), this.sep(Sep.AFTER_FOR_INIT)) : this.sep(Sep.EMPTY_FOR_INIT), this.t(";"), test ? seq(this.sep(Sep.BEFORE_FOR_TEST), test, this.sep(Sep.AFTER_FOR_TEST)) : this.sep(Sep.EMPTY_FOR_TEST), this.t(";"), update ? seq(this.sep(Sep.BEFORE_FOR_UPDATE), update, this.sep(Sep.AFTER_FOR_UPDATE)) : this.sep(Sep.EMPTY_FOR_UPDATE))), this.sep(Sep.BEFORE_FOR_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_FUNCTION_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), node.name.name === "*default*" ? empty() : name, this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_DECLARATION_BODY), this.brace(body, node, Sep.FUNCTION_BRACE_INITIAL, Sep.FUNCTION_BRACE_FINAL, Sep.FUNCTION_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), name ? name : empty(), this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_EXPRESSION_BODY), this.brace(body, node, Sep.FUNCTION_EXPRESSION_BRACE_INITIAL, Sep.FUNCTION_EXPRESSION_BRACE_FINAL, Sep.FUNCTION_EXPRESSION_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return this.commaSep(items.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]), Sep.PARAMETER_BEFORE_COMMA, Sep.PARAMETER_AFTER_COMMA);
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = this.paren(params, Sep.ARROW_PARAMETERS_PAREN_BEFORE, Sep.ARROW_PARAMETERS_PAREN_AFTER, Sep.ARROW_PARAMETERS_PAREN_EMPTY);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = this.brace(body, node, Sep.ARROW_BRACE_INITIAL, Sep.ARROW_BRACE_FINAL, Sep.ARROW_BRACE_EMPTY);
	      } else if (body.startsWithCurly) {
	        body = this.paren(body, Sep.ARROW_BODY_PAREN_BEFORE, Sep.ARROW_BODY_PAREN_AFTER);
	      }
	      return seq(params, this.sep(Sep.BEFORE_ARROW), this.t("=>"), this.sep(Sep.AFTER_ARROW), this.p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(this.t("get"), this.sep(Sep.AFTER_GET), name, this.sep(Sep.BEFORE_GET_PARAMS), this.paren(empty(), null, null, Sep.GETTER_PARAMS), this.sep(Sep.BEFORE_GET_BODY), this.brace(body, node, Sep.GET_BRACE_INTIAL, Sep.GET_BRACE_FINAL, Sep.GET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node, Sep.MISSING_ELSE_INTIIAL, Sep.MISSING_ELSE_FINAL, Sep.MISSING_ELSE_EMPTY);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), consequent, alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), alternate) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(this.brace(this.commaSep(namedImports, Sep.NAMED_IMPORT_BEFORE_COMMA, Sep.NAMED_IMPORT_AFTER_COMMA), node, Sep.IMPORT_BRACE_INTIAL, Sep.IMPORT_BRACE_FINAL, Sep.IMPORT_BRACE_EMPTY));
	      }
	      if (bindings.length === 0) {
	        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_MODULE), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_BINDINGS), this.commaSep(bindings, Sep.IMPORT_BEFORE_COMMA, Sep.IMPORT_AFTER_COMMA), this.sep(Sep.AFTER_IMPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_NAMESPACE), defaultBinding == null ? empty() : seq(defaultBinding, this.sep(Sep.IMPORT_BEFORE_COMMA), this.t(","), this.sep(Sep.IMPORT_AFTER_COMMA)), this.sep(Sep.BEFORE_IMPORT_STAR), this.t("*"), this.sep(Sep.AFTER_IMPORT_STAR), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), namespaceBinding, this.sep(Sep.AFTER_NAMESPACE_BINDING), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_IMPORT_AS), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_STAR), this.t("*"), this.sep(Sep.AFTER_EXPORT_STAR), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), node.moduleSpecifier == null ? empty() : seq(this.sep(Sep.AFTER_EXPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node))));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.AFTER_EXPORT), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? this.paren(body, Sep.EXPORT_PAREN_BEFORE, Sep.EXPORT_PAREN_AFTER) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return this.t(node.exportedName);
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(this.t(label), this.sep(Sep.BEFORE_LABEL_COLON), this.t(":"), this.sep(Sep.AFTER_LABEL_COLON), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return this.t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return this.t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return this.t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return this.t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? seq(this.t("*"), this.sep(Sep.AFTER_METHOD_GENERATOR_STAR)) : empty(), name, this.sep(Sep.AFTER_METHOD_NAME), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_METHOD_BODY), this.brace(body, node, Sep.METHOD_BRACE_INTIAL, Sep.METHOD_BRACE_FINAL, Sep.METHOD_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_MODULE_DIRECTIVES) : empty()], _toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? this.paren(callee, Sep.NEW_CALLEE_PAREN_BEFORE, Sep.NEW_CALLEE_PAREN_AFTER) : this.p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(this.t("new"), this.sep(Sep.AFTER_NEW), calleeRep, args.length === 0 ? this.sep(Sep.EMPTY_NEW_CALL) : seq(this.sep(Sep.BEFORE_NEW_ARGS), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.NEW_PAREN_BEFORE, Sep.NEW_PAREN_AFTER, Sep.NEW_PAREN_EMPTY)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return seq(this.t("new"), this.sep(Sep.NEW_TARGET_BEFORE_DOT), this.t("."), this.sep(Sep.NEW_TARGET_AFTER_DOT), this.t("target"));
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(this.p(node.operand, _coderep.Precedence.New, operand), this.sep(Sep.BEFORE_POSTFIX(node.operator)), this.t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(this.t(node.operator), this.sep(Sep.UNARY(node.operator)), this.p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(this.t("return"), expression ? seq(this.sep(Sep.RETURN), expression) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_SCRIPT_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(this.t("set"), this.sep(Sep.AFTER_SET), name, this.sep(Sep.BEFORE_SET_PARAMS), this.paren(param, Sep.SETTER_PARAM_BEFORE, Sep.SETTER_PARAM_AFTER), this.sep(Sep.BEFORE_SET_BODY), this.brace(body, node, Sep.SET_BRACE_INTIIAL, Sep.SET_BRACE_FINAL, Sep.SET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return this.t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_DOT), this.t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return this.t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return this.t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(cases)), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases))), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : seq(this.p(node.tag, (0, _coderep.getPrecedence)(node), tag), this.sep(Sep.TEMPLATE_TAG));
	      var templateData = "";
	      state = seq(state, this.t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, this.t(d));
	        } else {
	          state = seq(state, this.sep(Sep.BEFORE_TEMPLATE_EXPRESSION), elements[i], this.sep(Sep.AFTER_TEMPLATE_EXPRESSION));
	        }
	      }
	      state = seq(state, this.t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return this.t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return this.t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(this.t("throw"), this.sep(Sep.THROW), expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, this.sep(Sep.BEFORE_CATCH), catchClause, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, catchClause ? seq(this.sep(Sep.BEFORE_CATCH), catchClause) : empty(), this.sep(Sep.BEFORE_FINALLY), this.t("finally"), this.sep(Sep.AFTER_FINALLY), finalizer, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return this.t("yield");
	      return seq(this.t("yield"), this.sep(Sep.YIELD), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(this.t("yield"), this.sep(Sep.BEFORE_YIELD_STAR), this.t("*"), this.sep(Sep.AFTER_YIELD_STAR), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(this.t(delim + node.rawValue + delim), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(this.t(node.kind), this.sep(Sep.VARIABLE_DECLARATION), this.commaSep(declarators, Sep.DECLARATORS_BEFORE_COMMA, Sep.DECLARATORS_AFTER_COMMA));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = this.paren(init, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, this.sep(Sep.BEFORE_INIT_EQUALS), this.t("="), this.sep(Sep.AFTER_INIT_EQUALS), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(this.t("while"), this.sep(Sep.AFTER_WHILE), this.paren(test, Sep.WHILE_TEST_PAREN_BEFORE, Sep.WHILE_TEST_PAREN_AFTER), this.sep(Sep.BEFORE_WHILE_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(this.t("with"), this.sep(Sep.AFTER_WITH), this.paren(object, Sep.WITH_PAREN_BEFORE, Sep.WITH_PAREN_AFTER), this.sep(Sep.BEFORE_WITH_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return ExtensibleCodeGen;
	}();

	var INDENT = "  ";

	var Linebreak = function (_CodeRep) {
	  _inherits(Linebreak, _CodeRep);

	  function Linebreak() {
	    _classCallCheck(this, Linebreak);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Linebreak).call(this));

	    _this4.indentation = 0;
	    return _this4;
	  }

	  _createClass(Linebreak, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("\n");
	      for (var i = 0; i < this.indentation; ++i) {
	        ts.put(INDENT);
	      }
	    }
	  }]);

	  return Linebreak;
	}(_coderep.CodeRep);

	function withoutTrailingLinebreak(state) {
	  if (state && state instanceof _coderep.Seq) {
	    var lastChild = state.children[state.children.length - 1];
	    /* istanbul ignore next */
	    while (lastChild instanceof _coderep.Empty) {
	      state.children.pop();
	      lastChild = state.children[state.children.length - 1];
	    }
	    /* istanbul ignore else */
	    if (lastChild instanceof _coderep.Seq) {
	      withoutTrailingLinebreak(lastChild);
	    } else if (lastChild instanceof Linebreak) {
	      state.children.pop();
	    }
	  }
	  return state;
	}

	function indent(rep, includingFinal) {
	  var finalLinebreak = undefined;
	  function indentNode(node) {
	    if (node instanceof Linebreak) {
	      finalLinebreak = node;
	      ++node.indentation;
	    }
	  }
	  rep.forEach(indentNode);
	  if (!includingFinal) {
	    --finalLinebreak.indentation;
	  }
	  return rep;
	}

	var FormattedCodeGen = exports.FormattedCodeGen = function (_ExtensibleCodeGen) {
	  _inherits(FormattedCodeGen, _ExtensibleCodeGen);

	  function FormattedCodeGen() {
	    _classCallCheck(this, FormattedCodeGen);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(FormattedCodeGen).apply(this, arguments));
	  }

	  _createClass(FormattedCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(element)));
	      }
	      return original;
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node) {
	      if (isEmpty(rep)) {
	        return this.t("{}");
	      }

	      switch (node.type) {
	        case "ObjectBinding":
	        case "Import":
	        case "ExportFrom":
	        case "ObjectExpression":
	          return new _coderep.Brace(rep);
	      }

	      rep = seq(new Linebreak(), rep);
	      indent(rep, false);
	      return new _coderep.Brace(rep);
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref68) {
	      var body = _ref68.body;
	      var test = _ref68.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), withoutTrailingLinebreak(body), this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref69) {
	      var test = _ref69.test;
	      var consequent = _ref69.consequent;
	      var alternate = _ref69.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), withoutTrailingLinebreak(consequent), alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), withoutTrailingLinebreak(alternate)) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref70) {
	      var test = _ref70.test;
	      var consequent = _ref70.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), consequent, this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref71) {
	      var consequent = _ref71.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), consequent, this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "sep",
	    value: function sep(separator) {
	      switch (separator.type) {
	        case "ARRAY_AFTER_COMMA":
	        case "OBJECT_AFTER_COMMA":
	        case "ARGS_AFTER_COMMA":
	        case "PARAMETER_AFTER_COMMA":
	        case "DECLARATORS_AFTER_COMMA":
	        case "NAMED_IMPORT_AFTER_COMMA":
	        case "IMPORT_AFTER_COMMA":
	        case "BEFORE_DEFAULT_EQUALS":
	        case "AFTER_DEFAULT_EQUALS":
	        case "AFTER_PROP":
	        case "BEFORE_JUMP_LABEL":
	        case "BEFORE_CATCH":
	        case "BEFORE_CATCH_BINDING":
	        case "AFTER_CATCH_BINDING":
	        case "BEFORE_CLASS_NAME":
	        case "BEFORE_EXTENDS":
	        case "AFTER_EXTENDS":
	        case "BEFORE_CLASS_DECLARATION_ELEMENTS":
	        case "BEFORE_CLASS_EXPRESSION_ELEMENTS":
	        case "AFTER_STATIC":
	        case "BEFORE_TERNARY_QUESTION":
	        case "AFTER_TERNARY_QUESTION":
	        case "BEFORE_TERNARY_COLON":
	        case "AFTER_TERNARY_COLON":
	        case "AFTER_DO":
	        case "BEFORE_DOWHILE_WHILE":
	        case "AFTER_DOWHILE_WHILE":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_IN":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_BODY":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_OF":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_BODY":
	        case "AFTER_FOR_FOR":
	        case "BEFORE_FOR_TEST":
	        case "BEFORE_FOR_UPDATE":
	        case "BEFORE_FOR_BODY":
	        case "BEFORE_FUNCTION_DECLARATION_BODY":
	        case "BEFORE_FUNCTION_EXPRESSION_BODY":
	        case "BEFORE_ARROW":
	        case "AFTER_ARROW":
	        case "AFTER_GET":
	        case "BEFORE_GET_BODY":
	        case "AFTER_IF":
	        case "AFTER_IF_TEST":
	        case "BEFORE_ELSE":
	        case "AFTER_ELSE":
	        case "BEFORE_IMPORT_BINDINGS":
	        case "BEFORE_IMPORT_MODULE":
	        case "AFTER_IMPORT_BINDINGS":
	        case "AFTER_FROM":
	        case "BEFORE_IMPORT_NAMESPACE":
	        case "BEFORE_IMPORT_STAR":
	        case "AFTER_IMPORT_STAR":
	        case "AFTER_IMPORT_AS":
	        case "AFTER_NAMESPACE_BINDING":
	        case "BEFORE_IMPORT_AS":
	        case "AFTER_IMPORT_AS":
	        case "EXPORTS_AFTER_COMMA":
	        case "BEFORE_EXPORT_STAR":
	        case "AFTER_EXPORT_STAR":
	        case "BEFORE_EXPORT_BINDINGS":
	        case "AFTER_EXPORT_BINDINGS":
	        case "AFTER_EXPORT":
	        case "AFTER_EXPORT_DEFAULT":
	        case "BEFORE_EXPORT_AS":
	        case "AFTER_EXPORT_AS":
	        case "AFTER_LABEL_COLON":
	        case "BEFORE_METHOD_BODY":
	        case "AFTER_NEW":
	        case "RETURN":
	        case "AFTER_SET":
	        case "BEFORE_SET_BODY":
	        case "BEFORE_SET_PARAMS":
	        case "BEFORE_CASE_TEST":
	        case "BEFORE_SWITCH_DISCRIM":
	        case "BEFORE_SWITCH_BODY":
	        case "THROW":
	        case "AFTER_TRY":
	        case "BEFORE_CATCH":
	        case "BEFORE_FINALLY":
	        case "AFTER_FINALLY":
	        case "VARIABLE_DECLARATION":
	        case "YIELD":
	        case "AFTER_YIELD_STAR":
	        case "DECLARATORS_AFTER_COMMA":
	        case "BEFORE_INIT_EQUALS":
	        case "AFTER_INIT_EQUALS":
	        case "AFTER_WHILE":
	        case "BEFORE_WHILE_BODY":
	        case "AFTER_WITH":
	        case "BEFORE_WITH_BODY":
	        case "BEFORE_FUNCTION_NAME":
	        case "AFTER_BINOP":
	        case "BEFORE_ASSIGN_OP":
	        case "AFTER_ASSIGN_OP":
	          return this.t(" ");
	        case "AFTER_STATEMENT":
	          switch (separator.node.type) {
	            case "ForInStatement":
	            case "ForOfStatement":
	            case "ForStatement":
	            case "WhileStatement":
	            case "WithStatement":
	              return empty(); // because those already end with an AFTER_STATEMENT
	            default:
	              return new Linebreak();
	          }
	        case "AFTER_CLASS_ELEMENT":
	        case "BEFORE_CASE_BODY":
	        case "AFTER_CASE_BODY":
	        case "AFTER_DEFAULT_BODY":
	          return new Linebreak();
	        case "BEFORE_BINOP":
	          return separator.op === "," ? empty() : this.t(" ");
	        case "UNARY":
	          return separator.op === "delete" || separator.op === "void" || separator.op === "typeof" ? this.t(" ") : empty();
	        default:
	          return empty();
	      }
	    }
	  }]);

	  return FormattedCodeGen;
	}(ExtensibleCodeGen);

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TokenStream = undefined;

	var _esutils = __webpack_require__(6);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function numberDot(fragment) {
	  if (fragment.indexOf(".") < 0 && fragment.indexOf("e") < 0) {
	    return "..";
	  }
	  return ".";
	}

	function renderNumber(n) {
	  var s;
	  if (n >= 1e3 && n % 10 === 0) {
	    s = n.toString(10);
	    if (/[eE]/.test(s)) {
	      return s.replace(/[eE]\+/, "e");
	    }
	    return n.toString(10).replace(/0+$/, function (match) {
	      return "e" + match.length;
	    });
	  } else if (n % 1 === 0) {
	    if (n > 1e15 && n < 1e20) {
	      return "0x" + n.toString(16).toUpperCase();
	    }
	    return n.toString(10).replace(/[eE]\+/, "e");
	  } else {
	    return n.toString(10).replace(/^0\./, ".").replace(/[eE]\+/, "e");
	  }
	}

	var TokenStream = exports.TokenStream = function () {
	  function TokenStream() {
	    _classCallCheck(this, TokenStream);

	    this.result = "";
	    this.lastNumber = null;
	    this.lastChar = null;
	    this.optionalSemi = false;
	  }

	  _createClass(TokenStream, [{
	    key: "putNumber",
	    value: function putNumber(number) {
	      var tokenStr = renderNumber(number);
	      this.put(tokenStr);
	      this.lastNumber = tokenStr;
	    }
	  }, {
	    key: "putOptionalSemi",
	    value: function putOptionalSemi() {
	      this.optionalSemi = true;
	    }
	  }, {
	    key: "put",
	    value: function put(tokenStr) {
	      if (this.optionalSemi) {
	        this.optionalSemi = false;
	        if (tokenStr !== "}") {
	          this.put(";");
	        }
	      }
	      if (this.lastNumber !== null && tokenStr.length == 1) {
	        if (tokenStr === ".") {
	          this.result += numberDot(this.lastNumber);
	          this.lastNumber = null;
	          this.lastChar = ".";
	          return;
	        }
	      }
	      this.lastNumber = null;
	      var rightChar = tokenStr.charAt(0);
	      var lastChar = this.lastChar;
	      this.lastChar = tokenStr.charAt(tokenStr.length - 1);
	      if (lastChar && ((lastChar == "+" || lastChar == "-") && lastChar == rightChar || _esutils.code.isIdentifierPartES6(lastChar.charCodeAt(0)) && _esutils.code.isIdentifierPartES6(rightChar.charCodeAt(0)) || lastChar == "/" && rightChar == "i")) {
	        this.result += " ";
	      }

	      this.result += tokenStr;
	    }
	  }]);

	  return TokenStream;
	}();

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Scope = exports.freshScope = undefined;

	var _errors = __webpack_require__(13);

	var _symbol = __webpack_require__(44);

	let scopeIndex_586 = 0;
	function freshScope_587() {
	  let name_589 = arguments.length <= 0 || arguments[0] === undefined ? "scope" : arguments[0];

	  scopeIndex_586++;
	  return (0, _symbol.Symbol)(name_589 + "_" + scopeIndex_586);
	}
	;
	function Scope_588(name_590) {
	  return (0, _symbol.Symbol)(name_590);
	}
	exports.freshScope = freshScope_587;
	exports.Scope = Scope_588;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Njb3BlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQSxJQUFJLGlCQUFpQixDQUFyQjtBQUNBLFNBQVMsY0FBVCxHQUE0QztBQUFBLE1BQXBCLFFBQW9CLHlEQUFULE9BQVM7O0FBQzFDO0FBQ0EsU0FBTyxvQkFBTyxXQUFXLEdBQVgsR0FBaUIsY0FBeEIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsRUFBNkI7QUFDM0IsU0FBTyxvQkFBTyxRQUFQLENBQVA7QUFDRDtRQUN5QixVLEdBQWxCLGM7UUFDYSxLLEdBQWIsUyIsImZpbGUiOiJzY29wZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXhwZWN0LCBhc3NlcnR9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHtTeW1ib2wsIGdlbnN5bX0gZnJvbSBcIi4vc3ltYm9sXCI7XG5sZXQgc2NvcGVJbmRleF81ODYgPSAwO1xuZnVuY3Rpb24gZnJlc2hTY29wZV81ODcobmFtZV81ODkgPSBcInNjb3BlXCIpIHtcbiAgc2NvcGVJbmRleF81ODYrKztcbiAgcmV0dXJuIFN5bWJvbChuYW1lXzU4OSArIFwiX1wiICsgc2NvcGVJbmRleF81ODYpO1xufVxuO1xuZnVuY3Rpb24gU2NvcGVfNTg4KG5hbWVfNTkwKSB7XG4gIHJldHVybiBTeW1ib2wobmFtZV81OTApO1xufVxuZXhwb3J0IHtmcmVzaFNjb3BlXzU4NyBhcyBmcmVzaFNjb3BlfTtcbmV4cG9ydCB7U2NvcGVfNTg4IGFzIFNjb3BlfSJdfQ==

/***/ },
/* 44 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	let internedMap_776 = new Map();
	let counter_777 = 0;
	function gensym_778(name_781) {
	  let prefix_782 = name_781 == null ? "s_" : name_781 + "_";
	  let sym_783 = new Symbol_779(prefix_782 + counter_777);
	  counter_777++;
	  return sym_783;
	}
	function Symbol_779(name_784) {
	  this.name = name_784;
	}
	Symbol_779.prototype.toString = function () {
	  return this.name;
	};
	function makeSymbol_780(name_785) {
	  if (internedMap_776.has(name_785)) {
	    return internedMap_776.get(name_785);
	  } else {
	    let sym = new Symbol_779(name_785);
	    internedMap_776.set(name_785, sym);
	    return sym;
	  }
	}
	exports.Symbol = makeSymbol_780;
	exports.SymbolClass = Symbol_779;
	exports.gensym = gensym_778;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N5bWJvbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUksa0JBQWtCLElBQUksR0FBSixFQUF0QjtBQUNBLElBQUksY0FBYyxDQUFsQjtBQUNBLFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QjtBQUM1QixNQUFJLGFBQWEsWUFBWSxJQUFaLEdBQW1CLElBQW5CLEdBQTBCLFdBQVcsR0FBdEQ7QUFDQSxNQUFJLFVBQVUsSUFBSSxVQUFKLENBQWUsYUFBYSxXQUE1QixDQUFkO0FBQ0E7QUFDQSxTQUFPLE9BQVA7QUFDRDtBQUNELFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QjtBQUM1QixPQUFLLElBQUwsR0FBWSxRQUFaO0FBQ0Q7QUFDRCxXQUFXLFNBQVgsQ0FBcUIsUUFBckIsR0FBZ0MsWUFBWTtBQUMxQyxTQUFPLEtBQUssSUFBWjtBQUNELENBRkQ7QUFHQSxTQUFTLGNBQVQsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDaEMsTUFBSSxnQkFBZ0IsR0FBaEIsQ0FBb0IsUUFBcEIsQ0FBSixFQUFtQztBQUNqQyxXQUFPLGdCQUFnQixHQUFoQixDQUFvQixRQUFwQixDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSSxNQUFNLElBQUksVUFBSixDQUFlLFFBQWYsQ0FBVjtBQUNBLG9CQUFnQixHQUFoQixDQUFvQixRQUFwQixFQUE4QixHQUE5QjtBQUNBLFdBQU8sR0FBUDtBQUNEO0FBQ0Y7UUFDeUIsTSxHQUFsQixjO1FBQXdDLFcsR0FBZCxVO1FBQ1osTSxHQUFkLFUiLCJmaWxlIjoic3ltYm9sLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGludGVybmVkTWFwXzc3NiA9IG5ldyBNYXA7XG5sZXQgY291bnRlcl83NzcgPSAwO1xuZnVuY3Rpb24gZ2Vuc3ltXzc3OChuYW1lXzc4MSkge1xuICBsZXQgcHJlZml4Xzc4MiA9IG5hbWVfNzgxID09IG51bGwgPyBcInNfXCIgOiBuYW1lXzc4MSArIFwiX1wiO1xuICBsZXQgc3ltXzc4MyA9IG5ldyBTeW1ib2xfNzc5KHByZWZpeF83ODIgKyBjb3VudGVyXzc3Nyk7XG4gIGNvdW50ZXJfNzc3Kys7XG4gIHJldHVybiBzeW1fNzgzO1xufVxuZnVuY3Rpb24gU3ltYm9sXzc3OShuYW1lXzc4NCkge1xuICB0aGlzLm5hbWUgPSBuYW1lXzc4NDtcbn1cblN5bWJvbF83NzkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5uYW1lO1xufTtcbmZ1bmN0aW9uIG1ha2VTeW1ib2xfNzgwKG5hbWVfNzg1KSB7XG4gIGlmIChpbnRlcm5lZE1hcF83NzYuaGFzKG5hbWVfNzg1KSkge1xuICAgIHJldHVybiBpbnRlcm5lZE1hcF83NzYuZ2V0KG5hbWVfNzg1KTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3ltID0gbmV3IFN5bWJvbF83NzkobmFtZV83ODUpO1xuICAgIGludGVybmVkTWFwXzc3Ni5zZXQobmFtZV83ODUsIHN5bSk7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxufVxuZXhwb3J0IHttYWtlU3ltYm9sXzc4MCBhcyBTeW1ib2wsIFN5bWJvbF83NzkgYXMgU3ltYm9sQ2xhc3N9O1xuZXhwb3J0IHtnZW5zeW1fNzc4IGFzIGdlbnN5bX0iXX0=

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Modules = exports.Module = undefined;

	var _immutable = __webpack_require__(11);

	var _env = __webpack_require__(30);

	var _env2 = _interopRequireDefault(_env);

	var _store = __webpack_require__(46);

	var _store2 = _interopRequireDefault(_store);

	var _shiftReader = __webpack_require__(3);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _tokenExpander = __webpack_require__(49);

	var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

	var _termExpander = __webpack_require__(53);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _bindingMap = __webpack_require__(14);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _symbol = __webpack_require__(44);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _loadSyntax = __webpack_require__(52);

	var _compiler = __webpack_require__(55);

	var _compiler2 = _interopRequireDefault(_compiler);

	var _transforms = __webpack_require__(31);

	var _scope = __webpack_require__(43);

	var _errors = __webpack_require__(13);

	var _hygieneUtils = __webpack_require__(66);

	var _syntax = __webpack_require__(12);

	var _utilsDirname = __webpack_require__(67);

	var _utilsDirname2 = _interopRequireDefault(_utilsDirname);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Module_430 {
	  constructor(moduleSpecifier_435, isNative_436, importEntries_437, exportEntries_438, pragmas_439, body_440) {
	    this.moduleSpecifier = moduleSpecifier_435;
	    this.isNative = isNative_436;
	    this.importEntries = importEntries_437;
	    this.exportEntries = exportEntries_438;
	    this.pragmas = pragmas_439;
	    this.body = body_440;
	  }
	}
	const findBindingIdentifierName_431 = term_441 => {
	  (0, _errors.assert)(term_441.name, `not implemented yet for type ${ term_441.type }`);
	  return term_441.name;
	};
	const convertExport_432 = term_442 => {
	  let declaration_443 = term_442.declaration;
	  let bindings_444 = [];
	  if ((0, _terms.isVariableDeclaration)(declaration_443)) {
	    bindings_444 = declaration_443.declarators.map(decl_446 => findBindingIdentifierName_431(decl_446.binding));
	  } else if ((0, _terms.isFunctionDeclaration)(declaration_443) || (0, _terms.isClassDeclaration)(declaration_443)) {
	    bindings_444.push(findBindingIdentifierName_431(declaration_443.name));
	  }
	  let namedExports_445 = bindings_444.map(binding_447 => {
	    return new _terms2.default("ExportSpecifier", { name: null, exportedName: binding_447 });
	  });
	  return new _terms2.default("ExportFrom", { moduleSpecifier: null, namedExports: (0, _immutable.List)(namedExports_445) });
	};
	const pragmaRegep_433 = /^\s*#\w*/;
	class Modules_434 {
	  constructor(context_448) {
	    this.compiledModules = new Map();
	    this.context = context_448;
	    this.context.modules = this;
	  }
	  loadString(str_449) {
	    let checkPragma_450 = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	    let hasPragma_451 = pragmaRegep_433.test(str_449);
	    if (checkPragma_450 && !hasPragma_451) {
	      return { isNative: true, body: (0, _immutable.List)() };
	    }
	    return { isNative: !hasPragma_451, body: new _shiftReader2.default(str_449).read() };
	  }
	  load(path_452) {
	    return this.loadString(this.context.moduleLoader(path_452));
	  }
	  compile(mod_453, path_454) {
	    let stxl_455 = mod_453.body;
	    let outScope_456 = (0, _scope.freshScope)("outsideEdge");
	    let inScope_457 = (0, _scope.freshScope)(`insideEdge0`);
	    let compiler_458 = new _compiler2.default(0, new _env2.default(), new _store2.default(), _.merge(this.context, { currentScope: [outScope_456, inScope_457], cwd: path_454 === "<<entrypoint>>" ? this.context.cwd : (0, _utilsDirname2.default)(path_454) }));
	    let terms_459 = compiler_458.compile(stxl_455.map(s_464 => s_464.addScope(outScope_456, this.context.bindings, _syntax.ALL_PHASES).addScope(inScope_457, this.context.bindings, 0)));
	    let importEntries_460 = [];
	    let exportEntries_461 = [];
	    let pragmas_462 = [];
	    let filteredTerms_463 = terms_459.reduce((acc_465, t_466) => {
	      return _.cond([[_terms.isImport, t_467 => {
	        importEntries_460.push(t_467);
	        return acc_465;
	      }], [_terms.isExport, t_468 => {
	        if (t_468.declaration) {
	          exportEntries_461.push(convertExport_432(t_468));
	          if ((0, _terms.isVariableDeclaration)(t_468.declaration)) {
	            return acc_465.concat(new _terms2.default("VariableDeclarationStatement", { declaration: t_468.declaration }));
	          }
	          return acc_465.concat(t_468.declaration);
	        }
	        exportEntries_461.push(t_468);
	        return acc_465;
	      }], [_terms.isPragma, t_469 => {
	        pragmas_462.push(t_469);
	        return acc_465;
	      }], [_.T, t_470 => acc_465.concat(t_470)]])(t_466);
	    }, (0, _immutable.List)());
	    return new Module_430(path_454, mod_453.isNative, (0, _immutable.List)(importEntries_460), (0, _immutable.List)(exportEntries_461), (0, _immutable.List)(pragmas_462), filteredTerms_463);
	  }
	  compileEntrypoint(source_471, filename_472) {
	    let enforcePragma_473 = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	    let stxl_474 = this.loadString(source_471, false);
	    if (enforcePragma_473 && stxl_474.isNative) {
	      throw new Error(`Entrypoint ${ filename_472 } must begin with #lang pragma`);
	    }
	    return this.getAtPhase("<<entrypoint>>", 0, this.context.cwd, stxl_474);
	  }
	  getAtPhase(rawPath_475, phase_476, cwd_477) {
	    let rawStxl_478 = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	    let path_479 = rawPath_475 === "<<entrypoint>>" ? rawPath_475 : this.context.moduleResolver(rawPath_475, cwd_477);
	    let mapKey_480 = `${ path_479 }:${ phase_476 }`;
	    if (!this.compiledModules.has(mapKey_480)) {
	      if (phase_476 === 0) {
	        let stxl = rawStxl_478 != null ? rawStxl_478 : this.load(path_479);
	        this.compiledModules.set(mapKey_480, this.compile(stxl, path_479));
	      } else {
	        let rawMod = this.getAtPhase(rawPath_475, 0, cwd_477, rawStxl_478);
	        let scope = (0, _scope.freshScope)(`insideEdge${ phase_476 }`);
	        this.compiledModules.set(mapKey_480, new Module_430(rawMod.moduleSpecifier, false, rawMod.importEntries.map(term_481 => term_481.addScope(scope, this.context.bindings, phase_476)), rawMod.exportEntries.map(term_482 => term_482.addScope(scope, this.context.bindings, phase_476)), rawMod.pragmas, rawMod.body.map(term_483 => term_483.addScope(scope, this.context.bindings, phase_476))));
	      }
	    }
	    return this.compiledModules.get(mapKey_480);
	  }
	  has(rawPath_484) {
	    let phase_485 = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    let path_486 = rawPath_484 === "<<entrypoint>>" ? rawPath_484 : this.context.moduleResolver(rawPath_484, this.context.cwd);
	    let key_487 = `${ path_486 }:${ phase_485 }`;
	    return this.compiledModules.has(key_487) && !this.compiledModules.get(key_487).isNative;
	  }
	  registerSyntaxDeclaration(term_488, phase_489, store_490) {
	    term_488.declarators.forEach(decl_491 => {
	      let val_492 = (0, _loadSyntax.evalCompiletimeValue)(decl_491.init.gen(), _.merge(this.context, { phase: phase_489 + 1, store: store_490 }));
	      (0, _hygieneUtils.collectBindings)(decl_491.binding).forEach(stx_493 => {
	        if (phase_489 !== 0) {
	          let newBinding = (0, _symbol.gensym)(stx_493.val());
	          this.context.bindings.add(stx_493, { binding: newBinding, phase: phase_489, skipDup: false });
	        }
	        let resolvedName_494 = stx_493.resolve(phase_489);
	        store_490.set(resolvedName_494, new _transforms.CompiletimeTransform(val_492));
	      });
	    });
	  }
	  registerVariableDeclaration(term_495, phase_496, store_497) {
	    term_495.declarators.forEach(decl_498 => {
	      (0, _hygieneUtils.collectBindings)(decl_498.binding).forEach(stx_499 => {
	        if (phase_496 !== 0) {
	          let newBinding = (0, _symbol.gensym)(stx_499.val());
	          this.context.bindings.add(stx_499, { binding: newBinding, phase: phase_496, skipDup: term_495.kind === "var" });
	        }
	        let resolvedName_500 = stx_499.resolve(phase_496);
	        store_497.set(resolvedName_500, new _transforms.VarBindingTransform(stx_499));
	      });
	    });
	  }
	  registerFunctionOrClass(term_501, phase_502, store_503) {
	    (0, _hygieneUtils.collectBindings)(term_501.name).forEach(stx_504 => {
	      if (phase_502 !== 0) {
	        let newBinding = (0, _symbol.gensym)(stx_504.val());
	        this.context.bindings.add(stx_504, { binding: newBinding, phase: phase_502, skipDup: false });
	      }
	      let resolvedName_505 = stx_504.resolve(phase_502);
	      store_503.set(resolvedName_505, new _transforms.VarBindingTransform(stx_504));
	    });
	  }
	  visit(mod_506, phase_507, store_508) {
	    mod_506.body.forEach(term_509 => {
	      if ((0, _terms.isSyntaxDeclarationStatement)(term_509)) {
	        this.registerSyntaxDeclaration(term_509.declaration, phase_507, store_508);
	      }
	    });
	    return store_508;
	  }
	  invoke(mod_510, phase_511, store_512) {
	    let body_513 = mod_510.body.filter(_.complement(_terms.isCompiletimeStatement)).map(term_515 => {
	      term_515 = term_515.gen();
	      if ((0, _terms.isVariableDeclarationStatement)(term_515)) {
	        this.registerVariableDeclaration(term_515.declaration, phase_511, store_512);
	      } else if ((0, _terms.isFunctionDeclaration)(term_515)) {
	        this.registerFunctionOrClass(term_515, phase_511, store_512);
	      }
	      return term_515;
	    });
	    let exportsObj_514 = (0, _loadSyntax.evalRuntimeValues)(body_513, _.merge(this.context, { store: store_512, phase: phase_511 }));
	    return store_512;
	  }
	}
	exports.Module = Module_430;
	exports.Modules = Modules_434;
	//# sourceMappingURL=data:application/json;base64,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LEVBQTRDO0FBQzFDLGFBQUsseUJBQUwsQ0FBK0IsU0FBUyxXQUF4QyxFQUFxRCxTQUFyRCxFQUFnRSxTQUFoRTtBQUNEO0FBQ0YsS0FKRDtBQUtBLFdBQU8sU0FBUDtBQUNEO0FBQ0QsU0FBTyxPQUFQLEVBQWdCLFNBQWhCLEVBQTJCLFNBQTNCLEVBQXNDO0FBQ3BDLFFBQUksV0FBVyxRQUFRLElBQVIsQ0FBYSxNQUFiLENBQW9CLEVBQUUsVUFBRiwrQkFBcEIsRUFBMEQsR0FBMUQsQ0FBOEQsWUFBWTtBQUN2RixpQkFBVyxTQUFTLEdBQVQsRUFBWDtBQUNBLFVBQUksMkNBQStCLFFBQS9CLENBQUosRUFBOEM7QUFDNUMsYUFBSywyQkFBTCxDQUFpQyxTQUFTLFdBQTFDLEVBQXVELFNBQXZELEVBQWtFLFNBQWxFO0FBQ0QsT0FGRCxNQUVPLElBQUksa0NBQXNCLFFBQXRCLENBQUosRUFBcUM7QUFDMUMsYUFBSyx1QkFBTCxDQUE2QixRQUE3QixFQUF1QyxTQUF2QyxFQUFrRCxTQUFsRDtBQUNEO0FBQ0QsYUFBTyxRQUFQO0FBQ0QsS0FSYyxDQUFmO0FBU0EsUUFBSSxpQkFBaUIsbUNBQWtCLFFBQWxCLEVBQTRCLEVBQUUsS0FBRixDQUFRLEtBQUssT0FBYixFQUFzQixFQUFDLE9BQU8sU0FBUixFQUFtQixPQUFPLFNBQTFCLEVBQXRCLENBQTVCLENBQXJCO0FBQ0EsV0FBTyxTQUFQO0FBQ0Q7QUFoSWU7UUFrSUksTSxHQUFkLFU7UUFDZSxPLEdBQWYsVyIsImZpbGUiOiJtb2R1bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQgRW52IGZyb20gXCIuL2VudlwiO1xuaW1wb3J0IFN0b3JlIGZyb20gXCIuL3N0b3JlXCI7XG5pbXBvcnQgUmVhZGVyIGZyb20gXCIuL3NoaWZ0LXJlYWRlclwiO1xuaW1wb3J0IFRva2VuRXhwYW5kZXIgZnJvbSBcIi4vdG9rZW4tZXhwYW5kZXIuanNcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSBcIi4vYmluZGluZy1tYXAuanNcIjtcbmltcG9ydCB7Z2Vuc3ltfSBmcm9tIFwiLi9zeW1ib2xcIjtcbmltcG9ydCBUZXJtLCB7aXNFT0YsIGlzQmluZGluZ0lkZW50aWZpZXIsIGlzRnVuY3Rpb25EZWNsYXJhdGlvbiwgaXNGdW5jdGlvbkV4cHJlc3Npb24sIGlzRnVuY3Rpb25UZXJtLCBpc0Z1bmN0aW9uV2l0aE5hbWUsIGlzU3ludGF4RGVjbGFyYXRpb24sIGlzU3ludGF4cmVjRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50LCBpc0ltcG9ydCwgaXNFeHBvcnQsIGlzRXhwb3J0RnJvbSwgaXNFeHBvcnRBbGxGcm9tLCBpc0V4cG9ydERlZmF1bHQsIGlzRXhwb3J0U3ludGF4LCBpc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50LCBpc1ByYWdtYSwgaXNDb21waWxldGltZURlY2xhcmF0aW9uLCBpc0NvbXBpbGV0aW1lU3RhdGVtZW50LCBpc0NsYXNzRGVjbGFyYXRpb259IGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge2V2YWxDb21waWxldGltZVZhbHVlLCBldmFsUnVudGltZVZhbHVlc30gZnJvbSBcIi4vbG9hZC1zeW50YXhcIjtcbmltcG9ydCBDb21waWxlciBmcm9tIFwiLi9jb21waWxlclwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtTY29wZSwgZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7Y29sbGVjdEJpbmRpbmdzfSBmcm9tIFwiLi9oeWdpZW5lLXV0aWxzXCI7XG5pbXBvcnQge0FMTF9QSEFTRVN9IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0IGRpcm5hbWUgZnJvbSBcInV0aWxzLWRpcm5hbWVcIjtcbmltcG9ydCAgKiBhcyBfIGZyb20gXCJyYW1kYVwiO1xuY2xhc3MgTW9kdWxlXzQzMCB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZVNwZWNpZmllcl80MzUsIGlzTmF0aXZlXzQzNiwgaW1wb3J0RW50cmllc180MzcsIGV4cG9ydEVudHJpZXNfNDM4LCBwcmFnbWFzXzQzOSwgYm9keV80NDApIHtcbiAgICB0aGlzLm1vZHVsZVNwZWNpZmllciA9IG1vZHVsZVNwZWNpZmllcl80MzU7XG4gICAgdGhpcy5pc05hdGl2ZSA9IGlzTmF0aXZlXzQzNjtcbiAgICB0aGlzLmltcG9ydEVudHJpZXMgPSBpbXBvcnRFbnRyaWVzXzQzNztcbiAgICB0aGlzLmV4cG9ydEVudHJpZXMgPSBleHBvcnRFbnRyaWVzXzQzODtcbiAgICB0aGlzLnByYWdtYXMgPSBwcmFnbWFzXzQzOTtcbiAgICB0aGlzLmJvZHkgPSBib2R5XzQ0MDtcbiAgfVxufVxuY29uc3QgZmluZEJpbmRpbmdJZGVudGlmaWVyTmFtZV80MzEgPSB0ZXJtXzQ0MSA9PiB7XG4gIGFzc2VydCh0ZXJtXzQ0MS5uYW1lLCBgbm90IGltcGxlbWVudGVkIHlldCBmb3IgdHlwZSAke3Rlcm1fNDQxLnR5cGV9YCk7XG4gIHJldHVybiB0ZXJtXzQ0MS5uYW1lO1xufTtcbmNvbnN0IGNvbnZlcnRFeHBvcnRfNDMyID0gdGVybV80NDIgPT4ge1xuICBsZXQgZGVjbGFyYXRpb25fNDQzID0gdGVybV80NDIuZGVjbGFyYXRpb247XG4gIGxldCBiaW5kaW5nc180NDQgPSBbXTtcbiAgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbl80NDMpKSB7XG4gICAgYmluZGluZ3NfNDQ0ID0gZGVjbGFyYXRpb25fNDQzLmRlY2xhcmF0b3JzLm1hcChkZWNsXzQ0NiA9PiBmaW5kQmluZGluZ0lkZW50aWZpZXJOYW1lXzQzMShkZWNsXzQ0Ni5iaW5kaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uXzQ0MykgfHwgaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uXzQ0MykpIHtcbiAgICBiaW5kaW5nc180NDQucHVzaChmaW5kQmluZGluZ0lkZW50aWZpZXJOYW1lXzQzMShkZWNsYXJhdGlvbl80NDMubmFtZSkpO1xuICB9XG4gIGxldCBuYW1lZEV4cG9ydHNfNDQ1ID0gYmluZGluZ3NfNDQ0Lm1hcChiaW5kaW5nXzQ0NyA9PiB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0U3BlY2lmaWVyXCIsIHtuYW1lOiBudWxsLCBleHBvcnRlZE5hbWU6IGJpbmRpbmdfNDQ3fSk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRGcm9tXCIsIHttb2R1bGVTcGVjaWZpZXI6IG51bGwsIG5hbWVkRXhwb3J0czogTGlzdChuYW1lZEV4cG9ydHNfNDQ1KX0pO1xufTtcbmNvbnN0IHByYWdtYVJlZ2VwXzQzMyA9IC9eXFxzKiNcXHcqLztcbmNsYXNzIE1vZHVsZXNfNDM0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dF80NDgpIHtcbiAgICB0aGlzLmNvbXBpbGVkTW9kdWxlcyA9IG5ldyBNYXA7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF80NDg7XG4gICAgdGhpcy5jb250ZXh0Lm1vZHVsZXMgPSB0aGlzO1xuICB9XG4gIGxvYWRTdHJpbmcoc3RyXzQ0OSwgY2hlY2tQcmFnbWFfNDUwID0gdHJ1ZSkge1xuICAgIGxldCBoYXNQcmFnbWFfNDUxID0gcHJhZ21hUmVnZXBfNDMzLnRlc3Qoc3RyXzQ0OSk7XG4gICAgaWYgKGNoZWNrUHJhZ21hXzQ1MCAmJiAhaGFzUHJhZ21hXzQ1MSkge1xuICAgICAgcmV0dXJuIHtpc05hdGl2ZTogdHJ1ZSwgYm9keTogTGlzdCgpfTtcbiAgICB9XG4gICAgcmV0dXJuIHtpc05hdGl2ZTogIWhhc1ByYWdtYV80NTEsIGJvZHk6IG5ldyBSZWFkZXIoc3RyXzQ0OSkucmVhZCgpfTtcbiAgfVxuICBsb2FkKHBhdGhfNDUyKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZFN0cmluZyh0aGlzLmNvbnRleHQubW9kdWxlTG9hZGVyKHBhdGhfNDUyKSk7XG4gIH1cbiAgY29tcGlsZShtb2RfNDUzLCBwYXRoXzQ1NCkge1xuICAgIGxldCBzdHhsXzQ1NSA9IG1vZF80NTMuYm9keTtcbiAgICBsZXQgb3V0U2NvcGVfNDU2ID0gZnJlc2hTY29wZShcIm91dHNpZGVFZGdlXCIpO1xuICAgIGxldCBpblNjb3BlXzQ1NyA9IGZyZXNoU2NvcGUoYGluc2lkZUVkZ2UwYCk7XG4gICAgbGV0IGNvbXBpbGVyXzQ1OCA9IG5ldyBDb21waWxlcigwLCBuZXcgRW52LCBuZXcgU3RvcmUsIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7Y3VycmVudFNjb3BlOiBbb3V0U2NvcGVfNDU2LCBpblNjb3BlXzQ1N10sIGN3ZDogcGF0aF80NTQgPT09IFwiPDxlbnRyeXBvaW50Pj5cIiA/IHRoaXMuY29udGV4dC5jd2QgOiBkaXJuYW1lKHBhdGhfNDU0KX0pKTtcbiAgICBsZXQgdGVybXNfNDU5ID0gY29tcGlsZXJfNDU4LmNvbXBpbGUoc3R4bF80NTUubWFwKHNfNDY0ID0+IHNfNDY0LmFkZFNjb3BlKG91dFNjb3BlXzQ1NiwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKS5hZGRTY29wZShpblNjb3BlXzQ1NywgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCAwKSkpO1xuICAgIGxldCBpbXBvcnRFbnRyaWVzXzQ2MCA9IFtdO1xuICAgIGxldCBleHBvcnRFbnRyaWVzXzQ2MSA9IFtdO1xuICAgIGxldCBwcmFnbWFzXzQ2MiA9IFtdO1xuICAgIGxldCBmaWx0ZXJlZFRlcm1zXzQ2MyA9IHRlcm1zXzQ1OS5yZWR1Y2UoKGFjY180NjUsIHRfNDY2KSA9PiB7XG4gICAgICByZXR1cm4gXy5jb25kKFtbaXNJbXBvcnQsIHRfNDY3ID0+IHtcbiAgICAgICAgaW1wb3J0RW50cmllc180NjAucHVzaCh0XzQ2Nyk7XG4gICAgICAgIHJldHVybiBhY2NfNDY1O1xuICAgICAgfV0sIFtpc0V4cG9ydCwgdF80NjggPT4ge1xuICAgICAgICBpZiAodF80NjguZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBleHBvcnRFbnRyaWVzXzQ2MS5wdXNoKGNvbnZlcnRFeHBvcnRfNDMyKHRfNDY4KSk7XG4gICAgICAgICAgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbih0XzQ2OC5kZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NfNDY1LmNvbmNhdChuZXcgVGVybShcIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnRcIiwge2RlY2xhcmF0aW9uOiB0XzQ2OC5kZWNsYXJhdGlvbn0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjY180NjUuY29uY2F0KHRfNDY4LmRlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRFbnRyaWVzXzQ2MS5wdXNoKHRfNDY4KTtcbiAgICAgICAgcmV0dXJuIGFjY180NjU7XG4gICAgICB9XSwgW2lzUHJhZ21hLCB0XzQ2OSA9PiB7XG4gICAgICAgIHByYWdtYXNfNDYyLnB1c2godF80NjkpO1xuICAgICAgICByZXR1cm4gYWNjXzQ2NTtcbiAgICAgIH1dLCBbXy5ULCB0XzQ3MCA9PiBhY2NfNDY1LmNvbmNhdCh0XzQ3MCldXSkodF80NjYpO1xuICAgIH0sIExpc3QoKSk7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVfNDMwKHBhdGhfNDU0LCBtb2RfNDUzLmlzTmF0aXZlLCBMaXN0KGltcG9ydEVudHJpZXNfNDYwKSwgTGlzdChleHBvcnRFbnRyaWVzXzQ2MSksIExpc3QocHJhZ21hc180NjIpLCBmaWx0ZXJlZFRlcm1zXzQ2Myk7XG4gIH1cbiAgY29tcGlsZUVudHJ5cG9pbnQoc291cmNlXzQ3MSwgZmlsZW5hbWVfNDcyLCBlbmZvcmNlUHJhZ21hXzQ3MyA9IGZhbHNlKSB7XG4gICAgbGV0IHN0eGxfNDc0ID0gdGhpcy5sb2FkU3RyaW5nKHNvdXJjZV80NzEsIGZhbHNlKTtcbiAgICBpZiAoZW5mb3JjZVByYWdtYV80NzMgJiYgc3R4bF80NzQuaXNOYXRpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW50cnlwb2ludCAke2ZpbGVuYW1lXzQ3Mn0gbXVzdCBiZWdpbiB3aXRoICNsYW5nIHByYWdtYWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBdFBoYXNlKFwiPDxlbnRyeXBvaW50Pj5cIiwgMCwgdGhpcy5jb250ZXh0LmN3ZCwgc3R4bF80NzQpO1xuICB9XG4gIGdldEF0UGhhc2UocmF3UGF0aF80NzUsIHBoYXNlXzQ3NiwgY3dkXzQ3NywgcmF3U3R4bF80NzggPSBudWxsKSB7XG4gICAgbGV0IHBhdGhfNDc5ID0gcmF3UGF0aF80NzUgPT09IFwiPDxlbnRyeXBvaW50Pj5cIiA/IHJhd1BhdGhfNDc1IDogdGhpcy5jb250ZXh0Lm1vZHVsZVJlc29sdmVyKHJhd1BhdGhfNDc1LCBjd2RfNDc3KTtcbiAgICBsZXQgbWFwS2V5XzQ4MCA9IGAke3BhdGhfNDc5fToke3BoYXNlXzQ3Nn1gO1xuICAgIGlmICghdGhpcy5jb21waWxlZE1vZHVsZXMuaGFzKG1hcEtleV80ODApKSB7XG4gICAgICBpZiAocGhhc2VfNDc2ID09PSAwKSB7XG4gICAgICAgIGxldCBzdHhsID0gcmF3U3R4bF80NzggIT0gbnVsbCA/IHJhd1N0eGxfNDc4IDogdGhpcy5sb2FkKHBhdGhfNDc5KTtcbiAgICAgICAgdGhpcy5jb21waWxlZE1vZHVsZXMuc2V0KG1hcEtleV80ODAsIHRoaXMuY29tcGlsZShzdHhsLCBwYXRoXzQ3OSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJhd01vZCA9IHRoaXMuZ2V0QXRQaGFzZShyYXdQYXRoXzQ3NSwgMCwgY3dkXzQ3NywgcmF3U3R4bF80NzgpO1xuICAgICAgICBsZXQgc2NvcGUgPSBmcmVzaFNjb3BlKGBpbnNpZGVFZGdlJHtwaGFzZV80NzZ9YCk7XG4gICAgICAgIHRoaXMuY29tcGlsZWRNb2R1bGVzLnNldChtYXBLZXlfNDgwLCBuZXcgTW9kdWxlXzQzMChyYXdNb2QubW9kdWxlU3BlY2lmaWVyLCBmYWxzZSwgcmF3TW9kLmltcG9ydEVudHJpZXMubWFwKHRlcm1fNDgxID0+IHRlcm1fNDgxLmFkZFNjb3BlKHNjb3BlLCB0aGlzLmNvbnRleHQuYmluZGluZ3MsIHBoYXNlXzQ3NikpLCByYXdNb2QuZXhwb3J0RW50cmllcy5tYXAodGVybV80ODIgPT4gdGVybV80ODIuYWRkU2NvcGUoc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgcGhhc2VfNDc2KSksIHJhd01vZC5wcmFnbWFzLCByYXdNb2QuYm9keS5tYXAodGVybV80ODMgPT4gdGVybV80ODMuYWRkU2NvcGUoc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgcGhhc2VfNDc2KSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRNb2R1bGVzLmdldChtYXBLZXlfNDgwKTtcbiAgfVxuICBoYXMocmF3UGF0aF80ODQsIHBoYXNlXzQ4NSA9IDApIHtcbiAgICBsZXQgcGF0aF80ODYgPSByYXdQYXRoXzQ4NCA9PT0gXCI8PGVudHJ5cG9pbnQ+PlwiID8gcmF3UGF0aF80ODQgOiB0aGlzLmNvbnRleHQubW9kdWxlUmVzb2x2ZXIocmF3UGF0aF80ODQsIHRoaXMuY29udGV4dC5jd2QpO1xuICAgIGxldCBrZXlfNDg3ID0gYCR7cGF0aF80ODZ9OiR7cGhhc2VfNDg1fWA7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRNb2R1bGVzLmhhcyhrZXlfNDg3KSAmJiAhdGhpcy5jb21waWxlZE1vZHVsZXMuZ2V0KGtleV80ODcpLmlzTmF0aXZlO1xuICB9XG4gIHJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24odGVybV80ODgsIHBoYXNlXzQ4OSwgc3RvcmVfNDkwKSB7XG4gICAgdGVybV80ODguZGVjbGFyYXRvcnMuZm9yRWFjaChkZWNsXzQ5MSA9PiB7XG4gICAgICBsZXQgdmFsXzQ5MiA9IGV2YWxDb21waWxldGltZVZhbHVlKGRlY2xfNDkxLmluaXQuZ2VuKCksIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHBoYXNlXzQ4OSArIDEsIHN0b3JlOiBzdG9yZV80OTB9KSk7XG4gICAgICBjb2xsZWN0QmluZGluZ3MoZGVjbF80OTEuYmluZGluZykuZm9yRWFjaChzdHhfNDkzID0+IHtcbiAgICAgICAgaWYgKHBoYXNlXzQ4OSAhPT0gMCkge1xuICAgICAgICAgIGxldCBuZXdCaW5kaW5nID0gZ2Vuc3ltKHN0eF80OTMudmFsKCkpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzQ5Mywge2JpbmRpbmc6IG5ld0JpbmRpbmcsIHBoYXNlOiBwaGFzZV80ODksIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc29sdmVkTmFtZV80OTQgPSBzdHhfNDkzLnJlc29sdmUocGhhc2VfNDg5KTtcbiAgICAgICAgc3RvcmVfNDkwLnNldChyZXNvbHZlZE5hbWVfNDk0LCBuZXcgQ29tcGlsZXRpbWVUcmFuc2Zvcm0odmFsXzQ5MikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fNDk1LCBwaGFzZV80OTYsIHN0b3JlXzQ5Nykge1xuICAgIHRlcm1fNDk1LmRlY2xhcmF0b3JzLmZvckVhY2goZGVjbF80OTggPT4ge1xuICAgICAgY29sbGVjdEJpbmRpbmdzKGRlY2xfNDk4LmJpbmRpbmcpLmZvckVhY2goc3R4XzQ5OSA9PiB7XG4gICAgICAgIGlmIChwaGFzZV80OTYgIT09IDApIHtcbiAgICAgICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShzdHhfNDk5LnZhbCgpKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MuYWRkKHN0eF80OTksIHtiaW5kaW5nOiBuZXdCaW5kaW5nLCBwaGFzZTogcGhhc2VfNDk2LCBza2lwRHVwOiB0ZXJtXzQ5NS5raW5kID09PSBcInZhclwifSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc29sdmVkTmFtZV81MDAgPSBzdHhfNDk5LnJlc29sdmUocGhhc2VfNDk2KTtcbiAgICAgICAgc3RvcmVfNDk3LnNldChyZXNvbHZlZE5hbWVfNTAwLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfNDk5KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uT3JDbGFzcyh0ZXJtXzUwMSwgcGhhc2VfNTAyLCBzdG9yZV81MDMpIHtcbiAgICBjb2xsZWN0QmluZGluZ3ModGVybV81MDEubmFtZSkuZm9yRWFjaChzdHhfNTA0ID0+IHtcbiAgICAgIGlmIChwaGFzZV81MDIgIT09IDApIHtcbiAgICAgICAgbGV0IG5ld0JpbmRpbmcgPSBnZW5zeW0oc3R4XzUwNC52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzUwNCwge2JpbmRpbmc6IG5ld0JpbmRpbmcsIHBoYXNlOiBwaGFzZV81MDIsIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzb2x2ZWROYW1lXzUwNSA9IHN0eF81MDQucmVzb2x2ZShwaGFzZV81MDIpO1xuICAgICAgc3RvcmVfNTAzLnNldChyZXNvbHZlZE5hbWVfNTA1LCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfNTA0KSk7XG4gICAgfSk7XG4gIH1cbiAgdmlzaXQobW9kXzUwNiwgcGhhc2VfNTA3LCBzdG9yZV81MDgpIHtcbiAgICBtb2RfNTA2LmJvZHkuZm9yRWFjaCh0ZXJtXzUwOSA9PiB7XG4gICAgICBpZiAoaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudCh0ZXJtXzUwOSkpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclN5bnRheERlY2xhcmF0aW9uKHRlcm1fNTA5LmRlY2xhcmF0aW9uLCBwaGFzZV81MDcsIHN0b3JlXzUwOCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0b3JlXzUwODtcbiAgfVxuICBpbnZva2UobW9kXzUxMCwgcGhhc2VfNTExLCBzdG9yZV81MTIpIHtcbiAgICBsZXQgYm9keV81MTMgPSBtb2RfNTEwLmJvZHkuZmlsdGVyKF8uY29tcGxlbWVudChpc0NvbXBpbGV0aW1lU3RhdGVtZW50KSkubWFwKHRlcm1fNTE1ID0+IHtcbiAgICAgIHRlcm1fNTE1ID0gdGVybV81MTUuZ2VuKCk7XG4gICAgICBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm1fNTE1KSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtXzUxNS5kZWNsYXJhdGlvbiwgcGhhc2VfNTExLCBzdG9yZV81MTIpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uRGVjbGFyYXRpb24odGVybV81MTUpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvbk9yQ2xhc3ModGVybV81MTUsIHBoYXNlXzUxMSwgc3RvcmVfNTEyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXJtXzUxNTtcbiAgICB9KTtcbiAgICBsZXQgZXhwb3J0c09ial81MTQgPSBldmFsUnVudGltZVZhbHVlcyhib2R5XzUxMywgXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtzdG9yZTogc3RvcmVfNTEyLCBwaGFzZTogcGhhc2VfNTExfSkpO1xuICAgIHJldHVybiBzdG9yZV81MTI7XG4gIH1cbn1cbmV4cG9ydCB7TW9kdWxlXzQzMCBhcyBNb2R1bGV9O1xuZXhwb3J0IHtNb2R1bGVzXzQzNCBhcyBNb2R1bGVzfSJdfQ==

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _vm = __webpack_require__(47);

	var _vm2 = _interopRequireDefault(_vm);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Store {
	  constructor() {
	    this.map = new Map();
	    this.nodeContext = _vm2.default.createContext();
	  }
	  has(key_754) {
	    return this.map.has(key_754);
	  }
	  get(key_755) {
	    return this.map.get(key_755);
	  }
	  set(key_756, val_757) {
	    this.nodeContext[key_756] = val_757;
	    return this.map.set(key_756, val_757);
	  }
	  getNodeContext() {
	    return this.nodeContext;
	  }
	}
	exports.default = Store;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N0b3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFDZSxNQUFNLEtBQU4sQ0FBWTtBQUN6QixnQkFBYztBQUNaLFNBQUssR0FBTCxHQUFXLElBQUksR0FBSixFQUFYO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLGFBQUcsYUFBSCxFQUFuQjtBQUNEO0FBQ0QsTUFBSSxPQUFKLEVBQWE7QUFDWCxXQUFPLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiLENBQVA7QUFDRDtBQUNELE1BQUksT0FBSixFQUFhO0FBQ1gsV0FBTyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsT0FBYixDQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQUosRUFBYSxPQUFiLEVBQXNCO0FBQ3BCLFNBQUssV0FBTCxDQUFpQixPQUFqQixJQUE0QixPQUE1QjtBQUNBLFdBQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBUDtBQUNEO0FBQ0QsbUJBQWlCO0FBQ2YsV0FBTyxLQUFLLFdBQVo7QUFDRDtBQWpCd0I7a0JBQU4sSyIsImZpbGUiOiJzdG9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2bSBmcm9tIFwidm1cIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwO1xuICAgIHRoaXMubm9kZUNvbnRleHQgPSB2bS5jcmVhdGVDb250ZXh0KCk7XG4gIH1cbiAgaGFzKGtleV83NTQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleV83NTQpO1xuICB9XG4gIGdldChrZXlfNzU1KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXlfNzU1KTtcbiAgfVxuICBzZXQoa2V5Xzc1NiwgdmFsXzc1Nykge1xuICAgIHRoaXMubm9kZUNvbnRleHRba2V5Xzc1Nl0gPSB2YWxfNzU3O1xuICAgIHJldHVybiB0aGlzLm1hcC5zZXQoa2V5Xzc1NiwgdmFsXzc1Nyk7XG4gIH1cbiAgZ2V0Tm9kZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNvbnRleHQ7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(48);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 48 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(11);

	var _enforester = __webpack_require__(50);

	var _termExpander = __webpack_require__(53);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _bindingMap = __webpack_require__(14);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _env = __webpack_require__(30);

	var _env2 = _interopRequireDefault(_env);

	var _shiftReader = __webpack_require__(3);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _symbol = __webpack_require__(44);

	var _transforms = __webpack_require__(31);

	var _errors = __webpack_require__(13);

	var _loadSyntax = __webpack_require__(52);

	var _scope = __webpack_require__(43);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _astDispatcher = __webpack_require__(63);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	var _hygieneUtils = __webpack_require__(66);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function bindImports_1213(impTerm_1216, exModule_1217, context_1218) {
	  let names_1219 = [];
	  let phase_1220 = impTerm_1216.forSyntax ? context_1218.phase + 1 : context_1218.phase;
	  impTerm_1216.namedImports.forEach(specifier_1221 => {
	    let name_1222 = specifier_1221.binding.name;
	    let exportName_1223 = findNameInExports_1214(name_1222, exModule_1217.exportEntries);
	    if (exportName_1223 != null) {
	      let newBinding = (0, _symbol.gensym)(name_1222.val());
	      context_1218.store.set(newBinding.toString(), new _transforms.VarBindingTransform(name_1222));
	      context_1218.bindings.addForward(name_1222, exportName_1223, newBinding, phase_1220);
	      names_1219.push(name_1222);
	    }
	  });
	  return (0, _immutable.List)(names_1219);
	}
	function findNameInExports_1214(name_1224, exp_1225) {
	  let foundNames_1226 = exp_1225.reduce((acc_1227, e_1228) => {
	    if ((0, _terms.isExportFrom)(e_1228)) {
	      return acc_1227.concat(e_1228.namedExports.reduce((acc_1229, specifier_1230) => {
	        if (specifier_1230.exportedName.val() === name_1224.val()) {
	          return acc_1229.concat(specifier_1230.exportedName);
	        }
	        return acc_1229;
	      }, (0, _immutable.List)()));
	    } else if ((0, _terms.isExport)(e_1228)) {
	      return acc_1227.concat(e_1228.declaration.declarators.reduce((acc_1231, decl_1232) => {
	        if (decl_1232.binding.name.val() === name_1224.val()) {
	          return acc_1231.concat(decl_1232.binding.name);
	        }
	        return acc_1231;
	      }, (0, _immutable.List)()));
	    }
	    return acc_1227;
	  }, (0, _immutable.List)());
	  (0, _errors.assert)(foundNames_1226.size <= 1, "expecting no more than 1 matching name in exports");
	  return foundNames_1226.get(0);
	}
	function removeNames_1215(impTerm_1233, names_1234) {
	  let namedImports_1235 = impTerm_1233.namedImports.filter(specifier_1236 => !names_1234.contains(specifier_1236.binding.name));
	  return impTerm_1233.extend({ namedImports: namedImports_1235 });
	}
	class TokenExpander extends _astDispatcher2.default {
	  constructor(context_1237) {
	    super("expand", false);
	    this.context = context_1237;
	  }
	  expand(stxl_1238) {
	    let result_1239 = [];
	    if (stxl_1238.size === 0) {
	      return (0, _immutable.List)(result_1239);
	    }
	    let prev_1240 = (0, _immutable.List)();
	    let enf_1241 = new _enforester.Enforester(stxl_1238, prev_1240, this.context);
	    while (!enf_1241.done) {
	      result_1239.push(this.dispatch(enf_1241.enforest()));
	    }
	    return (0, _immutable.List)(result_1239);
	  }
	  expandVariableDeclarationStatement(term_1242) {
	    return term_1242.extend({ declaration: this.registerVariableDeclaration(term_1242.declaration) });
	  }
	  expandFunctionDeclaration(term_1243) {
	    let registeredTerm_1244 = this.registerFunctionOrClass(term_1243);
	    let stx_1245 = registeredTerm_1244.name.name;
	    this.context.env.set(stx_1245.resolve(this.context.phase), new _transforms.VarBindingTransform(stx_1245));
	    return registeredTerm_1244;
	  }
	  expandImport(term_1246) {
	    let path_1247 = term_1246.moduleSpecifier.val();
	    let mod_1248;
	    if (term_1246.forSyntax) {
	      mod_1248 = this.context.modules.getAtPhase(path_1247, this.context.phase + 1, this.context.cwd);
	      this.context.store = this.context.modules.visit(mod_1248, this.context.phase + 1, this.context.store);
	      this.context.store = this.context.modules.invoke(mod_1248, this.context.phase + 1, this.context.store);
	    } else {
	      mod_1248 = this.context.modules.getAtPhase(path_1247, this.context.phase, this.context.cwd);
	      this.context.store = this.context.modules.visit(mod_1248, this.context.phase, this.context.store);
	    }
	    let boundNames_1249 = bindImports_1213(term_1246, mod_1248, this.context);
	    return removeNames_1215(term_1246, boundNames_1249);
	  }
	  expandExport(term_1250) {
	    if ((0, _terms.isFunctionDeclaration)(term_1250.declaration) || (0, _terms.isClassDeclaration)(term_1250.declaration)) {
	      return term_1250.extend({ declaration: this.registerFunctionOrClass(term_1250.declaration) });
	    } else if ((0, _terms.isVariableDeclaration)(term_1250.declaration)) {
	      return term_1250.extend({ declaration: this.registerVariableDeclaration(term_1250.declaration) });
	    }
	    return term_1250;
	  }
	  registerFunctionOrClass(term_1251) {
	    let name_1252 = term_1251.name.removeScope(this.context.useScope, this.context.phase);
	    (0, _hygieneUtils.collectBindings)(term_1251.name).forEach(stx_1253 => {
	      let newBinding_1254 = (0, _symbol.gensym)(stx_1253.val());
	      this.context.bindings.add(stx_1253, { binding: newBinding_1254, phase: this.context.phase, skipDup: false });
	      this.context.env.set(newBinding_1254.toString(), new _transforms.VarBindingTransform(stx_1253));
	    });
	    return term_1251.extend({ name: name_1252 });
	  }
	  registerVariableDeclaration(term_1255) {
	    if ((0, _terms.isSyntaxDeclaration)(term_1255) || (0, _terms.isSyntaxrecDeclaration)(term_1255)) {
	      return this.registerSyntaxDeclaration(term_1255);
	    }
	    return term_1255.extend({ declarators: term_1255.declarators.map(decl_1256 => {
	        let binding_1257 = decl_1256.binding.removeScope(this.context.useScope, this.context.phase);
	        (0, _hygieneUtils.collectBindings)(binding_1257).forEach(stx_1258 => {
	          let newBinding_1259 = (0, _symbol.gensym)(stx_1258.val());
	          this.context.bindings.add(stx_1258, { binding: newBinding_1259, phase: this.context.phase, skipDup: term_1255.kind === "var" });
	          this.context.env.set(newBinding_1259.toString(), new _transforms.VarBindingTransform(stx_1258));
	        });
	        return decl_1256.extend({ binding: binding_1257 });
	      }) });
	  }
	  registerSyntaxDeclaration(term_1260) {
	    if ((0, _terms.isSyntaxDeclaration)(term_1260)) {
	      let scope = (0, _scope.freshScope)("nonrec");
	      term_1260 = term_1260.extend({ declarators: term_1260.declarators.map(decl_1261 => {
	          let name_1262 = decl_1261.binding.name;
	          let nameAdded_1263 = name_1262.addScope(scope, this.context.bindings, _syntax.ALL_PHASES);
	          let nameRemoved_1264 = name_1262.removeScope(this.context.currentScope[this.context.currentScope.length - 1], this.context.phase);
	          let newBinding_1265 = (0, _symbol.gensym)(name_1262.val());
	          this.context.bindings.addForward(nameAdded_1263, nameRemoved_1264, newBinding_1265, this.context.phase);
	          return decl_1261.extend({ init: decl_1261.init.addScope(scope, this.context.bindings, _syntax.ALL_PHASES) });
	        }) });
	    }
	    return term_1260.extend({ declarators: term_1260.declarators.map(decl_1266 => {
	        let binding_1267 = decl_1266.binding.removeScope(this.context.useScope, this.context.phase);
	        let syntaxExpander_1268 = new _termExpander2.default(_.merge(this.context, { phase: this.context.phase + 1, env: new _env2.default(), store: this.context.store }));
	        let init_1269 = syntaxExpander_1268.expand(decl_1266.init);
	        let val_1270 = (0, _loadSyntax.evalCompiletimeValue)(init_1269.gen(), _.merge(this.context, { phase: this.context.phase + 1 }));
	        (0, _hygieneUtils.collectBindings)(binding_1267).forEach(stx_1271 => {
	          let newBinding_1272 = (0, _symbol.gensym)(stx_1271.val());
	          this.context.bindings.add(stx_1271, { binding: newBinding_1272, phase: this.context.phase, skipDup: false });
	          let resolvedName_1273 = stx_1271.resolve(this.context.phase);
	          this.context.env.set(resolvedName_1273, new _transforms.CompiletimeTransform(val_1270));
	        });
	        return decl_1266.extend({ binding: binding_1267, init: init_1269 });
	      }) });
	  }
	}
	exports.default = TokenExpander;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Rva2VuLWV4cGFuZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0lBQWEsQzs7Ozs7O0FBQ2IsU0FBUyxnQkFBVCxDQUEwQixZQUExQixFQUF3QyxhQUF4QyxFQUF1RCxZQUF2RCxFQUFxRTtBQUNuRSxNQUFJLGFBQWEsRUFBakI7QUFDQSxNQUFJLGFBQWEsYUFBYSxTQUFiLEdBQXlCLGFBQWEsS0FBYixHQUFxQixDQUE5QyxHQUFrRCxhQUFhLEtBQWhGO0FBQ0EsZUFBYSxZQUFiLENBQTBCLE9BQTFCLENBQWtDLGtCQUFrQjtBQUNsRCxRQUFJLFlBQVksZUFBZSxPQUFmLENBQXVCLElBQXZDO0FBQ0EsUUFBSSxrQkFBa0IsdUJBQXVCLFNBQXZCLEVBQWtDLGNBQWMsYUFBaEQsQ0FBdEI7QUFDQSxRQUFJLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQixVQUFJLGFBQWEsb0JBQU8sVUFBVSxHQUFWLEVBQVAsQ0FBakI7QUFDQSxtQkFBYSxLQUFiLENBQW1CLEdBQW5CLENBQXVCLFdBQVcsUUFBWCxFQUF2QixFQUE4QyxvQ0FBd0IsU0FBeEIsQ0FBOUM7QUFDQSxtQkFBYSxRQUFiLENBQXNCLFVBQXRCLENBQWlDLFNBQWpDLEVBQTRDLGVBQTVDLEVBQTZELFVBQTdELEVBQXlFLFVBQXpFO0FBQ0EsaUJBQVcsSUFBWCxDQUFnQixTQUFoQjtBQUNEO0FBQ0YsR0FURDtBQVVBLFNBQU8scUJBQUssVUFBTCxDQUFQO0FBQ0Q7QUFDRCxTQUFTLHNCQUFULENBQWdDLFNBQWhDLEVBQTJDLFFBQTNDLEVBQXFEO0FBQ25ELE1BQUksa0JBQWtCLFNBQVMsTUFBVCxDQUFnQixDQUFDLFFBQUQsRUFBVyxNQUFYLEtBQXNCO0FBQzFELFFBQUks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QUFJLGtCQUFrQixvQkFBTyxTQUFTLEdBQVQsRUFBUCxDQUF0QjtBQUNBLGVBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsR0FBdEIsQ0FBMEIsUUFBMUIsRUFBb0MsRUFBQyxTQUFTLGVBQVYsRUFBMkIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUEvQyxFQUFzRCxTQUFTLEtBQS9ELEVBQXBDO0FBQ0EsY0FBSSxvQkFBb0IsU0FBUyxPQUFULENBQWlCLEtBQUssT0FBTCxDQUFhLEtBQTlCLENBQXhCO0FBQ0EsZUFBSyxPQUFMLENBQWEsR0FBYixDQUFpQixHQUFqQixDQUFxQixpQkFBckIsRUFBd0MscUNBQXlCLFFBQXpCLENBQXhDO0FBQ0QsU0FMRDtBQU1BLGVBQU8sVUFBVSxNQUFWLENBQWlCLEVBQUMsU0FBUyxZQUFWLEVBQXdCLE1BQU0sU0FBOUIsRUFBakIsQ0FBUDtBQUNELE9BWnFDLENBQWQsRUFBakIsQ0FBUDtBQWFEO0FBaEdzRDtrQkFBcEMsYSIsImZpbGUiOiJ0b2tlbi1leHBhbmRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IHtlbmZvcmVzdEV4cHIsIEVuZm9yZXN0ZXJ9IGZyb20gXCIuL2VuZm9yZXN0ZXJcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSBcIi4vYmluZGluZy1tYXAuanNcIjtcbmltcG9ydCBFbnYgZnJvbSBcIi4vZW52XCI7XG5pbXBvcnQgUmVhZGVyIGZyb20gXCIuL3NoaWZ0LXJlYWRlclwiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSwgaXNCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyLCBpc09iamVjdEJpbmRpbmcsIGlzQXJyYXlCaW5kaW5nLCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24sIGlzRnVuY3Rpb25FeHByZXNzaW9uLCBpc0Z1bmN0aW9uVGVybSwgaXNGdW5jdGlvbldpdGhOYW1lLCBpc1N5bnRheERlY2xhcmF0aW9uLCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCwgaXNJbXBvcnQsIGlzRXhwb3J0LCBpc0V4cG9ydEZyb20sIGlzUHJhZ21hLCBpc0V4cG9ydFN5bnRheCwgaXNDbGFzc0RlY2xhcmF0aW9ufSBmcm9tIFwiLi90ZXJtc1wiO1xuaW1wb3J0IHtnZW5zeW19IGZyb20gXCIuL3N5bWJvbFwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQge2V2YWxDb21waWxldGltZVZhbHVlfSBmcm9tIFwiLi9sb2FkLXN5bnRheFwiO1xuaW1wb3J0IHtTY29wZSwgZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCBBU1REaXNwYXRjaGVyIGZyb20gXCIuL2FzdC1kaXNwYXRjaGVyXCI7XG5pbXBvcnQge2NvbGxlY3RCaW5kaW5nc30gZnJvbSBcIi4vaHlnaWVuZS11dGlsc1wiO1xuaW1wb3J0ICAqIGFzIF8gZnJvbSBcInJhbWRhXCI7XG5mdW5jdGlvbiBiaW5kSW1wb3J0c18xMjEzKGltcFRlcm1fMTIxNiwgZXhNb2R1bGVfMTIxNywgY29udGV4dF8xMjE4KSB7XG4gIGxldCBuYW1lc18xMjE5ID0gW107XG4gIGxldCBwaGFzZV8xMjIwID0gaW1wVGVybV8xMjE2LmZvclN5bnRheCA/IGNvbnRleHRfMTIxOC5waGFzZSArIDEgOiBjb250ZXh0XzEyMTgucGhhc2U7XG4gIGltcFRlcm1fMTIxNi5uYW1lZEltcG9ydHMuZm9yRWFjaChzcGVjaWZpZXJfMTIyMSA9PiB7XG4gICAgbGV0IG5hbWVfMTIyMiA9IHNwZWNpZmllcl8xMjIxLmJpbmRpbmcubmFtZTtcbiAgICBsZXQgZXhwb3J0TmFtZV8xMjIzID0gZmluZE5hbWVJbkV4cG9ydHNfMTIxNChuYW1lXzEyMjIsIGV4TW9kdWxlXzEyMTcuZXhwb3J0RW50cmllcyk7XG4gICAgaWYgKGV4cG9ydE5hbWVfMTIyMyAhPSBudWxsKSB7XG4gICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuYW1lXzEyMjIudmFsKCkpO1xuICAgICAgY29udGV4dF8xMjE4LnN0b3JlLnNldChuZXdCaW5kaW5nLnRvU3RyaW5nKCksIG5ldyBWYXJCaW5kaW5nVHJhbnNmb3JtKG5hbWVfMTIyMikpO1xuICAgICAgY29udGV4dF8xMjE4LmJpbmRpbmdzLmFkZEZvcndhcmQobmFtZV8xMjIyLCBleHBvcnROYW1lXzEyMjMsIG5ld0JpbmRpbmcsIHBoYXNlXzEyMjApO1xuICAgICAgbmFtZXNfMTIxOS5wdXNoKG5hbWVfMTIyMik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIExpc3QobmFtZXNfMTIxOSk7XG59XG5mdW5jdGlvbiBmaW5kTmFtZUluRXhwb3J0c18xMjE0KG5hbWVfMTIyNCwgZXhwXzEyMjUpIHtcbiAgbGV0IGZvdW5kTmFtZXNfMTIyNiA9IGV4cF8xMjI1LnJlZHVjZSgoYWNjXzEyMjcsIGVfMTIyOCkgPT4ge1xuICAgIGlmIChpc0V4cG9ydEZyb20oZV8xMjI4KSkge1xuICAgICAgcmV0dXJuIGFjY18xMjI3LmNvbmNhdChlXzEyMjgubmFtZWRFeHBvcnRzLnJlZHVjZSgoYWNjXzEyMjksIHNwZWNpZmllcl8xMjMwKSA9PiB7XG4gICAgICAgIGlmIChzcGVjaWZpZXJfMTIzMC5leHBvcnRlZE5hbWUudmFsKCkgPT09IG5hbWVfMTIyNC52YWwoKSkge1xuICAgICAgICAgIHJldHVybiBhY2NfMTIyOS5jb25jYXQoc3BlY2lmaWVyXzEyMzAuZXhwb3J0ZWROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjXzEyMjk7XG4gICAgICB9LCBMaXN0KCkpKTtcbiAgICB9IGVsc2UgaWYgKGlzRXhwb3J0KGVfMTIyOCkpIHtcbiAgICAgIHJldHVybiBhY2NfMTIyNy5jb25jYXQoZV8xMjI4LmRlY2xhcmF0aW9uLmRlY2xhcmF0b3JzLnJlZHVjZSgoYWNjXzEyMzEsIGRlY2xfMTIzMikgPT4ge1xuICAgICAgICBpZiAoZGVjbF8xMjMyLmJpbmRpbmcubmFtZS52YWwoKSA9PT0gbmFtZV8xMjI0LnZhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY18xMjMxLmNvbmNhdChkZWNsXzEyMzIuYmluZGluZy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjXzEyMzE7XG4gICAgICB9LCBMaXN0KCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY18xMjI3O1xuICB9LCBMaXN0KCkpO1xuICBhc3NlcnQoZm91bmROYW1lc18xMjI2LnNpemUgPD0gMSwgXCJleHBlY3Rpbmcgbm8gbW9yZSB0aGFuIDEgbWF0Y2hpbmcgbmFtZSBpbiBleHBvcnRzXCIpO1xuICByZXR1cm4gZm91bmROYW1lc18xMjI2LmdldCgwKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5hbWVzXzEyMTUoaW1wVGVybV8xMjMzLCBuYW1lc18xMjM0KSB7XG4gIGxldCBuYW1lZEltcG9ydHNfMTIzNSA9IGltcFRlcm1fMTIzMy5uYW1lZEltcG9ydHMuZmlsdGVyKHNwZWNpZmllcl8xMjM2ID0+ICFuYW1lc18xMjM0LmNvbnRhaW5zKHNwZWNpZmllcl8xMjM2LmJpbmRpbmcubmFtZSkpO1xuICByZXR1cm4gaW1wVGVybV8xMjMzLmV4dGVuZCh7bmFtZWRJbXBvcnRzOiBuYW1lZEltcG9ydHNfMTIzNX0pO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9rZW5FeHBhbmRlciBleHRlbmRzIEFTVERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0XzEyMzcpIHtcbiAgICBzdXBlcihcImV4cGFuZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF8xMjM3O1xuICB9XG4gIGV4cGFuZChzdHhsXzEyMzgpIHtcbiAgICBsZXQgcmVzdWx0XzEyMzkgPSBbXTtcbiAgICBpZiAoc3R4bF8xMjM4LnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBMaXN0KHJlc3VsdF8xMjM5KTtcbiAgICB9XG4gICAgbGV0IHByZXZfMTI0MCA9IExpc3QoKTtcbiAgICBsZXQgZW5mXzEyNDEgPSBuZXcgRW5mb3Jlc3RlcihzdHhsXzEyMzgsIHByZXZfMTI0MCwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoIWVuZl8xMjQxLmRvbmUpIHtcbiAgICAgIHJlc3VsdF8xMjM5LnB1c2godGhpcy5kaXNwYXRjaChlbmZfMTI0MS5lbmZvcmVzdCgpKSk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF8xMjM5KTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm1fMTI0Mikge1xuICAgIHJldHVybiB0ZXJtXzEyNDIuZXh0ZW5kKHtkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjQyLmRlY2xhcmF0aW9uKX0pO1xuICB9XG4gIGV4cGFuZEZ1bmN0aW9uRGVjbGFyYXRpb24odGVybV8xMjQzKSB7XG4gICAgbGV0IHJlZ2lzdGVyZWRUZXJtXzEyNDQgPSB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzKHRlcm1fMTI0Myk7XG4gICAgbGV0IHN0eF8xMjQ1ID0gcmVnaXN0ZXJlZFRlcm1fMTI0NC5uYW1lLm5hbWU7XG4gICAgdGhpcy5jb250ZXh0LmVudi5zZXQoc3R4XzEyNDUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfMTI0NSkpO1xuICAgIHJldHVybiByZWdpc3RlcmVkVGVybV8xMjQ0O1xuICB9XG4gIGV4cGFuZEltcG9ydCh0ZXJtXzEyNDYpIHtcbiAgICBsZXQgcGF0aF8xMjQ3ID0gdGVybV8xMjQ2Lm1vZHVsZVNwZWNpZmllci52YWwoKTtcbiAgICBsZXQgbW9kXzEyNDg7XG4gICAgaWYgKHRlcm1fMTI0Ni5mb3JTeW50YXgpIHtcbiAgICAgIG1vZF8xMjQ4ID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMuZ2V0QXRQaGFzZShwYXRoXzEyNDcsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5jd2QpO1xuICAgICAgdGhpcy5jb250ZXh0LnN0b3JlID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMudmlzaXQobW9kXzEyNDgsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB0aGlzLmNvbnRleHQubW9kdWxlcy5pbnZva2UobW9kXzEyNDgsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZF8xMjQ4ID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMuZ2V0QXRQaGFzZShwYXRoXzEyNDcsIHRoaXMuY29udGV4dC5waGFzZSwgdGhpcy5jb250ZXh0LmN3ZCk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB0aGlzLmNvbnRleHQubW9kdWxlcy52aXNpdChtb2RfMTI0OCwgdGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuc3RvcmUpO1xuICAgIH1cbiAgICBsZXQgYm91bmROYW1lc18xMjQ5ID0gYmluZEltcG9ydHNfMTIxMyh0ZXJtXzEyNDYsIG1vZF8xMjQ4LCB0aGlzLmNvbnRleHQpO1xuICAgIHJldHVybiByZW1vdmVOYW1lc18xMjE1KHRlcm1fMTI0NiwgYm91bmROYW1lc18xMjQ5KTtcbiAgfVxuICBleHBhbmRFeHBvcnQodGVybV8xMjUwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb25EZWNsYXJhdGlvbih0ZXJtXzEyNTAuZGVjbGFyYXRpb24pIHx8IGlzQ2xhc3NEZWNsYXJhdGlvbih0ZXJtXzEyNTAuZGVjbGFyYXRpb24pKSB7XG4gICAgICByZXR1cm4gdGVybV8xMjUwLmV4dGVuZCh7ZGVjbGFyYXRpb246IHRoaXMucmVnaXN0ZXJGdW5jdGlvbk9yQ2xhc3ModGVybV8xMjUwLmRlY2xhcmF0aW9uKX0pO1xuICAgIH0gZWxzZSBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMTI1MC5kZWNsYXJhdGlvbikpIHtcbiAgICAgIHJldHVybiB0ZXJtXzEyNTAuZXh0ZW5kKHtkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjUwLmRlY2xhcmF0aW9uKX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVybV8xMjUwO1xuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzKHRlcm1fMTI1MSkge1xuICAgIGxldCBuYW1lXzEyNTIgPSB0ZXJtXzEyNTEubmFtZS5yZW1vdmVTY29wZSh0aGlzLmNvbnRleHQudXNlU2NvcGUsIHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgY29sbGVjdEJpbmRpbmdzKHRlcm1fMTI1MS5uYW1lKS5mb3JFYWNoKHN0eF8xMjUzID0+IHtcbiAgICAgIGxldCBuZXdCaW5kaW5nXzEyNTQgPSBnZW5zeW0oc3R4XzEyNTMudmFsKCkpO1xuICAgICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChzdHhfMTI1Mywge2JpbmRpbmc6IG5ld0JpbmRpbmdfMTI1NCwgcGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSwgc2tpcER1cDogZmFsc2V9KTtcbiAgICAgIHRoaXMuY29udGV4dC5lbnYuc2V0KG5ld0JpbmRpbmdfMTI1NC50b1N0cmluZygpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfMTI1MykpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXJtXzEyNTEuZXh0ZW5kKHtuYW1lOiBuYW1lXzEyNTJ9KTtcbiAgfVxuICByZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjU1KSB7XG4gICAgaWYgKGlzU3ludGF4RGVjbGFyYXRpb24odGVybV8xMjU1KSB8fCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uKHRlcm1fMTI1NSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24odGVybV8xMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm1fMTI1NS5leHRlbmQoe2RlY2xhcmF0b3JzOiB0ZXJtXzEyNTUuZGVjbGFyYXRvcnMubWFwKGRlY2xfMTI1NiA9PiB7XG4gICAgICBsZXQgYmluZGluZ18xMjU3ID0gZGVjbF8xMjU2LmJpbmRpbmcucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LnVzZVNjb3BlLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgY29sbGVjdEJpbmRpbmdzKGJpbmRpbmdfMTI1NykuZm9yRWFjaChzdHhfMTI1OCA9PiB7XG4gICAgICAgIGxldCBuZXdCaW5kaW5nXzEyNTkgPSBnZW5zeW0oc3R4XzEyNTgudmFsKCkpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MuYWRkKHN0eF8xMjU4LCB7YmluZGluZzogbmV3QmluZGluZ18xMjU5LCBwaGFzZTogdGhpcy5jb250ZXh0LnBoYXNlLCBza2lwRHVwOiB0ZXJtXzEyNTUua2luZCA9PT0gXCJ2YXJcIn0pO1xuICAgICAgICB0aGlzLmNvbnRleHQuZW52LnNldChuZXdCaW5kaW5nXzEyNTkudG9TdHJpbmcoKSwgbmV3IFZhckJpbmRpbmdUcmFuc2Zvcm0oc3R4XzEyNTgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlY2xfMTI1Ni5leHRlbmQoe2JpbmRpbmc6IGJpbmRpbmdfMTI1N30pO1xuICAgIH0pfSk7XG4gIH1cbiAgcmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbih0ZXJtXzEyNjApIHtcbiAgICBpZiAoaXNTeW50YXhEZWNsYXJhdGlvbih0ZXJtXzEyNjApKSB7XG4gICAgICBsZXQgc2NvcGUgPSBmcmVzaFNjb3BlKFwibm9ucmVjXCIpO1xuICAgICAgdGVybV8xMjYwID0gdGVybV8xMjYwLmV4dGVuZCh7ZGVjbGFyYXRvcnM6IHRlcm1fMTI2MC5kZWNsYXJhdG9ycy5tYXAoZGVjbF8xMjYxID0+IHtcbiAgICAgICAgbGV0IG5hbWVfMTI2MiA9IGRlY2xfMTI2MS5iaW5kaW5nLm5hbWU7XG4gICAgICAgIGxldCBuYW1lQWRkZWRfMTI2MyA9IG5hbWVfMTI2Mi5hZGRTY29wZShzY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKTtcbiAgICAgICAgbGV0IG5hbWVSZW1vdmVkXzEyNjQgPSBuYW1lXzEyNjIucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZVt0aGlzLmNvbnRleHQuY3VycmVudFNjb3BlLmxlbmd0aCAtIDFdLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgICBsZXQgbmV3QmluZGluZ18xMjY1ID0gZ2Vuc3ltKG5hbWVfMTI2Mi52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGRGb3J3YXJkKG5hbWVBZGRlZF8xMjYzLCBuYW1lUmVtb3ZlZF8xMjY0LCBuZXdCaW5kaW5nXzEyNjUsIHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgICAgIHJldHVybiBkZWNsXzEyNjEuZXh0ZW5kKHtpbml0OiBkZWNsXzEyNjEuaW5pdC5hZGRTY29wZShzY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKX0pO1xuICAgICAgfSl9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm1fMTI2MC5leHRlbmQoe2RlY2xhcmF0b3JzOiB0ZXJtXzEyNjAuZGVjbGFyYXRvcnMubWFwKGRlY2xfMTI2NiA9PiB7XG4gICAgICBsZXQgYmluZGluZ18xMjY3ID0gZGVjbF8xMjY2LmJpbmRpbmcucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LnVzZVNjb3BlLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgbGV0IHN5bnRheEV4cGFuZGVyXzEyNjggPSBuZXcgVGVybUV4cGFuZGVyKF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSArIDEsIGVudjogbmV3IEVudiwgc3RvcmU6IHRoaXMuY29udGV4dC5zdG9yZX0pKTtcbiAgICAgIGxldCBpbml0XzEyNjkgPSBzeW50YXhFeHBhbmRlcl8xMjY4LmV4cGFuZChkZWNsXzEyNjYuaW5pdCk7XG4gICAgICBsZXQgdmFsXzEyNzAgPSBldmFsQ29tcGlsZXRpbWVWYWx1ZShpbml0XzEyNjkuZ2VuKCksIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSArIDF9KSk7XG4gICAgICBjb2xsZWN0QmluZGluZ3MoYmluZGluZ18xMjY3KS5mb3JFYWNoKHN0eF8xMjcxID0+IHtcbiAgICAgICAgbGV0IG5ld0JpbmRpbmdfMTI3MiA9IGdlbnN5bShzdHhfMTI3MS52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzEyNzEsIHtiaW5kaW5nOiBuZXdCaW5kaW5nXzEyNzIsIHBoYXNlOiB0aGlzLmNvbnRleHQucGhhc2UsIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICAgIGxldCByZXNvbHZlZE5hbWVfMTI3MyA9IHN0eF8xMjcxLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVudi5zZXQocmVzb2x2ZWROYW1lXzEyNzMsIG5ldyBDb21waWxldGltZVRyYW5zZm9ybSh2YWxfMTI3MCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVjbF8xMjY2LmV4dGVuZCh7YmluZGluZzogYmluZGluZ18xMjY3LCBpbml0OiBpbml0XzEyNjl9KTtcbiAgICB9KX0pO1xuICB9XG59XG4iXX0=

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Enforester = undefined;

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _transforms = __webpack_require__(31);

	var _immutable = __webpack_require__(11);

	var _errors = __webpack_require__(13);

	var _operators = __webpack_require__(51);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _scope = __webpack_require__(43);

	var _loadSyntax = __webpack_require__(52);

	var _macroContext = __webpack_require__(64);

	var _macroContext2 = _interopRequireDefault(_macroContext);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const EXPR_LOOP_OPERATOR_41 = {};
	const EXPR_LOOP_NO_CHANGE_42 = {};
	const EXPR_LOOP_EXPANSION_43 = {};
	class Enforester_44 {
	  constructor(stxl_45, prev_46, context_47) {
	    this.done = false;
	    (0, _errors.assert)(_immutable.List.isList(stxl_45), "expecting a list of terms to enforest");
	    (0, _errors.assert)(_immutable.List.isList(prev_46), "expecting a list of terms to enforest");
	    (0, _errors.assert)(context_47, "expecting a context to enforest");
	    this.term = null;
	    this.rest = stxl_45;
	    this.prev = prev_46;
	    this.context = context_47;
	  }
	  peek() {
	    let n_48 = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	    return this.rest.get(n_48);
	  }
	  advance() {
	    let ret_49 = this.rest.first();
	    this.rest = this.rest.rest();
	    return ret_49;
	  }
	  enforest() {
	    let type_50 = arguments.length <= 0 || arguments[0] === undefined ? "Module" : arguments[0];

	    this.term = null;
	    if (this.rest.size === 0) {
	      this.done = true;
	      return this.term;
	    }
	    if (this.isEOF(this.peek())) {
	      this.term = new _terms2.default("EOF", {});
	      this.advance();
	      return this.term;
	    }
	    let result_51;
	    if (type_50 === "expression") {
	      result_51 = this.enforestExpressionLoop();
	    } else {
	      result_51 = this.enforestModule();
	    }
	    if (this.rest.size === 0) {
	      this.done = true;
	    }
	    return result_51;
	  }
	  enforestModule() {
	    return this.enforestBody();
	  }
	  enforestBody() {
	    return this.enforestModuleItem();
	  }
	  enforestModuleItem() {
	    let lookahead_52 = this.peek();
	    if (this.isKeyword(lookahead_52, "import")) {
	      this.advance();
	      return this.enforestImportDeclaration();
	    } else if (this.isKeyword(lookahead_52, "export")) {
	      this.advance();
	      return this.enforestExportDeclaration();
	    } else if (this.isIdentifier(lookahead_52, "#")) {
	      return this.enforestLanguagePragma();
	    }
	    return this.enforestStatement();
	  }
	  enforestLanguagePragma() {
	    this.matchIdentifier("#");
	    this.matchIdentifier("lang");
	    let path_53 = this.matchStringLiteral();
	    this.consumeSemicolon();
	    return new _terms2.default("Pragma", { kind: "lang", items: _immutable.List.of(path_53) });
	  }
	  enforestExportDeclaration() {
	    let lookahead_54 = this.peek();
	    if (this.isPunctuator(lookahead_54, "*")) {
	      this.advance();
	      let moduleSpecifier = this.enforestFromClause();
	      return new _terms2.default("ExportAllFrom", { moduleSpecifier: moduleSpecifier });
	    } else if (this.isBraces(lookahead_54)) {
	      let namedExports = this.enforestExportClause();
	      let moduleSpecifier = null;
	      if (this.isIdentifier(this.peek(), "from")) {
	        moduleSpecifier = this.enforestFromClause();
	      }
	      return new _terms2.default("ExportFrom", { namedExports: namedExports, moduleSpecifier: moduleSpecifier });
	    } else if (this.isKeyword(lookahead_54, "class")) {
	      return new _terms2.default("Export", { declaration: this.enforestClass({ isExpr: false }) });
	    } else if (this.isFnDeclTransform(lookahead_54)) {
	      return new _terms2.default("Export", { declaration: this.enforestFunction({ isExpr: false, inDefault: false }) });
	    } else if (this.isKeyword(lookahead_54, "default")) {
	      this.advance();
	      if (this.isFnDeclTransform(this.peek())) {
	        return new _terms2.default("ExportDefault", { body: this.enforestFunction({ isExpr: false, inDefault: true }) });
	      } else if (this.isKeyword(this.peek(), "class")) {
	        return new _terms2.default("ExportDefault", { body: this.enforestClass({ isExpr: false, inDefault: true }) });
	      } else {
	        let body = this.enforestExpressionLoop();
	        this.consumeSemicolon();
	        return new _terms2.default("ExportDefault", { body: body });
	      }
	    } else if (this.isVarDeclTransform(lookahead_54) || this.isLetDeclTransform(lookahead_54) || this.isConstDeclTransform(lookahead_54) || this.isSyntaxrecDeclTransform(lookahead_54) || this.isSyntaxDeclTransform(lookahead_54)) {
	      return new _terms2.default("Export", { declaration: this.enforestVariableDeclaration() });
	    }
	    throw this.createError(lookahead_54, "unexpected syntax");
	  }
	  enforestExportClause() {
	    let enf_55 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let result_56 = [];
	    while (enf_55.rest.size !== 0) {
	      result_56.push(enf_55.enforestExportSpecifier());
	      enf_55.consumeComma();
	    }
	    return (0, _immutable.List)(result_56);
	  }
	  enforestExportSpecifier() {
	    let name_57 = this.enforestIdentifier();
	    if (this.isIdentifier(this.peek(), "as")) {
	      this.advance();
	      let exportedName = this.enforestIdentifier();
	      return new _terms2.default("ExportSpecifier", { name: name_57, exportedName: exportedName });
	    }
	    return new _terms2.default("ExportSpecifier", { name: null, exportedName: name_57 });
	  }
	  enforestImportDeclaration() {
	    let lookahead_58 = this.peek();
	    let defaultBinding_59 = null;
	    let namedImports_60 = (0, _immutable.List)();
	    let forSyntax_61 = false;
	    if (this.isStringLiteral(lookahead_58)) {
	      let moduleSpecifier = this.advance();
	      this.consumeSemicolon();
	      return new _terms2.default("Import", { defaultBinding: defaultBinding_59, namedImports: namedImports_60, moduleSpecifier: moduleSpecifier });
	    }
	    if (this.isIdentifier(lookahead_58) || this.isKeyword(lookahead_58)) {
	      defaultBinding_59 = this.enforestBindingIdentifier();
	      if (!this.isPunctuator(this.peek(), ",")) {
	        let moduleSpecifier = this.enforestFromClause();
	        if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
	          this.advance();
	          this.advance();
	          forSyntax_61 = true;
	        }
	        return new _terms2.default("Import", { defaultBinding: defaultBinding_59, moduleSpecifier: moduleSpecifier, namedImports: (0, _immutable.List)(), forSyntax: forSyntax_61 });
	      }
	    }
	    this.consumeComma();
	    lookahead_58 = this.peek();
	    if (this.isBraces(lookahead_58)) {
	      let imports = this.enforestNamedImports();
	      let fromClause = this.enforestFromClause();
	      if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
	        this.advance();
	        this.advance();
	        forSyntax_61 = true;
	      }
	      return new _terms2.default("Import", { defaultBinding: defaultBinding_59, forSyntax: forSyntax_61, namedImports: imports, moduleSpecifier: fromClause });
	    } else if (this.isPunctuator(lookahead_58, "*")) {
	      let namespaceBinding = this.enforestNamespaceBinding();
	      let moduleSpecifier = this.enforestFromClause();
	      if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
	        this.advance();
	        this.advance();
	        forSyntax_61 = true;
	      }
	      return new _terms2.default("ImportNamespace", { defaultBinding: defaultBinding_59, forSyntax: forSyntax_61, namespaceBinding: namespaceBinding, moduleSpecifier: moduleSpecifier });
	    }
	    throw this.createError(lookahead_58, "unexpected syntax");
	  }
	  enforestNamespaceBinding() {
	    this.matchPunctuator("*");
	    this.matchIdentifier("as");
	    return this.enforestBindingIdentifier();
	  }
	  enforestNamedImports() {
	    let enf_62 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let result_63 = [];
	    while (enf_62.rest.size !== 0) {
	      result_63.push(enf_62.enforestImportSpecifiers());
	      enf_62.consumeComma();
	    }
	    return (0, _immutable.List)(result_63);
	  }
	  enforestImportSpecifiers() {
	    let lookahead_64 = this.peek();
	    let name_65;
	    if (this.isIdentifier(lookahead_64) || this.isKeyword(lookahead_64)) {
	      name_65 = this.advance();
	      if (!this.isIdentifier(this.peek(), "as")) {
	        return new _terms2.default("ImportSpecifier", { name: null, binding: new _terms2.default("BindingIdentifier", { name: name_65 }) });
	      } else {
	        this.matchIdentifier("as");
	      }
	    } else {
	      throw this.createError(lookahead_64, "unexpected token in import specifier");
	    }
	    return new _terms2.default("ImportSpecifier", { name: name_65, binding: this.enforestBindingIdentifier() });
	  }
	  enforestFromClause() {
	    this.matchIdentifier("from");
	    let lookahead_66 = this.matchStringLiteral();
	    this.consumeSemicolon();
	    return lookahead_66;
	  }
	  enforestStatementListItem() {
	    let lookahead_67 = this.peek();
	    if (this.isFnDeclTransform(lookahead_67)) {
	      return this.enforestFunctionDeclaration({ isExpr: false });
	    } else if (this.isKeyword(lookahead_67, "class")) {
	      return this.enforestClass({ isExpr: false });
	    } else {
	      return this.enforestStatement();
	    }
	  }
	  enforestStatement() {
	    let lookahead_68 = this.peek();
	    if (this.term === null && this.isCompiletimeTransform(lookahead_68)) {
	      this.expandMacro();
	      lookahead_68 = this.peek();
	    }
	    if (this.term === null && this.isTerm(lookahead_68)) {
	      return this.advance();
	    }
	    if (this.term === null && this.isBraces(lookahead_68)) {
	      return this.enforestBlockStatement();
	    }
	    if (this.term === null && this.isWhileTransform(lookahead_68)) {
	      return this.enforestWhileStatement();
	    }
	    if (this.term === null && this.isIfTransform(lookahead_68)) {
	      return this.enforestIfStatement();
	    }
	    if (this.term === null && this.isForTransform(lookahead_68)) {
	      return this.enforestForStatement();
	    }
	    if (this.term === null && this.isSwitchTransform(lookahead_68)) {
	      return this.enforestSwitchStatement();
	    }
	    if (this.term === null && this.isBreakTransform(lookahead_68)) {
	      return this.enforestBreakStatement();
	    }
	    if (this.term === null && this.isContinueTransform(lookahead_68)) {
	      return this.enforestContinueStatement();
	    }
	    if (this.term === null && this.isDoTransform(lookahead_68)) {
	      return this.enforestDoStatement();
	    }
	    if (this.term === null && this.isDebuggerTransform(lookahead_68)) {
	      return this.enforestDebuggerStatement();
	    }
	    if (this.term === null && this.isWithTransform(lookahead_68)) {
	      return this.enforestWithStatement();
	    }
	    if (this.term === null && this.isTryTransform(lookahead_68)) {
	      return this.enforestTryStatement();
	    }
	    if (this.term === null && this.isThrowTransform(lookahead_68)) {
	      return this.enforestThrowStatement();
	    }
	    if (this.term === null && this.isKeyword(lookahead_68, "class")) {
	      return this.enforestClass({ isExpr: false });
	    }
	    if (this.term === null && this.isFnDeclTransform(lookahead_68)) {
	      return this.enforestFunctionDeclaration();
	    }
	    if (this.term === null && this.isIdentifier(lookahead_68) && this.isPunctuator(this.peek(1), ":")) {
	      return this.enforestLabeledStatement();
	    }
	    if (this.term === null && (this.isVarDeclTransform(lookahead_68) || this.isLetDeclTransform(lookahead_68) || this.isConstDeclTransform(lookahead_68) || this.isSyntaxrecDeclTransform(lookahead_68) || this.isSyntaxDeclTransform(lookahead_68))) {
	      let stmt = new _terms2.default("VariableDeclarationStatement", { declaration: this.enforestVariableDeclaration() });
	      this.consumeSemicolon();
	      return stmt;
	    }
	    if (this.term === null && this.isReturnStmtTransform(lookahead_68)) {
	      return this.enforestReturnStatement();
	    }
	    if (this.term === null && this.isPunctuator(lookahead_68, ";")) {
	      this.advance();
	      return new _terms2.default("EmptyStatement", {});
	    }
	    return this.enforestExpressionStatement();
	  }
	  enforestLabeledStatement() {
	    let label_69 = this.matchIdentifier();
	    let punc_70 = this.matchPunctuator(":");
	    let stmt_71 = this.enforestStatement();
	    return new _terms2.default("LabeledStatement", { label: label_69, body: stmt_71 });
	  }
	  enforestBreakStatement() {
	    this.matchKeyword("break");
	    let lookahead_72 = this.peek();
	    let label_73 = null;
	    if (this.rest.size === 0 || this.isPunctuator(lookahead_72, ";")) {
	      this.consumeSemicolon();
	      return new _terms2.default("BreakStatement", { label: label_73 });
	    }
	    if (this.isIdentifier(lookahead_72) || this.isKeyword(lookahead_72, "yield") || this.isKeyword(lookahead_72, "let")) {
	      label_73 = this.enforestIdentifier();
	    }
	    this.consumeSemicolon();
	    return new _terms2.default("BreakStatement", { label: label_73 });
	  }
	  enforestTryStatement() {
	    this.matchKeyword("try");
	    let body_74 = this.enforestBlock();
	    if (this.isKeyword(this.peek(), "catch")) {
	      let catchClause = this.enforestCatchClause();
	      if (this.isKeyword(this.peek(), "finally")) {
	        this.advance();
	        let finalizer = this.enforestBlock();
	        return new _terms2.default("TryFinallyStatement", { body: body_74, catchClause: catchClause, finalizer: finalizer });
	      }
	      return new _terms2.default("TryCatchStatement", { body: body_74, catchClause: catchClause });
	    }
	    if (this.isKeyword(this.peek(), "finally")) {
	      this.advance();
	      let finalizer = this.enforestBlock();
	      return new _terms2.default("TryFinallyStatement", { body: body_74, catchClause: null, finalizer: finalizer });
	    }
	    throw this.createError(this.peek(), "try with no catch or finally");
	  }
	  enforestCatchClause() {
	    this.matchKeyword("catch");
	    let bindingParens_75 = this.matchParens();
	    let enf_76 = new Enforester_44(bindingParens_75, (0, _immutable.List)(), this.context);
	    let binding_77 = enf_76.enforestBindingTarget();
	    let body_78 = this.enforestBlock();
	    return new _terms2.default("CatchClause", { binding: binding_77, body: body_78 });
	  }
	  enforestThrowStatement() {
	    this.matchKeyword("throw");
	    let expression_79 = this.enforestExpression();
	    this.consumeSemicolon();
	    return new _terms2.default("ThrowStatement", { expression: expression_79 });
	  }
	  enforestWithStatement() {
	    this.matchKeyword("with");
	    let objParens_80 = this.matchParens();
	    let enf_81 = new Enforester_44(objParens_80, (0, _immutable.List)(), this.context);
	    let object_82 = enf_81.enforestExpression();
	    let body_83 = this.enforestStatement();
	    return new _terms2.default("WithStatement", { object: object_82, body: body_83 });
	  }
	  enforestDebuggerStatement() {
	    this.matchKeyword("debugger");
	    return new _terms2.default("DebuggerStatement", {});
	  }
	  enforestDoStatement() {
	    this.matchKeyword("do");
	    let body_84 = this.enforestStatement();
	    this.matchKeyword("while");
	    let testBody_85 = this.matchParens();
	    let enf_86 = new Enforester_44(testBody_85, (0, _immutable.List)(), this.context);
	    let test_87 = enf_86.enforestExpression();
	    this.consumeSemicolon();
	    return new _terms2.default("DoWhileStatement", { body: body_84, test: test_87 });
	  }
	  enforestContinueStatement() {
	    let kwd_88 = this.matchKeyword("continue");
	    let lookahead_89 = this.peek();
	    let label_90 = null;
	    if (this.rest.size === 0 || this.isPunctuator(lookahead_89, ";")) {
	      this.consumeSemicolon();
	      return new _terms2.default("ContinueStatement", { label: label_90 });
	    }
	    if (this.lineNumberEq(kwd_88, lookahead_89) && (this.isIdentifier(lookahead_89) || this.isKeyword(lookahead_89, "yield") || this.isKeyword(lookahead_89, "let"))) {
	      label_90 = this.enforestIdentifier();
	    }
	    this.consumeSemicolon();
	    return new _terms2.default("ContinueStatement", { label: label_90 });
	  }
	  enforestSwitchStatement() {
	    this.matchKeyword("switch");
	    let cond_91 = this.matchParens();
	    let enf_92 = new Enforester_44(cond_91, (0, _immutable.List)(), this.context);
	    let discriminant_93 = enf_92.enforestExpression();
	    let body_94 = this.matchCurlies();
	    if (body_94.size === 0) {
	      return new _terms2.default("SwitchStatement", { discriminant: discriminant_93, cases: (0, _immutable.List)() });
	    }
	    enf_92 = new Enforester_44(body_94, (0, _immutable.List)(), this.context);
	    let cases_95 = enf_92.enforestSwitchCases();
	    let lookahead_96 = enf_92.peek();
	    if (enf_92.isKeyword(lookahead_96, "default")) {
	      let defaultCase = enf_92.enforestSwitchDefault();
	      let postDefaultCases = enf_92.enforestSwitchCases();
	      return new _terms2.default("SwitchStatementWithDefault", { discriminant: discriminant_93, preDefaultCases: cases_95, defaultCase: defaultCase, postDefaultCases: postDefaultCases });
	    }
	    return new _terms2.default("SwitchStatement", { discriminant: discriminant_93, cases: cases_95 });
	  }
	  enforestSwitchCases() {
	    let cases_97 = [];
	    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), "default"))) {
	      cases_97.push(this.enforestSwitchCase());
	    }
	    return (0, _immutable.List)(cases_97);
	  }
	  enforestSwitchCase() {
	    this.matchKeyword("case");
	    return new _terms2.default("SwitchCase", { test: this.enforestExpression(), consequent: this.enforestSwitchCaseBody() });
	  }
	  enforestSwitchCaseBody() {
	    this.matchPunctuator(":");
	    return this.enforestStatementListInSwitchCaseBody();
	  }
	  enforestStatementListInSwitchCaseBody() {
	    let result_98 = [];
	    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), "default") || this.isKeyword(this.peek(), "case"))) {
	      result_98.push(this.enforestStatementListItem());
	    }
	    return (0, _immutable.List)(result_98);
	  }
	  enforestSwitchDefault() {
	    this.matchKeyword("default");
	    return new _terms2.default("SwitchDefault", { consequent: this.enforestSwitchCaseBody() });
	  }
	  enforestForStatement() {
	    this.matchKeyword("for");
	    let cond_99 = this.matchParens();
	    let enf_100 = new Enforester_44(cond_99, (0, _immutable.List)(), this.context);
	    let lookahead_101, test_102, init_103, right_104, type_105, left_106, update_107;
	    if (enf_100.isPunctuator(enf_100.peek(), ";")) {
	      enf_100.advance();
	      if (!enf_100.isPunctuator(enf_100.peek(), ";")) {
	        test_102 = enf_100.enforestExpression();
	      }
	      enf_100.matchPunctuator(";");
	      if (enf_100.rest.size !== 0) {
	        right_104 = enf_100.enforestExpression();
	      }
	      return new _terms2.default("ForStatement", { init: null, test: test_102, update: right_104, body: this.enforestStatement() });
	    } else {
	      lookahead_101 = enf_100.peek();
	      if (enf_100.isVarDeclTransform(lookahead_101) || enf_100.isLetDeclTransform(lookahead_101) || enf_100.isConstDeclTransform(lookahead_101)) {
	        init_103 = enf_100.enforestVariableDeclaration();
	        lookahead_101 = enf_100.peek();
	        if (this.isKeyword(lookahead_101, "in") || this.isIdentifier(lookahead_101, "of")) {
	          if (this.isKeyword(lookahead_101, "in")) {
	            enf_100.advance();
	            right_104 = enf_100.enforestExpression();
	            type_105 = "ForInStatement";
	          } else if (this.isIdentifier(lookahead_101, "of")) {
	            enf_100.advance();
	            right_104 = enf_100.enforestExpression();
	            type_105 = "ForOfStatement";
	          }
	          return new _terms2.default(type_105, { left: init_103, right: right_104, body: this.enforestStatement() });
	        }
	        enf_100.matchPunctuator(";");
	        if (enf_100.isPunctuator(enf_100.peek(), ";")) {
	          enf_100.advance();
	          test_102 = null;
	        } else {
	          test_102 = enf_100.enforestExpression();
	          enf_100.matchPunctuator(";");
	        }
	        update_107 = enf_100.enforestExpression();
	      } else {
	        if (this.isKeyword(enf_100.peek(1), "in") || this.isIdentifier(enf_100.peek(1), "of")) {
	          left_106 = enf_100.enforestBindingIdentifier();
	          let kind = enf_100.advance();
	          if (this.isKeyword(kind, "in")) {
	            type_105 = "ForInStatement";
	          } else {
	            type_105 = "ForOfStatement";
	          }
	          right_104 = enf_100.enforestExpression();
	          return new _terms2.default(type_105, { left: left_106, right: right_104, body: this.enforestStatement() });
	        }
	        init_103 = enf_100.enforestExpression();
	        enf_100.matchPunctuator(";");
	        if (enf_100.isPunctuator(enf_100.peek(), ";")) {
	          enf_100.advance();
	          test_102 = null;
	        } else {
	          test_102 = enf_100.enforestExpression();
	          enf_100.matchPunctuator(";");
	        }
	        update_107 = enf_100.enforestExpression();
	      }
	      return new _terms2.default("ForStatement", { init: init_103, test: test_102, update: update_107, body: this.enforestStatement() });
	    }
	  }
	  enforestIfStatement() {
	    this.matchKeyword("if");
	    let cond_108 = this.matchParens();
	    let enf_109 = new Enforester_44(cond_108, (0, _immutable.List)(), this.context);
	    let lookahead_110 = enf_109.peek();
	    let test_111 = enf_109.enforestExpression();
	    if (test_111 === null) {
	      throw enf_109.createError(lookahead_110, "expecting an expression");
	    }
	    let consequent_112 = this.enforestStatement();
	    let alternate_113 = null;
	    if (this.isKeyword(this.peek(), "else")) {
	      this.advance();
	      alternate_113 = this.enforestStatement();
	    }
	    return new _terms2.default("IfStatement", { test: test_111, consequent: consequent_112, alternate: alternate_113 });
	  }
	  enforestWhileStatement() {
	    this.matchKeyword("while");
	    let cond_114 = this.matchParens();
	    let enf_115 = new Enforester_44(cond_114, (0, _immutable.List)(), this.context);
	    let lookahead_116 = enf_115.peek();
	    let test_117 = enf_115.enforestExpression();
	    if (test_117 === null) {
	      throw enf_115.createError(lookahead_116, "expecting an expression");
	    }
	    let body_118 = this.enforestStatement();
	    return new _terms2.default("WhileStatement", { test: test_117, body: body_118 });
	  }
	  enforestBlockStatement() {
	    return new _terms2.default("BlockStatement", { block: this.enforestBlock() });
	  }
	  enforestBlock() {
	    let b_119 = this.matchCurlies();
	    let body_120 = [];
	    let enf_121 = new Enforester_44(b_119, (0, _immutable.List)(), this.context);
	    while (enf_121.rest.size !== 0) {
	      let lookahead = enf_121.peek();
	      let stmt = enf_121.enforestStatement();
	      if (stmt == null) {
	        throw enf_121.createError(lookahead, "not a statement");
	      }
	      body_120.push(stmt);
	    }
	    return new _terms2.default("Block", { statements: (0, _immutable.List)(body_120) });
	  }
	  enforestClass(_ref) {
	    let isExpr = _ref.isExpr;
	    let inDefault = _ref.inDefault;

	    let kw_122 = this.advance();
	    let name_123 = null,
	        supr_124 = null;
	    let type_125 = isExpr ? "ClassExpression" : "ClassDeclaration";
	    if (this.isIdentifier(this.peek())) {
	      name_123 = this.enforestBindingIdentifier();
	    } else if (!isExpr) {
	      if (inDefault) {
	        name_123 = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("_default", kw_122) });
	      } else {
	        throw this.createError(this.peek(), "unexpected syntax");
	      }
	    }
	    if (this.isKeyword(this.peek(), "extends")) {
	      this.advance();
	      supr_124 = this.enforestExpressionLoop();
	    }
	    let elements_126 = [];
	    let enf_127 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    while (enf_127.rest.size !== 0) {
	      if (enf_127.isPunctuator(enf_127.peek(), ";")) {
	        enf_127.advance();
	        continue;
	      }
	      let isStatic = false;

	      var _enf_127$enforestMeth = enf_127.enforestMethodDefinition();

	      let methodOrKey = _enf_127$enforestMeth.methodOrKey;
	      let kind = _enf_127$enforestMeth.kind;

	      if (kind === "identifier" && methodOrKey.value.val() === "static") {
	        isStatic = true;

	        var _enf_127$enforestMeth2 = enf_127.enforestMethodDefinition();

	        methodOrKey = _enf_127$enforestMeth2.methodOrKey;
	        kind = _enf_127$enforestMeth2.kind;
	      }
	      if (kind === "method") {
	        elements_126.push(new _terms2.default("ClassElement", { isStatic: isStatic, method: methodOrKey }));
	      } else {
	        throw this.createError(enf_127.peek(), "Only methods are allowed in classes");
	      }
	    }
	    return new _terms2.default(type_125, { name: name_123, super: supr_124, elements: (0, _immutable.List)(elements_126) });
	  }
	  enforestBindingTarget() {
	    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    let allowPunctuator = _ref2.allowPunctuator;

	    let lookahead_128 = this.peek();
	    if (this.isIdentifier(lookahead_128) || this.isKeyword(lookahead_128) || allowPunctuator && this.isPunctuator(lookahead_128)) {
	      return this.enforestBindingIdentifier({ allowPunctuator: allowPunctuator });
	    } else if (this.isBrackets(lookahead_128)) {
	      return this.enforestArrayBinding();
	    } else if (this.isBraces(lookahead_128)) {
	      return this.enforestObjectBinding();
	    }
	    (0, _errors.assert)(false, "not implemented yet");
	  }
	  enforestObjectBinding() {
	    let enf_129 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let properties_130 = [];
	    while (enf_129.rest.size !== 0) {
	      properties_130.push(enf_129.enforestBindingProperty());
	      enf_129.consumeComma();
	    }
	    return new _terms2.default("ObjectBinding", { properties: (0, _immutable.List)(properties_130) });
	  }
	  enforestBindingProperty() {
	    let lookahead_131 = this.peek();

	    var _enforestPropertyName = this.enforestPropertyName();

	    let name = _enforestPropertyName.name;
	    let binding = _enforestPropertyName.binding;

	    if (this.isIdentifier(lookahead_131) || this.isKeyword(lookahead_131, "let") || this.isKeyword(lookahead_131, "yield")) {
	      if (!this.isPunctuator(this.peek(), ":")) {
	        let defaultValue = null;
	        if (this.isAssign(this.peek())) {
	          this.advance();
	          let expr = this.enforestExpressionLoop();
	          defaultValue = expr;
	        }
	        return new _terms2.default("BindingPropertyIdentifier", { binding: binding, init: defaultValue });
	      }
	    }
	    this.matchPunctuator(":");
	    binding = this.enforestBindingElement();
	    return new _terms2.default("BindingPropertyProperty", { name: name, binding: binding });
	  }
	  enforestArrayBinding() {
	    let bracket_132 = this.matchSquares();
	    let enf_133 = new Enforester_44(bracket_132, (0, _immutable.List)(), this.context);
	    let elements_134 = [],
	        restElement_135 = null;
	    while (enf_133.rest.size !== 0) {
	      let el;
	      if (enf_133.isPunctuator(enf_133.peek(), ",")) {
	        enf_133.consumeComma();
	        el = null;
	      } else {
	        if (enf_133.isPunctuator(enf_133.peek(), "...")) {
	          enf_133.advance();
	          restElement_135 = enf_133.enforestBindingTarget();
	          break;
	        } else {
	          el = enf_133.enforestBindingElement();
	        }
	        enf_133.consumeComma();
	      }
	      elements_134.push(el);
	    }
	    return new _terms2.default("ArrayBinding", { elements: (0, _immutable.List)(elements_134), restElement: restElement_135 });
	  }
	  enforestBindingElement() {
	    let binding_136 = this.enforestBindingTarget();
	    if (this.isAssign(this.peek())) {
	      this.advance();
	      let init = this.enforestExpressionLoop();
	      binding_136 = new _terms2.default("BindingWithDefault", { binding: binding_136, init: init });
	    }
	    return binding_136;
	  }
	  enforestBindingIdentifier() {
	    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    let allowPunctuator = _ref3.allowPunctuator;

	    let name_137;
	    if (allowPunctuator && this.isPunctuator(this.peek())) {
	      name_137 = this.enforestPunctuator();
	    } else {
	      name_137 = this.enforestIdentifier();
	    }
	    return new _terms2.default("BindingIdentifier", { name: name_137 });
	  }
	  enforestPunctuator() {
	    let lookahead_138 = this.peek();
	    if (this.isPunctuator(lookahead_138)) {
	      return this.advance();
	    }
	    throw this.createError(lookahead_138, "expecting a punctuator");
	  }
	  enforestIdentifier() {
	    let lookahead_139 = this.peek();
	    if (this.isIdentifier(lookahead_139) || this.isKeyword(lookahead_139)) {
	      return this.advance();
	    }
	    throw this.createError(lookahead_139, "expecting an identifier");
	  }
	  enforestReturnStatement() {
	    let kw_140 = this.advance();
	    let lookahead_141 = this.peek();
	    if (this.rest.size === 0 || lookahead_141 && !this.lineNumberEq(kw_140, lookahead_141)) {
	      return new _terms2.default("ReturnStatement", { expression: null });
	    }
	    let term_142 = null;
	    if (!this.isPunctuator(lookahead_141, ";")) {
	      term_142 = this.enforestExpression();
	      (0, _errors.expect)(term_142 != null, "Expecting an expression to follow return keyword", lookahead_141, this.rest);
	    }
	    this.consumeSemicolon();
	    return new _terms2.default("ReturnStatement", { expression: term_142 });
	  }
	  enforestVariableDeclaration() {
	    let kind_143;
	    let lookahead_144 = this.advance();
	    let kindSyn_145 = lookahead_144;
	    let phase_146 = this.context.phase;
	    if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.VariableDeclTransform) {
	      kind_143 = "var";
	    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.LetDeclTransform) {
	      kind_143 = "let";
	    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.ConstDeclTransform) {
	      kind_143 = "const";
	    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.SyntaxDeclTransform) {
	      kind_143 = "syntax";
	    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.SyntaxrecDeclTransform) {
	      kind_143 = "syntaxrec";
	    }
	    let decls_147 = (0, _immutable.List)();
	    while (true) {
	      let term = this.enforestVariableDeclarator({ isSyntax: kind_143 === "syntax" || kind_143 === "syntaxrec" });
	      let lookahead_144 = this.peek();
	      decls_147 = decls_147.concat(term);
	      if (this.isPunctuator(lookahead_144, ",")) {
	        this.advance();
	      } else {
	        break;
	      }
	    }
	    return new _terms2.default("VariableDeclaration", { kind: kind_143, declarators: decls_147 });
	  }
	  enforestVariableDeclarator(_ref4) {
	    let isSyntax = _ref4.isSyntax;

	    let id_148 = this.enforestBindingTarget({ allowPunctuator: isSyntax });
	    let lookahead_149 = this.peek();
	    let init_150, rest_151;
	    if (this.isPunctuator(lookahead_149, "=")) {
	      this.advance();
	      let enf = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
	      init_150 = enf.enforest("expression");
	      this.rest = enf.rest;
	    } else {
	      init_150 = null;
	    }
	    return new _terms2.default("VariableDeclarator", { binding: id_148, init: init_150 });
	  }
	  enforestExpressionStatement() {
	    let start_152 = this.rest.get(0);
	    let expr_153 = this.enforestExpression();
	    if (expr_153 === null) {
	      throw this.createError(start_152, "not a valid expression");
	    }
	    this.consumeSemicolon();
	    return new _terms2.default("ExpressionStatement", { expression: expr_153 });
	  }
	  enforestExpression() {
	    let left_154 = this.enforestExpressionLoop();
	    let lookahead_155 = this.peek();
	    if (this.isPunctuator(lookahead_155, ",")) {
	      while (this.rest.size !== 0) {
	        if (!this.isPunctuator(this.peek(), ",")) {
	          break;
	        }
	        let operator = this.advance();
	        let right = this.enforestExpressionLoop();
	        left_154 = new _terms2.default("BinaryExpression", { left: left_154, operator: operator, right: right });
	      }
	    }
	    this.term = null;
	    return left_154;
	  }
	  enforestExpressionLoop() {
	    this.term = null;
	    this.opCtx = { prec: 0, combine: x_156 => x_156, stack: (0, _immutable.List)() };
	    do {
	      let term = this.enforestAssignmentExpression();
	      if (term === EXPR_LOOP_NO_CHANGE_42 && this.opCtx.stack.size > 0) {
	        this.term = this.opCtx.combine(this.term);

	        var _opCtx$stack$last = this.opCtx.stack.last();

	        let prec = _opCtx$stack$last.prec;
	        let combine = _opCtx$stack$last.combine;

	        this.opCtx.prec = prec;
	        this.opCtx.combine = combine;
	        this.opCtx.stack = this.opCtx.stack.pop();
	      } else if (term === EXPR_LOOP_NO_CHANGE_42) {
	        break;
	      } else if (term === EXPR_LOOP_OPERATOR_41 || term === EXPR_LOOP_EXPANSION_43) {
	        this.term = null;
	      } else {
	        this.term = term;
	      }
	    } while (true);
	    return this.term;
	  }
	  enforestAssignmentExpression() {
	    let lookahead_157 = this.peek();
	    if (this.term === null && this.isCompiletimeTransform(lookahead_157)) {
	      this.expandMacro();
	      lookahead_157 = this.peek();
	    }
	    if (this.term === null && this.isTerm(lookahead_157)) {
	      return this.advance();
	    }
	    if (this.term === null && this.isKeyword(lookahead_157, "yield")) {
	      return this.enforestYieldExpression();
	    }
	    if (this.term === null && this.isKeyword(lookahead_157, "class")) {
	      return this.enforestClass({ isExpr: true });
	    }
	    if (this.term === null && this.isKeyword(lookahead_157, "super")) {
	      this.advance();
	      return new _terms2.default("Super", {});
	    }
	    if (this.term === null && (this.isIdentifier(lookahead_157) || this.isParens(lookahead_157)) && this.isPunctuator(this.peek(1), "=>") && this.lineNumberEq(lookahead_157, this.peek(1))) {
	      return this.enforestArrowExpression();
	    }
	    if (this.term === null && this.isSyntaxTemplate(lookahead_157)) {
	      return this.enforestSyntaxTemplate();
	    }
	    if (this.term === null && this.isSyntaxQuoteTransform(lookahead_157)) {
	      return this.enforestSyntaxQuote();
	    }
	    if (this.term === null && this.isNewTransform(lookahead_157)) {
	      return this.enforestNewExpression();
	    }
	    if (this.term === null && this.isParens(lookahead_157)) {
	      return new _terms2.default("ParenthesizedExpression", { inner: this.advance().inner() });
	    }
	    if (this.term === null && (this.isKeyword(lookahead_157, "this") || this.isIdentifier(lookahead_157) || this.isKeyword(lookahead_157, "let") || this.isKeyword(lookahead_157, "yield") || this.isNumericLiteral(lookahead_157) || this.isStringLiteral(lookahead_157) || this.isTemplate(lookahead_157) || this.isBooleanLiteral(lookahead_157) || this.isNullLiteral(lookahead_157) || this.isRegularExpression(lookahead_157) || this.isFnDeclTransform(lookahead_157) || this.isBraces(lookahead_157) || this.isBrackets(lookahead_157))) {
	      return this.enforestPrimaryExpression();
	    }
	    if (this.term === null && this.isOperator(lookahead_157)) {
	      return this.enforestUnaryExpression();
	    }
	    if (this.term === null && this.isVarBindingTransform(lookahead_157)) {
	      let id = this.getFromCompiletimeEnvironment(lookahead_157).id;
	      if (id !== lookahead_157) {
	        this.advance();
	        this.rest = _immutable.List.of(id).concat(this.rest);
	        return EXPR_LOOP_EXPANSION_43;
	      }
	    }
	    if (this.term && this.isUpdateOperator(lookahead_157)) {
	      return this.enforestUpdateExpression();
	    }
	    if (this.term && this.isOperator(lookahead_157)) {
	      return this.enforestBinaryExpression();
	    }
	    if (this.term && this.isPunctuator(lookahead_157, ".") && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) {
	      return this.enforestStaticMemberExpression();
	    }
	    if (this.term && this.isBrackets(lookahead_157)) {
	      return this.enforestComputedMemberExpression();
	    }
	    if (this.term && this.isParens(lookahead_157)) {
	      let paren = this.advance();
	      return new _terms2.default("CallExpression", { callee: this.term, arguments: paren.inner() });
	    }
	    if (this.term && this.isTemplate(lookahead_157)) {
	      return new _terms2.default("TemplateExpression", { tag: this.term, elements: this.enforestTemplateElements() });
	    }
	    if (this.term && this.isAssign(lookahead_157)) {
	      let binding = this.transformDestructuring(this.term);
	      let op = this.advance();
	      let enf = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
	      let init = enf.enforest("expression");
	      this.rest = enf.rest;
	      if (op.val() === "=") {
	        return new _terms2.default("AssignmentExpression", { binding: binding, expression: init });
	      } else {
	        return new _terms2.default("CompoundAssignmentExpression", { binding: binding, operator: op.val(), expression: init });
	      }
	    }
	    if (this.term && this.isPunctuator(lookahead_157, "?")) {
	      return this.enforestConditionalExpression();
	    }
	    return EXPR_LOOP_NO_CHANGE_42;
	  }
	  enforestPrimaryExpression() {
	    let lookahead_158 = this.peek();
	    if (this.term === null && this.isKeyword(lookahead_158, "this")) {
	      return this.enforestThisExpression();
	    }
	    if (this.term === null && (this.isIdentifier(lookahead_158) || this.isKeyword(lookahead_158, "let") || this.isKeyword(lookahead_158, "yield"))) {
	      return this.enforestIdentifierExpression();
	    }
	    if (this.term === null && this.isNumericLiteral(lookahead_158)) {
	      return this.enforestNumericLiteral();
	    }
	    if (this.term === null && this.isStringLiteral(lookahead_158)) {
	      return this.enforestStringLiteral();
	    }
	    if (this.term === null && this.isTemplate(lookahead_158)) {
	      return this.enforestTemplateLiteral();
	    }
	    if (this.term === null && this.isBooleanLiteral(lookahead_158)) {
	      return this.enforestBooleanLiteral();
	    }
	    if (this.term === null && this.isNullLiteral(lookahead_158)) {
	      return this.enforestNullLiteral();
	    }
	    if (this.term === null && this.isRegularExpression(lookahead_158)) {
	      return this.enforestRegularExpressionLiteral();
	    }
	    if (this.term === null && this.isFnDeclTransform(lookahead_158)) {
	      return this.enforestFunctionExpression();
	    }
	    if (this.term === null && this.isBraces(lookahead_158)) {
	      return this.enforestObjectExpression();
	    }
	    if (this.term === null && this.isBrackets(lookahead_158)) {
	      return this.enforestArrayExpression();
	    }
	    (0, _errors.assert)(false, "Not a primary expression");
	  }
	  enforestBooleanLiteral() {
	    return new _terms2.default("LiteralBooleanExpression", { value: this.advance() });
	  }
	  enforestTemplateLiteral() {
	    return new _terms2.default("TemplateExpression", { tag: null, elements: this.enforestTemplateElements() });
	  }
	  enforestStringLiteral() {
	    return new _terms2.default("LiteralStringExpression", { value: this.advance() });
	  }
	  enforestNumericLiteral() {
	    let num_159 = this.advance();
	    if (num_159.val() === 1 / 0) {
	      return new _terms2.default("LiteralInfinityExpression", {});
	    }
	    return new _terms2.default("LiteralNumericExpression", { value: num_159 });
	  }
	  enforestIdentifierExpression() {
	    return new _terms2.default("IdentifierExpression", { name: this.advance() });
	  }
	  enforestRegularExpressionLiteral() {
	    let reStx_160 = this.advance();
	    let lastSlash_161 = reStx_160.token.value.lastIndexOf("/");
	    let pattern_162 = reStx_160.token.value.slice(1, lastSlash_161);
	    let flags_163 = reStx_160.token.value.slice(lastSlash_161 + 1);
	    return new _terms2.default("LiteralRegExpExpression", { pattern: pattern_162, flags: flags_163 });
	  }
	  enforestNullLiteral() {
	    this.advance();
	    return new _terms2.default("LiteralNullExpression", {});
	  }
	  enforestThisExpression() {
	    return new _terms2.default("ThisExpression", { stx: this.advance() });
	  }
	  enforestArgumentList() {
	    let result_164 = [];
	    while (this.rest.size > 0) {
	      let arg;
	      if (this.isPunctuator(this.peek(), "...")) {
	        this.advance();
	        arg = new _terms2.default("SpreadElement", { expression: this.enforestExpressionLoop() });
	      } else {
	        arg = this.enforestExpressionLoop();
	      }
	      if (this.rest.size > 0) {
	        this.matchPunctuator(",");
	      }
	      result_164.push(arg);
	    }
	    return (0, _immutable.List)(result_164);
	  }
	  enforestNewExpression() {
	    this.matchKeyword("new");
	    let callee_165;
	    if (this.isKeyword(this.peek(), "new")) {
	      callee_165 = this.enforestNewExpression();
	    } else if (this.isKeyword(this.peek(), "super")) {
	      callee_165 = this.enforestExpressionLoop();
	    } else if (this.isPunctuator(this.peek(), ".") && this.isIdentifier(this.peek(1), "target")) {
	      this.advance();
	      this.advance();
	      return new _terms2.default("NewTargetExpression", {});
	    } else {
	      callee_165 = new _terms2.default("IdentifierExpression", { name: this.enforestIdentifier() });
	    }
	    let args_166;
	    if (this.isParens(this.peek())) {
	      args_166 = this.matchParens();
	    } else {
	      args_166 = (0, _immutable.List)();
	    }
	    return new _terms2.default("NewExpression", { callee: callee_165, arguments: args_166 });
	  }
	  enforestComputedMemberExpression() {
	    let enf_167 = new Enforester_44(this.matchSquares(), (0, _immutable.List)(), this.context);
	    return new _terms2.default("ComputedMemberExpression", { object: this.term, expression: enf_167.enforestExpression() });
	  }
	  transformDestructuring(term_168) {
	    switch (term_168.type) {
	      case "IdentifierExpression":
	        return new _terms2.default("BindingIdentifier", { name: term_168.name });
	      case "ParenthesizedExpression":
	        if (term_168.inner.size === 1 && this.isIdentifier(term_168.inner.get(0))) {
	          return new _terms2.default("BindingIdentifier", { name: term_168.inner.get(0) });
	        }
	      case "DataProperty":
	        return new _terms2.default("BindingPropertyProperty", { name: term_168.name, binding: this.transformDestructuringWithDefault(term_168.expression) });
	      case "ShorthandProperty":
	        return new _terms2.default("BindingPropertyIdentifier", { binding: new _terms2.default("BindingIdentifier", { name: term_168.name }), init: null });
	      case "ObjectExpression":
	        return new _terms2.default("ObjectBinding", { properties: term_168.properties.map(t_169 => this.transformDestructuring(t_169)) });
	      case "ArrayExpression":
	        let last = term_168.elements.last();
	        if (last != null && last.type === "SpreadElement") {
	          return new _terms2.default("ArrayBinding", { elements: term_168.elements.slice(0, -1).map(t_170 => t_170 && this.transformDestructuringWithDefault(t_170)), restElement: this.transformDestructuringWithDefault(last.expression) });
	        } else {
	          return new _terms2.default("ArrayBinding", { elements: term_168.elements.map(t_171 => t_171 && this.transformDestructuringWithDefault(t_171)), restElement: null });
	        }
	        return new _terms2.default("ArrayBinding", { elements: term_168.elements.map(t_172 => t_172 && this.transformDestructuring(t_172)), restElement: null });
	      case "StaticPropertyName":
	        return new _terms2.default("BindingIdentifier", { name: term_168.value });
	      case "ComputedMemberExpression":
	      case "StaticMemberExpression":
	      case "ArrayBinding":
	      case "BindingIdentifier":
	      case "BindingPropertyIdentifier":
	      case "BindingPropertyProperty":
	      case "BindingWithDefault":
	      case "ObjectBinding":
	        return term_168;
	    }
	    (0, _errors.assert)(false, "not implemented yet for " + term_168.type);
	  }
	  transformDestructuringWithDefault(term_173) {
	    switch (term_173.type) {
	      case "AssignmentExpression":
	        return new _terms2.default("BindingWithDefault", { binding: this.transformDestructuring(term_173.binding), init: term_173.expression });
	    }
	    return this.transformDestructuring(term_173);
	  }
	  enforestArrowExpression() {
	    let enf_174;
	    if (this.isIdentifier(this.peek())) {
	      enf_174 = new Enforester_44(_immutable.List.of(this.advance()), (0, _immutable.List)(), this.context);
	    } else {
	      let p = this.matchParens();
	      enf_174 = new Enforester_44(p, (0, _immutable.List)(), this.context);
	    }
	    let params_175 = enf_174.enforestFormalParameters();
	    this.matchPunctuator("=>");
	    let body_176;
	    if (this.isBraces(this.peek())) {
	      body_176 = this.matchCurlies();
	    } else {
	      enf_174 = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
	      body_176 = enf_174.enforestExpressionLoop();
	      this.rest = enf_174.rest;
	    }
	    return new _terms2.default("ArrowExpression", { params: params_175, body: body_176 });
	  }
	  enforestYieldExpression() {
	    let kwd_177 = this.matchKeyword("yield");
	    let lookahead_178 = this.peek();
	    if (this.rest.size === 0 || lookahead_178 && !this.lineNumberEq(kwd_177, lookahead_178)) {
	      return new _terms2.default("YieldExpression", { expression: null });
	    } else {
	      let isGenerator = false;
	      if (this.isPunctuator(this.peek(), "*")) {
	        isGenerator = true;
	        this.advance();
	      }
	      let expr = this.enforestExpression();
	      let type = isGenerator ? "YieldGeneratorExpression" : "YieldExpression";
	      return new _terms2.default(type, { expression: expr });
	    }
	  }
	  enforestSyntaxTemplate() {
	    return new _terms2.default("SyntaxTemplate", { template: this.advance() });
	  }
	  enforestSyntaxQuote() {
	    let name_179 = this.advance();
	    return new _terms2.default("SyntaxQuote", { name: name_179, template: new _terms2.default("TemplateExpression", { tag: new _terms2.default("IdentifierExpression", { name: name_179 }), elements: this.enforestTemplateElements() }) });
	  }
	  enforestStaticMemberExpression() {
	    let object_180 = this.term;
	    let dot_181 = this.advance();
	    let property_182 = this.advance();
	    return new _terms2.default("StaticMemberExpression", { object: object_180, property: property_182 });
	  }
	  enforestArrayExpression() {
	    let arr_183 = this.advance();
	    let elements_184 = [];
	    let enf_185 = new Enforester_44(arr_183.inner(), (0, _immutable.List)(), this.context);
	    while (enf_185.rest.size > 0) {
	      let lookahead = enf_185.peek();
	      if (enf_185.isPunctuator(lookahead, ",")) {
	        enf_185.advance();
	        elements_184.push(null);
	      } else if (enf_185.isPunctuator(lookahead, "...")) {
	        enf_185.advance();
	        let expression = enf_185.enforestExpressionLoop();
	        if (expression == null) {
	          throw enf_185.createError(lookahead, "expecting expression");
	        }
	        elements_184.push(new _terms2.default("SpreadElement", { expression: expression }));
	      } else {
	        let term = enf_185.enforestExpressionLoop();
	        if (term == null) {
	          throw enf_185.createError(lookahead, "expected expression");
	        }
	        elements_184.push(term);
	        enf_185.consumeComma();
	      }
	    }
	    return new _terms2.default("ArrayExpression", { elements: (0, _immutable.List)(elements_184) });
	  }
	  enforestObjectExpression() {
	    let obj_186 = this.advance();
	    let properties_187 = (0, _immutable.List)();
	    let enf_188 = new Enforester_44(obj_186.inner(), (0, _immutable.List)(), this.context);
	    let lastProp_189 = null;
	    while (enf_188.rest.size > 0) {
	      let prop = enf_188.enforestPropertyDefinition();
	      enf_188.consumeComma();
	      properties_187 = properties_187.concat(prop);
	      if (lastProp_189 === prop) {
	        throw enf_188.createError(prop, "invalid syntax in object");
	      }
	      lastProp_189 = prop;
	    }
	    return new _terms2.default("ObjectExpression", { properties: properties_187 });
	  }
	  enforestPropertyDefinition() {
	    var _enforestMethodDefini = this.enforestMethodDefinition();

	    let methodOrKey = _enforestMethodDefini.methodOrKey;
	    let kind = _enforestMethodDefini.kind;

	    switch (kind) {
	      case "method":
	        return methodOrKey;
	      case "identifier":
	        if (this.isAssign(this.peek())) {
	          this.advance();
	          let init = this.enforestExpressionLoop();
	          return new _terms2.default("BindingPropertyIdentifier", { init: init, binding: this.transformDestructuring(methodOrKey) });
	        } else if (!this.isPunctuator(this.peek(), ":")) {
	          return new _terms2.default("ShorthandProperty", { name: methodOrKey.value });
	        }
	    }
	    this.matchPunctuator(":");
	    let expr_190 = this.enforestExpressionLoop();
	    return new _terms2.default("DataProperty", { name: methodOrKey, expression: expr_190 });
	  }
	  enforestMethodDefinition() {
	    let lookahead_191 = this.peek();
	    let isGenerator_192 = false;
	    if (this.isPunctuator(lookahead_191, "*")) {
	      isGenerator_192 = true;
	      this.advance();
	    }
	    if (this.isIdentifier(lookahead_191, "get") && this.isPropertyName(this.peek(1))) {
	      this.advance();

	      var _enforestPropertyName2 = this.enforestPropertyName();

	      let name = _enforestPropertyName2.name;

	      this.matchParens();
	      let body = this.matchCurlies();
	      return { methodOrKey: new _terms2.default("Getter", { name: name, body: body }), kind: "method" };
	    } else if (this.isIdentifier(lookahead_191, "set") && this.isPropertyName(this.peek(1))) {
	      this.advance();

	      var _enforestPropertyName3 = this.enforestPropertyName();

	      let name = _enforestPropertyName3.name;

	      let enf = new Enforester_44(this.matchParens(), (0, _immutable.List)(), this.context);
	      let param = enf.enforestBindingElement();
	      let body = this.matchCurlies();
	      return { methodOrKey: new _terms2.default("Setter", { name: name, param: param, body: body }), kind: "method" };
	    }

	    var _enforestPropertyName4 = this.enforestPropertyName();

	    let name = _enforestPropertyName4.name;

	    if (this.isParens(this.peek())) {
	      let params = this.matchParens();
	      let enf = new Enforester_44(params, (0, _immutable.List)(), this.context);
	      let formalParams = enf.enforestFormalParameters();
	      let body = this.matchCurlies();
	      return { methodOrKey: new _terms2.default("Method", { isGenerator: isGenerator_192, name: name, params: formalParams, body: body }), kind: "method" };
	    }
	    return { methodOrKey: name, kind: this.isIdentifier(lookahead_191) || this.isKeyword(lookahead_191) ? "identifier" : "property" };
	  }
	  enforestPropertyName() {
	    let lookahead_193 = this.peek();
	    if (this.isStringLiteral(lookahead_193) || this.isNumericLiteral(lookahead_193)) {
	      return { name: new _terms2.default("StaticPropertyName", { value: this.advance() }), binding: null };
	    } else if (this.isBrackets(lookahead_193)) {
	      let enf = new Enforester_44(this.matchSquares(), (0, _immutable.List)(), this.context);
	      let expr = enf.enforestExpressionLoop();
	      return { name: new _terms2.default("ComputedPropertyName", { expression: expr }), binding: null };
	    }
	    let name_194 = this.advance();
	    return { name: new _terms2.default("StaticPropertyName", { value: name_194 }), binding: new _terms2.default("BindingIdentifier", { name: name_194 }) };
	  }
	  enforestFunction(_ref5) {
	    let isExpr = _ref5.isExpr;
	    let inDefault = _ref5.inDefault;
	    let allowGenerator = _ref5.allowGenerator;

	    let name_195 = null,
	        params_196,
	        body_197,
	        rest_198;
	    let isGenerator_199 = false;
	    let fnKeyword_200 = this.advance();
	    let lookahead_201 = this.peek();
	    let type_202 = isExpr ? "FunctionExpression" : "FunctionDeclaration";
	    if (this.isPunctuator(lookahead_201, "*")) {
	      isGenerator_199 = true;
	      this.advance();
	      lookahead_201 = this.peek();
	    }
	    if (!this.isParens(lookahead_201)) {
	      name_195 = this.enforestBindingIdentifier();
	    } else if (inDefault) {
	      name_195 = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("*default*", fnKeyword_200) });
	    }
	    params_196 = this.matchParens();
	    body_197 = this.matchCurlies();
	    let enf_203 = new Enforester_44(params_196, (0, _immutable.List)(), this.context);
	    let formalParams_204 = enf_203.enforestFormalParameters();
	    return new _terms2.default(type_202, { name: name_195, isGenerator: isGenerator_199, params: formalParams_204, body: body_197 });
	  }
	  enforestFunctionExpression() {
	    let name_205 = null,
	        params_206,
	        body_207,
	        rest_208;
	    let isGenerator_209 = false;
	    this.advance();
	    let lookahead_210 = this.peek();
	    if (this.isPunctuator(lookahead_210, "*")) {
	      isGenerator_209 = true;
	      this.advance();
	      lookahead_210 = this.peek();
	    }
	    if (!this.isParens(lookahead_210)) {
	      name_205 = this.enforestBindingIdentifier();
	    }
	    params_206 = this.matchParens();
	    body_207 = this.matchCurlies();
	    let enf_211 = new Enforester_44(params_206, (0, _immutable.List)(), this.context);
	    let formalParams_212 = enf_211.enforestFormalParameters();
	    return new _terms2.default("FunctionExpression", { name: name_205, isGenerator: isGenerator_209, params: formalParams_212, body: body_207 });
	  }
	  enforestFunctionDeclaration() {
	    let name_213, params_214, body_215, rest_216;
	    let isGenerator_217 = false;
	    this.advance();
	    let lookahead_218 = this.peek();
	    if (this.isPunctuator(lookahead_218, "*")) {
	      isGenerator_217 = true;
	      this.advance();
	    }
	    name_213 = this.enforestBindingIdentifier();
	    params_214 = this.matchParens();
	    body_215 = this.matchCurlies();
	    let enf_219 = new Enforester_44(params_214, (0, _immutable.List)(), this.context);
	    let formalParams_220 = enf_219.enforestFormalParameters();
	    return new _terms2.default("FunctionDeclaration", { name: name_213, isGenerator: isGenerator_217, params: formalParams_220, body: body_215 });
	  }
	  enforestFormalParameters() {
	    let items_221 = [];
	    let rest_222 = null;
	    while (this.rest.size !== 0) {
	      let lookahead = this.peek();
	      if (this.isPunctuator(lookahead, "...")) {
	        this.matchPunctuator("...");
	        rest_222 = this.enforestBindingIdentifier();
	        break;
	      }
	      items_221.push(this.enforestParam());
	      this.consumeComma();
	    }
	    return new _terms2.default("FormalParameters", { items: (0, _immutable.List)(items_221), rest: rest_222 });
	  }
	  enforestParam() {
	    return this.enforestBindingElement();
	  }
	  enforestUpdateExpression() {
	    let operator_223 = this.matchUnaryOperator();
	    return new _terms2.default("UpdateExpression", { isPrefix: false, operator: operator_223.val(), operand: this.transformDestructuring(this.term) });
	  }
	  enforestUnaryExpression() {
	    let operator_224 = this.matchUnaryOperator();
	    this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine });
	    this.opCtx.prec = 14;
	    this.opCtx.combine = rightTerm_225 => {
	      let type_226, term_227, isPrefix_228;
	      if (operator_224.val() === "++" || operator_224.val() === "--") {
	        type_226 = "UpdateExpression";
	        term_227 = this.transformDestructuring(rightTerm_225);
	        isPrefix_228 = true;
	      } else {
	        type_226 = "UnaryExpression";
	        isPrefix_228 = undefined;
	        term_227 = rightTerm_225;
	      }
	      return new _terms2.default(type_226, { operator: operator_224.val(), operand: term_227, isPrefix: isPrefix_228 });
	    };
	    return EXPR_LOOP_OPERATOR_41;
	  }
	  enforestConditionalExpression() {
	    let test_229 = this.opCtx.combine(this.term);
	    if (this.opCtx.stack.size > 0) {
	      var _opCtx$stack$last2 = this.opCtx.stack.last();

	      let prec = _opCtx$stack$last2.prec;
	      let combine = _opCtx$stack$last2.combine;

	      this.opCtx.stack = this.opCtx.stack.pop();
	      this.opCtx.prec = prec;
	      this.opCtx.combine = combine;
	    }
	    this.matchPunctuator("?");
	    let enf_230 = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
	    let consequent_231 = enf_230.enforestExpressionLoop();
	    enf_230.matchPunctuator(":");
	    enf_230 = new Enforester_44(enf_230.rest, (0, _immutable.List)(), this.context);
	    let alternate_232 = enf_230.enforestExpressionLoop();
	    this.rest = enf_230.rest;
	    return new _terms2.default("ConditionalExpression", { test: test_229, consequent: consequent_231, alternate: alternate_232 });
	  }
	  enforestBinaryExpression() {
	    let leftTerm_233 = this.term;
	    let opStx_234 = this.peek();
	    let op_235 = opStx_234.val();
	    let opPrec_236 = (0, _operators.getOperatorPrec)(op_235);
	    let opAssoc_237 = (0, _operators.getOperatorAssoc)(op_235);
	    if ((0, _operators.operatorLt)(this.opCtx.prec, opPrec_236, opAssoc_237)) {
	      this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine });
	      this.opCtx.prec = opPrec_236;
	      this.opCtx.combine = rightTerm_238 => {
	        return new _terms2.default("BinaryExpression", { left: leftTerm_233, operator: opStx_234, right: rightTerm_238 });
	      };
	      this.advance();
	      return EXPR_LOOP_OPERATOR_41;
	    } else {
	      let term = this.opCtx.combine(leftTerm_233);

	      var _opCtx$stack$last3 = this.opCtx.stack.last();

	      let prec = _opCtx$stack$last3.prec;
	      let combine = _opCtx$stack$last3.combine;

	      this.opCtx.stack = this.opCtx.stack.pop();
	      this.opCtx.prec = prec;
	      this.opCtx.combine = combine;
	      return term;
	    }
	  }
	  enforestTemplateElements() {
	    let lookahead_239 = this.matchTemplate();
	    let elements_240 = lookahead_239.token.items.map(it_241 => {
	      if (it_241 instanceof _syntax2.default && it_241.isDelimiter()) {
	        let enf = new Enforester_44(it_241.inner(), (0, _immutable.List)(), this.context);
	        return enf.enforest("expression");
	      }
	      return new _terms2.default("TemplateElement", { rawValue: it_241.slice.text });
	    });
	    return elements_240;
	  }
	  expandMacro() {
	    let lookahead_242 = this.peek();
	    while (this.isCompiletimeTransform(lookahead_242)) {
	      let name = this.advance();
	      let syntaxTransform = this.getFromCompiletimeEnvironment(name);
	      if (syntaxTransform == null || typeof syntaxTransform.value !== "function") {
	        throw this.createError(name, "the macro name was not bound to a value that could be invoked");
	      }
	      let useSiteScope = (0, _scope.freshScope)("u");
	      let introducedScope = (0, _scope.freshScope)("i");
	      this.context.useScope = useSiteScope;
	      let ctx = new _macroContext2.default(this, name, this.context, useSiteScope, introducedScope);
	      let result = (0, _loadSyntax.sanitizeReplacementValues)(syntaxTransform.value.call(null, ctx));
	      if (!_immutable.List.isList(result)) {
	        throw this.createError(name, "macro must return a list but got: " + result);
	      }
	      result = result.map(stx_243 => {
	        if (!(stx_243 && typeof stx_243.addScope === "function")) {
	          throw this.createError(name, "macro must return syntax objects or terms but got: " + stx_243);
	        }
	        return stx_243.addScope(introducedScope, this.context.bindings, _syntax.ALL_PHASES, { flip: true });
	      });
	      this.rest = result.concat(ctx._rest(this));
	      lookahead_242 = this.peek();
	    }
	  }
	  consumeSemicolon() {
	    let lookahead_244 = this.peek();
	    if (lookahead_244 && this.isPunctuator(lookahead_244, ";")) {
	      this.advance();
	    }
	  }
	  consumeComma() {
	    let lookahead_245 = this.peek();
	    if (lookahead_245 && this.isPunctuator(lookahead_245, ",")) {
	      this.advance();
	    }
	  }
	  isTerm(term_246) {
	    return term_246 && term_246 instanceof _terms2.default;
	  }
	  isEOF(term_247) {
	    return term_247 && term_247 instanceof _syntax2.default && term_247.isEOF();
	  }
	  isIdentifier(term_248) {
	    let val_249 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return term_248 && term_248 instanceof _syntax2.default && term_248.isIdentifier() && (val_249 === null || term_248.val() === val_249);
	  }
	  isPropertyName(term_250) {
	    return this.isIdentifier(term_250) || this.isKeyword(term_250) || this.isNumericLiteral(term_250) || this.isStringLiteral(term_250) || this.isBrackets(term_250);
	  }
	  isNumericLiteral(term_251) {
	    return term_251 && term_251 instanceof _syntax2.default && term_251.isNumericLiteral();
	  }
	  isStringLiteral(term_252) {
	    return term_252 && term_252 instanceof _syntax2.default && term_252.isStringLiteral();
	  }
	  isTemplate(term_253) {
	    return term_253 && term_253 instanceof _syntax2.default && term_253.isTemplate();
	  }
	  isBooleanLiteral(term_254) {
	    return term_254 && term_254 instanceof _syntax2.default && term_254.isBooleanLiteral();
	  }
	  isNullLiteral(term_255) {
	    return term_255 && term_255 instanceof _syntax2.default && term_255.isNullLiteral();
	  }
	  isRegularExpression(term_256) {
	    return term_256 && term_256 instanceof _syntax2.default && term_256.isRegularExpression();
	  }
	  isParens(term_257) {
	    return term_257 && term_257 instanceof _syntax2.default && term_257.isParens();
	  }
	  isBraces(term_258) {
	    return term_258 && term_258 instanceof _syntax2.default && term_258.isBraces();
	  }
	  isBrackets(term_259) {
	    return term_259 && term_259 instanceof _syntax2.default && term_259.isBrackets();
	  }
	  isAssign(term_260) {
	    if (this.isPunctuator(term_260)) {
	      switch (term_260.val()) {
	        case "=":
	        case "|=":
	        case "^=":
	        case "&=":
	        case "<<=":
	        case ">>=":
	        case ">>>=":
	        case "+=":
	        case "-=":
	        case "*=":
	        case "/=":
	        case "%=":
	          return true;
	        default:
	          return false;
	      }
	    }
	    return false;
	  }
	  isKeyword(term_261) {
	    let val_262 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return term_261 && term_261 instanceof _syntax2.default && term_261.isKeyword() && (val_262 === null || term_261.val() === val_262);
	  }
	  isPunctuator(term_263) {
	    let val_264 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return term_263 && term_263 instanceof _syntax2.default && term_263.isPunctuator() && (val_264 === null || term_263.val() === val_264);
	  }
	  isOperator(term_265) {
	    return term_265 && term_265 instanceof _syntax2.default && (0, _operators.isOperator)(term_265);
	  }
	  isUpdateOperator(term_266) {
	    return term_266 && term_266 instanceof _syntax2.default && term_266.isPunctuator() && (term_266.val() === "++" || term_266.val() === "--");
	  }
	  isFnDeclTransform(term_267) {
	    return term_267 && term_267 instanceof _syntax2.default && this.context.env.get(term_267.resolve(this.context.phase)) === _transforms.FunctionDeclTransform;
	  }
	  isVarDeclTransform(term_268) {
	    return term_268 && term_268 instanceof _syntax2.default && this.context.env.get(term_268.resolve(this.context.phase)) === _transforms.VariableDeclTransform;
	  }
	  isLetDeclTransform(term_269) {
	    return term_269 && term_269 instanceof _syntax2.default && this.context.env.get(term_269.resolve(this.context.phase)) === _transforms.LetDeclTransform;
	  }
	  isConstDeclTransform(term_270) {
	    return term_270 && term_270 instanceof _syntax2.default && this.context.env.get(term_270.resolve(this.context.phase)) === _transforms.ConstDeclTransform;
	  }
	  isSyntaxDeclTransform(term_271) {
	    return term_271 && term_271 instanceof _syntax2.default && this.context.env.get(term_271.resolve(this.context.phase)) === _transforms.SyntaxDeclTransform;
	  }
	  isSyntaxrecDeclTransform(term_272) {
	    return term_272 && term_272 instanceof _syntax2.default && this.context.env.get(term_272.resolve(this.context.phase)) === _transforms.SyntaxrecDeclTransform;
	  }
	  isSyntaxTemplate(term_273) {
	    return term_273 && term_273 instanceof _syntax2.default && term_273.isSyntaxTemplate();
	  }
	  isSyntaxQuoteTransform(term_274) {
	    return term_274 && term_274 instanceof _syntax2.default && this.context.env.get(term_274.resolve(this.context.phase)) === _transforms.SyntaxQuoteTransform;
	  }
	  isReturnStmtTransform(term_275) {
	    return term_275 && term_275 instanceof _syntax2.default && this.context.env.get(term_275.resolve(this.context.phase)) === _transforms.ReturnStatementTransform;
	  }
	  isWhileTransform(term_276) {
	    return term_276 && term_276 instanceof _syntax2.default && this.context.env.get(term_276.resolve(this.context.phase)) === _transforms.WhileTransform;
	  }
	  isForTransform(term_277) {
	    return term_277 && term_277 instanceof _syntax2.default && this.context.env.get(term_277.resolve(this.context.phase)) === _transforms.ForTransform;
	  }
	  isSwitchTransform(term_278) {
	    return term_278 && term_278 instanceof _syntax2.default && this.context.env.get(term_278.resolve(this.context.phase)) === _transforms.SwitchTransform;
	  }
	  isBreakTransform(term_279) {
	    return term_279 && term_279 instanceof _syntax2.default && this.context.env.get(term_279.resolve(this.context.phase)) === _transforms.BreakTransform;
	  }
	  isContinueTransform(term_280) {
	    return term_280 && term_280 instanceof _syntax2.default && this.context.env.get(term_280.resolve(this.context.phase)) === _transforms.ContinueTransform;
	  }
	  isDoTransform(term_281) {
	    return term_281 && term_281 instanceof _syntax2.default && this.context.env.get(term_281.resolve(this.context.phase)) === _transforms.DoTransform;
	  }
	  isDebuggerTransform(term_282) {
	    return term_282 && term_282 instanceof _syntax2.default && this.context.env.get(term_282.resolve(this.context.phase)) === _transforms.DebuggerTransform;
	  }
	  isWithTransform(term_283) {
	    return term_283 && term_283 instanceof _syntax2.default && this.context.env.get(term_283.resolve(this.context.phase)) === _transforms.WithTransform;
	  }
	  isTryTransform(term_284) {
	    return term_284 && term_284 instanceof _syntax2.default && this.context.env.get(term_284.resolve(this.context.phase)) === _transforms.TryTransform;
	  }
	  isThrowTransform(term_285) {
	    return term_285 && term_285 instanceof _syntax2.default && this.context.env.get(term_285.resolve(this.context.phase)) === _transforms.ThrowTransform;
	  }
	  isIfTransform(term_286) {
	    return term_286 && term_286 instanceof _syntax2.default && this.context.env.get(term_286.resolve(this.context.phase)) === _transforms.IfTransform;
	  }
	  isNewTransform(term_287) {
	    return term_287 && term_287 instanceof _syntax2.default && this.context.env.get(term_287.resolve(this.context.phase)) === _transforms.NewTransform;
	  }
	  isCompiletimeTransform(term_288) {
	    return term_288 && term_288 instanceof _syntax2.default && (this.context.env.get(term_288.resolve(this.context.phase)) instanceof _transforms.CompiletimeTransform || this.context.store.get(term_288.resolve(this.context.phase)) instanceof _transforms.CompiletimeTransform);
	  }
	  isVarBindingTransform(term_289) {
	    return term_289 && term_289 instanceof _syntax2.default && (this.context.env.get(term_289.resolve(this.context.phase)) instanceof _transforms.VarBindingTransform || this.context.store.get(term_289.resolve(this.context.phase)) instanceof _transforms.VarBindingTransform);
	  }
	  getFromCompiletimeEnvironment(term_290) {
	    if (this.context.env.has(term_290.resolve(this.context.phase))) {
	      return this.context.env.get(term_290.resolve(this.context.phase));
	    }
	    return this.context.store.get(term_290.resolve(this.context.phase));
	  }
	  lineNumberEq(a_291, b_292) {
	    if (!(a_291 && b_292)) {
	      return false;
	    }
	    return a_291.lineNumber() === b_292.lineNumber();
	  }
	  matchIdentifier(val_293) {
	    let lookahead_294 = this.advance();
	    if (this.isIdentifier(lookahead_294)) {
	      return lookahead_294;
	    }
	    throw this.createError(lookahead_294, "expecting an identifier");
	  }
	  matchKeyword(val_295) {
	    let lookahead_296 = this.advance();
	    if (this.isKeyword(lookahead_296, val_295)) {
	      return lookahead_296;
	    }
	    throw this.createError(lookahead_296, "expecting " + val_295);
	  }
	  matchLiteral() {
	    let lookahead_297 = this.advance();
	    if (this.isNumericLiteral(lookahead_297) || this.isStringLiteral(lookahead_297) || this.isBooleanLiteral(lookahead_297) || this.isNullLiteral(lookahead_297) || this.isTemplate(lookahead_297) || this.isRegularExpression(lookahead_297)) {
	      return lookahead_297;
	    }
	    throw this.createError(lookahead_297, "expecting a literal");
	  }
	  matchStringLiteral() {
	    let lookahead_298 = this.advance();
	    if (this.isStringLiteral(lookahead_298)) {
	      return lookahead_298;
	    }
	    throw this.createError(lookahead_298, "expecting a string literal");
	  }
	  matchTemplate() {
	    let lookahead_299 = this.advance();
	    if (this.isTemplate(lookahead_299)) {
	      return lookahead_299;
	    }
	    throw this.createError(lookahead_299, "expecting a template literal");
	  }
	  matchParens() {
	    let lookahead_300 = this.advance();
	    if (this.isParens(lookahead_300)) {
	      return lookahead_300.inner();
	    }
	    throw this.createError(lookahead_300, "expecting parens");
	  }
	  matchCurlies() {
	    let lookahead_301 = this.advance();
	    if (this.isBraces(lookahead_301)) {
	      return lookahead_301.inner();
	    }
	    throw this.createError(lookahead_301, "expecting curly braces");
	  }
	  matchSquares() {
	    let lookahead_302 = this.advance();
	    if (this.isBrackets(lookahead_302)) {
	      return lookahead_302.inner();
	    }
	    throw this.createError(lookahead_302, "expecting sqaure braces");
	  }
	  matchUnaryOperator() {
	    let lookahead_303 = this.advance();
	    if ((0, _operators.isUnaryOperator)(lookahead_303)) {
	      return lookahead_303;
	    }
	    throw this.createError(lookahead_303, "expecting a unary operator");
	  }
	  matchPunctuator(val_304) {
	    let lookahead_305 = this.advance();
	    if (this.isPunctuator(lookahead_305)) {
	      if (typeof val_304 !== "undefined") {
	        if (lookahead_305.val() === val_304) {
	          return lookahead_305;
	        } else {
	          throw this.createError(lookahead_305, "expecting a " + val_304 + " punctuator");
	        }
	      }
	      return lookahead_305;
	    }
	    throw this.createError(lookahead_305, "expecting a punctuator");
	  }
	  createError(stx_306, message_307) {
	    let ctx_308 = "";
	    let offending_309 = stx_306;
	    if (this.rest.size > 0) {
	      ctx_308 = this.rest.slice(0, 20).map(term_310 => {
	        if (term_310.isDelimiter()) {
	          return term_310.inner();
	        }
	        return _immutable.List.of(term_310);
	      }).flatten().map(s_311 => {
	        if (s_311 === offending_309) {
	          return "__" + s_311.val() + "__";
	        }
	        return s_311.val();
	      }).join(" ");
	    } else {
	      ctx_308 = offending_309.toString();
	    }
	    return new Error(message_307 + "\n" + ctx_308);
	  }
	}
	exports.Enforester = Enforester_44;
	//# sourceMappingURL=data:application/json;base64,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LElBQUwsQ0FBVSxLQUFWLENBQWdCLENBQWhCLEVBQW1CLEVBQW5CLEVBQXVCLEdBQXZCLENBQTJCLFlBQVk7QUFDL0MsWUFBSSxTQUFTLFdBQVQsRUFBSixFQUE0QjtBQUMxQixpQkFBTyxTQUFTLEtBQVQsRUFBUDtBQUNEO0FBQ0QsZUFBTyxnQkFBSyxFQUFMLENBQVEsUUFBUixDQUFQO0FBQ0QsT0FMUyxFQUtQLE9BTE8sR0FLRyxHQUxILENBS08sU0FBUztBQUN4QixZQUFJLFVBQVUsYUFBZCxFQUE2QjtBQUMzQixpQkFBTyxPQUFPLE1BQU0sR0FBTixFQUFQLEdBQXFCLElBQTVCO0FBQ0Q7QUFDRCxlQUFPLE1BQU0sR0FBTixFQUFQO0FBQ0QsT0FWUyxFQVVQLElBVk8sQ0FVRixHQVZFLENBQVY7QUFXRCxLQVpELE1BWU87QUFDTCxnQkFBVSxjQUFjLFFBQWQsRUFBVjtBQUNEO0FBQ0QsV0FBTyxJQUFJLEtBQUosQ0FBVSxjQUFjLElBQWQsR0FBcUIsT0FBL0IsQ0FBUDtBQUNEO0FBbmpEaUI7UUFxakRLLFUsR0FBakIsYSIsImZpbGUiOiJlbmZvcmVzdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRlcm0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtLCBWYXJpYWJsZURlY2xUcmFuc2Zvcm0sIE5ld1RyYW5zZm9ybSwgTGV0RGVjbFRyYW5zZm9ybSwgQ29uc3REZWNsVHJhbnNmb3JtLCBTeW50YXhEZWNsVHJhbnNmb3JtLCBTeW50YXhyZWNEZWNsVHJhbnNmb3JtLCBTeW50YXhRdW90ZVRyYW5zZm9ybSwgUmV0dXJuU3RhdGVtZW50VHJhbnNmb3JtLCBXaGlsZVRyYW5zZm9ybSwgSWZUcmFuc2Zvcm0sIEZvclRyYW5zZm9ybSwgU3dpdGNoVHJhbnNmb3JtLCBCcmVha1RyYW5zZm9ybSwgQ29udGludWVUcmFuc2Zvcm0sIERvVHJhbnNmb3JtLCBEZWJ1Z2dlclRyYW5zZm9ybSwgV2l0aFRyYW5zZm9ybSwgVHJ5VHJhbnNmb3JtLCBUaHJvd1RyYW5zZm9ybSwgQ29tcGlsZXRpbWVUcmFuc2Zvcm0sIFZhckJpbmRpbmdUcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybXNcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQge2lzT3BlcmF0b3IsIGlzVW5hcnlPcGVyYXRvciwgZ2V0T3BlcmF0b3JBc3NvYywgZ2V0T3BlcmF0b3JQcmVjLCBvcGVyYXRvckx0fSBmcm9tIFwiLi9vcGVyYXRvcnNcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7ZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCB7c2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc30gZnJvbSBcIi4vbG9hZC1zeW50YXhcIjtcbmltcG9ydCBNYWNyb0NvbnRleHQgZnJvbSBcIi4vbWFjcm8tY29udGV4dFwiO1xuY29uc3QgRVhQUl9MT09QX09QRVJBVE9SXzQxID0ge307XG5jb25zdCBFWFBSX0xPT1BfTk9fQ0hBTkdFXzQyID0ge307XG5jb25zdCBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzID0ge307XG5jbGFzcyBFbmZvcmVzdGVyXzQ0IHtcbiAgY29uc3RydWN0b3Ioc3R4bF80NSwgcHJldl80NiwgY29udGV4dF80Nykge1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIGFzc2VydChMaXN0LmlzTGlzdChzdHhsXzQ1KSwgXCJleHBlY3RpbmcgYSBsaXN0IG9mIHRlcm1zIHRvIGVuZm9yZXN0XCIpO1xuICAgIGFzc2VydChMaXN0LmlzTGlzdChwcmV2XzQ2KSwgXCJleHBlY3RpbmcgYSBsaXN0IG9mIHRlcm1zIHRvIGVuZm9yZXN0XCIpO1xuICAgIGFzc2VydChjb250ZXh0XzQ3LCBcImV4cGVjdGluZyBhIGNvbnRleHQgdG8gZW5mb3Jlc3RcIik7XG4gICAgdGhpcy50ZXJtID0gbnVsbDtcbiAgICB0aGlzLnJlc3QgPSBzdHhsXzQ1O1xuICAgIHRoaXMucHJldiA9IHByZXZfNDY7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF80NztcbiAgfVxuICBwZWVrKG5fNDggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5nZXQobl80OCk7XG4gIH1cbiAgYWR2YW5jZSgpIHtcbiAgICBsZXQgcmV0XzQ5ID0gdGhpcy5yZXN0LmZpcnN0KCk7XG4gICAgdGhpcy5yZXN0ID0gdGhpcy5yZXN0LnJlc3QoKTtcbiAgICByZXR1cm4gcmV0XzQ5O1xuICB9XG4gIGVuZm9yZXN0KHR5cGVfNTAgPSBcIk1vZHVsZVwiKSB7XG4gICAgdGhpcy50ZXJtID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy50ZXJtO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VPRih0aGlzLnBlZWsoKSkpIHtcbiAgICAgIHRoaXMudGVybSA9IG5ldyBUZXJtKFwiRU9GXCIsIHt9KTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudGVybTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdF81MTtcbiAgICBpZiAodHlwZV81MCA9PT0gXCJleHByZXNzaW9uXCIpIHtcbiAgICAgIHJlc3VsdF81MSA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRfNTEgPSB0aGlzLmVuZm9yZXN0TW9kdWxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdF81MTtcbiAgfVxuICBlbmZvcmVzdE1vZHVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJvZHkoKTtcbiAgfVxuICBlbmZvcmVzdEJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RNb2R1bGVJdGVtKCk7XG4gIH1cbiAgZW5mb3Jlc3RNb2R1bGVJdGVtKCkge1xuICAgIGxldCBsb29rYWhlYWRfNTIgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzUyLCBcImltcG9ydFwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNTIsIFwiZXhwb3J0XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF81MiwgXCIjXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdExhbmd1YWdlUHJhZ21hKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RMYW5ndWFnZVByYWdtYSgpIHtcbiAgICB0aGlzLm1hdGNoSWRlbnRpZmllcihcIiNcIik7XG4gICAgdGhpcy5tYXRjaElkZW50aWZpZXIoXCJsYW5nXCIpO1xuICAgIGxldCBwYXRoXzUzID0gdGhpcy5tYXRjaFN0cmluZ0xpdGVyYWwoKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJQcmFnbWFcIiwge2tpbmQ6IFwibGFuZ1wiLCBpdGVtczogTGlzdC5vZihwYXRoXzUzKX0pO1xuICB9XG4gIGVuZm9yZXN0RXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZF81NCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNTQsIFwiKlwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydEFsbEZyb21cIiwge21vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF81NCkpIHtcbiAgICAgIGxldCBuYW1lZEV4cG9ydHMgPSB0aGlzLmVuZm9yZXN0RXhwb3J0Q2xhdXNlKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgXCJmcm9tXCIpKSB7XG4gICAgICAgIG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRGcm9tXCIsIHtuYW1lZEV4cG9ydHM6IG5hbWVkRXhwb3J0cywgbW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJ9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81NCwgXCJjbGFzc1wiKSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdENsYXNzKHtpc0V4cHI6IGZhbHNlfSl9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNGbkRlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzU0KSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdEZ1bmN0aW9uKHtpc0V4cHI6IGZhbHNlLCBpbkRlZmF1bHQ6IGZhbHNlfSl9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81NCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKHRoaXMucGVlaygpKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnREZWZhdWx0XCIsIHtib2R5OiB0aGlzLmVuZm9yZXN0RnVuY3Rpb24oe2lzRXhwcjogZmFsc2UsIGluRGVmYXVsdDogdHJ1ZX0pfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImNsYXNzXCIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydERlZmF1bHRcIiwge2JvZHk6IHRoaXMuZW5mb3Jlc3RDbGFzcyh7aXNFeHByOiBmYWxzZSwgaW5EZWZhdWx0OiB0cnVlfSl9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBib2R5ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnREZWZhdWx0XCIsIHtib2R5OiBib2R5fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmFyRGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNTQpIHx8IHRoaXMuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF81NCkgfHwgdGhpcy5pc0NvbnN0RGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNTQpIHx8IHRoaXMuaXNTeW50YXhyZWNEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF81NCkgfHwgdGhpcy5pc1N5bnRheERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzU0KSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRpb24oKX0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF81NCwgXCJ1bmV4cGVjdGVkIHN5bnRheFwiKTtcbiAgfVxuICBlbmZvcmVzdEV4cG9ydENsYXVzZSgpIHtcbiAgICBsZXQgZW5mXzU1ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCByZXN1bHRfNTYgPSBbXTtcbiAgICB3aGlsZSAoZW5mXzU1LnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcmVzdWx0XzU2LnB1c2goZW5mXzU1LmVuZm9yZXN0RXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgZW5mXzU1LmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHRfNTYpO1xuICB9XG4gIGVuZm9yZXN0RXhwb3J0U3BlY2lmaWVyKCkge1xuICAgIGxldCBuYW1lXzU3ID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCksIFwiYXNcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IGV4cG9ydGVkTmFtZSA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNTcsIGV4cG9ydGVkTmFtZTogZXhwb3J0ZWROYW1lfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydFNwZWNpZmllclwiLCB7bmFtZTogbnVsbCwgZXhwb3J0ZWROYW1lOiBuYW1lXzU3fSk7XG4gIH1cbiAgZW5mb3Jlc3RJbXBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzU4ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IGRlZmF1bHRCaW5kaW5nXzU5ID0gbnVsbDtcbiAgICBsZXQgbmFtZWRJbXBvcnRzXzYwID0gTGlzdCgpO1xuICAgIGxldCBmb3JTeW50YXhfNjEgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1N0cmluZ0xpdGVyYWwobG9va2FoZWFkXzU4KSkge1xuICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRcIiwge2RlZmF1bHRCaW5kaW5nOiBkZWZhdWx0QmluZGluZ181OSwgbmFtZWRJbXBvcnRzOiBuYW1lZEltcG9ydHNfNjAsIG1vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfNTgpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81OCkpIHtcbiAgICAgIGRlZmF1bHRCaW5kaW5nXzU5ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgICBpZiAoIXRoaXMuaXNQdW5jdHVhdG9yKHRoaXMucGVlaygpLCBcIixcIikpIHtcbiAgICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmb3JcIikgJiYgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpLCBcInN5bnRheFwiKSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIGZvclN5bnRheF82MSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0XCIsIHtkZWZhdWx0QmluZGluZzogZGVmYXVsdEJpbmRpbmdfNTksIG1vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyLCBuYW1lZEltcG9ydHM6IExpc3QoKSwgZm9yU3ludGF4OiBmb3JTeW50YXhfNjF9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdW1lQ29tbWEoKTtcbiAgICBsb29rYWhlYWRfNTggPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNlcyhsb29rYWhlYWRfNTgpKSB7XG4gICAgICBsZXQgaW1wb3J0cyA9IHRoaXMuZW5mb3Jlc3ROYW1lZEltcG9ydHMoKTtcbiAgICAgIGxldCBmcm9tQ2xhdXNlID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmb3JcIikgJiYgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpLCBcInN5bnRheFwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGZvclN5bnRheF82MSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRcIiwge2RlZmF1bHRCaW5kaW5nOiBkZWZhdWx0QmluZGluZ181OSwgZm9yU3ludGF4OiBmb3JTeW50YXhfNjEsIG5hbWVkSW1wb3J0czogaW1wb3J0cywgbW9kdWxlU3BlY2lmaWVyOiBmcm9tQ2xhdXNlfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNTgsIFwiKlwiKSkge1xuICAgICAgbGV0IG5hbWVzcGFjZUJpbmRpbmcgPSB0aGlzLmVuZm9yZXN0TmFtZXNwYWNlQmluZGluZygpO1xuICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZm9yXCIpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgXCJzeW50YXhcIikpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBmb3JTeW50YXhfNjEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0TmFtZXNwYWNlXCIsIHtkZWZhdWx0QmluZGluZzogZGVmYXVsdEJpbmRpbmdfNTksIGZvclN5bnRheDogZm9yU3ludGF4XzYxLCBuYW1lc3BhY2VCaW5kaW5nOiBuYW1lc3BhY2VCaW5kaW5nLCBtb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcn0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF81OCwgXCJ1bmV4cGVjdGVkIHN5bnRheFwiKTtcbiAgfVxuICBlbmZvcmVzdE5hbWVzcGFjZUJpbmRpbmcoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCIqXCIpO1xuICAgIHRoaXMubWF0Y2hJZGVudGlmaWVyKFwiYXNcIik7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICB9XG4gIGVuZm9yZXN0TmFtZWRJbXBvcnRzKCkge1xuICAgIGxldCBlbmZfNjIgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLm1hdGNoQ3VybGllcygpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IHJlc3VsdF82MyA9IFtdO1xuICAgIHdoaWxlIChlbmZfNjIucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICByZXN1bHRfNjMucHVzaChlbmZfNjIuZW5mb3Jlc3RJbXBvcnRTcGVjaWZpZXJzKCkpO1xuICAgICAgZW5mXzYyLmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHRfNjMpO1xuICB9XG4gIGVuZm9yZXN0SW1wb3J0U3BlY2lmaWVycygpIHtcbiAgICBsZXQgbG9va2FoZWFkXzY0ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IG5hbWVfNjU7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF82NCkgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzY0KSkge1xuICAgICAgbmFtZV82NSA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgXCJhc1wiKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG51bGwsIGJpbmRpbmc6IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfNjV9KX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRjaElkZW50aWZpZXIoXCJhc1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihsb29rYWhlYWRfNjQsIFwidW5leHBlY3RlZCB0b2tlbiBpbiBpbXBvcnQgc3BlY2lmaWVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNjUsIGJpbmRpbmc6IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpfSk7XG4gIH1cbiAgZW5mb3Jlc3RGcm9tQ2xhdXNlKCkge1xuICAgIHRoaXMubWF0Y2hJZGVudGlmaWVyKFwiZnJvbVwiKTtcbiAgICBsZXQgbG9va2FoZWFkXzY2ID0gdGhpcy5tYXRjaFN0cmluZ0xpdGVyYWwoKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbG9va2FoZWFkXzY2O1xuICB9XG4gIGVuZm9yZXN0U3RhdGVtZW50TGlzdEl0ZW0oKSB7XG4gICAgbGV0IGxvb2thaGVhZF82NyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb25EZWNsYXJhdGlvbih7aXNFeHByOiBmYWxzZX0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzY3LCBcImNsYXNzXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdENsYXNzKHtpc0V4cHI6IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgfVxuICB9XG4gIGVuZm9yZXN0U3RhdGVtZW50KCkge1xuICAgIGxldCBsb29rYWhlYWRfNjggPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNDb21waWxldGltZVRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICB0aGlzLmV4cGFuZE1hY3JvKCk7XG4gICAgICBsb29rYWhlYWRfNjggPSB0aGlzLnBlZWsoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVGVybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyYWNlcyhsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJsb2NrU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1doaWxlVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0V2hpbGVTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzSWZUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RJZlN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNGb3JUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RGb3JTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3dpdGNoVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3dpdGNoU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyZWFrVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QnJlYWtTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQ29udGludWVUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb250aW51ZVN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNEb1RyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdERvU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0RlYnVnZ2VyVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzV2l0aFRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFdpdGhTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVHJ5VHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VHJ5U3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1Rocm93VHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VGhyb3dTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNjgsIFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogZmFsc2V9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF82OCkgJiYgdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKDEpLCBcIjpcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TGFiZWxlZFN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmICh0aGlzLmlzVmFyRGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNjgpIHx8IHRoaXMuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkgfHwgdGhpcy5pc0NvbnN0RGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNjgpIHx8IHRoaXMuaXNTeW50YXhyZWNEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkgfHwgdGhpcy5pc1N5bnRheERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkpIHtcbiAgICAgIGxldCBzdG10ID0gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRpb24oKX0pO1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzUmV0dXJuU3RtdFRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFJldHVyblN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF82OCwgXCI7XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkVtcHR5U3RhdGVtZW50XCIsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uU3RhdGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RMYWJlbGVkU3RhdGVtZW50KCkge1xuICAgIGxldCBsYWJlbF82OSA9IHRoaXMubWF0Y2hJZGVudGlmaWVyKCk7XG4gICAgbGV0IHB1bmNfNzAgPSB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgbGV0IHN0bXRfNzEgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGFiZWxlZFN0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzY5LCBib2R5OiBzdG10XzcxfSk7XG4gIH1cbiAgZW5mb3Jlc3RCcmVha1N0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcImJyZWFrXCIpO1xuICAgIGxldCBsb29rYWhlYWRfNzIgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgbGFiZWxfNzMgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNzIsIFwiO1wiKSkge1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJCcmVha1N0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzczfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfNzIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF83MiwgXCJ5aWVsZFwiKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNzIsIFwibGV0XCIpKSB7XG4gICAgICBsYWJlbF83MyA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJyZWFrU3RhdGVtZW50XCIsIHtsYWJlbDogbGFiZWxfNzN9KTtcbiAgfVxuICBlbmZvcmVzdFRyeVN0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcInRyeVwiKTtcbiAgICBsZXQgYm9keV83NCA9IHRoaXMuZW5mb3Jlc3RCbG9jaygpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJjYXRjaFwiKSkge1xuICAgICAgbGV0IGNhdGNoQ2xhdXNlID0gdGhpcy5lbmZvcmVzdENhdGNoQ2xhdXNlKCk7XG4gICAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZmluYWxseVwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGZpbmFsaXplciA9IHRoaXMuZW5mb3Jlc3RCbG9jaygpO1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlGaW5hbGx5U3RhdGVtZW50XCIsIHtib2R5OiBib2R5Xzc0LCBjYXRjaENsYXVzZTogY2F0Y2hDbGF1c2UsIGZpbmFsaXplcjogZmluYWxpemVyfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlDYXRjaFN0YXRlbWVudFwiLCB7Ym9keTogYm9keV83NCwgY2F0Y2hDbGF1c2U6IGNhdGNoQ2xhdXNlfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmaW5hbGx5XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBmaW5hbGl6ZXIgPSB0aGlzLmVuZm9yZXN0QmxvY2soKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIiwge2JvZHk6IGJvZHlfNzQsIGNhdGNoQ2xhdXNlOiBudWxsLCBmaW5hbGl6ZXI6IGZpbmFsaXplcn0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKHRoaXMucGVlaygpLCBcInRyeSB3aXRoIG5vIGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gIH1cbiAgZW5mb3Jlc3RDYXRjaENsYXVzZSgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcImNhdGNoXCIpO1xuICAgIGxldCBiaW5kaW5nUGFyZW5zXzc1ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfNzYgPSBuZXcgRW5mb3Jlc3Rlcl80NChiaW5kaW5nUGFyZW5zXzc1LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGJpbmRpbmdfNzcgPSBlbmZfNzYuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgbGV0IGJvZHlfNzggPSB0aGlzLmVuZm9yZXN0QmxvY2soKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDYXRjaENsYXVzZVwiLCB7YmluZGluZzogYmluZGluZ183NywgYm9keTogYm9keV83OH0pO1xuICB9XG4gIGVuZm9yZXN0VGhyb3dTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJ0aHJvd1wiKTtcbiAgICBsZXQgZXhwcmVzc2lvbl83OSA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVGhyb3dTdGF0ZW1lbnRcIiwge2V4cHJlc3Npb246IGV4cHJlc3Npb25fNzl9KTtcbiAgfVxuICBlbmZvcmVzdFdpdGhTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJ3aXRoXCIpO1xuICAgIGxldCBvYmpQYXJlbnNfODAgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl84MSA9IG5ldyBFbmZvcmVzdGVyXzQ0KG9ialBhcmVuc184MCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBvYmplY3RfODIgPSBlbmZfODEuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgbGV0IGJvZHlfODMgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiV2l0aFN0YXRlbWVudFwiLCB7b2JqZWN0OiBvYmplY3RfODIsIGJvZHk6IGJvZHlfODN9KTtcbiAgfVxuICBlbmZvcmVzdERlYnVnZ2VyU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZGVidWdnZXJcIik7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwge30pO1xuICB9XG4gIGVuZm9yZXN0RG9TdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJkb1wiKTtcbiAgICBsZXQgYm9keV84NCA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcIndoaWxlXCIpO1xuICAgIGxldCB0ZXN0Qm9keV84NSA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICBsZXQgZW5mXzg2ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGVzdEJvZHlfODUsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgdGVzdF84NyA9IGVuZl84Ni5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJEb1doaWxlU3RhdGVtZW50XCIsIHtib2R5OiBib2R5Xzg0LCB0ZXN0OiB0ZXN0Xzg3fSk7XG4gIH1cbiAgZW5mb3Jlc3RDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICBsZXQga3dkXzg4ID0gdGhpcy5tYXRjaEtleXdvcmQoXCJjb250aW51ZVwiKTtcbiAgICBsZXQgbG9va2FoZWFkXzg5ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IGxhYmVsXzkwID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDAgfHwgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzg5LCBcIjtcIikpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29udGludWVTdGF0ZW1lbnRcIiwge2xhYmVsOiBsYWJlbF85MH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5saW5lTnVtYmVyRXEoa3dkXzg4LCBsb29rYWhlYWRfODkpICYmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfODkpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF84OSwgXCJ5aWVsZFwiKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfODksIFwibGV0XCIpKSkge1xuICAgICAgbGFiZWxfOTAgPSB0aGlzLmVuZm9yZXN0SWRlbnRpZmllcigpO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb250aW51ZVN0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzkwfSk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJzd2l0Y2hcIik7XG4gICAgbGV0IGNvbmRfOTEgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl85MiA9IG5ldyBFbmZvcmVzdGVyXzQ0KGNvbmRfOTEsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgZGlzY3JpbWluYW50XzkzID0gZW5mXzkyLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgIGxldCBib2R5Xzk0ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICBpZiAoYm9keV85NC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge2Rpc2NyaW1pbmFudDogZGlzY3JpbWluYW50XzkzLCBjYXNlczogTGlzdCgpfSk7XG4gICAgfVxuICAgIGVuZl85MiA9IG5ldyBFbmZvcmVzdGVyXzQ0KGJvZHlfOTQsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgY2FzZXNfOTUgPSBlbmZfOTIuZW5mb3Jlc3RTd2l0Y2hDYXNlcygpO1xuICAgIGxldCBsb29rYWhlYWRfOTYgPSBlbmZfOTIucGVlaygpO1xuICAgIGlmIChlbmZfOTIuaXNLZXl3b3JkKGxvb2thaGVhZF85NiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICBsZXQgZGVmYXVsdENhc2UgPSBlbmZfOTIuZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0KCk7XG4gICAgICBsZXQgcG9zdERlZmF1bHRDYXNlcyA9IGVuZl85Mi5lbmZvcmVzdFN3aXRjaENhc2VzKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwiLCB7ZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnRfOTMsIHByZURlZmF1bHRDYXNlczogY2FzZXNfOTUsIGRlZmF1bHRDYXNlOiBkZWZhdWx0Q2FzZSwgcG9zdERlZmF1bHRDYXNlczogcG9zdERlZmF1bHRDYXNlc30pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge2Rpc2NyaW1pbmFudDogZGlzY3JpbWluYW50XzkzLCBjYXNlczogY2FzZXNfOTV9KTtcbiAgfVxuICBlbmZvcmVzdFN3aXRjaENhc2VzKCkge1xuICAgIGxldCBjYXNlc185NyA9IFtdO1xuICAgIHdoaWxlICghKHRoaXMucmVzdC5zaXplID09PSAwIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImRlZmF1bHRcIikpKSB7XG4gICAgICBjYXNlc185Ny5wdXNoKHRoaXMuZW5mb3Jlc3RTd2l0Y2hDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChjYXNlc185Nyk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hDYXNlKCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiY2FzZVwiKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hDYXNlXCIsIHt0ZXN0OiB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbigpLCBjb25zZXF1ZW50OiB0aGlzLmVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKX0pO1xuICB9XG4gIGVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCI6XCIpO1xuICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50TGlzdEluU3dpdGNoQ2FzZUJvZHkoKTtcbiAgfVxuICBlbmZvcmVzdFN0YXRlbWVudExpc3RJblN3aXRjaENhc2VCb2R5KCkge1xuICAgIGxldCByZXN1bHRfOTggPSBbXTtcbiAgICB3aGlsZSAoISh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJkZWZhdWx0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImNhc2VcIikpKSB7XG4gICAgICByZXN1bHRfOTgucHVzaCh0aGlzLmVuZm9yZXN0U3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF85OCk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZGVmYXVsdFwiKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hEZWZhdWx0XCIsIHtjb25zZXF1ZW50OiB0aGlzLmVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKX0pO1xuICB9XG4gIGVuZm9yZXN0Rm9yU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZm9yXCIpO1xuICAgIGxldCBjb25kXzk5ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfMTAwID0gbmV3IEVuZm9yZXN0ZXJfNDQoY29uZF85OSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTAxLCB0ZXN0XzEwMiwgaW5pdF8xMDMsIHJpZ2h0XzEwNCwgdHlwZV8xMDUsIGxlZnRfMTA2LCB1cGRhdGVfMTA3O1xuICAgIGlmIChlbmZfMTAwLmlzUHVuY3R1YXRvcihlbmZfMTAwLnBlZWsoKSwgXCI7XCIpKSB7XG4gICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgIGlmICghZW5mXzEwMC5pc1B1bmN0dWF0b3IoZW5mXzEwMC5wZWVrKCksIFwiO1wiKSkge1xuICAgICAgICB0ZXN0XzEwMiA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgICBlbmZfMTAwLm1hdGNoUHVuY3R1YXRvcihcIjtcIik7XG4gICAgICBpZiAoZW5mXzEwMC5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgcmlnaHRfMTA0ID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybShcIkZvclN0YXRlbWVudFwiLCB7aW5pdDogbnVsbCwgdGVzdDogdGVzdF8xMDIsIHVwZGF0ZTogcmlnaHRfMTA0LCBib2R5OiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9va2FoZWFkXzEwMSA9IGVuZl8xMDAucGVlaygpO1xuICAgICAgaWYgKGVuZl8xMDAuaXNWYXJEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xMDEpIHx8IGVuZl8xMDAuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xMDEpIHx8IGVuZl8xMDAuaXNDb25zdERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzEwMSkpIHtcbiAgICAgICAgaW5pdF8xMDMgPSBlbmZfMTAwLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICBsb29rYWhlYWRfMTAxID0gZW5mXzEwMC5wZWVrKCk7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTAxLCBcImluXCIpIHx8IHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xMDEsIFwib2ZcIikpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzEwMSwgXCJpblwiKSkge1xuICAgICAgICAgICAgZW5mXzEwMC5hZHZhbmNlKCk7XG4gICAgICAgICAgICByaWdodF8xMDQgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgdHlwZV8xMDUgPSBcIkZvckluU3RhdGVtZW50XCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTAxLCBcIm9mXCIpKSB7XG4gICAgICAgICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJpZ2h0XzEwNCA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB0eXBlXzEwNSA9IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA1LCB7bGVmdDogaW5pdF8xMDMsIHJpZ2h0OiByaWdodF8xMDQsIGJvZHk6IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKX0pO1xuICAgICAgICB9XG4gICAgICAgIGVuZl8xMDAubWF0Y2hQdW5jdHVhdG9yKFwiO1wiKTtcbiAgICAgICAgaWYgKGVuZl8xMDAuaXNQdW5jdHVhdG9yKGVuZl8xMDAucGVlaygpLCBcIjtcIikpIHtcbiAgICAgICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgICAgICB0ZXN0XzEwMiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVzdF8xMDIgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgIGVuZl8xMDAubWF0Y2hQdW5jdHVhdG9yKFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVfMTA3ID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChlbmZfMTAwLnBlZWsoMSksIFwiaW5cIikgfHwgdGhpcy5pc0lkZW50aWZpZXIoZW5mXzEwMC5wZWVrKDEpLCBcIm9mXCIpKSB7XG4gICAgICAgICAgbGVmdF8xMDYgPSBlbmZfMTAwLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoKTtcbiAgICAgICAgICBsZXQga2luZCA9IGVuZl8xMDAuYWR2YW5jZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChraW5kLCBcImluXCIpKSB7XG4gICAgICAgICAgICB0eXBlXzEwNSA9IFwiRm9ySW5TdGF0ZW1lbnRcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZV8xMDUgPSBcIkZvck9mU3RhdGVtZW50XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0XzEwNCA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA1LCB7bGVmdDogbGVmdF8xMDYsIHJpZ2h0OiByaWdodF8xMDQsIGJvZHk6IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKX0pO1xuICAgICAgICB9XG4gICAgICAgIGluaXRfMTAzID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgICAgZW5mXzEwMC5tYXRjaFB1bmN0dWF0b3IoXCI7XCIpO1xuICAgICAgICBpZiAoZW5mXzEwMC5pc1B1bmN0dWF0b3IoZW5mXzEwMC5wZWVrKCksIFwiO1wiKSkge1xuICAgICAgICAgIGVuZl8xMDAuYWR2YW5jZSgpO1xuICAgICAgICAgIHRlc3RfMTAyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXN0XzEwMiA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZW5mXzEwMC5tYXRjaFB1bmN0dWF0b3IoXCI7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZV8xMDcgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yU3RhdGVtZW50XCIsIHtpbml0OiBpbml0XzEwMywgdGVzdDogdGVzdF8xMDIsIHVwZGF0ZTogdXBkYXRlXzEwNywgYm9keTogdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpfSk7XG4gICAgfVxuICB9XG4gIGVuZm9yZXN0SWZTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJpZlwiKTtcbiAgICBsZXQgY29uZF8xMDggPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl8xMDkgPSBuZXcgRW5mb3Jlc3Rlcl80NChjb25kXzEwOCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTEwID0gZW5mXzEwOS5wZWVrKCk7XG4gICAgbGV0IHRlc3RfMTExID0gZW5mXzEwOS5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICBpZiAodGVzdF8xMTEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVuZl8xMDkuY3JlYXRlRXJyb3IobG9va2FoZWFkXzExMCwgXCJleHBlY3RpbmcgYW4gZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgbGV0IGNvbnNlcXVlbnRfMTEyID0gdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgIGxldCBhbHRlcm5hdGVfMTEzID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZWxzZVwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBhbHRlcm5hdGVfMTEzID0gdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJZlN0YXRlbWVudFwiLCB7dGVzdDogdGVzdF8xMTEsIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnRfMTEyLCBhbHRlcm5hdGU6IGFsdGVybmF0ZV8xMTN9KTtcbiAgfVxuICBlbmZvcmVzdFdoaWxlU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwid2hpbGVcIik7XG4gICAgbGV0IGNvbmRfMTE0ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfMTE1ID0gbmV3IEVuZm9yZXN0ZXJfNDQoY29uZF8xMTQsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgbG9va2FoZWFkXzExNiA9IGVuZl8xMTUucGVlaygpO1xuICAgIGxldCB0ZXN0XzExNyA9IGVuZl8xMTUuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRlc3RfMTE3ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBlbmZfMTE1LmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMTYsIFwiZXhwZWN0aW5nIGFuIGV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIGxldCBib2R5XzExOCA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaGlsZVN0YXRlbWVudFwiLCB7dGVzdDogdGVzdF8xMTcsIGJvZHk6IGJvZHlfMTE4fSk7XG4gIH1cbiAgZW5mb3Jlc3RCbG9ja1N0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCbG9ja1N0YXRlbWVudFwiLCB7YmxvY2s6IHRoaXMuZW5mb3Jlc3RCbG9jaygpfSk7XG4gIH1cbiAgZW5mb3Jlc3RCbG9jaygpIHtcbiAgICBsZXQgYl8xMTkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBib2R5XzEyMCA9IFtdO1xuICAgIGxldCBlbmZfMTIxID0gbmV3IEVuZm9yZXN0ZXJfNDQoYl8xMTksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoZW5mXzEyMS5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGxldCBsb29rYWhlYWQgPSBlbmZfMTIxLnBlZWsoKTtcbiAgICAgIGxldCBzdG10ID0gZW5mXzEyMS5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgICAgaWYgKHN0bXQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlbmZfMTIxLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgXCJub3QgYSBzdGF0ZW1lbnRcIik7XG4gICAgICB9XG4gICAgICBib2R5XzEyMC5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCbG9ja1wiLCB7c3RhdGVtZW50czogTGlzdChib2R5XzEyMCl9KTtcbiAgfVxuICBlbmZvcmVzdENsYXNzKHtpc0V4cHIsIGluRGVmYXVsdH0pIHtcbiAgICBsZXQga3dfMTIyID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IG5hbWVfMTIzID0gbnVsbCwgc3Vwcl8xMjQgPSBudWxsO1xuICAgIGxldCB0eXBlXzEyNSA9IGlzRXhwciA/IFwiQ2xhc3NFeHByZXNzaW9uXCIgOiBcIkNsYXNzRGVjbGFyYXRpb25cIjtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCkpKSB7XG4gICAgICBuYW1lXzEyMyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgIH0gZWxzZSBpZiAoIWlzRXhwcikge1xuICAgICAgaWYgKGluRGVmYXVsdCkge1xuICAgICAgICBuYW1lXzEyMyA9IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IFN5bnRheC5mcm9tSWRlbnRpZmllcihcIl9kZWZhdWx0XCIsIGt3XzEyMil9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IodGhpcy5wZWVrKCksIFwidW5leHBlY3RlZCBzeW50YXhcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJleHRlbmRzXCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHN1cHJfMTI0ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgfVxuICAgIGxldCBlbGVtZW50c18xMjYgPSBbXTtcbiAgICBsZXQgZW5mXzEyNyA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hDdXJsaWVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoZW5mXzEyNy5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGlmIChlbmZfMTI3LmlzUHVuY3R1YXRvcihlbmZfMTI3LnBlZWsoKSwgXCI7XCIpKSB7XG4gICAgICAgIGVuZl8xMjcuYWR2YW5jZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgbGV0IHttZXRob2RPcktleSwga2luZH0gPSBlbmZfMTI3LmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaWRlbnRpZmllclwiICYmIG1ldGhvZE9yS2V5LnZhbHVlLnZhbCgpID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgKHttZXRob2RPcktleSwga2luZH0gPSBlbmZfMTI3LmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBcIm1ldGhvZFwiKSB7XG4gICAgICAgIGVsZW1lbnRzXzEyNi5wdXNoKG5ldyBUZXJtKFwiQ2xhc3NFbGVtZW50XCIsIHtpc1N0YXRpYzogaXNTdGF0aWMsIG1ldGhvZDogbWV0aG9kT3JLZXl9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGVuZl8xMjcucGVlaygpLCBcIk9ubHkgbWV0aG9kcyBhcmUgYWxsb3dlZCBpbiBjbGFzc2VzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8xMjUsIHtuYW1lOiBuYW1lXzEyMywgc3VwZXI6IHN1cHJfMTI0LCBlbGVtZW50czogTGlzdChlbGVtZW50c18xMjYpfSk7XG4gIH1cbiAgZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KHthbGxvd1B1bmN0dWF0b3J9ID0ge30pIHtcbiAgICBsZXQgbG9va2FoZWFkXzEyOCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTI4KSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTI4KSB8fCBhbGxvd1B1bmN0dWF0b3IgJiYgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzEyOCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoe2FsbG93UHVuY3R1YXRvcjogYWxsb3dQdW5jdHVhdG9yfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2tldHMobG9va2FoZWFkXzEyOCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QXJyYXlCaW5kaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF8xMjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE9iamVjdEJpbmRpbmcoKTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIH1cbiAgZW5mb3Jlc3RPYmplY3RCaW5kaW5nKCkge1xuICAgIGxldCBlbmZfMTI5ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBwcm9wZXJ0aWVzXzEzMCA9IFtdO1xuICAgIHdoaWxlIChlbmZfMTI5LnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcHJvcGVydGllc18xMzAucHVzaChlbmZfMTI5LmVuZm9yZXN0QmluZGluZ1Byb3BlcnR5KCkpO1xuICAgICAgZW5mXzEyOS5jb25zdW1lQ29tbWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiT2JqZWN0QmluZGluZ1wiLCB7cHJvcGVydGllczogTGlzdChwcm9wZXJ0aWVzXzEzMCl9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmRpbmdQcm9wZXJ0eSgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzEzMSA9IHRoaXMucGVlaygpO1xuICAgIGxldCB7bmFtZSwgYmluZGluZ30gPSB0aGlzLmVuZm9yZXN0UHJvcGVydHlOYW1lKCk7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xMzEpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xMzEsIFwibGV0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xMzEsIFwieWllbGRcIikpIHtcbiAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiOlwiKSkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3NpZ24odGhpcy5wZWVrKCkpKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgbGV0IGV4cHIgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBleHByO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJcIiwge2JpbmRpbmc6IGJpbmRpbmcsIGluaXQ6IGRlZmF1bHRWYWx1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgYmluZGluZyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5XCIsIHtuYW1lOiBuYW1lLCBiaW5kaW5nOiBiaW5kaW5nfSk7XG4gIH1cbiAgZW5mb3Jlc3RBcnJheUJpbmRpbmcoKSB7XG4gICAgbGV0IGJyYWNrZXRfMTMyID0gdGhpcy5tYXRjaFNxdWFyZXMoKTtcbiAgICBsZXQgZW5mXzEzMyA9IG5ldyBFbmZvcmVzdGVyXzQ0KGJyYWNrZXRfMTMyLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGVsZW1lbnRzXzEzNCA9IFtdLCByZXN0RWxlbWVudF8xMzUgPSBudWxsO1xuICAgIHdoaWxlIChlbmZfMTMzLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgbGV0IGVsO1xuICAgICAgaWYgKGVuZl8xMzMuaXNQdW5jdHVhdG9yKGVuZl8xMzMucGVlaygpLCBcIixcIikpIHtcbiAgICAgICAgZW5mXzEzMy5jb25zdW1lQ29tbWEoKTtcbiAgICAgICAgZWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVuZl8xMzMuaXNQdW5jdHVhdG9yKGVuZl8xMzMucGVlaygpLCBcIi4uLlwiKSkge1xuICAgICAgICAgIGVuZl8xMzMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJlc3RFbGVtZW50XzEzNSA9IGVuZl8xMzMuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwgPSBlbmZfMTMzLmVuZm9yZXN0QmluZGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbmZfMTMzLmNvbnN1bWVDb21tYSgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudHNfMTM0LnB1c2goZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiBMaXN0KGVsZW1lbnRzXzEzNCksIHJlc3RFbGVtZW50OiByZXN0RWxlbWVudF8xMzV9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmRpbmdFbGVtZW50KCkge1xuICAgIGxldCBiaW5kaW5nXzEzNiA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgaWYgKHRoaXMuaXNBc3NpZ24odGhpcy5wZWVrKCkpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBpbml0ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICBiaW5kaW5nXzEzNiA9IG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiBiaW5kaW5nXzEzNiwgaW5pdDogaW5pdH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ18xMzY7XG4gIH1cbiAgZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcih7YWxsb3dQdW5jdHVhdG9yfSA9IHt9KSB7XG4gICAgbGV0IG5hbWVfMTM3O1xuICAgIGlmIChhbGxvd1B1bmN0dWF0b3IgJiYgdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCkpKSB7XG4gICAgICBuYW1lXzEzNyA9IHRoaXMuZW5mb3Jlc3RQdW5jdHVhdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVfMTM3ID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfMTM3fSk7XG4gIH1cbiAgZW5mb3Jlc3RQdW5jdHVhdG9yKCkge1xuICAgIGxldCBsb29rYWhlYWRfMTM4ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xMzgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzEzOCwgXCJleHBlY3RpbmcgYSBwdW5jdHVhdG9yXCIpO1xuICB9XG4gIGVuZm9yZXN0SWRlbnRpZmllcigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzEzOSA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTM5KSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTM5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMzksIFwiZXhwZWN0aW5nIGFuIGlkZW50aWZpZXJcIik7XG4gIH1cbiAgZW5mb3Jlc3RSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgbGV0IGt3XzE0MCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGxldCBsb29rYWhlYWRfMTQxID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMucmVzdC5zaXplID09PSAwIHx8IGxvb2thaGVhZF8xNDEgJiYgIXRoaXMubGluZU51bWJlckVxKGt3XzE0MCwgbG9va2FoZWFkXzE0MSkpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlJldHVyblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogbnVsbH0pO1xuICAgIH1cbiAgICBsZXQgdGVybV8xNDIgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE0MSwgXCI7XCIpKSB7XG4gICAgICB0ZXJtXzE0MiA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QodGVybV8xNDIgIT0gbnVsbCwgXCJFeHBlY3RpbmcgYW4gZXhwcmVzc2lvbiB0byBmb2xsb3cgcmV0dXJuIGtleXdvcmRcIiwgbG9va2FoZWFkXzE0MSwgdGhpcy5yZXN0KTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiB0ZXJtXzE0Mn0pO1xuICB9XG4gIGVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQga2luZF8xNDM7XG4gICAgbGV0IGxvb2thaGVhZF8xNDQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBsZXQga2luZFN5bl8xNDUgPSBsb29rYWhlYWRfMTQ0O1xuICAgIGxldCBwaGFzZV8xNDYgPSB0aGlzLmNvbnRleHQucGhhc2U7XG4gICAgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFZhcmlhYmxlRGVjbFRyYW5zZm9ybSkge1xuICAgICAga2luZF8xNDMgPSBcInZhclwiO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5bl8xNDUgJiYgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bl8xNDUucmVzb2x2ZShwaGFzZV8xNDYpKSA9PT0gTGV0RGVjbFRyYW5zZm9ybSkge1xuICAgICAga2luZF8xNDMgPSBcImxldFwiO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5bl8xNDUgJiYgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bl8xNDUucmVzb2x2ZShwaGFzZV8xNDYpKSA9PT0gQ29uc3REZWNsVHJhbnNmb3JtKSB7XG4gICAgICBraW5kXzE0MyA9IFwiY29uc3RcIjtcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFN5bnRheERlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmRfMTQzID0gXCJzeW50YXhcIjtcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFN5bnRheHJlY0RlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmRfMTQzID0gXCJzeW50YXhyZWNcIjtcbiAgICB9XG4gICAgbGV0IGRlY2xzXzE0NyA9IExpc3QoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdG9yKHtpc1N5bnRheDoga2luZF8xNDMgPT09IFwic3ludGF4XCIgfHwga2luZF8xNDMgPT09IFwic3ludGF4cmVjXCJ9KTtcbiAgICAgIGxldCBsb29rYWhlYWRfMTQ0ID0gdGhpcy5wZWVrKCk7XG4gICAgICBkZWNsc18xNDcgPSBkZWNsc18xNDcuY29uY2F0KHRlcm0pO1xuICAgICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNDQsIFwiLFwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtraW5kOiBraW5kXzE0MywgZGVjbGFyYXRvcnM6IGRlY2xzXzE0N30pO1xuICB9XG4gIGVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdG9yKHtpc1N5bnRheH0pIHtcbiAgICBsZXQgaWRfMTQ4ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdUYXJnZXQoe2FsbG93UHVuY3R1YXRvcjogaXNTeW50YXh9KTtcbiAgICBsZXQgbG9va2FoZWFkXzE0OSA9IHRoaXMucGVlaygpO1xuICAgIGxldCBpbml0XzE1MCwgcmVzdF8xNTE7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNDksIFwiPVwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5yZXN0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBpbml0XzE1MCA9IGVuZi5lbmZvcmVzdChcImV4cHJlc3Npb25cIik7XG4gICAgICB0aGlzLnJlc3QgPSBlbmYucmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdF8xNTAgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwge2JpbmRpbmc6IGlkXzE0OCwgaW5pdDogaW5pdF8xNTB9KTtcbiAgfVxuICBlbmZvcmVzdEV4cHJlc3Npb25TdGF0ZW1lbnQoKSB7XG4gICAgbGV0IHN0YXJ0XzE1MiA9IHRoaXMucmVzdC5nZXQoMCk7XG4gICAgbGV0IGV4cHJfMTUzID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICBpZiAoZXhwcl8xNTMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3Ioc3RhcnRfMTUyLCBcIm5vdCBhIHZhbGlkIGV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwge2V4cHJlc3Npb246IGV4cHJfMTUzfSk7XG4gIH1cbiAgZW5mb3Jlc3RFeHByZXNzaW9uKCkge1xuICAgIGxldCBsZWZ0XzE1NCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIGxldCBsb29rYWhlYWRfMTU1ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNTUsIFwiLFwiKSkge1xuICAgICAgd2hpbGUgKHRoaXMucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiLFwiKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVyYXRvciA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgbGVmdF8xNTQgPSBuZXcgVGVybShcIkJpbmFyeUV4cHJlc3Npb25cIiwge2xlZnQ6IGxlZnRfMTU0LCBvcGVyYXRvcjogb3BlcmF0b3IsIHJpZ2h0OiByaWdodH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRlcm0gPSBudWxsO1xuICAgIHJldHVybiBsZWZ0XzE1NDtcbiAgfVxuICBlbmZvcmVzdEV4cHJlc3Npb25Mb29wKCkge1xuICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgdGhpcy5vcEN0eCA9IHtwcmVjOiAwLCBjb21iaW5lOiB4XzE1NiA9PiB4XzE1Niwgc3RhY2s6IExpc3QoKX07XG4gICAgZG8ge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLmVuZm9yZXN0QXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0ZXJtID09PSBFWFBSX0xPT1BfTk9fQ0hBTkdFXzQyICYmIHRoaXMub3BDdHguc3RhY2suc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5vcEN0eC5jb21iaW5lKHRoaXMudGVybSk7XG4gICAgICAgIGxldCB7cHJlYywgY29tYmluZX0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgICAgdGhpcy5vcEN0eC5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5vcEN0eC5zdGFjayA9IHRoaXMub3BDdHguc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9OT19DSEFOR0VfNDIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9PUEVSQVRPUl80MSB8fCB0ZXJtID09PSBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzKSB7XG4gICAgICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cbiAgZW5mb3Jlc3RBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE1NyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0NvbXBpbGV0aW1lVHJhbnNmb3JtKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICB0aGlzLmV4cGFuZE1hY3JvKCk7XG4gICAgICBsb29rYWhlYWRfMTU3ID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1Rlcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTU3LCBcInlpZWxkXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFlpZWxkRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogdHJ1ZX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwic3VwZXJcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiU3VwZXJcIiwge30pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTU3KSB8fCB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZF8xNTcpKSAmJiB0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoMSksIFwiPT5cIikgJiYgdGhpcy5saW5lTnVtYmVyRXEobG9va2FoZWFkXzE1NywgdGhpcy5wZWVrKDEpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3ludGF4VGVtcGxhdGUobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3ludGF4VGVtcGxhdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3ludGF4UXVvdGVUcmFuc2Zvcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3ludGF4UXVvdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzTmV3VHJhbnNmb3JtKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE5ld0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCB7aW5uZXI6IHRoaXMuYWR2YW5jZSgpLmlubmVyKCl9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzE1NywgXCJ0aGlzXCIpIHx8IHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwibGV0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwieWllbGRcIikgfHwgdGhpcy5pc051bWVyaWNMaXRlcmFsKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNTdHJpbmdMaXRlcmFsKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNUZW1wbGF0ZShsb29rYWhlYWRfMTU3KSB8fCB0aGlzLmlzQm9vbGVhbkxpdGVyYWwobG9va2FoZWFkXzE1NykgfHwgdGhpcy5pc051bGxMaXRlcmFsKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNSZWd1bGFyRXhwcmVzc2lvbihsb29rYWhlYWRfMTU3KSB8fCB0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNCcmFjZXMobG9va2FoZWFkXzE1NykgfHwgdGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZF8xNTcpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNPcGVyYXRvcihsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RVbmFyeUV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVmFyQmluZGluZ1RyYW5zZm9ybShsb29rYWhlYWRfMTU3KSkge1xuICAgICAgbGV0IGlkID0gdGhpcy5nZXRGcm9tQ29tcGlsZXRpbWVFbnZpcm9ubWVudChsb29rYWhlYWRfMTU3KS5pZDtcbiAgICAgIGlmIChpZCAhPT0gbG9va2FoZWFkXzE1Nykge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5yZXN0ID0gTGlzdC5vZihpZCkuY29uY2F0KHRoaXMucmVzdCk7XG4gICAgICAgIHJldHVybiBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNVcGRhdGVPcGVyYXRvcihsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc09wZXJhdG9yKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmFyeUV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMTU3LCBcIi5cIikgJiYgKHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSkgfHwgdGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKDEpKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGljTWVtYmVyRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb21wdXRlZE1lbWJlckV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICBsZXQgcGFyZW4gPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkNhbGxFeHByZXNzaW9uXCIsIHtjYWxsZWU6IHRoaXMudGVybSwgYXJndW1lbnRzOiBwYXJlbi5pbm5lcigpfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJUZW1wbGF0ZUV4cHJlc3Npb25cIiwge3RhZzogdGhpcy50ZXJtLCBlbGVtZW50czogdGhpcy5lbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNBc3NpZ24obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIGxldCBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRoaXMudGVybSk7XG4gICAgICBsZXQgb3AgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBpbml0ID0gZW5mLmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzdCA9IGVuZi5yZXN0O1xuICAgICAgaWYgKG9wLnZhbCgpID09PSBcIj1cIikge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogYmluZGluZywgZXhwcmVzc2lvbjogaW5pdH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogYmluZGluZywgb3BlcmF0b3I6IG9wLnZhbCgpLCBleHByZXNzaW9uOiBpbml0fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE1NywgXCI/XCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdENvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gRVhQUl9MT09QX05PX0NIQU5HRV80MjtcbiAgfVxuICBlbmZvcmVzdFByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgIGxldCBsb29rYWhlYWRfMTU4ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTU4LCBcInRoaXNcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VGhpc0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkXzE1OCkgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzE1OCwgXCJsZXRcIikgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzE1OCwgXCJ5aWVsZFwiKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0SWRlbnRpZmllckV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzTnVtZXJpY0xpdGVyYWwobG9va2FoZWFkXzE1OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TnVtZXJpY0xpdGVyYWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWRfMTU4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RTdHJpbmdMaXRlcmFsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZF8xNTgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNCb29sZWFuTGl0ZXJhbChsb29rYWhlYWRfMTU4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCb29sZWFuTGl0ZXJhbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNOdWxsTGl0ZXJhbChsb29rYWhlYWRfMTU4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3ROdWxsTGl0ZXJhbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNSZWd1bGFyRXhwcmVzc2lvbihsb29rYWhlYWRfMTU4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RSZWd1bGFyRXhwcmVzc2lvbkxpdGVyYWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xNTgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNCcmFjZXMobG9va2FoZWFkXzE1OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0T2JqZWN0RXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWRfMTU4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RBcnJheUV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIk5vdCBhIHByaW1hcnkgZXhwcmVzc2lvblwiKTtcbiAgfVxuICBlbmZvcmVzdEJvb2xlYW5MaXRlcmFsKCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxCb29sZWFuRXhwcmVzc2lvblwiLCB7dmFsdWU6IHRoaXMuYWR2YW5jZSgpfSk7XG4gIH1cbiAgZW5mb3Jlc3RUZW1wbGF0ZUxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVGVtcGxhdGVFeHByZXNzaW9uXCIsIHt0YWc6IG51bGwsIGVsZW1lbnRzOiB0aGlzLmVuZm9yZXN0VGVtcGxhdGVFbGVtZW50cygpfSk7XG4gIH1cbiAgZW5mb3Jlc3RTdHJpbmdMaXRlcmFsKCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxTdHJpbmdFeHByZXNzaW9uXCIsIHt2YWx1ZTogdGhpcy5hZHZhbmNlKCl9KTtcbiAgfVxuICBlbmZvcmVzdE51bWVyaWNMaXRlcmFsKCkge1xuICAgIGxldCBudW1fMTU5ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKG51bV8xNTkudmFsKCkgPT09IDEgLyAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXCIsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXCIsIHt2YWx1ZTogbnVtXzE1OX0pO1xuICB9XG4gIGVuZm9yZXN0SWRlbnRpZmllckV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IHRoaXMuYWR2YW5jZSgpfSk7XG4gIH1cbiAgZW5mb3Jlc3RSZWd1bGFyRXhwcmVzc2lvbkxpdGVyYWwoKSB7XG4gICAgbGV0IHJlU3R4XzE2MCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGxldCBsYXN0U2xhc2hfMTYxID0gcmVTdHhfMTYwLnRva2VuLnZhbHVlLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBsZXQgcGF0dGVybl8xNjIgPSByZVN0eF8xNjAudG9rZW4udmFsdWUuc2xpY2UoMSwgbGFzdFNsYXNoXzE2MSk7XG4gICAgbGV0IGZsYWdzXzE2MyA9IHJlU3R4XzE2MC50b2tlbi52YWx1ZS5zbGljZShsYXN0U2xhc2hfMTYxICsgMSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25cIiwge3BhdHRlcm46IHBhdHRlcm5fMTYyLCBmbGFnczogZmxhZ3NfMTYzfSk7XG4gIH1cbiAgZW5mb3Jlc3ROdWxsTGl0ZXJhbCgpIHtcbiAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJMaXRlcmFsTnVsbEV4cHJlc3Npb25cIiwge30pO1xuICB9XG4gIGVuZm9yZXN0VGhpc0V4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVGhpc0V4cHJlc3Npb25cIiwge3N0eDogdGhpcy5hZHZhbmNlKCl9KTtcbiAgfVxuICBlbmZvcmVzdEFyZ3VtZW50TGlzdCgpIHtcbiAgICBsZXQgcmVzdWx0XzE2NCA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgIGxldCBhcmc7XG4gICAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiLi4uXCIpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBhcmcgPSBuZXcgVGVybShcIlNwcmVhZEVsZW1lbnRcIiwge2V4cHJlc3Npb246IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmcgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCIsXCIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0XzE2NC5wdXNoKGFyZyk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF8xNjQpO1xuICB9XG4gIGVuZm9yZXN0TmV3RXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcIm5ld1wiKTtcbiAgICBsZXQgY2FsbGVlXzE2NTtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwibmV3XCIpKSB7XG4gICAgICBjYWxsZWVfMTY1ID0gdGhpcy5lbmZvcmVzdE5ld0V4cHJlc3Npb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcInN1cGVyXCIpKSB7XG4gICAgICBjYWxsZWVfMTY1ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoKSwgXCIuXCIpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgXCJ0YXJnZXRcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJOZXdUYXJnZXRFeHByZXNzaW9uXCIsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVlXzE2NSA9IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCl9KTtcbiAgICB9XG4gICAgbGV0IGFyZ3NfMTY2O1xuICAgIGlmICh0aGlzLmlzUGFyZW5zKHRoaXMucGVlaygpKSkge1xuICAgICAgYXJnc18xNjYgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NfMTY2ID0gTGlzdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJOZXdFeHByZXNzaW9uXCIsIHtjYWxsZWU6IGNhbGxlZV8xNjUsIGFyZ3VtZW50czogYXJnc18xNjZ9KTtcbiAgfVxuICBlbmZvcmVzdENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgZW5mXzE2NyA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIiwge29iamVjdDogdGhpcy50ZXJtLCBleHByZXNzaW9uOiBlbmZfMTY3LmVuZm9yZXN0RXhwcmVzc2lvbigpfSk7XG4gIH1cbiAgdHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0ZXJtXzE2OCkge1xuICAgIHN3aXRjaCAodGVybV8xNjgudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2OC5uYW1lfSk7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHRlcm1fMTY4LmlubmVyLnNpemUgPT09IDEgJiYgdGhpcy5pc0lkZW50aWZpZXIodGVybV8xNjguaW5uZXIuZ2V0KDApKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2OC5pbm5lci5nZXQoMCl9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkRhdGFQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGVybV8xNjgubmFtZSwgYmluZGluZzogdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nV2l0aERlZmF1bHQodGVybV8xNjguZXhwcmVzc2lvbil9KTtcbiAgICAgIGNhc2UgXCJTaG9ydGhhbmRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCIsIHtiaW5kaW5nOiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2OC5uYW1lfSksIGluaXQ6IG51bGx9KTtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEJpbmRpbmdcIiwge3Byb3BlcnRpZXM6IHRlcm1fMTY4LnByb3BlcnRpZXMubWFwKHRfMTY5ID0+IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0XzE2OSkpfSk7XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIGxldCBsYXN0ID0gdGVybV8xNjguZWxlbWVudHMubGFzdCgpO1xuICAgICAgICBpZiAobGFzdCAhPSBudWxsICYmIGxhc3QudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiB0ZXJtXzE2OC5lbGVtZW50cy5zbGljZSgwLCAtMSkubWFwKHRfMTcwID0+IHRfMTcwICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRfMTcwKSksIHJlc3RFbGVtZW50OiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmdXaXRoRGVmYXVsdChsYXN0LmV4cHJlc3Npb24pfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV8xNjguZWxlbWVudHMubWFwKHRfMTcxID0+IHRfMTcxICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRfMTcxKSksIHJlc3RFbGVtZW50OiBudWxsfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV8xNjguZWxlbWVudHMubWFwKHRfMTcyID0+IHRfMTcyICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0XzE3MikpLCByZXN0RWxlbWVudDogbnVsbH0pO1xuICAgICAgY2FzZSBcIlN0YXRpY1Byb3BlcnR5TmFtZVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogdGVybV8xNjgudmFsdWV9KTtcbiAgICAgIGNhc2UgXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQXJyYXlCaW5kaW5nXCI6XG4gICAgICBjYXNlIFwiQmluZGluZ0lkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiQmluZGluZ1Byb3BlcnR5UHJvcGVydHlcIjpcbiAgICAgIGNhc2UgXCJCaW5kaW5nV2l0aERlZmF1bHRcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RCaW5kaW5nXCI6XG4gICAgICAgIHJldHVybiB0ZXJtXzE2ODtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXQgZm9yIFwiICsgdGVybV8xNjgudHlwZSk7XG4gIH1cbiAgdHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRlcm1fMTczKSB7XG4gICAgc3dpdGNoICh0ZXJtXzE3My50eXBlKSB7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmcodGVybV8xNzMuYmluZGluZyksIGluaXQ6IHRlcm1fMTczLmV4cHJlc3Npb259KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0ZXJtXzE3Myk7XG4gIH1cbiAgZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKSB7XG4gICAgbGV0IGVuZl8xNzQ7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygpKSkge1xuICAgICAgZW5mXzE3NCA9IG5ldyBFbmZvcmVzdGVyXzQ0KExpc3Qub2YodGhpcy5hZHZhbmNlKCkpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgICAgZW5mXzE3NCA9IG5ldyBFbmZvcmVzdGVyXzQ0KHAsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgbGV0IHBhcmFtc18xNzUgPSBlbmZfMTc0LmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiPT5cIik7XG4gICAgbGV0IGJvZHlfMTc2O1xuICAgIGlmICh0aGlzLmlzQnJhY2VzKHRoaXMucGVlaygpKSkge1xuICAgICAgYm9keV8xNzYgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmZfMTc0ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5yZXN0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBib2R5XzE3NiA9IGVuZl8xNzQuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgdGhpcy5yZXN0ID0gZW5mXzE3NC5yZXN0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJvd0V4cHJlc3Npb25cIiwge3BhcmFtczogcGFyYW1zXzE3NSwgYm9keTogYm9keV8xNzZ9KTtcbiAgfVxuICBlbmZvcmVzdFlpZWxkRXhwcmVzc2lvbigpIHtcbiAgICBsZXQga3dkXzE3NyA9IHRoaXMubWF0Y2hLZXl3b3JkKFwieWllbGRcIik7XG4gICAgbGV0IGxvb2thaGVhZF8xNzggPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDAgfHwgbG9va2FoZWFkXzE3OCAmJiAhdGhpcy5saW5lTnVtYmVyRXEoa3dkXzE3NywgbG9va2FoZWFkXzE3OCkpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIllpZWxkRXhwcmVzc2lvblwiLCB7ZXhwcmVzc2lvbjogbnVsbH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaXNHZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoKSwgXCIqXCIpKSB7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBsZXQgZXhwciA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICBsZXQgdHlwZSA9IGlzR2VuZXJhdG9yID8gXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIiA6IFwiWWllbGRFeHByZXNzaW9uXCI7XG4gICAgICByZXR1cm4gbmV3IFRlcm0odHlwZSwge2V4cHJlc3Npb246IGV4cHJ9KTtcbiAgICB9XG4gIH1cbiAgZW5mb3Jlc3RTeW50YXhUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTeW50YXhUZW1wbGF0ZVwiLCB7dGVtcGxhdGU6IHRoaXMuYWR2YW5jZSgpfSk7XG4gIH1cbiAgZW5mb3Jlc3RTeW50YXhRdW90ZSgpIHtcbiAgICBsZXQgbmFtZV8xNzkgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTeW50YXhRdW90ZVwiLCB7bmFtZTogbmFtZV8xNzksIHRlbXBsYXRlOiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiBuYW1lXzE3OX0pLCBlbGVtZW50czogdGhpcy5lbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKX0pfSk7XG4gIH1cbiAgZW5mb3Jlc3RTdGF0aWNNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgIGxldCBvYmplY3RfMTgwID0gdGhpcy50ZXJtO1xuICAgIGxldCBkb3RfMTgxID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IHByb3BlcnR5XzE4MiA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIiwge29iamVjdDogb2JqZWN0XzE4MCwgcHJvcGVydHk6IHByb3BlcnR5XzE4Mn0pO1xuICB9XG4gIGVuZm9yZXN0QXJyYXlFeHByZXNzaW9uKCkge1xuICAgIGxldCBhcnJfMTgzID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGVsZW1lbnRzXzE4NCA9IFtdO1xuICAgIGxldCBlbmZfMTg1ID0gbmV3IEVuZm9yZXN0ZXJfNDQoYXJyXzE4My5pbm5lcigpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgd2hpbGUgKGVuZl8xODUucmVzdC5zaXplID4gMCkge1xuICAgICAgbGV0IGxvb2thaGVhZCA9IGVuZl8xODUucGVlaygpO1xuICAgICAgaWYgKGVuZl8xODUuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgXCIsXCIpKSB7XG4gICAgICAgIGVuZl8xODUuYWR2YW5jZSgpO1xuICAgICAgICBlbGVtZW50c18xODQucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoZW5mXzE4NS5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCBcIi4uLlwiKSkge1xuICAgICAgICBlbmZfMTg1LmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSBlbmZfMTg1LmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVuZl8xODUuY3JlYXRlRXJyb3IobG9va2FoZWFkLCBcImV4cGVjdGluZyBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzXzE4NC5wdXNoKG5ldyBUZXJtKFwiU3ByZWFkRWxlbWVudFwiLCB7ZXhwcmVzc2lvbjogZXhwcmVzc2lvbn0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0ZXJtID0gZW5mXzE4NS5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGlmICh0ZXJtID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlbmZfMTg1LmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgXCJleHBlY3RlZCBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzXzE4NC5wdXNoKHRlcm0pO1xuICAgICAgICBlbmZfMTg1LmNvbnN1bWVDb21tYSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUV4cHJlc3Npb25cIiwge2VsZW1lbnRzOiBMaXN0KGVsZW1lbnRzXzE4NCl9KTtcbiAgfVxuICBlbmZvcmVzdE9iamVjdEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9ial8xODYgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBsZXQgcHJvcGVydGllc18xODcgPSBMaXN0KCk7XG4gICAgbGV0IGVuZl8xODggPSBuZXcgRW5mb3Jlc3Rlcl80NChvYmpfMTg2LmlubmVyKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgbGFzdFByb3BfMTg5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW5mXzE4OC5yZXN0LnNpemUgPiAwKSB7XG4gICAgICBsZXQgcHJvcCA9IGVuZl8xODguZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKTtcbiAgICAgIGVuZl8xODguY29uc3VtZUNvbW1hKCk7XG4gICAgICBwcm9wZXJ0aWVzXzE4NyA9IHByb3BlcnRpZXNfMTg3LmNvbmNhdChwcm9wKTtcbiAgICAgIGlmIChsYXN0UHJvcF8xODkgPT09IHByb3ApIHtcbiAgICAgICAgdGhyb3cgZW5mXzE4OC5jcmVhdGVFcnJvcihwcm9wLCBcImludmFsaWQgc3ludGF4IGluIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGxhc3RQcm9wXzE4OSA9IHByb3A7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEV4cHJlc3Npb25cIiwge3Byb3BlcnRpZXM6IHByb3BlcnRpZXNfMTg3fSk7XG4gIH1cbiAgZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKSB7XG4gICAgbGV0IHttZXRob2RPcktleSwga2luZH0gPSB0aGlzLmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBcIm1ldGhvZFwiOlxuICAgICAgICByZXR1cm4gbWV0aG9kT3JLZXk7XG4gICAgICBjYXNlIFwiaWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pc0Fzc2lnbih0aGlzLnBlZWsoKSkpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICBsZXQgaW5pdCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJcIiwge2luaXQ6IGluaXQsIGJpbmRpbmc6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyhtZXRob2RPcktleSl9KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiOlwiKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIlNob3J0aGFuZFByb3BlcnR5XCIsIHtuYW1lOiBtZXRob2RPcktleS52YWx1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiOlwiKTtcbiAgICBsZXQgZXhwcl8xOTAgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJEYXRhUHJvcGVydHlcIiwge25hbWU6IG1ldGhvZE9yS2V5LCBleHByZXNzaW9uOiBleHByXzE5MH0pO1xuICB9XG4gIGVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE5MSA9IHRoaXMucGVlaygpO1xuICAgIGxldCBpc0dlbmVyYXRvcl8xOTIgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE5MSwgXCIqXCIpKSB7XG4gICAgICBpc0dlbmVyYXRvcl8xOTIgPSB0cnVlO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTkxLCBcImdldFwiKSAmJiB0aGlzLmlzUHJvcGVydHlOYW1lKHRoaXMucGVlaygxKSkpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IHtuYW1lfSA9IHRoaXMuZW5mb3Jlc3RQcm9wZXJ0eU5hbWUoKTtcbiAgICAgIHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICAgIGxldCBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICAgIHJldHVybiB7bWV0aG9kT3JLZXk6IG5ldyBUZXJtKFwiR2V0dGVyXCIsIHtuYW1lOiBuYW1lLCBib2R5OiBib2R5fSksIGtpbmQ6IFwibWV0aG9kXCJ9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkXzE5MSwgXCJzZXRcIikgJiYgdGhpcy5pc1Byb3BlcnR5TmFtZSh0aGlzLnBlZWsoMSkpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCB7bmFtZX0gPSB0aGlzLmVuZm9yZXN0UHJvcGVydHlOYW1lKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaFBhcmVucygpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBsZXQgcGFyYW0gPSBlbmYuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICAgICAgbGV0IGJvZHkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgICAgcmV0dXJuIHttZXRob2RPcktleTogbmV3IFRlcm0oXCJTZXR0ZXJcIiwge25hbWU6IG5hbWUsIHBhcmFtOiBwYXJhbSwgYm9keTogYm9keX0pLCBraW5kOiBcIm1ldGhvZFwifTtcbiAgICB9XG4gICAgbGV0IHtuYW1lfSA9IHRoaXMuZW5mb3Jlc3RQcm9wZXJ0eU5hbWUoKTtcbiAgICBpZiAodGhpcy5pc1BhcmVucyh0aGlzLnBlZWsoKSkpIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBsZXQgZm9ybWFsUGFyYW1zID0gZW5mLmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgICAgbGV0IGJvZHkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgICAgcmV0dXJuIHttZXRob2RPcktleTogbmV3IFRlcm0oXCJNZXRob2RcIiwge2lzR2VuZXJhdG9yOiBpc0dlbmVyYXRvcl8xOTIsIG5hbWU6IG5hbWUsIHBhcmFtczogZm9ybWFsUGFyYW1zLCBib2R5OiBib2R5fSksIGtpbmQ6IFwibWV0aG9kXCJ9O1xuICAgIH1cbiAgICByZXR1cm4ge21ldGhvZE9yS2V5OiBuYW1lLCBraW5kOiB0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTkxKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTkxKSA/IFwiaWRlbnRpZmllclwiIDogXCJwcm9wZXJ0eVwifTtcbiAgfVxuICBlbmZvcmVzdFByb3BlcnR5TmFtZSgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE5MyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWRfMTkzKSB8fCB0aGlzLmlzTnVtZXJpY0xpdGVyYWwobG9va2FoZWFkXzE5MykpIHtcbiAgICAgIHJldHVybiB7bmFtZTogbmV3IFRlcm0oXCJTdGF0aWNQcm9wZXJ0eU5hbWVcIiwge3ZhbHVlOiB0aGlzLmFkdmFuY2UoKX0pLCBiaW5kaW5nOiBudWxsfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWRfMTkzKSkge1xuICAgICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBleHByID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgIHJldHVybiB7bmFtZTogbmV3IFRlcm0oXCJDb21wdXRlZFByb3BlcnR5TmFtZVwiLCB7ZXhwcmVzc2lvbjogZXhwcn0pLCBiaW5kaW5nOiBudWxsfTtcbiAgICB9XG4gICAgbGV0IG5hbWVfMTk0ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHtuYW1lOiBuZXcgVGVybShcIlN0YXRpY1Byb3BlcnR5TmFtZVwiLCB7dmFsdWU6IG5hbWVfMTk0fSksIGJpbmRpbmc6IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfMTk0fSl9O1xuICB9XG4gIGVuZm9yZXN0RnVuY3Rpb24oe2lzRXhwciwgaW5EZWZhdWx0LCBhbGxvd0dlbmVyYXRvcn0pIHtcbiAgICBsZXQgbmFtZV8xOTUgPSBudWxsLCBwYXJhbXNfMTk2LCBib2R5XzE5NywgcmVzdF8xOTg7XG4gICAgbGV0IGlzR2VuZXJhdG9yXzE5OSA9IGZhbHNlO1xuICAgIGxldCBmbktleXdvcmRfMjAwID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGxvb2thaGVhZF8yMDEgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgdHlwZV8yMDIgPSBpc0V4cHIgPyBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIDogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8yMDEsIFwiKlwiKSkge1xuICAgICAgaXNHZW5lcmF0b3JfMTk5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbG9va2FoZWFkXzIwMSA9IHRoaXMucGVlaygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNQYXJlbnMobG9va2FoZWFkXzIwMSkpIHtcbiAgICAgIG5hbWVfMTk1ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmIChpbkRlZmF1bHQpIHtcbiAgICAgIG5hbWVfMTk1ID0gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogU3ludGF4LmZyb21JZGVudGlmaWVyKFwiKmRlZmF1bHQqXCIsIGZuS2V5d29yZF8yMDApfSk7XG4gICAgfVxuICAgIHBhcmFtc18xOTYgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgYm9keV8xOTcgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBlbmZfMjAzID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zXzE5NiwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBmb3JtYWxQYXJhbXNfMjA0ID0gZW5mXzIwMy5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8yMDIsIHtuYW1lOiBuYW1lXzE5NSwgaXNHZW5lcmF0b3I6IGlzR2VuZXJhdG9yXzE5OSwgcGFyYW1zOiBmb3JtYWxQYXJhbXNfMjA0LCBib2R5OiBib2R5XzE5N30pO1xuICB9XG4gIGVuZm9yZXN0RnVuY3Rpb25FeHByZXNzaW9uKCkge1xuICAgIGxldCBuYW1lXzIwNSA9IG51bGwsIHBhcmFtc18yMDYsIGJvZHlfMjA3LCByZXN0XzIwODtcbiAgICBsZXQgaXNHZW5lcmF0b3JfMjA5ID0gZmFsc2U7XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGxvb2thaGVhZF8yMTAgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzIxMCwgXCIqXCIpKSB7XG4gICAgICBpc0dlbmVyYXRvcl8yMDkgPSB0cnVlO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsb29rYWhlYWRfMjEwID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1BhcmVucyhsb29rYWhlYWRfMjEwKSkge1xuICAgICAgbmFtZV8yMDUgPSB0aGlzLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgcGFyYW1zXzIwNiA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICBib2R5XzIwNyA9IHRoaXMubWF0Y2hDdXJsaWVzKCk7XG4gICAgbGV0IGVuZl8yMTEgPSBuZXcgRW5mb3Jlc3Rlcl80NChwYXJhbXNfMjA2LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGZvcm1hbFBhcmFtc18yMTIgPSBlbmZfMjExLmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7bmFtZTogbmFtZV8yMDUsIGlzR2VuZXJhdG9yOiBpc0dlbmVyYXRvcl8yMDksIHBhcmFtczogZm9ybWFsUGFyYW1zXzIxMiwgYm9keTogYm9keV8yMDd9KTtcbiAgfVxuICBlbmZvcmVzdEZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IG5hbWVfMjEzLCBwYXJhbXNfMjE0LCBib2R5XzIxNSwgcmVzdF8yMTY7XG4gICAgbGV0IGlzR2VuZXJhdG9yXzIxNyA9IGZhbHNlO1xuICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIGxldCBsb29rYWhlYWRfMjE4ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8yMTgsIFwiKlwiKSkge1xuICAgICAgaXNHZW5lcmF0b3JfMjE3ID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICBuYW1lXzIxMyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgIHBhcmFtc18yMTQgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgYm9keV8yMTUgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBlbmZfMjE5ID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zXzIxNCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBmb3JtYWxQYXJhbXNfMjIwID0gZW5mXzIxOS5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIHtuYW1lOiBuYW1lXzIxMywgaXNHZW5lcmF0b3I6IGlzR2VuZXJhdG9yXzIxNywgcGFyYW1zOiBmb3JtYWxQYXJhbXNfMjIwLCBib2R5OiBib2R5XzIxNX0pO1xuICB9XG4gIGVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpIHtcbiAgICBsZXQgaXRlbXNfMjIxID0gW107XG4gICAgbGV0IHJlc3RfMjIyID0gbnVsbDtcbiAgICB3aGlsZSAodGhpcy5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsIFwiLi4uXCIpKSB7XG4gICAgICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiLi4uXCIpO1xuICAgICAgICByZXN0XzIyMiA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGl0ZW1zXzIyMS5wdXNoKHRoaXMuZW5mb3Jlc3RQYXJhbSgpKTtcbiAgICAgIHRoaXMuY29uc3VtZUNvbW1hKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiBMaXN0KGl0ZW1zXzIyMSksIHJlc3Q6IHJlc3RfMjIyfSk7XG4gIH1cbiAgZW5mb3Jlc3RQYXJhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmRpbmdFbGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCkge1xuICAgIGxldCBvcGVyYXRvcl8yMjMgPSB0aGlzLm1hdGNoVW5hcnlPcGVyYXRvcigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge2lzUHJlZml4OiBmYWxzZSwgb3BlcmF0b3I6IG9wZXJhdG9yXzIyMy52YWwoKSwgb3BlcmFuZDogdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRoaXMudGVybSl9KTtcbiAgfVxuICBlbmZvcmVzdFVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgb3BlcmF0b3JfMjI0ID0gdGhpcy5tYXRjaFVuYXJ5T3BlcmF0b3IoKTtcbiAgICB0aGlzLm9wQ3R4LnN0YWNrID0gdGhpcy5vcEN0eC5zdGFjay5wdXNoKHtwcmVjOiB0aGlzLm9wQ3R4LnByZWMsIGNvbWJpbmU6IHRoaXMub3BDdHguY29tYmluZX0pO1xuICAgIHRoaXMub3BDdHgucHJlYyA9IDE0O1xuICAgIHRoaXMub3BDdHguY29tYmluZSA9IHJpZ2h0VGVybV8yMjUgPT4ge1xuICAgICAgbGV0IHR5cGVfMjI2LCB0ZXJtXzIyNywgaXNQcmVmaXhfMjI4O1xuICAgICAgaWYgKG9wZXJhdG9yXzIyNC52YWwoKSA9PT0gXCIrK1wiIHx8IG9wZXJhdG9yXzIyNC52YWwoKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIHR5cGVfMjI2ID0gXCJVcGRhdGVFeHByZXNzaW9uXCI7XG4gICAgICAgIHRlcm1fMjI3ID0gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHJpZ2h0VGVybV8yMjUpO1xuICAgICAgICBpc1ByZWZpeF8yMjggPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZV8yMjYgPSBcIlVuYXJ5RXhwcmVzc2lvblwiO1xuICAgICAgICBpc1ByZWZpeF8yMjggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRlcm1fMjI3ID0gcmlnaHRUZXJtXzIyNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybSh0eXBlXzIyNiwge29wZXJhdG9yOiBvcGVyYXRvcl8yMjQudmFsKCksIG9wZXJhbmQ6IHRlcm1fMjI3LCBpc1ByZWZpeDogaXNQcmVmaXhfMjI4fSk7XG4gICAgfTtcbiAgICByZXR1cm4gRVhQUl9MT09QX09QRVJBVE9SXzQxO1xuICB9XG4gIGVuZm9yZXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgIGxldCB0ZXN0XzIyOSA9IHRoaXMub3BDdHguY29tYmluZSh0aGlzLnRlcm0pO1xuICAgIGlmICh0aGlzLm9wQ3R4LnN0YWNrLnNpemUgPiAwKSB7XG4gICAgICBsZXQge3ByZWMsIGNvbWJpbmV9ID0gdGhpcy5vcEN0eC5zdGFjay5sYXN0KCk7XG4gICAgICB0aGlzLm9wQ3R4LnN0YWNrID0gdGhpcy5vcEN0eC5zdGFjay5wb3AoKTtcbiAgICAgIHRoaXMub3BDdHgucHJlYyA9IHByZWM7XG4gICAgICB0aGlzLm9wQ3R4LmNvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cbiAgICB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIj9cIik7XG4gICAgbGV0IGVuZl8yMzAgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgY29uc2VxdWVudF8yMzEgPSBlbmZfMjMwLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICBlbmZfMjMwLm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgZW5mXzIzMCA9IG5ldyBFbmZvcmVzdGVyXzQ0KGVuZl8yMzAucmVzdCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhbHRlcm5hdGVfMjMyID0gZW5mXzIzMC5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgdGhpcy5yZXN0ID0gZW5mXzIzMC5yZXN0O1xuICAgIHJldHVybiBuZXcgVGVybShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7dGVzdDogdGVzdF8yMjksIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnRfMjMxLCBhbHRlcm5hdGU6IGFsdGVybmF0ZV8yMzJ9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnRUZXJtXzIzMyA9IHRoaXMudGVybTtcbiAgICBsZXQgb3BTdHhfMjM0ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IG9wXzIzNSA9IG9wU3R4XzIzNC52YWwoKTtcbiAgICBsZXQgb3BQcmVjXzIzNiA9IGdldE9wZXJhdG9yUHJlYyhvcF8yMzUpO1xuICAgIGxldCBvcEFzc29jXzIzNyA9IGdldE9wZXJhdG9yQXNzb2Mob3BfMjM1KTtcbiAgICBpZiAob3BlcmF0b3JMdCh0aGlzLm9wQ3R4LnByZWMsIG9wUHJlY18yMzYsIG9wQXNzb2NfMjM3KSkge1xuICAgICAgdGhpcy5vcEN0eC5zdGFjayA9IHRoaXMub3BDdHguc3RhY2sucHVzaCh7cHJlYzogdGhpcy5vcEN0eC5wcmVjLCBjb21iaW5lOiB0aGlzLm9wQ3R4LmNvbWJpbmV9KTtcbiAgICAgIHRoaXMub3BDdHgucHJlYyA9IG9wUHJlY18yMzY7XG4gICAgICB0aGlzLm9wQ3R4LmNvbWJpbmUgPSByaWdodFRlcm1fMjM4ID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7bGVmdDogbGVmdFRlcm1fMjMzLCBvcGVyYXRvcjogb3BTdHhfMjM0LCByaWdodDogcmlnaHRUZXJtXzIzOH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIEVYUFJfTE9PUF9PUEVSQVRPUl80MTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLm9wQ3R4LmNvbWJpbmUobGVmdFRlcm1fMjMzKTtcbiAgICAgIGxldCB7cHJlYywgY29tYmluZX0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgIHRoaXMub3BDdHguc3RhY2sgPSB0aGlzLm9wQ3R4LnN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgIHRoaXMub3BDdHguY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gIH1cbiAgZW5mb3Jlc3RUZW1wbGF0ZUVsZW1lbnRzKCkge1xuICAgIGxldCBsb29rYWhlYWRfMjM5ID0gdGhpcy5tYXRjaFRlbXBsYXRlKCk7XG4gICAgbGV0IGVsZW1lbnRzXzI0MCA9IGxvb2thaGVhZF8yMzkudG9rZW4uaXRlbXMubWFwKGl0XzI0MSA9PiB7XG4gICAgICBpZiAoaXRfMjQxIGluc3RhbmNlb2YgU3ludGF4ICYmIGl0XzI0MS5pc0RlbGltaXRlcigpKSB7XG4gICAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcl80NChpdF8yNDEuaW5uZXIoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZW5mLmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRWxlbWVudFwiLCB7cmF3VmFsdWU6IGl0XzI0MS5zbGljZS50ZXh0fSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnRzXzI0MDtcbiAgfVxuICBleHBhbmRNYWNybygpIHtcbiAgICBsZXQgbG9va2FoZWFkXzI0MiA9IHRoaXMucGVlaygpO1xuICAgIHdoaWxlICh0aGlzLmlzQ29tcGlsZXRpbWVUcmFuc2Zvcm0obG9va2FoZWFkXzI0MikpIHtcbiAgICAgIGxldCBuYW1lID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgc3ludGF4VHJhbnNmb3JtID0gdGhpcy5nZXRGcm9tQ29tcGlsZXRpbWVFbnZpcm9ubWVudChuYW1lKTtcbiAgICAgIGlmIChzeW50YXhUcmFuc2Zvcm0gPT0gbnVsbCB8fCB0eXBlb2Ygc3ludGF4VHJhbnNmb3JtLnZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihuYW1lLCBcInRoZSBtYWNybyBuYW1lIHdhcyBub3QgYm91bmQgdG8gYSB2YWx1ZSB0aGF0IGNvdWxkIGJlIGludm9rZWRcIik7XG4gICAgICB9XG4gICAgICBsZXQgdXNlU2l0ZVNjb3BlID0gZnJlc2hTY29wZShcInVcIik7XG4gICAgICBsZXQgaW50cm9kdWNlZFNjb3BlID0gZnJlc2hTY29wZShcImlcIik7XG4gICAgICB0aGlzLmNvbnRleHQudXNlU2NvcGUgPSB1c2VTaXRlU2NvcGU7XG4gICAgICBsZXQgY3R4ID0gbmV3IE1hY3JvQ29udGV4dCh0aGlzLCBuYW1lLCB0aGlzLmNvbnRleHQsIHVzZVNpdGVTY29wZSwgaW50cm9kdWNlZFNjb3BlKTtcbiAgICAgIGxldCByZXN1bHQgPSBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKHN5bnRheFRyYW5zZm9ybS52YWx1ZS5jYWxsKG51bGwsIGN0eCkpO1xuICAgICAgaWYgKCFMaXN0LmlzTGlzdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZSwgXCJtYWNybyBtdXN0IHJldHVybiBhIGxpc3QgYnV0IGdvdDogXCIgKyByZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChzdHhfMjQzID0+IHtcbiAgICAgICAgaWYgKCEoc3R4XzI0MyAmJiB0eXBlb2Ygc3R4XzI0My5hZGRTY29wZSA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZSwgXCJtYWNybyBtdXN0IHJldHVybiBzeW50YXggb2JqZWN0cyBvciB0ZXJtcyBidXQgZ290OiBcIiArIHN0eF8yNDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHhfMjQzLmFkZFNjb3BlKGludHJvZHVjZWRTY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTLCB7ZmxpcDogdHJ1ZX0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlc3QgPSByZXN1bHQuY29uY2F0KGN0eC5fcmVzdCh0aGlzKSk7XG4gICAgICBsb29rYWhlYWRfMjQyID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuICB9XG4gIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yNDQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAobG9va2FoZWFkXzI0NCAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMjQ0LCBcIjtcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdW1lQ29tbWEoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yNDUgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAobG9va2FoZWFkXzI0NSAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMjQ1LCBcIixcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuICBpc1Rlcm0odGVybV8yNDYpIHtcbiAgICByZXR1cm4gdGVybV8yNDYgJiYgdGVybV8yNDYgaW5zdGFuY2VvZiBUZXJtO1xuICB9XG4gIGlzRU9GKHRlcm1fMjQ3KSB7XG4gICAgcmV0dXJuIHRlcm1fMjQ3ICYmIHRlcm1fMjQ3IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjQ3LmlzRU9GKCk7XG4gIH1cbiAgaXNJZGVudGlmaWVyKHRlcm1fMjQ4LCB2YWxfMjQ5ID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI0OCAmJiB0ZXJtXzI0OCBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI0OC5pc0lkZW50aWZpZXIoKSAmJiAodmFsXzI0OSA9PT0gbnVsbCB8fCB0ZXJtXzI0OC52YWwoKSA9PT0gdmFsXzI0OSk7XG4gIH1cbiAgaXNQcm9wZXJ0eU5hbWUodGVybV8yNTApIHtcbiAgICByZXR1cm4gdGhpcy5pc0lkZW50aWZpZXIodGVybV8yNTApIHx8IHRoaXMuaXNLZXl3b3JkKHRlcm1fMjUwKSB8fCB0aGlzLmlzTnVtZXJpY0xpdGVyYWwodGVybV8yNTApIHx8IHRoaXMuaXNTdHJpbmdMaXRlcmFsKHRlcm1fMjUwKSB8fCB0aGlzLmlzQnJhY2tldHModGVybV8yNTApO1xuICB9XG4gIGlzTnVtZXJpY0xpdGVyYWwodGVybV8yNTEpIHtcbiAgICByZXR1cm4gdGVybV8yNTEgJiYgdGVybV8yNTEgaW5zdGFuY2VvZiBTeW50YXggJiYgdGVybV8yNTEuaXNOdW1lcmljTGl0ZXJhbCgpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh0ZXJtXzI1Mikge1xuICAgIHJldHVybiB0ZXJtXzI1MiAmJiB0ZXJtXzI1MiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1Mi5pc1N0cmluZ0xpdGVyYWwoKTtcbiAgfVxuICBpc1RlbXBsYXRlKHRlcm1fMjUzKSB7XG4gICAgcmV0dXJuIHRlcm1fMjUzICYmIHRlcm1fMjUzIGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjUzLmlzVGVtcGxhdGUoKTtcbiAgfVxuICBpc0Jvb2xlYW5MaXRlcmFsKHRlcm1fMjU0KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU0ICYmIHRlcm1fMjU0IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU0LmlzQm9vbGVhbkxpdGVyYWwoKTtcbiAgfVxuICBpc051bGxMaXRlcmFsKHRlcm1fMjU1KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU1ICYmIHRlcm1fMjU1IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU1LmlzTnVsbExpdGVyYWwoKTtcbiAgfVxuICBpc1JlZ3VsYXJFeHByZXNzaW9uKHRlcm1fMjU2KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU2ICYmIHRlcm1fMjU2IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU2LmlzUmVndWxhckV4cHJlc3Npb24oKTtcbiAgfVxuICBpc1BhcmVucyh0ZXJtXzI1Nykge1xuICAgIHJldHVybiB0ZXJtXzI1NyAmJiB0ZXJtXzI1NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1Ny5pc1BhcmVucygpO1xuICB9XG4gIGlzQnJhY2VzKHRlcm1fMjU4KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU4ICYmIHRlcm1fMjU4IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU4LmlzQnJhY2VzKCk7XG4gIH1cbiAgaXNCcmFja2V0cyh0ZXJtXzI1OSkge1xuICAgIHJldHVybiB0ZXJtXzI1OSAmJiB0ZXJtXzI1OSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1OS5pc0JyYWNrZXRzKCk7XG4gIH1cbiAgaXNBc3NpZ24odGVybV8yNjApIHtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGVybV8yNjApKSB7XG4gICAgICBzd2l0Y2ggKHRlcm1fMjYwLnZhbCgpKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgIGNhc2UgXCJ8PVwiOlxuICAgICAgICBjYXNlIFwiXj1cIjpcbiAgICAgICAgY2FzZSBcIiY9XCI6XG4gICAgICAgIGNhc2UgXCI8PD1cIjpcbiAgICAgICAgY2FzZSBcIj4+PVwiOlxuICAgICAgICBjYXNlIFwiPj4+PVwiOlxuICAgICAgICBjYXNlIFwiKz1cIjpcbiAgICAgICAgY2FzZSBcIi09XCI6XG4gICAgICAgIGNhc2UgXCIqPVwiOlxuICAgICAgICBjYXNlIFwiLz1cIjpcbiAgICAgICAgY2FzZSBcIiU9XCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNLZXl3b3JkKHRlcm1fMjYxLCB2YWxfMjYyID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI2MSAmJiB0ZXJtXzI2MSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI2MS5pc0tleXdvcmQoKSAmJiAodmFsXzI2MiA9PT0gbnVsbCB8fCB0ZXJtXzI2MS52YWwoKSA9PT0gdmFsXzI2Mik7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHRlcm1fMjYzLCB2YWxfMjY0ID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI2MyAmJiB0ZXJtXzI2MyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI2My5pc1B1bmN0dWF0b3IoKSAmJiAodmFsXzI2NCA9PT0gbnVsbCB8fCB0ZXJtXzI2My52YWwoKSA9PT0gdmFsXzI2NCk7XG4gIH1cbiAgaXNPcGVyYXRvcih0ZXJtXzI2NSkge1xuICAgIHJldHVybiB0ZXJtXzI2NSAmJiB0ZXJtXzI2NSBpbnN0YW5jZW9mIFN5bnRheCAmJiBpc09wZXJhdG9yKHRlcm1fMjY1KTtcbiAgfVxuICBpc1VwZGF0ZU9wZXJhdG9yKHRlcm1fMjY2KSB7XG4gICAgcmV0dXJuIHRlcm1fMjY2ICYmIHRlcm1fMjY2IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjY2LmlzUHVuY3R1YXRvcigpICYmICh0ZXJtXzI2Ni52YWwoKSA9PT0gXCIrK1wiIHx8IHRlcm1fMjY2LnZhbCgpID09PSBcIi0tXCIpO1xuICB9XG4gIGlzRm5EZWNsVHJhbnNmb3JtKHRlcm1fMjY3KSB7XG4gICAgcmV0dXJuIHRlcm1fMjY3ICYmIHRlcm1fMjY3IGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjY3LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IEZ1bmN0aW9uRGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1ZhckRlY2xUcmFuc2Zvcm0odGVybV8yNjgpIHtcbiAgICByZXR1cm4gdGVybV8yNjggJiYgdGVybV8yNjggaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNjgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVmFyaWFibGVEZWNsVHJhbnNmb3JtO1xuICB9XG4gIGlzTGV0RGVjbFRyYW5zZm9ybSh0ZXJtXzI2OSkge1xuICAgIHJldHVybiB0ZXJtXzI2OSAmJiB0ZXJtXzI2OSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI2OS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBMZXREZWNsVHJhbnNmb3JtO1xuICB9XG4gIGlzQ29uc3REZWNsVHJhbnNmb3JtKHRlcm1fMjcwKSB7XG4gICAgcmV0dXJuIHRlcm1fMjcwICYmIHRlcm1fMjcwIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjcwLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IENvbnN0RGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheERlY2xUcmFuc2Zvcm0odGVybV8yNzEpIHtcbiAgICByZXR1cm4gdGVybV8yNzEgJiYgdGVybV8yNzEgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzEucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3ludGF4RGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheHJlY0RlY2xUcmFuc2Zvcm0odGVybV8yNzIpIHtcbiAgICByZXR1cm4gdGVybV8yNzIgJiYgdGVybV8yNzIgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzIucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3ludGF4cmVjRGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheFRlbXBsYXRlKHRlcm1fMjczKSB7XG4gICAgcmV0dXJuIHRlcm1fMjczICYmIHRlcm1fMjczIGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjczLmlzU3ludGF4VGVtcGxhdGUoKTtcbiAgfVxuICBpc1N5bnRheFF1b3RlVHJhbnNmb3JtKHRlcm1fMjc0KSB7XG4gICAgcmV0dXJuIHRlcm1fMjc0ICYmIHRlcm1fMjc0IGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjc0LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IFN5bnRheFF1b3RlVHJhbnNmb3JtO1xuICB9XG4gIGlzUmV0dXJuU3RtdFRyYW5zZm9ybSh0ZXJtXzI3NSkge1xuICAgIHJldHVybiB0ZXJtXzI3NSAmJiB0ZXJtXzI3NSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3NS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBSZXR1cm5TdGF0ZW1lbnRUcmFuc2Zvcm07XG4gIH1cbiAgaXNXaGlsZVRyYW5zZm9ybSh0ZXJtXzI3Nikge1xuICAgIHJldHVybiB0ZXJtXzI3NiAmJiB0ZXJtXzI3NiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3Ni5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBXaGlsZVRyYW5zZm9ybTtcbiAgfVxuICBpc0ZvclRyYW5zZm9ybSh0ZXJtXzI3Nykge1xuICAgIHJldHVybiB0ZXJtXzI3NyAmJiB0ZXJtXzI3NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3Ny5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBGb3JUcmFuc2Zvcm07XG4gIH1cbiAgaXNTd2l0Y2hUcmFuc2Zvcm0odGVybV8yNzgpIHtcbiAgICByZXR1cm4gdGVybV8yNzggJiYgdGVybV8yNzggaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3dpdGNoVHJhbnNmb3JtO1xuICB9XG4gIGlzQnJlYWtUcmFuc2Zvcm0odGVybV8yNzkpIHtcbiAgICByZXR1cm4gdGVybV8yNzkgJiYgdGVybV8yNzkgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzkucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gQnJlYWtUcmFuc2Zvcm07XG4gIH1cbiAgaXNDb250aW51ZVRyYW5zZm9ybSh0ZXJtXzI4MCkge1xuICAgIHJldHVybiB0ZXJtXzI4MCAmJiB0ZXJtXzI4MCBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBDb250aW51ZVRyYW5zZm9ybTtcbiAgfVxuICBpc0RvVHJhbnNmb3JtKHRlcm1fMjgxKSB7XG4gICAgcmV0dXJuIHRlcm1fMjgxICYmIHRlcm1fMjgxIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjgxLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IERvVHJhbnNmb3JtO1xuICB9XG4gIGlzRGVidWdnZXJUcmFuc2Zvcm0odGVybV8yODIpIHtcbiAgICByZXR1cm4gdGVybV8yODIgJiYgdGVybV8yODIgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODIucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gRGVidWdnZXJUcmFuc2Zvcm07XG4gIH1cbiAgaXNXaXRoVHJhbnNmb3JtKHRlcm1fMjgzKSB7XG4gICAgcmV0dXJuIHRlcm1fMjgzICYmIHRlcm1fMjgzIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjgzLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IFdpdGhUcmFuc2Zvcm07XG4gIH1cbiAgaXNUcnlUcmFuc2Zvcm0odGVybV8yODQpIHtcbiAgICByZXR1cm4gdGVybV8yODQgJiYgdGVybV8yODQgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODQucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVHJ5VHJhbnNmb3JtO1xuICB9XG4gIGlzVGhyb3dUcmFuc2Zvcm0odGVybV8yODUpIHtcbiAgICByZXR1cm4gdGVybV8yODUgJiYgdGVybV8yODUgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVGhyb3dUcmFuc2Zvcm07XG4gIH1cbiAgaXNJZlRyYW5zZm9ybSh0ZXJtXzI4Nikge1xuICAgIHJldHVybiB0ZXJtXzI4NiAmJiB0ZXJtXzI4NiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4Ni5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBJZlRyYW5zZm9ybTtcbiAgfVxuICBpc05ld1RyYW5zZm9ybSh0ZXJtXzI4Nykge1xuICAgIHJldHVybiB0ZXJtXzI4NyAmJiB0ZXJtXzI4NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4Ny5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBOZXdUcmFuc2Zvcm07XG4gIH1cbiAgaXNDb21waWxldGltZVRyYW5zZm9ybSh0ZXJtXzI4OCkge1xuICAgIHJldHVybiB0ZXJtXzI4OCAmJiB0ZXJtXzI4OCBpbnN0YW5jZW9mIFN5bnRheCAmJiAodGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIENvbXBpbGV0aW1lVHJhbnNmb3JtIHx8IHRoaXMuY29udGV4dC5zdG9yZS5nZXQodGVybV8yODgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIENvbXBpbGV0aW1lVHJhbnNmb3JtKTtcbiAgfVxuICBpc1ZhckJpbmRpbmdUcmFuc2Zvcm0odGVybV8yODkpIHtcbiAgICByZXR1cm4gdGVybV8yODkgJiYgdGVybV8yODkgaW5zdGFuY2VvZiBTeW50YXggJiYgKHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjg5LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgaW5zdGFuY2VvZiBWYXJCaW5kaW5nVHJhbnNmb3JtIHx8IHRoaXMuY29udGV4dC5zdG9yZS5nZXQodGVybV8yODkucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIFZhckJpbmRpbmdUcmFuc2Zvcm0pO1xuICB9XG4gIGdldEZyb21Db21waWxldGltZUVudmlyb25tZW50KHRlcm1fMjkwKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5lbnYuaGFzKHRlcm1fMjkwLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI5MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN0b3JlLmdldCh0ZXJtXzI5MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpO1xuICB9XG4gIGxpbmVOdW1iZXJFcShhXzI5MSwgYl8yOTIpIHtcbiAgICBpZiAoIShhXzI5MSAmJiBiXzI5MikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFfMjkxLmxpbmVOdW1iZXIoKSA9PT0gYl8yOTIubGluZU51bWJlcigpO1xuICB9XG4gIG1hdGNoSWRlbnRpZmllcih2YWxfMjkzKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yOTQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkXzI5NCkpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWRfMjk0O1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8yOTQsIFwiZXhwZWN0aW5nIGFuIGlkZW50aWZpZXJcIik7XG4gIH1cbiAgbWF0Y2hLZXl3b3JkKHZhbF8yOTUpIHtcbiAgICBsZXQgbG9va2FoZWFkXzI5NiA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMjk2LCB2YWxfMjk1KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTY7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5NiwgXCJleHBlY3RpbmcgXCIgKyB2YWxfMjk1KTtcbiAgfVxuICBtYXRjaExpdGVyYWwoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yOTcgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc051bWVyaWNMaXRlcmFsKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNTdHJpbmdMaXRlcmFsKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNCb29sZWFuTGl0ZXJhbChsb29rYWhlYWRfMjk3KSB8fCB0aGlzLmlzTnVsbExpdGVyYWwobG9va2FoZWFkXzI5NykgfHwgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNSZWd1bGFyRXhwcmVzc2lvbihsb29rYWhlYWRfMjk3KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTc7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5NywgXCJleHBlY3RpbmcgYSBsaXRlcmFsXCIpO1xuICB9XG4gIG1hdGNoU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzI5OCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWRfMjk4KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTg7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5OCwgXCJleHBlY3RpbmcgYSBzdHJpbmcgbGl0ZXJhbFwiKTtcbiAgfVxuICBtYXRjaFRlbXBsYXRlKCkge1xuICAgIGxldCBsb29rYWhlYWRfMjk5ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNUZW1wbGF0ZShsb29rYWhlYWRfMjk5KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5OSwgXCJleHBlY3RpbmcgYSB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICB9XG4gIG1hdGNoUGFyZW5zKCkge1xuICAgIGxldCBsb29rYWhlYWRfMzAwID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNQYXJlbnMobG9va2FoZWFkXzMwMCkpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWRfMzAwLmlubmVyKCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwMCwgXCJleHBlY3RpbmcgcGFyZW5zXCIpO1xuICB9XG4gIG1hdGNoQ3VybGllcygpIHtcbiAgICBsZXQgbG9va2FoZWFkXzMwMSA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF8zMDEpKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkXzMwMS5pbm5lcigpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDEsIFwiZXhwZWN0aW5nIGN1cmx5IGJyYWNlc1wiKTtcbiAgfVxuICBtYXRjaFNxdWFyZXMoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8zMDIgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZF8zMDIpKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkXzMwMi5pbm5lcigpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDIsIFwiZXhwZWN0aW5nIHNxYXVyZSBicmFjZXNcIik7XG4gIH1cbiAgbWF0Y2hVbmFyeU9wZXJhdG9yKCkge1xuICAgIGxldCBsb29rYWhlYWRfMzAzID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKGlzVW5hcnlPcGVyYXRvcihsb29rYWhlYWRfMzAzKSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8zMDM7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwMywgXCJleHBlY3RpbmcgYSB1bmFyeSBvcGVyYXRvclwiKTtcbiAgfVxuICBtYXRjaFB1bmN0dWF0b3IodmFsXzMwNCkge1xuICAgIGxldCBsb29rYWhlYWRfMzA1ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8zMDUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbF8zMDQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZF8zMDUudmFsKCkgPT09IHZhbF8zMDQpIHtcbiAgICAgICAgICByZXR1cm4gbG9va2FoZWFkXzMwNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDUsIFwiZXhwZWN0aW5nIGEgXCIgKyB2YWxfMzA0ICsgXCIgcHVuY3R1YXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxvb2thaGVhZF8zMDU7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwNSwgXCJleHBlY3RpbmcgYSBwdW5jdHVhdG9yXCIpO1xuICB9XG4gIGNyZWF0ZUVycm9yKHN0eF8zMDYsIG1lc3NhZ2VfMzA3KSB7XG4gICAgbGV0IGN0eF8zMDggPSBcIlwiO1xuICAgIGxldCBvZmZlbmRpbmdfMzA5ID0gc3R4XzMwNjtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPiAwKSB7XG4gICAgICBjdHhfMzA4ID0gdGhpcy5yZXN0LnNsaWNlKDAsIDIwKS5tYXAodGVybV8zMTAgPT4ge1xuICAgICAgICBpZiAodGVybV8zMTAuaXNEZWxpbWl0ZXIoKSkge1xuICAgICAgICAgIHJldHVybiB0ZXJtXzMxMC5pbm5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMaXN0Lm9mKHRlcm1fMzEwKTtcbiAgICAgIH0pLmZsYXR0ZW4oKS5tYXAoc18zMTEgPT4ge1xuICAgICAgICBpZiAoc18zMTEgPT09IG9mZmVuZGluZ18zMDkpIHtcbiAgICAgICAgICByZXR1cm4gXCJfX1wiICsgc18zMTEudmFsKCkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNfMzExLnZhbCgpO1xuICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eF8zMDggPSBvZmZlbmRpbmdfMzA5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZV8zMDcgKyBcIlxcblwiICsgY3R4XzMwOCk7XG4gIH1cbn1cbmV4cG9ydCB7RW5mb3Jlc3Rlcl80NCBhcyBFbmZvcmVzdGVyfSJdfQ==

/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	const unaryOperators_519 = { "+": true, "-": true, "!": true, "~": true, "++": true, "--": true, typeof: true, void: true, delete: true };
	const binaryOperatorPrecedence_520 = { "*": 13, "/": 13, "%": 13, "+": 12, "-": 12, ">>": 11, "<<": 11, ">>>": 11, "<": 10, "<=": 10, ">": 10, ">=": 10, in: 10, instanceof: 10, "==": 9, "!=": 9, "===": 9, "!==": 9, "&": 8, "^": 7, "|": 6, "&&": 5, "||": 4 };
	var operatorAssoc_521 = { "*": "left", "/": "left", "%": "left", "+": "left", "-": "left", ">>": "left", "<<": "left", ">>>": "left", "<": "left", "<=": "left", ">": "left", ">=": "left", in: "left", instanceof: "left", "==": "left", "!=": "left", "===": "left", "!==": "left", "&": "left", "^": "left", "|": "left", "&&": "left", "||": "left" };
	function operatorLt_522(left_527, right_528, assoc_529) {
	  if (assoc_529 === "left") {
	    return left_527 < right_528;
	  } else {
	    return left_527 <= right_528;
	  }
	}
	function getOperatorPrec_523(op_530) {
	  return binaryOperatorPrecedence_520[op_530];
	}
	function getOperatorAssoc_524(op_531) {
	  return operatorAssoc_521[op_531];
	}
	function isUnaryOperator_525(op_532) {
	  return (op_532.match("punctuator") || op_532.match("identifier") || op_532.match("keyword")) && unaryOperators_519.hasOwnProperty(op_532.val());
	}
	function isOperator_526(op_533) {
	  if (op_533.match("punctuator") || op_533.match("identifier") || op_533.match("keyword")) {
	    return binaryOperatorPrecedence_520.hasOwnProperty(op_533) || unaryOperators_519.hasOwnProperty(op_533.val());
	  }
	  return false;
	}
	exports.operatorLt = operatorLt_522;
	exports.getOperatorPrec = getOperatorPrec_523;
	exports.getOperatorAssoc = getOperatorAssoc_524;
	exports.isUnaryOperator = isUnaryOperator_525;
	exports.isOperator = isOperator_526;
	//# sourceMappingURL=data:application/json;base64,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QixjO1FBQ3VCLGUsR0FBdkIsbUI7UUFDd0IsZ0IsR0FBeEIsb0I7UUFDdUIsZSxHQUF2QixtQjtRQUNrQixVLEdBQWxCLGMiLCJmaWxlIjoib3BlcmF0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdW5hcnlPcGVyYXRvcnNfNTE5ID0ge1wiK1wiOiB0cnVlLCBcIi1cIjogdHJ1ZSwgXCIhXCI6IHRydWUsIFwiflwiOiB0cnVlLCBcIisrXCI6IHRydWUsIFwiLS1cIjogdHJ1ZSwgdHlwZW9mOiB0cnVlLCB2b2lkOiB0cnVlLCBkZWxldGU6IHRydWV9O1xuY29uc3QgYmluYXJ5T3BlcmF0b3JQcmVjZWRlbmNlXzUyMCA9IHtcIipcIjogMTMsIFwiL1wiOiAxMywgXCIlXCI6IDEzLCBcIitcIjogMTIsIFwiLVwiOiAxMiwgXCI+PlwiOiAxMSwgXCI8PFwiOiAxMSwgXCI+Pj5cIjogMTEsIFwiPFwiOiAxMCwgXCI8PVwiOiAxMCwgXCI+XCI6IDEwLCBcIj49XCI6IDEwLCBpbjogMTAsIGluc3RhbmNlb2Y6IDEwLCBcIj09XCI6IDksIFwiIT1cIjogOSwgXCI9PT1cIjogOSwgXCIhPT1cIjogOSwgXCImXCI6IDgsIFwiXlwiOiA3LCBcInxcIjogNiwgXCImJlwiOiA1LCBcInx8XCI6IDR9O1xudmFyIG9wZXJhdG9yQXNzb2NfNTIxID0ge1wiKlwiOiBcImxlZnRcIiwgXCIvXCI6IFwibGVmdFwiLCBcIiVcIjogXCJsZWZ0XCIsIFwiK1wiOiBcImxlZnRcIiwgXCItXCI6IFwibGVmdFwiLCBcIj4+XCI6IFwibGVmdFwiLCBcIjw8XCI6IFwibGVmdFwiLCBcIj4+PlwiOiBcImxlZnRcIiwgXCI8XCI6IFwibGVmdFwiLCBcIjw9XCI6IFwibGVmdFwiLCBcIj5cIjogXCJsZWZ0XCIsIFwiPj1cIjogXCJsZWZ0XCIsIGluOiBcImxlZnRcIiwgaW5zdGFuY2VvZjogXCJsZWZ0XCIsIFwiPT1cIjogXCJsZWZ0XCIsIFwiIT1cIjogXCJsZWZ0XCIsIFwiPT09XCI6IFwibGVmdFwiLCBcIiE9PVwiOiBcImxlZnRcIiwgXCImXCI6IFwibGVmdFwiLCBcIl5cIjogXCJsZWZ0XCIsIFwifFwiOiBcImxlZnRcIiwgXCImJlwiOiBcImxlZnRcIiwgXCJ8fFwiOiBcImxlZnRcIn07XG5mdW5jdGlvbiBvcGVyYXRvckx0XzUyMihsZWZ0XzUyNywgcmlnaHRfNTI4LCBhc3NvY181MjkpIHtcbiAgaWYgKGFzc29jXzUyOSA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gbGVmdF81MjcgPCByaWdodF81Mjg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlZnRfNTI3IDw9IHJpZ2h0XzUyODtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3BlcmF0b3JQcmVjXzUyMyhvcF81MzApIHtcbiAgcmV0dXJuIGJpbmFyeU9wZXJhdG9yUHJlY2VkZW5jZV81MjBbb3BfNTMwXTtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdG9yQXNzb2NfNTI0KG9wXzUzMSkge1xuICByZXR1cm4gb3BlcmF0b3JBc3NvY181MjFbb3BfNTMxXTtcbn1cbmZ1bmN0aW9uIGlzVW5hcnlPcGVyYXRvcl81MjUob3BfNTMyKSB7XG4gIHJldHVybiAob3BfNTMyLm1hdGNoKFwicHVuY3R1YXRvclwiKSB8fCBvcF81MzIubWF0Y2goXCJpZGVudGlmaWVyXCIpIHx8IG9wXzUzMi5tYXRjaChcImtleXdvcmRcIikpICYmIHVuYXJ5T3BlcmF0b3JzXzUxOS5oYXNPd25Qcm9wZXJ0eShvcF81MzIudmFsKCkpO1xufVxuZnVuY3Rpb24gaXNPcGVyYXRvcl81MjYob3BfNTMzKSB7XG4gIGlmIChvcF81MzMubWF0Y2goXCJwdW5jdHVhdG9yXCIpIHx8IG9wXzUzMy5tYXRjaChcImlkZW50aWZpZXJcIikgfHwgb3BfNTMzLm1hdGNoKFwia2V5d29yZFwiKSkge1xuICAgIHJldHVybiBiaW5hcnlPcGVyYXRvclByZWNlZGVuY2VfNTIwLmhhc093blByb3BlcnR5KG9wXzUzMykgfHwgdW5hcnlPcGVyYXRvcnNfNTE5Lmhhc093blByb3BlcnR5KG9wXzUzMy52YWwoKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IHtvcGVyYXRvckx0XzUyMiBhcyBvcGVyYXRvckx0fTtcbmV4cG9ydCB7Z2V0T3BlcmF0b3JQcmVjXzUyMyBhcyBnZXRPcGVyYXRvclByZWN9O1xuZXhwb3J0IHtnZXRPcGVyYXRvckFzc29jXzUyNCBhcyBnZXRPcGVyYXRvckFzc29jfTtcbmV4cG9ydCB7aXNVbmFyeU9wZXJhdG9yXzUyNSBhcyBpc1VuYXJ5T3BlcmF0b3J9O1xuZXhwb3J0IHtpc09wZXJhdG9yXzUyNiBhcyBpc09wZXJhdG9yfSJdfQ==

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.evalCompiletimeValue = exports.evalRuntimeValues = exports.sanitizeReplacementValues = undefined;

	var _termExpander = __webpack_require__(53);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _immutable = __webpack_require__(11);

	var _parseReducer = __webpack_require__(36);

	var _parseReducer2 = _interopRequireDefault(_parseReducer);

	var _shiftReducer = __webpack_require__(32);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _serializer = __webpack_require__(56);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _shiftCodegen = __webpack_require__(37);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	var _transforms = __webpack_require__(31);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReader = __webpack_require__(3);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _macroContext = __webpack_require__(64);

	var _templateProcessor = __webpack_require__(62);

	var _vm = __webpack_require__(47);

	var _vm2 = _interopRequireDefault(_vm);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	let geval_341 = eval;
	function sanitizeReplacementValues_342(values_345) {
	  if (Array.isArray(values_345)) {
	    return sanitizeReplacementValues_342((0, _immutable.List)(values_345));
	  } else if (_immutable.List.isList(values_345)) {
	    return values_345.map(sanitizeReplacementValues_342);
	  } else if (values_345 == null) {
	    throw new Error("replacement values for syntax template must not be null or undefined");
	  } else if (typeof values_345.next === "function") {
	    return sanitizeReplacementValues_342((0, _immutable.List)(values_345));
	  }
	  return (0, _macroContext.unwrap)(values_345);
	}
	function evalRuntimeValues_343(terms_346, context_347) {
	  let prepped_348 = terms_346.reduce((acc_354, term_355) => {
	    let result_356 = (0, _immutable.List)();
	    if ((0, _terms.isExport)(term_355)) {
	      if ((0, _terms.isVariableDeclaration)(term_355.declaration)) {
	        return acc_354.concat(new _terms2.default("VariableDeclarationStatement", { declaration: term_355.declaration })).concat(term_355.declaration.declarators.map(decl_357 => {
	          return new _terms2.default("ExpressionStatement", { expression: new _terms2.default("AssignmentExpression", { binding: new _terms2.default("StaticMemberExpression", { object: new _terms2.default("IdentifierExpression", { name: _syntax2.default.fromIdentifier("exports") }), property: decl_357.binding.name }), expression: new _terms2.default("IdentifierExpression", { name: decl_357.binding.name }) }) });
	        }));
	      }
	    } else if ((0, _terms.isImport)(term_355)) {
	      return acc_354;
	    }
	    return acc_354.concat(term_355);
	  }, (0, _immutable.List)());
	  let parsed_349 = (0, _shiftReducer2.default)(new _parseReducer2.default(context_347, false), new _terms2.default("Module", { directives: (0, _immutable.List)(), items: prepped_348 }).gen({ includeImports: false }));
	  let gen_350 = (0, _shiftCodegen2.default)(parsed_349, new _shiftCodegen.FormattedCodeGen());
	  let result_351 = context_347.transform(gen_350, { babelrc: true, filename: context_347.filename });
	  let exportsObj_352 = {};
	  context_347.store.set("exports", exportsObj_352);
	  let val_353 = _vm2.default.runInContext(result_351.code, context_347.store.getNodeContext());
	  return exportsObj_352;
	}
	function evalCompiletimeValue_344(expr_358, context_359) {
	  let deserializer_360 = (0, _serializer.makeDeserializer)(context_359.bindings);
	  let sandbox_361 = { syntaxQuote: function syntaxQuote(strings_369) {
	      for (var _len = arguments.length, values_368 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        values_368[_key - 1] = arguments[_key];
	      }

	      let ctx_370 = deserializer_360.read(_.last(values_368));
	      let reader_371 = new _shiftReader2.default(strings_369, ctx_370, _.take(values_368.length - 1, values_368));
	      return reader_371.read();
	    }, syntaxTemplate: function syntaxTemplate(str_373) {
	      for (var _len2 = arguments.length, values_372 = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        values_372[_key2 - 1] = arguments[_key2];
	      }

	      return (0, _templateProcessor.replaceTemplate)(deserializer_360.read(str_373), sanitizeReplacementValues_342(values_372));
	    } };
	  let sandboxKeys_362 = (0, _immutable.List)(Object.keys(sandbox_361));
	  let sandboxVals_363 = sandboxKeys_362.map(k_374 => sandbox_361[k_374]).toArray();
	  let parsed_364 = (0, _shiftReducer2.default)(new _parseReducer2.default(context_359), new _terms2.default("Module", { directives: (0, _immutable.List)(), items: _immutable.List.of(new _terms2.default("ExpressionStatement", { expression: new _terms2.default("FunctionExpression", { isGenerator: false, name: null, params: new _terms2.default("FormalParameters", { items: sandboxKeys_362.map(param_375 => {
	            return new _terms2.default("BindingIdentifier", { name: _syntax2.default.from("identifier", param_375) });
	          }), rest: null }), body: new _terms2.default("FunctionBody", { directives: _immutable.List.of(new _terms2.default("Directive", { rawValue: "use strict" })), statements: _immutable.List.of(new _terms2.default("ReturnStatement", { expression: expr_358 })) }) }) })) }));
	  let gen_365 = (0, _shiftCodegen2.default)(parsed_364, new _shiftCodegen.FormattedCodeGen());
	  let result_366 = context_359.transform(gen_365, { babelrc: true, filename: context_359.filename });
	  let val_367 = _vm2.default.runInContext(result_366.code, context_359.store.getNodeContext());
	  return val_367.apply(undefined, sandboxVals_363);
	}
	exports.sanitizeReplacementValues = sanitizeReplacementValues_342;
	exports.evalRuntimeValues = evalRuntimeValues_343;
	exports.evalCompiletimeValue = evalCompiletimeValue_344;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2xvYWQtc3ludGF4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7O0lBQWEsQzs7Ozs7O0FBQ2IsSUFBSSxZQUFZLElBQWhCO0FBQ0EsU0FBUyw2QkFBVCxDQUF1QyxVQUF2QyxFQUFtRDtBQUNqRCxNQUFJLE1BQU0sT0FBTixDQUFjLFVBQWQsQ0FBSixFQUErQjtBQUM3QixXQUFPLDhCQUE4QixxQkFBSyxVQUFMLENBQTlCLENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSSxnQkFBSyxNQUFMLENBQVksVUFBWixDQUFKLEVBQTZCO0FBQ2xDLFdBQU8sV0FBVyxHQUFYLENBQWUsNkJBQWYsQ0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJLGNBQWMsSUFBbEIsRUFBd0I7QUFDN0IsVUFBTSxJQUFJLEtBQUosQ0FBVSxzRUFBVixDQUFOO0FBQ0QsR0FGTSxNQUVBLElBQUksT0FBTyxXQUFXLElBQWxCLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ2hELFdBQU8sOEJBQThCLHFCQUFLLFVBQUwsQ0FBOUIsQ0FBUDtBQUNEO0FBQ0QsU0FBTywwQkFBTyxVQUFQLENBQVA7QUFDRDtBQUNELFNBQVMscUJBQVQsQ0FBK0IsU0FBL0IsRUFBMEMsV0FBMUMsRUFBdUQ7QUFDckQsTUFBSSxjQUFjLFVBQVUsTUFBVixDQUFpQixDQUFDLE9BQUQsRUFBVSxRQUFWLEtBQXVCO0FBQ3hELFFBQUksYUFBYSxzQkFBakI7QUFDQSxRQUFJLHFCQUFTLFFBQVQsQ0FBSixFQUF3QjtBQUN0QixVQUFJLGtDQUFzQixTQUFTLFdBQS9CLENBQUosRUFBaUQ7QUFDL0MsZUFBTyxRQUFRLE1BQVIsQ0FBZSxvQkFBUyw4QkFBVCxFQUF5QyxFQUFDLGFBQWEsU0FBUyxXQUF2QixFQUF6QyxDQUFmLEVB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QixFQUFDLGFBQWEsS0FBZCxFQUFxQixNQUFNLElBQTNCLEVBQWlDLFFBQVEsb0JBQVMsa0JBQVQsRUFBNkIsRUFBQyxPQUFPLGdCQUFnQixHQUFoQixDQUFvQixhQUFhO0FBQ3hTLG1CQUFPLG9CQUFTLG1CQUFULEVBQThCLEVBQUMsTUFBTSxpQkFBTyxJQUFQLENBQVksWUFBWixFQUEwQixTQUExQixDQUFQLEVBQTlCLENBQVA7QUFDRCxXQUZ3USxDQUFSLEVBRTdQLE1BQU0sSUFGdVAsRUFBN0IsQ0FBekMsRUFFekssTUFBTSxvQkFBUyxjQUFULEVBQXlCLEVBQUMsWUFBWSxnQkFBSyxFQUFMLENBQVEsb0JBQVMsV0FBVCxFQUFzQixFQUFDLFVBQVUsWUFBWCxFQUF0QixDQUFSLENBQWIsRUFBdUUsWUFBWSxnQkFBSyxFQUFMLENBQVEsb0JBQVMsaUJBQVQsRUFBNEIsRUFBQyxZQUFZLFFBQWIsRUFBNUIsQ0FBUixDQUFuRixFQUF6QixDQUZtSyxFQUEvQixDQUFiLEVBQWhDLENBQVIsQ0FBNUIsRUFBbkIsQ0FBdkMsQ0FBakI7QUFHQSxNQUFJLFVBQVUsNEJBQVEsVUFBUixFQUFvQixvQ0FBcEIsQ0FBZDtBQUNBLE1BQUksYUFBYSxZQUFZLFNBQVosQ0FBc0IsT0FBdEIsRUFBK0IsRUFBQyxTQUFTLElBQVYsRUFBZ0IsVUFBVSxZQUFZLFFBQXRDLEVBQS9CLENBQWpCO0FBQ0EsTUFBSSxVQUFVLGFBQUcsWUFBSCxDQUFnQixXQUFXLElBQTNCLEVBQWlDLFlBQVksS0FBWixDQUFrQixjQUFsQixFQUFqQyxDQUFkO0FBQ0EsU0FBTyxRQUFRLEtBQVIsQ0FBYyxTQUFkLEVBQXlCLGVBQXpCLENBQVA7QUFDRDtRQUN3Qyx5QixHQUFqQyw2QjtRQUN5QixpQixHQUF6QixxQjtRQUM0QixvQixHQUE1Qix3QiIsImZpbGUiOiJsb2FkLXN5bnRheC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlclwiO1xuaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQgUGFyc2VSZWR1Y2VyIGZyb20gXCIuL3BhcnNlLXJlZHVjZXIuanNcIjtcbmltcG9ydCByZWR1Y2VyLCB7TW9ub2lkYWxSZWR1Y2VyfSBmcm9tIFwic2hpZnQtcmVkdWNlclwiO1xuaW1wb3J0IHttYWtlRGVzZXJpYWxpemVyfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG5pbXBvcnQgU3ludGF4IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0IGNvZGVnZW4sIHtGb3JtYXR0ZWRDb2RlR2VufSBmcm9tIFwic2hpZnQtY29kZWdlblwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNGdW5jdGlvbkRlY2xhcmF0aW9uLCBpc0Z1bmN0aW9uRXhwcmVzc2lvbiwgaXNGdW5jdGlvblRlcm0sIGlzRnVuY3Rpb25XaXRoTmFtZSwgaXNTeW50YXhEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQsIGlzSW1wb3J0LCBpc0V4cG9ydH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCBSZWFkZXIgZnJvbSBcIi4vc2hpZnQtcmVhZGVyXCI7XG5pbXBvcnQge3Vud3JhcH0gZnJvbSBcIi4vbWFjcm8tY29udGV4dFwiO1xuaW1wb3J0IHtyZXBsYWNlVGVtcGxhdGV9IGZyb20gXCIuL3RlbXBsYXRlLXByb2Nlc3NvclwiO1xuaW1wb3J0IHZtIGZyb20gXCJ2bVwiO1xuaW1wb3J0ICAqIGFzIF8gZnJvbSBcInJhbWRhXCI7XG5sZXQgZ2V2YWxfMzQxID0gZXZhbDtcbmZ1bmN0aW9uIHNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXNfMzQyKHZhbHVlc18zNDUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzXzM0NSkpIHtcbiAgICByZXR1cm4gc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDIoTGlzdCh2YWx1ZXNfMzQ1KSk7XG4gIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodmFsdWVzXzM0NSkpIHtcbiAgICByZXR1cm4gdmFsdWVzXzM0NS5tYXAoc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDIpO1xuICB9IGVsc2UgaWYgKHZhbHVlc18zNDUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlcGxhY2VtZW50IHZhbHVlcyBmb3Igc3ludGF4IHRlbXBsYXRlIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXNfMzQ1Lm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzXzM0MihMaXN0KHZhbHVlc18zNDUpKTtcbiAgfVxuICByZXR1cm4gdW53cmFwKHZhbHVlc18zNDUpO1xufVxuZnVuY3Rpb24gZXZhbFJ1bnRpbWVWYWx1ZXNfMzQzKHRlcm1zXzM0NiwgY29udGV4dF8zNDcpIHtcbiAgbGV0IHByZXBwZWRfMzQ4ID0gdGVybXNfMzQ2LnJlZHVjZSgoYWNjXzM1NCwgdGVybV8zNTUpID0+IHtcbiAgICBsZXQgcmVzdWx0XzM1NiA9IExpc3QoKTtcbiAgICBpZiAoaXNFeHBvcnQodGVybV8zNTUpKSB7XG4gICAgICBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMzU1LmRlY2xhcmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gYWNjXzM1NC5jb25jYXQobmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGVybV8zNTUuZGVjbGFyYXRpb259KSkuY29uY2F0KHRlcm1fMzU1LmRlY2xhcmF0aW9uLmRlY2xhcmF0b3JzLm1hcChkZWNsXzM1NyA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogbmV3IFRlcm0oXCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uXCIsIHtvYmplY3Q6IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IFN5bnRheC5mcm9tSWRlbnRpZmllcihcImV4cG9ydHNcIil9KSwgcHJvcGVydHk6IGRlY2xfMzU3LmJpbmRpbmcubmFtZX0pLCBleHByZXNzaW9uOiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiBkZWNsXzM1Ny5iaW5kaW5nLm5hbWV9KX0pfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSW1wb3J0KHRlcm1fMzU1KSkge1xuICAgICAgcmV0dXJuIGFjY18zNTQ7XG4gICAgfVxuICAgIHJldHVybiBhY2NfMzU0LmNvbmNhdCh0ZXJtXzM1NSk7XG4gIH0sIExpc3QoKSk7XG4gIGxldCBwYXJzZWRfMzQ5ID0gcmVkdWNlcihuZXcgUGFyc2VSZWR1Y2VyKGNvbnRleHRfMzQ3LCBmYWxzZSksIG5ldyBUZXJtKFwiTW9kdWxlXCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIGl0ZW1zOiBwcmVwcGVkXzM0OH0pLmdlbih7aW5jbHVkZUltcG9ydHM6IGZhbHNlfSkpO1xuICBsZXQgZ2VuXzM1MCA9IGNvZGVnZW4ocGFyc2VkXzM0OSwgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICBsZXQgcmVzdWx0XzM1MSA9IGNvbnRleHRfMzQ3LnRyYW5zZm9ybShnZW5fMzUwLCB7YmFiZWxyYzogdHJ1ZSwgZmlsZW5hbWU6IGNvbnRleHRfMzQ3LmZpbGVuYW1lfSk7XG4gIGxldCBleHBvcnRzT2JqXzM1MiA9IHt9O1xuICBjb250ZXh0XzM0Ny5zdG9yZS5zZXQoXCJleHBvcnRzXCIsIGV4cG9ydHNPYmpfMzUyKTtcbiAgbGV0IHZhbF8zNTMgPSB2bS5ydW5JbkNvbnRleHQocmVzdWx0XzM1MS5jb2RlLCBjb250ZXh0XzM0Ny5zdG9yZS5nZXROb2RlQ29udGV4dCgpKTtcbiAgcmV0dXJuIGV4cG9ydHNPYmpfMzUyO1xufVxuZnVuY3Rpb24gZXZhbENvbXBpbGV0aW1lVmFsdWVfMzQ0KGV4cHJfMzU4LCBjb250ZXh0XzM1OSkge1xuICBsZXQgZGVzZXJpYWxpemVyXzM2MCA9IG1ha2VEZXNlcmlhbGl6ZXIoY29udGV4dF8zNTkuYmluZGluZ3MpO1xuICBsZXQgc2FuZGJveF8zNjEgPSB7c3ludGF4UXVvdGU6IGZ1bmN0aW9uIChzdHJpbmdzXzM2OSwgLi4udmFsdWVzXzM2OCkge1xuICAgIGxldCBjdHhfMzcwID0gZGVzZXJpYWxpemVyXzM2MC5yZWFkKF8ubGFzdCh2YWx1ZXNfMzY4KSk7XG4gICAgbGV0IHJlYWRlcl8zNzEgPSBuZXcgUmVhZGVyKHN0cmluZ3NfMzY5LCBjdHhfMzcwLCBfLnRha2UodmFsdWVzXzM2OC5sZW5ndGggLSAxLCB2YWx1ZXNfMzY4KSk7XG4gICAgcmV0dXJuIHJlYWRlcl8zNzEucmVhZCgpO1xuICB9LCBzeW50YXhUZW1wbGF0ZTogZnVuY3Rpb24gKHN0cl8zNzMsIC4uLnZhbHVlc18zNzIpIHtcbiAgICByZXR1cm4gcmVwbGFjZVRlbXBsYXRlKGRlc2VyaWFsaXplcl8zNjAucmVhZChzdHJfMzczKSwgc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDIodmFsdWVzXzM3MikpO1xuICB9fTtcbiAgbGV0IHNhbmRib3hLZXlzXzM2MiA9IExpc3QoT2JqZWN0LmtleXMoc2FuZGJveF8zNjEpKTtcbiAgbGV0IHNhbmRib3hWYWxzXzM2MyA9IHNhbmRib3hLZXlzXzM2Mi5tYXAoa18zNzQgPT4gc2FuZGJveF8zNjFba18zNzRdKS50b0FycmF5KCk7XG4gIGxldCBwYXJzZWRfMzY0ID0gcmVkdWNlcihuZXcgUGFyc2VSZWR1Y2VyKGNvbnRleHRfMzU5KSwgbmV3IFRlcm0oXCJNb2R1bGVcIiwge2RpcmVjdGl2ZXM6IExpc3QoKSwgaXRlbXM6IExpc3Qub2YobmV3IFRlcm0oXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiBuZXcgVGVybShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7aXNHZW5lcmF0b3I6IGZhbHNlLCBuYW1lOiBudWxsLCBwYXJhbXM6IG5ldyBUZXJtKFwiRm9ybWFsUGFyYW1ldGVyc1wiLCB7aXRlbXM6IHNhbmRib3hLZXlzXzM2Mi5tYXAocGFyYW1fMzc1ID0+IHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogU3ludGF4LmZyb20oXCJpZGVudGlmaWVyXCIsIHBhcmFtXzM3NSl9KTtcbiAgfSksIHJlc3Q6IG51bGx9KSwgYm9keTogbmV3IFRlcm0oXCJGdW5jdGlvbkJvZHlcIiwge2RpcmVjdGl2ZXM6IExpc3Qub2YobmV3IFRlcm0oXCJEaXJlY3RpdmVcIiwge3Jhd1ZhbHVlOiBcInVzZSBzdHJpY3RcIn0pKSwgc3RhdGVtZW50czogTGlzdC5vZihuZXcgVGVybShcIlJldHVyblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogZXhwcl8zNTh9KSl9KX0pfSkpfSkpO1xuICBsZXQgZ2VuXzM2NSA9IGNvZGVnZW4ocGFyc2VkXzM2NCwgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICBsZXQgcmVzdWx0XzM2NiA9IGNvbnRleHRfMzU5LnRyYW5zZm9ybShnZW5fMzY1LCB7YmFiZWxyYzogdHJ1ZSwgZmlsZW5hbWU6IGNvbnRleHRfMzU5LmZpbGVuYW1lfSk7XG4gIGxldCB2YWxfMzY3ID0gdm0ucnVuSW5Db250ZXh0KHJlc3VsdF8zNjYuY29kZSwgY29udGV4dF8zNTkuc3RvcmUuZ2V0Tm9kZUNvbnRleHQoKSk7XG4gIHJldHVybiB2YWxfMzY3LmFwcGx5KHVuZGVmaW5lZCwgc2FuZGJveFZhbHNfMzYzKTtcbn1cbmV4cG9ydCB7c2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDIgYXMgc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc307XG5leHBvcnQge2V2YWxSdW50aW1lVmFsdWVzXzM0MyBhcyBldmFsUnVudGltZVZhbHVlc307XG5leHBvcnQge2V2YWxDb21waWxldGltZVZhbHVlXzM0NCBhcyBldmFsQ29tcGlsZXRpbWVWYWx1ZX0iXX0=

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(11);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _scope = __webpack_require__(43);

	var _applyScopeInParamsReducer = __webpack_require__(54);

	var _applyScopeInParamsReducer2 = _interopRequireDefault(_applyScopeInParamsReducer);

	var _shiftReducer = __webpack_require__(32);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _compiler = __webpack_require__(55);

	var _compiler2 = _interopRequireDefault(_compiler);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _serializer = __webpack_require__(56);

	var _enforester = __webpack_require__(50);

	var _errors = __webpack_require__(13);

	var _templateProcessor = __webpack_require__(62);

	var _astDispatcher = __webpack_require__(63);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class TermExpander extends _astDispatcher2.default {
	  constructor(context_944) {
	    super("expand", true);
	    this.context = context_944;
	  }
	  expand(term_945) {
	    return this.dispatch(term_945);
	  }
	  expandPragma(term_946) {
	    return term_946;
	  }
	  expandTemplateExpression(term_947) {
	    return new _terms2.default("TemplateExpression", { tag: term_947.tag == null ? null : this.expand(term_947.tag), elements: term_947.elements.toArray() });
	  }
	  expandBreakStatement(term_948) {
	    return new _terms2.default("BreakStatement", { label: term_948.label ? term_948.label.val() : null });
	  }
	  expandDoWhileStatement(term_949) {
	    return new _terms2.default("DoWhileStatement", { body: this.expand(term_949.body), test: this.expand(term_949.test) });
	  }
	  expandWithStatement(term_950) {
	    return new _terms2.default("WithStatement", { body: this.expand(term_950.body), object: this.expand(term_950.object) });
	  }
	  expandDebuggerStatement(term_951) {
	    return term_951;
	  }
	  expandContinueStatement(term_952) {
	    return new _terms2.default("ContinueStatement", { label: term_952.label ? term_952.label.val() : null });
	  }
	  expandSwitchStatementWithDefault(term_953) {
	    return new _terms2.default("SwitchStatementWithDefault", { discriminant: this.expand(term_953.discriminant), preDefaultCases: term_953.preDefaultCases.map(c_954 => this.expand(c_954)).toArray(), defaultCase: this.expand(term_953.defaultCase), postDefaultCases: term_953.postDefaultCases.map(c_955 => this.expand(c_955)).toArray() });
	  }
	  expandComputedMemberExpression(term_956) {
	    return new _terms2.default("ComputedMemberExpression", { object: this.expand(term_956.object), expression: this.expand(term_956.expression) });
	  }
	  expandSwitchStatement(term_957) {
	    return new _terms2.default("SwitchStatement", { discriminant: this.expand(term_957.discriminant), cases: term_957.cases.map(c_958 => this.expand(c_958)).toArray() });
	  }
	  expandFormalParameters(term_959) {
	    let rest_960 = term_959.rest == null ? null : this.expand(term_959.rest);
	    return new _terms2.default("FormalParameters", { items: term_959.items.map(i_961 => this.expand(i_961)), rest: rest_960 });
	  }
	  expandArrowExpression(term_962) {
	    return this.doFunctionExpansion(term_962, "ArrowExpression");
	  }
	  expandSwitchDefault(term_963) {
	    return new _terms2.default("SwitchDefault", { consequent: term_963.consequent.map(c_964 => this.expand(c_964)).toArray() });
	  }
	  expandSwitchCase(term_965) {
	    return new _terms2.default("SwitchCase", { test: this.expand(term_965.test), consequent: term_965.consequent.map(c_966 => this.expand(c_966)).toArray() });
	  }
	  expandForInStatement(term_967) {
	    return new _terms2.default("ForInStatement", { left: this.expand(term_967.left), right: this.expand(term_967.right), body: this.expand(term_967.body) });
	  }
	  expandTryCatchStatement(term_968) {
	    return new _terms2.default("TryCatchStatement", { body: this.expand(term_968.body), catchClause: this.expand(term_968.catchClause) });
	  }
	  expandTryFinallyStatement(term_969) {
	    let catchClause_970 = term_969.catchClause == null ? null : this.expand(term_969.catchClause);
	    return new _terms2.default("TryFinallyStatement", { body: this.expand(term_969.body), catchClause: catchClause_970, finalizer: this.expand(term_969.finalizer) });
	  }
	  expandCatchClause(term_971) {
	    return new _terms2.default("CatchClause", { binding: this.expand(term_971.binding), body: this.expand(term_971.body) });
	  }
	  expandThrowStatement(term_972) {
	    return new _terms2.default("ThrowStatement", { expression: this.expand(term_972.expression) });
	  }
	  expandForOfStatement(term_973) {
	    return new _terms2.default("ForOfStatement", { left: this.expand(term_973.left), right: this.expand(term_973.right), body: this.expand(term_973.body) });
	  }
	  expandBindingIdentifier(term_974) {
	    return term_974;
	  }
	  expandBindingPropertyIdentifier(term_975) {
	    return term_975;
	  }
	  expandBindingPropertyProperty(term_976) {
	    return new _terms2.default("BindingPropertyProperty", { name: this.expand(term_976.name), binding: this.expand(term_976.binding) });
	  }
	  expandComputedPropertyName(term_977) {
	    return new _terms2.default("ComputedPropertyName", { expression: this.expand(term_977.expression) });
	  }
	  expandObjectBinding(term_978) {
	    return new _terms2.default("ObjectBinding", { properties: term_978.properties.map(t_979 => this.expand(t_979)).toArray() });
	  }
	  expandArrayBinding(term_980) {
	    let restElement_981 = term_980.restElement == null ? null : this.expand(term_980.restElement);
	    return new _terms2.default("ArrayBinding", { elements: term_980.elements.map(t_982 => t_982 == null ? null : this.expand(t_982)).toArray(), restElement: restElement_981 });
	  }
	  expandBindingWithDefault(term_983) {
	    return new _terms2.default("BindingWithDefault", { binding: this.expand(term_983.binding), init: this.expand(term_983.init) });
	  }
	  expandShorthandProperty(term_984) {
	    return new _terms2.default("DataProperty", { name: new _terms2.default("StaticPropertyName", { value: term_984.name }), expression: new _terms2.default("IdentifierExpression", { name: term_984.name }) });
	  }
	  expandForStatement(term_985) {
	    let init_986 = term_985.init == null ? null : this.expand(term_985.init);
	    let test_987 = term_985.test == null ? null : this.expand(term_985.test);
	    let update_988 = term_985.update == null ? null : this.expand(term_985.update);
	    let body_989 = this.expand(term_985.body);
	    return new _terms2.default("ForStatement", { init: init_986, test: test_987, update: update_988, body: body_989 });
	  }
	  expandYieldExpression(term_990) {
	    let expr_991 = term_990.expression == null ? null : this.expand(term_990.expression);
	    return new _terms2.default("YieldExpression", { expression: expr_991 });
	  }
	  expandYieldGeneratorExpression(term_992) {
	    let expr_993 = term_992.expression == null ? null : this.expand(term_992.expression);
	    return new _terms2.default("YieldGeneratorExpression", { expression: expr_993 });
	  }
	  expandWhileStatement(term_994) {
	    return new _terms2.default("WhileStatement", { test: this.expand(term_994.test), body: this.expand(term_994.body) });
	  }
	  expandIfStatement(term_995) {
	    let consequent_996 = term_995.consequent == null ? null : this.expand(term_995.consequent);
	    let alternate_997 = term_995.alternate == null ? null : this.expand(term_995.alternate);
	    return new _terms2.default("IfStatement", { test: this.expand(term_995.test), consequent: consequent_996, alternate: alternate_997 });
	  }
	  expandBlockStatement(term_998) {
	    return new _terms2.default("BlockStatement", { block: this.expand(term_998.block) });
	  }
	  expandBlock(term_999) {
	    return new _terms2.default("Block", { statements: term_999.statements.map(s_1000 => this.expand(s_1000)).toArray() });
	  }
	  expandVariableDeclarationStatement(term_1001) {
	    return new _terms2.default("VariableDeclarationStatement", { declaration: this.expand(term_1001.declaration) });
	  }
	  expandReturnStatement(term_1002) {
	    if (term_1002.expression == null) {
	      return term_1002;
	    }
	    return new _terms2.default("ReturnStatement", { expression: this.expand(term_1002.expression) });
	  }
	  expandClassDeclaration(term_1003) {
	    return new _terms2.default("ClassDeclaration", { name: term_1003.name == null ? null : this.expand(term_1003.name), super: term_1003.super == null ? null : this.expand(term_1003.super), elements: term_1003.elements.map(el_1004 => this.expand(el_1004)).toArray() });
	  }
	  expandClassExpression(term_1005) {
	    return new _terms2.default("ClassExpression", { name: term_1005.name == null ? null : this.expand(term_1005.name), super: term_1005.super == null ? null : this.expand(term_1005.super), elements: term_1005.elements.map(el_1006 => this.expand(el_1006)).toArray() });
	  }
	  expandClassElement(term_1007) {
	    return new _terms2.default("ClassElement", { isStatic: term_1007.isStatic, method: this.expand(term_1007.method) });
	  }
	  expandThisExpression(term_1008) {
	    return term_1008;
	  }
	  expandSyntaxTemplate(term_1009) {
	    let r_1010 = (0, _templateProcessor.processTemplate)(term_1009.template.inner());
	    let str_1011 = _syntax2.default.from("string", _serializer.serializer.write(r_1010.template));
	    let callee_1012 = new _terms2.default("IdentifierExpression", { name: _syntax2.default.from("identifier", "syntaxTemplate") });
	    let expandedInterps_1013 = r_1010.interp.map(i_1015 => {
	      let enf_1016 = new _enforester.Enforester(i_1015, (0, _immutable.List)(), this.context);
	      return this.expand(enf_1016.enforest("expression"));
	    });
	    let args_1014 = _immutable.List.of(new _terms2.default("LiteralStringExpression", { value: str_1011 })).concat(expandedInterps_1013);
	    return new _terms2.default("CallExpression", { callee: callee_1012, arguments: args_1014 });
	  }
	  expandSyntaxQuote(term_1017) {
	    let str_1018 = new _terms2.default("LiteralStringExpression", { value: _syntax2.default.from("string", _serializer.serializer.write(term_1017.name)) });
	    return new _terms2.default("TemplateExpression", { tag: term_1017.template.tag, elements: term_1017.template.elements.push(str_1018).push(new _terms2.default("TemplateElement", { rawValue: "" })).toArray() });
	  }
	  expandStaticMemberExpression(term_1019) {
	    return new _terms2.default("StaticMemberExpression", { object: this.expand(term_1019.object), property: term_1019.property });
	  }
	  expandArrayExpression(term_1020) {
	    return new _terms2.default("ArrayExpression", { elements: term_1020.elements.map(t_1021 => t_1021 == null ? t_1021 : this.expand(t_1021)) });
	  }
	  expandImport(term_1022) {
	    return term_1022;
	  }
	  expandImportNamespace(term_1023) {
	    return term_1023;
	  }
	  expandExport(term_1024) {
	    return new _terms2.default("Export", { declaration: this.expand(term_1024.declaration) });
	  }
	  expandExportDefault(term_1025) {
	    return new _terms2.default("ExportDefault", { body: this.expand(term_1025.body) });
	  }
	  expandExportFrom(term_1026) {
	    return term_1026;
	  }
	  expandExportAllFrom(term_1027) {
	    return term_1027;
	  }
	  expandExportSpecifier(term_1028) {
	    return term_1028;
	  }
	  expandStaticPropertyName(term_1029) {
	    return term_1029;
	  }
	  expandDataProperty(term_1030) {
	    return new _terms2.default("DataProperty", { name: this.expand(term_1030.name), expression: this.expand(term_1030.expression) });
	  }
	  expandObjectExpression(term_1031) {
	    return new _terms2.default("ObjectExpression", { properties: term_1031.properties.map(t_1032 => this.expand(t_1032)) });
	  }
	  expandVariableDeclarator(term_1033) {
	    let init_1034 = term_1033.init == null ? null : this.expand(term_1033.init);
	    return new _terms2.default("VariableDeclarator", { binding: this.expand(term_1033.binding), init: init_1034 });
	  }
	  expandVariableDeclaration(term_1035) {
	    if (term_1035.kind === "syntax" || term_1035.kind === "syntaxrec") {
	      return term_1035;
	    }
	    return new _terms2.default("VariableDeclaration", { kind: term_1035.kind, declarators: term_1035.declarators.map(d_1036 => this.expand(d_1036)) });
	  }
	  expandParenthesizedExpression(term_1037) {
	    if (term_1037.inner.size === 0) {
	      throw new Error("unexpected end of input");
	    }
	    let enf_1038 = new _enforester.Enforester(term_1037.inner, (0, _immutable.List)(), this.context);
	    let lookahead_1039 = enf_1038.peek();
	    let t_1040 = enf_1038.enforestExpression();
	    if (t_1040 == null || enf_1038.rest.size > 0) {
	      throw enf_1038.createError(lookahead_1039, "unexpected syntax");
	    }
	    return this.expand(t_1040);
	  }
	  expandUnaryExpression(term_1041) {
	    return new _terms2.default("UnaryExpression", { operator: term_1041.operator, operand: this.expand(term_1041.operand) });
	  }
	  expandUpdateExpression(term_1042) {
	    return new _terms2.default("UpdateExpression", { isPrefix: term_1042.isPrefix, operator: term_1042.operator, operand: this.expand(term_1042.operand) });
	  }
	  expandBinaryExpression(term_1043) {
	    let left_1044 = this.expand(term_1043.left);
	    let right_1045 = this.expand(term_1043.right);
	    return new _terms2.default("BinaryExpression", { left: left_1044, operator: term_1043.operator, right: right_1045 });
	  }
	  expandConditionalExpression(term_1046) {
	    return new _terms2.default("ConditionalExpression", { test: this.expand(term_1046.test), consequent: this.expand(term_1046.consequent), alternate: this.expand(term_1046.alternate) });
	  }
	  expandNewTargetExpression(term_1047) {
	    return term_1047;
	  }
	  expandNewExpression(term_1048) {
	    let callee_1049 = this.expand(term_1048.callee);
	    let enf_1050 = new _enforester.Enforester(term_1048.arguments, (0, _immutable.List)(), this.context);
	    let args_1051 = enf_1050.enforestArgumentList().map(arg_1052 => this.expand(arg_1052));
	    return new _terms2.default("NewExpression", { callee: callee_1049, arguments: args_1051.toArray() });
	  }
	  expandSuper(term_1053) {
	    return term_1053;
	  }
	  expandCallExpression(term_1054) {
	    let callee_1055 = this.expand(term_1054.callee);
	    let enf_1056 = new _enforester.Enforester(term_1054.arguments, (0, _immutable.List)(), this.context);
	    let args_1057 = enf_1056.enforestArgumentList().map(arg_1058 => this.expand(arg_1058));
	    return new _terms2.default("CallExpression", { callee: callee_1055, arguments: args_1057 });
	  }
	  expandSpreadElement(term_1059) {
	    return new _terms2.default("SpreadElement", { expression: this.expand(term_1059.expression) });
	  }
	  expandExpressionStatement(term_1060) {
	    let child_1061 = this.expand(term_1060.expression);
	    return new _terms2.default("ExpressionStatement", { expression: child_1061 });
	  }
	  expandLabeledStatement(term_1062) {
	    return new _terms2.default("LabeledStatement", { label: term_1062.label.val(), body: this.expand(term_1062.body) });
	  }
	  doFunctionExpansion(term_1063, type_1064) {
	    let scope_1065 = (0, _scope.freshScope)("fun");
	    let red_1066 = new _applyScopeInParamsReducer2.default(scope_1065, this.context);
	    let params_1067;
	    if (type_1064 !== "Getter" && type_1064 !== "Setter") {
	      params_1067 = red_1066.transform(term_1063.params);
	      params_1067 = this.expand(params_1067);
	    }
	    this.context.currentScope.push(scope_1065);
	    let compiler_1068 = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);
	    let markedBody_1069, bodyTerm_1070;
	    if (term_1063.body instanceof _terms2.default) {
	      bodyTerm_1070 = this.expand(term_1063.body.addScope(scope_1065, this.context.bindings, _syntax.ALL_PHASES));
	    } else {
	      markedBody_1069 = term_1063.body.map(b_1071 => b_1071.addScope(scope_1065, this.context.bindings, _syntax.ALL_PHASES));
	      bodyTerm_1070 = new _terms2.default("FunctionBody", { directives: (0, _immutable.List)(), statements: compiler_1068.compile(markedBody_1069) });
	    }
	    this.context.currentScope.pop();
	    if (type_1064 === "Getter") {
	      return new _terms2.default(type_1064, { name: this.expand(term_1063.name), body: bodyTerm_1070 });
	    } else if (type_1064 === "Setter") {
	      return new _terms2.default(type_1064, { name: this.expand(term_1063.name), param: term_1063.param, body: bodyTerm_1070 });
	    }
	    return new _terms2.default(type_1064, { name: term_1063.name, isGenerator: term_1063.isGenerator, params: params_1067, body: bodyTerm_1070 });
	  }
	  expandMethod(term_1072) {
	    return this.doFunctionExpansion(term_1072, "Method");
	  }
	  expandSetter(term_1073) {
	    return this.doFunctionExpansion(term_1073, "Setter");
	  }
	  expandGetter(term_1074) {
	    return this.doFunctionExpansion(term_1074, "Getter");
	  }
	  expandFunctionDeclaration(term_1075) {
	    return this.doFunctionExpansion(term_1075, "FunctionDeclaration");
	  }
	  expandFunctionExpression(term_1076) {
	    return this.doFunctionExpansion(term_1076, "FunctionExpression");
	  }
	  expandCompoundAssignmentExpression(term_1077) {
	    return new _terms2.default("CompoundAssignmentExpression", { binding: this.expand(term_1077.binding), operator: term_1077.operator, expression: this.expand(term_1077.expression) });
	  }
	  expandAssignmentExpression(term_1078) {
	    return new _terms2.default("AssignmentExpression", { binding: this.expand(term_1078.binding), expression: this.expand(term_1078.expression) });
	  }
	  expandEmptyStatement(term_1079) {
	    return term_1079;
	  }
	  expandLiteralBooleanExpression(term_1080) {
	    return term_1080;
	  }
	  expandLiteralNumericExpression(term_1081) {
	    return term_1081;
	  }
	  expandLiteralInfinityExpression(term_1082) {
	    return term_1082;
	  }
	  expandIdentifierExpression(term_1083) {
	    let trans_1084 = this.context.env.get(term_1083.name.resolve(this.context.phase));
	    if (trans_1084) {
	      return new _terms2.default("IdentifierExpression", { name: trans_1084.id });
	    }
	    return term_1083;
	  }
	  expandLiteralNullExpression(term_1085) {
	    return term_1085;
	  }
	  expandLiteralStringExpression(term_1086) {
	    return term_1086;
	  }
	  expandLiteralRegExpExpression(term_1087) {
	    return term_1087;
	  }
	}
	exports.default = TermExpander;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Rlcm0tZXhwYW5kZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFDZSxNQUFNLFlBQU4saUNBQXlDO0FBQ3RELGNBQVksV0FBWixFQUF5QjtBQUN2QixVQUFNLFFBQU4sRUFBZ0IsSUFBaEI7QUFDQSxTQUFLLE9BQUwsR0FBZSxXQUFmO0FBQ0Q7QUFDRCxTQUFPLFFBQVAsRUFBaUI7QUFDZixXQUFPLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBUDtBQUNEO0FBQ0QsZUFBYSxRQUFiLEVBQXVCO0FBQ3JCLFdBQU8sUUFBUDtBQUNEO0FBQ0QsMkJBQXlCLFFBQXpCLEVBQW1DO0FBQ2pDLFdBQU8sb0JBQVMsb0JBQVQsRUFBK0IsRUFBQyxLQUFLLFNBQVMsR0FBVCxJQUFnQixJQUFoQixHQUF1QixJQUF2QixHQUE4QixLQUFLLE1BQUwsQ0FBWSxTQUFTLEdBQXJCLENBQXBDLEVBQStELFVBQVUsU0FBUyxRQUFULENBQWtCLE9BQWxCLEVBQXpFLEVBQS9CLENBQVA7QUFDRDtBQUNELHVCQUFxQixRQUFyQixFQUErQjtBQUM3QixXQUFPLG9CQUFTLGdCQUFULEVBQTJCLEVBQUMsT0FBTyxTQUFTLEtBQVQsR0FBaUIsU0FBUyxLQUFULENBQWUsR0FBZixFQUFqQixHQUF3QyxJQUFoRCxFQUEzQixDQUFQO0FBQ0Q7QUFDRCx5QkFBdUIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBTyxvQkFBUyxrQkFBVCxFQUE2QixFQUFDLE1BQU0sS0FBSyxNQUFMLENBQVksU0FBUyxJQUFyQixDQUFQLEVBQW1DLE1BQU0sS0FBSyxNQUFMLENBQVksU0FBUyxJQUFyQixDQUF6QyxFQUE3QixDQUFQO0FBQ0Q7QUFDRCxzQkFBb0IsUUFBcEIsRUFBOEI7QUFDNUIsV0FBTyxvQkFBUyxlQUFULEVBQTBC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UyxzQkFBVCxFQUFpQyxFQUFDLE1BQU0sV0FBVyxFQUFsQixFQUFqQyxDQUFQO0FBQ0Q7QUFDRCxXQUFPLFNBQVA7QUFDRDtBQUNELDhCQUE0QixTQUE1QixFQUF1QztBQUNyQyxXQUFPLFNBQVA7QUFDRDtBQUNELGdDQUE4QixTQUE5QixFQUF5QztBQUN2QyxXQUFPLFNBQVA7QUFDRDtBQUNELGdDQUE4QixTQUE5QixFQUF5QztBQUN2QyxXQUFPLFNBQVA7QUFDRDtBQTdVcUQ7a0JBQW5DLFkiLCJmaWxlIjoidGVybS1leHBhbmRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNGdW5jdGlvbkRlY2xhcmF0aW9uLCBpc0Z1bmN0aW9uRXhwcmVzc2lvbiwgaXNGdW5jdGlvblRlcm0sIGlzRnVuY3Rpb25XaXRoTmFtZSwgaXNTeW50YXhEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQsIGlzSW1wb3J0LCBpc0V4cG9ydH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7U2NvcGUsIGZyZXNoU2NvcGV9IGZyb20gXCIuL3Njb3BlXCI7XG5pbXBvcnQgQXBwbHlTY29wZUluUGFyYW1zUmVkdWNlciBmcm9tIFwiLi9hcHBseS1zY29wZS1pbi1wYXJhbXMtcmVkdWNlclwiO1xuaW1wb3J0IHJlZHVjZXIsIHtNb25vaWRhbFJlZHVjZXJ9IGZyb20gXCJzaGlmdC1yZWR1Y2VyXCI7XG5pbXBvcnQgQ29tcGlsZXIgZnJvbSBcIi4vY29tcGlsZXJcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7c2VyaWFsaXplciwgbWFrZURlc2VyaWFsaXplcn0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuaW1wb3J0IHtlbmZvcmVzdEV4cHIsIEVuZm9yZXN0ZXJ9IGZyb20gXCIuL2VuZm9yZXN0ZXJcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7cHJvY2Vzc1RlbXBsYXRlfSBmcm9tIFwiLi90ZW1wbGF0ZS1wcm9jZXNzb3IuanNcIjtcbmltcG9ydCBBU1REaXNwYXRjaGVyIGZyb20gXCIuL2FzdC1kaXNwYXRjaGVyXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtRXhwYW5kZXIgZXh0ZW5kcyBBU1REaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dF85NDQpIHtcbiAgICBzdXBlcihcImV4cGFuZFwiLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0Xzk0NDtcbiAgfVxuICBleHBhbmQodGVybV85NDUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0ZXJtXzk0NSk7XG4gIH1cbiAgZXhwYW5kUHJhZ21hKHRlcm1fOTQ2KSB7XG4gICAgcmV0dXJuIHRlcm1fOTQ2O1xuICB9XG4gIGV4cGFuZFRlbXBsYXRlRXhwcmVzc2lvbih0ZXJtXzk0Nykge1xuICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiB0ZXJtXzk0Ny50YWcgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk0Ny50YWcpLCBlbGVtZW50czogdGVybV85NDcuZWxlbWVudHMudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kQnJlYWtTdGF0ZW1lbnQodGVybV85NDgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCcmVha1N0YXRlbWVudFwiLCB7bGFiZWw6IHRlcm1fOTQ4LmxhYmVsID8gdGVybV85NDgubGFiZWwudmFsKCkgOiBudWxsfSk7XG4gIH1cbiAgZXhwYW5kRG9XaGlsZVN0YXRlbWVudCh0ZXJtXzk0OSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTQ5LmJvZHkpLCB0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk0OS50ZXN0KX0pO1xuICB9XG4gIGV4cGFuZFdpdGhTdGF0ZW1lbnQodGVybV85NTApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaXRoU3RhdGVtZW50XCIsIHtib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzk1MC5ib2R5KSwgb2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk1MC5vYmplY3QpfSk7XG4gIH1cbiAgZXhwYW5kRGVidWdnZXJTdGF0ZW1lbnQodGVybV85NTEpIHtcbiAgICByZXR1cm4gdGVybV85NTE7XG4gIH1cbiAgZXhwYW5kQ29udGludWVTdGF0ZW1lbnQodGVybV85NTIpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb250aW51ZVN0YXRlbWVudFwiLCB7bGFiZWw6IHRlcm1fOTUyLmxhYmVsID8gdGVybV85NTIubGFiZWwudmFsKCkgOiBudWxsfSk7XG4gIH1cbiAgZXhwYW5kU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQodGVybV85NTMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwiLCB7ZGlzY3JpbWluYW50OiB0aGlzLmV4cGFuZCh0ZXJtXzk1My5kaXNjcmltaW5hbnQpLCBwcmVEZWZhdWx0Q2FzZXM6IHRlcm1fOTUzLnByZURlZmF1bHRDYXNlcy5tYXAoY185NTQgPT4gdGhpcy5leHBhbmQoY185NTQpKS50b0FycmF5KCksIGRlZmF1bHRDYXNlOiB0aGlzLmV4cGFuZCh0ZXJtXzk1My5kZWZhdWx0Q2FzZSksIHBvc3REZWZhdWx0Q2FzZXM6IHRlcm1fOTUzLnBvc3REZWZhdWx0Q2FzZXMubWFwKGNfOTU1ID0+IHRoaXMuZXhwYW5kKGNfOTU1KSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKHRlcm1fOTU2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uXCIsIHtvYmplY3Q6IHRoaXMuZXhwYW5kKHRlcm1fOTU2Lm9iamVjdCksIGV4cHJlc3Npb246IHRoaXMuZXhwYW5kKHRlcm1fOTU2LmV4cHJlc3Npb24pfSk7XG4gIH1cbiAgZXhwYW5kU3dpdGNoU3RhdGVtZW50KHRlcm1fOTU3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoU3RhdGVtZW50XCIsIHtkaXNjcmltaW5hbnQ6IHRoaXMuZXhwYW5kKHRlcm1fOTU3LmRpc2NyaW1pbmFudCksIGNhc2VzOiB0ZXJtXzk1Ny5jYXNlcy5tYXAoY185NTggPT4gdGhpcy5leHBhbmQoY185NTgpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRGb3JtYWxQYXJhbWV0ZXJzKHRlcm1fOTU5KSB7XG4gICAgbGV0IHJlc3RfOTYwID0gdGVybV85NTkucmVzdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTU5LnJlc3QpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiB0ZXJtXzk1OS5pdGVtcy5tYXAoaV85NjEgPT4gdGhpcy5leHBhbmQoaV85NjEpKSwgcmVzdDogcmVzdF85NjB9KTtcbiAgfVxuICBleHBhbmRBcnJvd0V4cHJlc3Npb24odGVybV85NjIpIHtcbiAgICByZXR1cm4gdGhpcy5kb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fOTYyLCBcIkFycm93RXhwcmVzc2lvblwiKTtcbiAgfVxuICBleHBhbmRTd2l0Y2hEZWZhdWx0KHRlcm1fOTYzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoRGVmYXVsdFwiLCB7Y29uc2VxdWVudDogdGVybV85NjMuY29uc2VxdWVudC5tYXAoY185NjQgPT4gdGhpcy5leHBhbmQoY185NjQpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRTd2l0Y2hDYXNlKHRlcm1fOTY1KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoQ2FzZVwiLCB7dGVzdDogdGhpcy5leHBhbmQodGVybV85NjUudGVzdCksIGNvbnNlcXVlbnQ6IHRlcm1fOTY1LmNvbnNlcXVlbnQubWFwKGNfOTY2ID0+IHRoaXMuZXhwYW5kKGNfOTY2KSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kRm9ySW5TdGF0ZW1lbnQodGVybV85NjcpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJGb3JJblN0YXRlbWVudFwiLCB7bGVmdDogdGhpcy5leHBhbmQodGVybV85NjcubGVmdCksIHJpZ2h0OiB0aGlzLmV4cGFuZCh0ZXJtXzk2Ny5yaWdodCksIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTY3LmJvZHkpfSk7XG4gIH1cbiAgZXhwYW5kVHJ5Q2F0Y2hTdGF0ZW1lbnQodGVybV85NjgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlDYXRjaFN0YXRlbWVudFwiLCB7Ym9keTogdGhpcy5leHBhbmQodGVybV85NjguYm9keSksIGNhdGNoQ2xhdXNlOiB0aGlzLmV4cGFuZCh0ZXJtXzk2OC5jYXRjaENsYXVzZSl9KTtcbiAgfVxuICBleHBhbmRUcnlGaW5hbGx5U3RhdGVtZW50KHRlcm1fOTY5KSB7XG4gICAgbGV0IGNhdGNoQ2xhdXNlXzk3MCA9IHRlcm1fOTY5LmNhdGNoQ2xhdXNlID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85NjkuY2F0Y2hDbGF1c2UpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTY5LmJvZHkpLCBjYXRjaENsYXVzZTogY2F0Y2hDbGF1c2VfOTcwLCBmaW5hbGl6ZXI6IHRoaXMuZXhwYW5kKHRlcm1fOTY5LmZpbmFsaXplcil9KTtcbiAgfVxuICBleHBhbmRDYXRjaENsYXVzZSh0ZXJtXzk3MSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNhdGNoQ2xhdXNlXCIsIHtiaW5kaW5nOiB0aGlzLmV4cGFuZCh0ZXJtXzk3MS5iaW5kaW5nKSwgYm9keTogdGhpcy5leHBhbmQodGVybV85NzEuYm9keSl9KTtcbiAgfVxuICBleHBhbmRUaHJvd1N0YXRlbWVudCh0ZXJtXzk3Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIlRocm93U3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzk3Mi5leHByZXNzaW9uKX0pO1xuICB9XG4gIGV4cGFuZEZvck9mU3RhdGVtZW50KHRlcm1fOTczKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yT2ZTdGF0ZW1lbnRcIiwge2xlZnQ6IHRoaXMuZXhwYW5kKHRlcm1fOTczLmxlZnQpLCByaWdodDogdGhpcy5leHBhbmQodGVybV85NzMucmlnaHQpLCBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzk3My5ib2R5KX0pO1xuICB9XG4gIGV4cGFuZEJpbmRpbmdJZGVudGlmaWVyKHRlcm1fOTc0KSB7XG4gICAgcmV0dXJuIHRlcm1fOTc0O1xuICB9XG4gIGV4cGFuZEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIodGVybV85NzUpIHtcbiAgICByZXR1cm4gdGVybV85NzU7XG4gIH1cbiAgZXhwYW5kQmluZGluZ1Byb3BlcnR5UHJvcGVydHkodGVybV85NzYpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGhpcy5leHBhbmQodGVybV85NzYubmFtZSksIGJpbmRpbmc6IHRoaXMuZXhwYW5kKHRlcm1fOTc2LmJpbmRpbmcpfSk7XG4gIH1cbiAgZXhwYW5kQ29tcHV0ZWRQcm9wZXJ0eU5hbWUodGVybV85NzcpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb21wdXRlZFByb3BlcnR5TmFtZVwiLCB7ZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybV85NzcuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRPYmplY3RCaW5kaW5nKHRlcm1fOTc4KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiT2JqZWN0QmluZGluZ1wiLCB7cHJvcGVydGllczogdGVybV85NzgucHJvcGVydGllcy5tYXAodF85NzkgPT4gdGhpcy5leHBhbmQodF85NzkpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRBcnJheUJpbmRpbmcodGVybV85ODApIHtcbiAgICBsZXQgcmVzdEVsZW1lbnRfOTgxID0gdGVybV85ODAucmVzdEVsZW1lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk4MC5yZXN0RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV85ODAuZWxlbWVudHMubWFwKHRfOTgyID0+IHRfOTgyID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodF85ODIpKS50b0FycmF5KCksIHJlc3RFbGVtZW50OiByZXN0RWxlbWVudF85ODF9KTtcbiAgfVxuICBleHBhbmRCaW5kaW5nV2l0aERlZmF1bHQodGVybV85ODMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nV2l0aERlZmF1bHRcIiwge2JpbmRpbmc6IHRoaXMuZXhwYW5kKHRlcm1fOTgzLmJpbmRpbmcpLCBpbml0OiB0aGlzLmV4cGFuZCh0ZXJtXzk4My5pbml0KX0pO1xuICB9XG4gIGV4cGFuZFNob3J0aGFuZFByb3BlcnR5KHRlcm1fOTg0KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRGF0YVByb3BlcnR5XCIsIHtuYW1lOiBuZXcgVGVybShcIlN0YXRpY1Byb3BlcnR5TmFtZVwiLCB7dmFsdWU6IHRlcm1fOTg0Lm5hbWV9KSwgZXhwcmVzc2lvbjogbmV3IFRlcm0oXCJJZGVudGlmaWVyRXhwcmVzc2lvblwiLCB7bmFtZTogdGVybV85ODQubmFtZX0pfSk7XG4gIH1cbiAgZXhwYW5kRm9yU3RhdGVtZW50KHRlcm1fOTg1KSB7XG4gICAgbGV0IGluaXRfOTg2ID0gdGVybV85ODUuaW5pdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTg1LmluaXQpO1xuICAgIGxldCB0ZXN0Xzk4NyA9IHRlcm1fOTg1LnRlc3QgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk4NS50ZXN0KTtcbiAgICBsZXQgdXBkYXRlXzk4OCA9IHRlcm1fOTg1LnVwZGF0ZSA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTg1LnVwZGF0ZSk7XG4gICAgbGV0IGJvZHlfOTg5ID0gdGhpcy5leHBhbmQodGVybV85ODUuYm9keSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yU3RhdGVtZW50XCIsIHtpbml0OiBpbml0Xzk4NiwgdGVzdDogdGVzdF85ODcsIHVwZGF0ZTogdXBkYXRlXzk4OCwgYm9keTogYm9keV85ODl9KTtcbiAgfVxuICBleHBhbmRZaWVsZEV4cHJlc3Npb24odGVybV85OTApIHtcbiAgICBsZXQgZXhwcl85OTEgPSB0ZXJtXzk5MC5leHByZXNzaW9uID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85OTAuZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiWWllbGRFeHByZXNzaW9uXCIsIHtleHByZXNzaW9uOiBleHByXzk5MX0pO1xuICB9XG4gIGV4cGFuZFlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbih0ZXJtXzk5Mikge1xuICAgIGxldCBleHByXzk5MyA9IHRlcm1fOTkyLmV4cHJlc3Npb24gPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk5Mi5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIiwge2V4cHJlc3Npb246IGV4cHJfOTkzfSk7XG4gIH1cbiAgZXhwYW5kV2hpbGVTdGF0ZW1lbnQodGVybV85OTQpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaGlsZVN0YXRlbWVudFwiLCB7dGVzdDogdGhpcy5leHBhbmQodGVybV85OTQudGVzdCksIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTk0LmJvZHkpfSk7XG4gIH1cbiAgZXhwYW5kSWZTdGF0ZW1lbnQodGVybV85OTUpIHtcbiAgICBsZXQgY29uc2VxdWVudF85OTYgPSB0ZXJtXzk5NS5jb25zZXF1ZW50ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85OTUuY29uc2VxdWVudCk7XG4gICAgbGV0IGFsdGVybmF0ZV85OTcgPSB0ZXJtXzk5NS5hbHRlcm5hdGUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk5NS5hbHRlcm5hdGUpO1xuICAgIHJldHVybiBuZXcgVGVybShcIklmU3RhdGVtZW50XCIsIHt0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk5NS50ZXN0KSwgY29uc2VxdWVudDogY29uc2VxdWVudF85OTYsIGFsdGVybmF0ZTogYWx0ZXJuYXRlXzk5N30pO1xuICB9XG4gIGV4cGFuZEJsb2NrU3RhdGVtZW50KHRlcm1fOTk4KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmxvY2tTdGF0ZW1lbnRcIiwge2Jsb2NrOiB0aGlzLmV4cGFuZCh0ZXJtXzk5OC5ibG9jayl9KTtcbiAgfVxuICBleHBhbmRCbG9jayh0ZXJtXzk5OSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkJsb2NrXCIsIHtzdGF0ZW1lbnRzOiB0ZXJtXzk5OS5zdGF0ZW1lbnRzLm1hcChzXzEwMDAgPT4gdGhpcy5leHBhbmQoc18xMDAwKSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCh0ZXJtXzEwMDEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5leHBhbmQodGVybV8xMDAxLmRlY2xhcmF0aW9uKX0pO1xuICB9XG4gIGV4cGFuZFJldHVyblN0YXRlbWVudCh0ZXJtXzEwMDIpIHtcbiAgICBpZiAodGVybV8xMDAyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRlcm1fMTAwMjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMDIuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRDbGFzc0RlY2xhcmF0aW9uKHRlcm1fMTAwMykge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNsYXNzRGVjbGFyYXRpb25cIiwge25hbWU6IHRlcm1fMTAwMy5uYW1lID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV8xMDAzLm5hbWUpLCBzdXBlcjogdGVybV8xMDAzLnN1cGVyID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV8xMDAzLnN1cGVyKSwgZWxlbWVudHM6IHRlcm1fMTAwMy5lbGVtZW50cy5tYXAoZWxfMTAwNCA9PiB0aGlzLmV4cGFuZChlbF8xMDA0KSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kQ2xhc3NFeHByZXNzaW9uKHRlcm1fMTAwNSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNsYXNzRXhwcmVzc2lvblwiLCB7bmFtZTogdGVybV8xMDA1Lm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMDUubmFtZSksIHN1cGVyOiB0ZXJtXzEwMDUuc3VwZXIgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMDUuc3VwZXIpLCBlbGVtZW50czogdGVybV8xMDA1LmVsZW1lbnRzLm1hcChlbF8xMDA2ID0+IHRoaXMuZXhwYW5kKGVsXzEwMDYpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRDbGFzc0VsZW1lbnQodGVybV8xMDA3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ2xhc3NFbGVtZW50XCIsIHtpc1N0YXRpYzogdGVybV8xMDA3LmlzU3RhdGljLCBtZXRob2Q6IHRoaXMuZXhwYW5kKHRlcm1fMTAwNy5tZXRob2QpfSk7XG4gIH1cbiAgZXhwYW5kVGhpc0V4cHJlc3Npb24odGVybV8xMDA4KSB7XG4gICAgcmV0dXJuIHRlcm1fMTAwODtcbiAgfVxuICBleHBhbmRTeW50YXhUZW1wbGF0ZSh0ZXJtXzEwMDkpIHtcbiAgICBsZXQgcl8xMDEwID0gcHJvY2Vzc1RlbXBsYXRlKHRlcm1fMTAwOS50ZW1wbGF0ZS5pbm5lcigpKTtcbiAgICBsZXQgc3RyXzEwMTEgPSBTeW50YXguZnJvbShcInN0cmluZ1wiLCBzZXJpYWxpemVyLndyaXRlKHJfMTAxMC50ZW1wbGF0ZSkpO1xuICAgIGxldCBjYWxsZWVfMTAxMiA9IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IFN5bnRheC5mcm9tKFwiaWRlbnRpZmllclwiLCBcInN5bnRheFRlbXBsYXRlXCIpfSk7XG4gICAgbGV0IGV4cGFuZGVkSW50ZXJwc18xMDEzID0gcl8xMDEwLmludGVycC5tYXAoaV8xMDE1ID0+IHtcbiAgICAgIGxldCBlbmZfMTAxNiA9IG5ldyBFbmZvcmVzdGVyKGlfMTAxNSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kKGVuZl8xMDE2LmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKSk7XG4gICAgfSk7XG4gICAgbGV0IGFyZ3NfMTAxNCA9IExpc3Qub2YobmV3IFRlcm0oXCJMaXRlcmFsU3RyaW5nRXhwcmVzc2lvblwiLCB7dmFsdWU6IHN0cl8xMDExfSkpLmNvbmNhdChleHBhbmRlZEludGVycHNfMTAxMyk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ2FsbEV4cHJlc3Npb25cIiwge2NhbGxlZTogY2FsbGVlXzEwMTIsIGFyZ3VtZW50czogYXJnc18xMDE0fSk7XG4gIH1cbiAgZXhwYW5kU3ludGF4UXVvdGUodGVybV8xMDE3KSB7XG4gICAgbGV0IHN0cl8xMDE4ID0gbmV3IFRlcm0oXCJMaXRlcmFsU3RyaW5nRXhwcmVzc2lvblwiLCB7dmFsdWU6IFN5bnRheC5mcm9tKFwic3RyaW5nXCIsIHNlcmlhbGl6ZXIud3JpdGUodGVybV8xMDE3Lm5hbWUpKX0pO1xuICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiB0ZXJtXzEwMTcudGVtcGxhdGUudGFnLCBlbGVtZW50czogdGVybV8xMDE3LnRlbXBsYXRlLmVsZW1lbnRzLnB1c2goc3RyXzEwMTgpLnB1c2gobmV3IFRlcm0oXCJUZW1wbGF0ZUVsZW1lbnRcIiwge3Jhd1ZhbHVlOiBcIlwifSkpLnRvQXJyYXkoKX0pO1xuICB9XG4gIGV4cGFuZFN0YXRpY01lbWJlckV4cHJlc3Npb24odGVybV8xMDE5KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3RhdGljTWVtYmVyRXhwcmVzc2lvblwiLCB7b2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtXzEwMTkub2JqZWN0KSwgcHJvcGVydHk6IHRlcm1fMTAxOS5wcm9wZXJ0eX0pO1xuICB9XG4gIGV4cGFuZEFycmF5RXhwcmVzc2lvbih0ZXJtXzEwMjApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUV4cHJlc3Npb25cIiwge2VsZW1lbnRzOiB0ZXJtXzEwMjAuZWxlbWVudHMubWFwKHRfMTAyMSA9PiB0XzEwMjEgPT0gbnVsbCA/IHRfMTAyMSA6IHRoaXMuZXhwYW5kKHRfMTAyMSkpfSk7XG4gIH1cbiAgZXhwYW5kSW1wb3J0KHRlcm1fMTAyMikge1xuICAgIHJldHVybiB0ZXJtXzEwMjI7XG4gIH1cbiAgZXhwYW5kSW1wb3J0TmFtZXNwYWNlKHRlcm1fMTAyMykge1xuICAgIHJldHVybiB0ZXJtXzEwMjM7XG4gIH1cbiAgZXhwYW5kRXhwb3J0KHRlcm1fMTAyNCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydFwiLCB7ZGVjbGFyYXRpb246IHRoaXMuZXhwYW5kKHRlcm1fMTAyNC5kZWNsYXJhdGlvbil9KTtcbiAgfVxuICBleHBhbmRFeHBvcnREZWZhdWx0KHRlcm1fMTAyNSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydERlZmF1bHRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fMTAyNS5ib2R5KX0pO1xuICB9XG4gIGV4cGFuZEV4cG9ydEZyb20odGVybV8xMDI2KSB7XG4gICAgcmV0dXJuIHRlcm1fMTAyNjtcbiAgfVxuICBleHBhbmRFeHBvcnRBbGxGcm9tKHRlcm1fMTAyNykge1xuICAgIHJldHVybiB0ZXJtXzEwMjc7XG4gIH1cbiAgZXhwYW5kRXhwb3J0U3BlY2lmaWVyKHRlcm1fMTAyOCkge1xuICAgIHJldHVybiB0ZXJtXzEwMjg7XG4gIH1cbiAgZXhwYW5kU3RhdGljUHJvcGVydHlOYW1lKHRlcm1fMTAyOSkge1xuICAgIHJldHVybiB0ZXJtXzEwMjk7XG4gIH1cbiAgZXhwYW5kRGF0YVByb3BlcnR5KHRlcm1fMTAzMCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkRhdGFQcm9wZXJ0eVwiLCB7bmFtZTogdGhpcy5leHBhbmQodGVybV8xMDMwLm5hbWUpLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMzAuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRPYmplY3RFeHByZXNzaW9uKHRlcm1fMTAzMSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEV4cHJlc3Npb25cIiwge3Byb3BlcnRpZXM6IHRlcm1fMTAzMS5wcm9wZXJ0aWVzLm1hcCh0XzEwMzIgPT4gdGhpcy5leHBhbmQodF8xMDMyKSl9KTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0b3IodGVybV8xMDMzKSB7XG4gICAgbGV0IGluaXRfMTAzNCA9IHRlcm1fMTAzMy5pbml0ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV8xMDMzLmluaXQpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDMzLmJpbmRpbmcpLCBpbml0OiBpbml0XzEwMzR9KTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMTAzNSkge1xuICAgIGlmICh0ZXJtXzEwMzUua2luZCA9PT0gXCJzeW50YXhcIiB8fCB0ZXJtXzEwMzUua2luZCA9PT0gXCJzeW50YXhyZWNcIikge1xuICAgICAgcmV0dXJuIHRlcm1fMTAzNTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCB7a2luZDogdGVybV8xMDM1LmtpbmQsIGRlY2xhcmF0b3JzOiB0ZXJtXzEwMzUuZGVjbGFyYXRvcnMubWFwKGRfMTAzNiA9PiB0aGlzLmV4cGFuZChkXzEwMzYpKX0pO1xuICB9XG4gIGV4cGFuZFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHRlcm1fMTAzNykge1xuICAgIGlmICh0ZXJtXzEwMzcuaW5uZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIik7XG4gICAgfVxuICAgIGxldCBlbmZfMTAzOCA9IG5ldyBFbmZvcmVzdGVyKHRlcm1fMTAzNy5pbm5lciwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTAzOSA9IGVuZl8xMDM4LnBlZWsoKTtcbiAgICBsZXQgdF8xMDQwID0gZW5mXzEwMzguZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRfMTA0MCA9PSBudWxsIHx8IGVuZl8xMDM4LnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgIHRocm93IGVuZl8xMDM4LmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMDM5LCBcInVuZXhwZWN0ZWQgc3ludGF4XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBhbmQodF8xMDQwKTtcbiAgfVxuICBleHBhbmRVbmFyeUV4cHJlc3Npb24odGVybV8xMDQxKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtvcGVyYXRvcjogdGVybV8xMDQxLm9wZXJhdG9yLCBvcGVyYW5kOiB0aGlzLmV4cGFuZCh0ZXJtXzEwNDEub3BlcmFuZCl9KTtcbiAgfVxuICBleHBhbmRVcGRhdGVFeHByZXNzaW9uKHRlcm1fMTA0Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge2lzUHJlZml4OiB0ZXJtXzEwNDIuaXNQcmVmaXgsIG9wZXJhdG9yOiB0ZXJtXzEwNDIub3BlcmF0b3IsIG9wZXJhbmQ6IHRoaXMuZXhwYW5kKHRlcm1fMTA0Mi5vcGVyYW5kKX0pO1xuICB9XG4gIGV4cGFuZEJpbmFyeUV4cHJlc3Npb24odGVybV8xMDQzKSB7XG4gICAgbGV0IGxlZnRfMTA0NCA9IHRoaXMuZXhwYW5kKHRlcm1fMTA0My5sZWZ0KTtcbiAgICBsZXQgcmlnaHRfMTA0NSA9IHRoaXMuZXhwYW5kKHRlcm1fMTA0My5yaWdodCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7bGVmdDogbGVmdF8xMDQ0LCBvcGVyYXRvcjogdGVybV8xMDQzLm9wZXJhdG9yLCByaWdodDogcmlnaHRfMTA0NX0pO1xuICB9XG4gIGV4cGFuZENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXJtXzEwNDYpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwge3Rlc3Q6IHRoaXMuZXhwYW5kKHRlcm1fMTA0Ni50ZXN0KSwgY29uc2VxdWVudDogdGhpcy5leHBhbmQodGVybV8xMDQ2LmNvbnNlcXVlbnQpLCBhbHRlcm5hdGU6IHRoaXMuZXhwYW5kKHRlcm1fMTA0Ni5hbHRlcm5hdGUpfSk7XG4gIH1cbiAgZXhwYW5kTmV3VGFyZ2V0RXhwcmVzc2lvbih0ZXJtXzEwNDcpIHtcbiAgICByZXR1cm4gdGVybV8xMDQ3O1xuICB9XG4gIGV4cGFuZE5ld0V4cHJlc3Npb24odGVybV8xMDQ4KSB7XG4gICAgbGV0IGNhbGxlZV8xMDQ5ID0gdGhpcy5leHBhbmQodGVybV8xMDQ4LmNhbGxlZSk7XG4gICAgbGV0IGVuZl8xMDUwID0gbmV3IEVuZm9yZXN0ZXIodGVybV8xMDQ4LmFyZ3VtZW50cywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhcmdzXzEwNTEgPSBlbmZfMTA1MC5lbmZvcmVzdEFyZ3VtZW50TGlzdCgpLm1hcChhcmdfMTA1MiA9PiB0aGlzLmV4cGFuZChhcmdfMTA1MikpO1xuICAgIHJldHVybiBuZXcgVGVybShcIk5ld0V4cHJlc3Npb25cIiwge2NhbGxlZTogY2FsbGVlXzEwNDksIGFyZ3VtZW50czogYXJnc18xMDUxLnRvQXJyYXkoKX0pO1xuICB9XG4gIGV4cGFuZFN1cGVyKHRlcm1fMTA1Mykge1xuICAgIHJldHVybiB0ZXJtXzEwNTM7XG4gIH1cbiAgZXhwYW5kQ2FsbEV4cHJlc3Npb24odGVybV8xMDU0KSB7XG4gICAgbGV0IGNhbGxlZV8xMDU1ID0gdGhpcy5leHBhbmQodGVybV8xMDU0LmNhbGxlZSk7XG4gICAgbGV0IGVuZl8xMDU2ID0gbmV3IEVuZm9yZXN0ZXIodGVybV8xMDU0LmFyZ3VtZW50cywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhcmdzXzEwNTcgPSBlbmZfMTA1Ni5lbmZvcmVzdEFyZ3VtZW50TGlzdCgpLm1hcChhcmdfMTA1OCA9PiB0aGlzLmV4cGFuZChhcmdfMTA1OCkpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkNhbGxFeHByZXNzaW9uXCIsIHtjYWxsZWU6IGNhbGxlZV8xMDU1LCBhcmd1bWVudHM6IGFyZ3NfMTA1N30pO1xuICB9XG4gIGV4cGFuZFNwcmVhZEVsZW1lbnQodGVybV8xMDU5KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3ByZWFkRWxlbWVudFwiLCB7ZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybV8xMDU5LmV4cHJlc3Npb24pfSk7XG4gIH1cbiAgZXhwYW5kRXhwcmVzc2lvblN0YXRlbWVudCh0ZXJtXzEwNjApIHtcbiAgICBsZXQgY2hpbGRfMTA2MSA9IHRoaXMuZXhwYW5kKHRlcm1fMTA2MC5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiBjaGlsZF8xMDYxfSk7XG4gIH1cbiAgZXhwYW5kTGFiZWxlZFN0YXRlbWVudCh0ZXJtXzEwNjIpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJMYWJlbGVkU3RhdGVtZW50XCIsIHtsYWJlbDogdGVybV8xMDYyLmxhYmVsLnZhbCgpLCBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzEwNjIuYm9keSl9KTtcbiAgfVxuICBkb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fMTA2MywgdHlwZV8xMDY0KSB7XG4gICAgbGV0IHNjb3BlXzEwNjUgPSBmcmVzaFNjb3BlKFwiZnVuXCIpO1xuICAgIGxldCByZWRfMTA2NiA9IG5ldyBBcHBseVNjb3BlSW5QYXJhbXNSZWR1Y2VyKHNjb3BlXzEwNjUsIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IHBhcmFtc18xMDY3O1xuICAgIGlmICh0eXBlXzEwNjQgIT09IFwiR2V0dGVyXCIgJiYgdHlwZV8xMDY0ICE9PSBcIlNldHRlclwiKSB7XG4gICAgICBwYXJhbXNfMTA2NyA9IHJlZF8xMDY2LnRyYW5zZm9ybSh0ZXJtXzEwNjMucGFyYW1zKTtcbiAgICAgIHBhcmFtc18xMDY3ID0gdGhpcy5leHBhbmQocGFyYW1zXzEwNjcpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuY3VycmVudFNjb3BlLnB1c2goc2NvcGVfMTA2NSk7XG4gICAgbGV0IGNvbXBpbGVyXzEwNjggPSBuZXcgQ29tcGlsZXIodGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuZW52LCB0aGlzLmNvbnRleHQuc3RvcmUsIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IG1hcmtlZEJvZHlfMTA2OSwgYm9keVRlcm1fMTA3MDtcbiAgICBpZiAodGVybV8xMDYzLmJvZHkgaW5zdGFuY2VvZiBUZXJtKSB7XG4gICAgICBib2R5VGVybV8xMDcwID0gdGhpcy5leHBhbmQodGVybV8xMDYzLmJvZHkuYWRkU2NvcGUoc2NvcGVfMTA2NSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlZEJvZHlfMTA2OSA9IHRlcm1fMTA2My5ib2R5Lm1hcChiXzEwNzEgPT4gYl8xMDcxLmFkZFNjb3BlKHNjb3BlXzEwNjUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUykpO1xuICAgICAgYm9keVRlcm1fMTA3MCA9IG5ldyBUZXJtKFwiRnVuY3Rpb25Cb2R5XCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIHN0YXRlbWVudHM6IGNvbXBpbGVyXzEwNjguY29tcGlsZShtYXJrZWRCb2R5XzEwNjkpfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5jdXJyZW50U2NvcGUucG9wKCk7XG4gICAgaWYgKHR5cGVfMTA2NCA9PT0gXCJHZXR0ZXJcIikge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA2NCwge25hbWU6IHRoaXMuZXhwYW5kKHRlcm1fMTA2My5uYW1lKSwgYm9keTogYm9keVRlcm1fMTA3MH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZV8xMDY0ID09PSBcIlNldHRlclwiKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8xMDY0LCB7bmFtZTogdGhpcy5leHBhbmQodGVybV8xMDYzLm5hbWUpLCBwYXJhbTogdGVybV8xMDYzLnBhcmFtLCBib2R5OiBib2R5VGVybV8xMDcwfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybSh0eXBlXzEwNjQsIHtuYW1lOiB0ZXJtXzEwNjMubmFtZSwgaXNHZW5lcmF0b3I6IHRlcm1fMTA2My5pc0dlbmVyYXRvciwgcGFyYW1zOiBwYXJhbXNfMTA2NywgYm9keTogYm9keVRlcm1fMTA3MH0pO1xuICB9XG4gIGV4cGFuZE1ldGhvZCh0ZXJtXzEwNzIpIHtcbiAgICByZXR1cm4gdGhpcy5kb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fMTA3MiwgXCJNZXRob2RcIik7XG4gIH1cbiAgZXhwYW5kU2V0dGVyKHRlcm1fMTA3Mykge1xuICAgIHJldHVybiB0aGlzLmRvRnVuY3Rpb25FeHBhbnNpb24odGVybV8xMDczLCBcIlNldHRlclwiKTtcbiAgfVxuICBleHBhbmRHZXR0ZXIodGVybV8xMDc0KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNzQsIFwiR2V0dGVyXCIpO1xuICB9XG4gIGV4cGFuZEZ1bmN0aW9uRGVjbGFyYXRpb24odGVybV8xMDc1KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNzUsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiKTtcbiAgfVxuICBleHBhbmRGdW5jdGlvbkV4cHJlc3Npb24odGVybV8xMDc2KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNzYsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG4gIGV4cGFuZENvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24odGVybV8xMDc3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDc3LmJpbmRpbmcpLCBvcGVyYXRvcjogdGVybV8xMDc3Lm9wZXJhdG9yLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwNzcuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRBc3NpZ25tZW50RXhwcmVzc2lvbih0ZXJtXzEwNzgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDc4LmJpbmRpbmcpLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwNzguZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRFbXB0eVN0YXRlbWVudCh0ZXJtXzEwNzkpIHtcbiAgICByZXR1cm4gdGVybV8xMDc5O1xuICB9XG4gIGV4cGFuZExpdGVyYWxCb29sZWFuRXhwcmVzc2lvbih0ZXJtXzEwODApIHtcbiAgICByZXR1cm4gdGVybV8xMDgwO1xuICB9XG4gIGV4cGFuZExpdGVyYWxOdW1lcmljRXhwcmVzc2lvbih0ZXJtXzEwODEpIHtcbiAgICByZXR1cm4gdGVybV8xMDgxO1xuICB9XG4gIGV4cGFuZExpdGVyYWxJbmZpbml0eUV4cHJlc3Npb24odGVybV8xMDgyKSB7XG4gICAgcmV0dXJuIHRlcm1fMTA4MjtcbiAgfVxuICBleHBhbmRJZGVudGlmaWVyRXhwcmVzc2lvbih0ZXJtXzEwODMpIHtcbiAgICBsZXQgdHJhbnNfMTA4NCA9IHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMTA4My5uYW1lLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSk7XG4gICAgaWYgKHRyYW5zXzEwODQpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiB0cmFuc18xMDg0LmlkfSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXJtXzEwODM7XG4gIH1cbiAgZXhwYW5kTGl0ZXJhbE51bGxFeHByZXNzaW9uKHRlcm1fMTA4NSkge1xuICAgIHJldHVybiB0ZXJtXzEwODU7XG4gIH1cbiAgZXhwYW5kTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24odGVybV8xMDg2KSB7XG4gICAgcmV0dXJuIHRlcm1fMTA4NjtcbiAgfVxuICBleHBhbmRMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbih0ZXJtXzEwODcpIHtcbiAgICByZXR1cm4gdGVybV8xMDg3O1xuICB9XG59XG4iXX0=

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _symbol = __webpack_require__(44);

	var _transforms = __webpack_require__(31);

	var _errors = __webpack_require__(13);

	var _syntax = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class ScopeApplyingReducer {
	  constructor(scope_0, context_1) {
	    this.context = context_1;
	    this.scope = scope_0;
	  }
	  transform(term_2) {
	    let field_3 = "transform" + term_2.type;
	    if (typeof this[field_3] === "function") {
	      return this[field_3](term_2);
	    }
	    (0, _errors.assert)(false, "transform not implemented yet for: " + term_2.type);
	  }
	  transformFormalParameters(term_4) {
	    let rest_5 = term_4.rest == null ? null : this.transform(term_4.rest);
	    return new _terms2.default("FormalParameters", { items: term_4.items.map(it_6 => this.transform(it_6)), rest: rest_5 });
	  }
	  transformBindingWithDefault(term_7) {
	    return new _terms2.default("BindingWithDefault", { binding: this.transform(term_7.binding), init: term_7.init });
	  }
	  transformObjectBinding(term_8) {
	    return term_8;
	  }
	  transformBindingPropertyIdentifier(term_9) {
	    return new _terms2.default("BindingPropertyIdentifier", { binding: this.transform(term_9.binding), init: term_9.init });
	  }
	  transformBindingPropertyProperty(term_10) {
	    return new _terms2.default("BindingPropertyProperty", { name: term_10.name, binding: this.transform(term_10.binding) });
	  }
	  transformArrayBinding(term_11) {
	    return new _terms2.default("ArrayBinding", { elements: term_11.elements.map(el_12 => this.transform(el_12)), restElement: term_11.restElement == null ? null : this.transform(term_11.restElement) });
	  }
	  transformBindingIdentifier(term_13) {
	    let name_14 = term_13.name.addScope(this.scope, this.context.bindings, _syntax.ALL_PHASES);
	    let newBinding_15 = (0, _symbol.gensym)(name_14.val());
	    this.context.env.set(newBinding_15.toString(), new _transforms.VarBindingTransform(name_14));
	    this.context.bindings.add(name_14, { binding: newBinding_15, phase: this.context.phase, skipDup: true });
	    return new _terms2.default("BindingIdentifier", { name: name_14 });
	  }
	}
	exports.default = ScopeApplyingReducer;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2FwcGx5LXNjb3BlLWluLXBhcmFtcy1yZWR1Y2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDZSxNQUFNLG9CQUFOLENBQTJCO0FBQ3hDLGNBQVksT0FBWixFQUFxQixTQUFyQixFQUFnQztBQUM5QixTQUFLLE9BQUwsR0FBZSxTQUFmO0FBQ0EsU0FBSyxLQUFMLEdBQWEsT0FBYjtBQUNEO0FBQ0QsWUFBVSxNQUFWLEVBQWtCO0FBQ2hCLFFBQUksVUFBVSxjQUFjLE9BQU8sSUFBbkM7QUFDQSxRQUFJLE9BQU8sS0FBSyxPQUFMLENBQVAsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkMsYUFBTyxLQUFLLE9BQUwsRUFBYyxNQUFkLENBQVA7QUFDRDtBQUNELHdCQUFPLEtBQVAsRUFBYyx3Q0FBd0MsT0FBTyxJQUE3RDtBQUNEO0FBQ0QsNEJBQTBCLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUksU0FBUyxPQUFPLElBQVAsSUFBZSxJQUFmLEdBQXNCLElBQXRCLEdBQTZCLEtBQUssU0FBTCxDQUFlLE9BQU8sSUFBdEIsQ0FBMUM7QUFDQSxXQUFPLG9CQUFTLGtCQUFULEVBQTZCLEVBQUMsT0FBTyxPQUFPLEtBQVAsQ0FBYSxHQUFiLENBQWlCLFFBQVEsS0FBSyxTQUFMLENBQWUsSUFBZixDQUF6QixDQUFSLEVBQXdELE1BQU0sTUFBOUQsRUFBN0IsQ0FBUDtBQUNEO0FBQ0QsOEJBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDLFdBQU8sb0JBQVMsb0JBQVQsRUFBK0IsRUFBQyxTQUFTLEtBQUssU0FBTCxDQUFlLE9BQU8sT0FBdEIsQ0FBVixFQUEwQyxNQUFNLE9BQU8sSUFBdkQsRUFBL0IsQ0FBUDtBQUNEO0FBQ0QseUJBQXVCLE1BQXZCLEVBQStCO0FBQzdCLFdBQU8sTUFBUDtBQUNEO0FBQ0QscUNBQW1DLE1BQW5DLEVBQTJDO0FBQ3pDLFdBQU8sb0JBQVMsMkJBQVQsRUFBc0MsRUFBQyxTQUFTLEtBQUssU0FBTCxDQUFlLE9BQU8sT0FBdEIsQ0FBVixFQUEwQyxNQUFNLE9BQU8sSUFBdkQsRUFBdEMsQ0FBUDtBQUNEO0FBQ0QsbUNBQWlDLE9BQWpDLEVBQTBDO0FBQ3hDLFdBQU8sb0JBQVMseUJBQVQsRUFBb0MsRUFBQyxNQUFNLFFBQVEsSUFBZixFQUFxQixTQUFTLEtBQUssU0FBTCxDQUFlLFFBQVEsT0FBdkIsQ0FBOUIsRUFBcEMsQ0FBUDtBQUNEO0FBQ0Qsd0JBQXNCLE9BQXRCLEVBQStCO0FBQzdCLFdBQU8sb0JBQVMsY0FBVCxFQUF5QixFQUFDLFVBQVUsUUFBUSxRQUFSLENBQWlCLEdBQWpCLENBQXFCLFNBQVMsS0FBSyxTQUFMLENBQWUsS0FBZixDQUE5QixDQUFYLEVBQWlFLGFBQWEsUUFBUSxXQUFSLElBQXVCLElBQXZCLEdBQThCLElBQTlCLEdBQXFDLEtBQUssU0FBTCxDQUFlLFFBQVEsV0FBdkIsQ0FBbkgsRUFBekIsQ0FBUDtBQUNEO0FBQ0QsNkJBQTJCLE9BQTNCLEVBQW9DO0FBQ2xDLFFBQUksVUFBVSxRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLEtBQUssS0FBM0IsRUFBa0MsS0FBSyxPQUFMLENBQWEsUUFBL0MscUJBQWQ7QUFDQSxRQUFJLGdCQUFnQixvQkFBTyxRQUFRLEdBQVIsRUFBUCxDQUFwQjtBQUNBLFNBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsR0FBakIsQ0FBcUIsY0FBYyxRQUFkLEVBQXJCLEVBQStDLG9DQUF3QixPQUF4QixDQUEvQztBQUNBLFNBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsR0FBdEIsQ0FBMEIsT0FBMUIsRUFBbUMsRUFBQyxTQUFTLGFBQVYsRUFBeUIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUE3QyxFQUFvRCxTQUFTLElBQTdELEVBQW5DO0FBQ0EsV0FBTyxvQkFBUyxtQkFBVCxFQUE4QixFQUFDLE1BQU0sT0FBUCxFQUE5QixDQUFQO0FBQ0Q7QUFyQ3VDO2tCQUFyQixvQiIsImZpbGUiOiJhcHBseS1zY29wZS1pbi1wYXJhbXMtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge2dlbnN5bX0gZnJvbSBcIi4vc3ltYm9sXCI7XG5pbXBvcnQge1ZhckJpbmRpbmdUcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybXNcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7QUxMX1BIQVNFU30gZnJvbSBcIi4vc3ludGF4XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY29wZUFwcGx5aW5nUmVkdWNlciB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlXzAsIGNvbnRleHRfMSkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGVfMDtcbiAgfVxuICB0cmFuc2Zvcm0odGVybV8yKSB7XG4gICAgbGV0IGZpZWxkXzMgPSBcInRyYW5zZm9ybVwiICsgdGVybV8yLnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXzNdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpZWxkXzNdKHRlcm1fMik7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2Zvcm0gbm90IGltcGxlbWVudGVkIHlldCBmb3I6IFwiICsgdGVybV8yLnR5cGUpO1xuICB9XG4gIHRyYW5zZm9ybUZvcm1hbFBhcmFtZXRlcnModGVybV80KSB7XG4gICAgbGV0IHJlc3RfNSA9IHRlcm1fNC5yZXN0ID09IG51bGwgPyBudWxsIDogdGhpcy50cmFuc2Zvcm0odGVybV80LnJlc3QpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiB0ZXJtXzQuaXRlbXMubWFwKGl0XzYgPT4gdGhpcy50cmFuc2Zvcm0oaXRfNikpLCByZXN0OiByZXN0XzV9KTtcbiAgfVxuICB0cmFuc2Zvcm1CaW5kaW5nV2l0aERlZmF1bHQodGVybV83KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybSh0ZXJtXzcuYmluZGluZyksIGluaXQ6IHRlcm1fNy5pbml0fSk7XG4gIH1cbiAgdHJhbnNmb3JtT2JqZWN0QmluZGluZyh0ZXJtXzgpIHtcbiAgICByZXR1cm4gdGVybV84O1xuICB9XG4gIHRyYW5zZm9ybUJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIodGVybV85KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllclwiLCB7YmluZGluZzogdGhpcy50cmFuc2Zvcm0odGVybV85LmJpbmRpbmcpLCBpbml0OiB0ZXJtXzkuaW5pdH0pO1xuICB9XG4gIHRyYW5zZm9ybUJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5KHRlcm1fMTApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGVybV8xMC5uYW1lLCBiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybSh0ZXJtXzEwLmJpbmRpbmcpfSk7XG4gIH1cbiAgdHJhbnNmb3JtQXJyYXlCaW5kaW5nKHRlcm1fMTEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiB0ZXJtXzExLmVsZW1lbnRzLm1hcChlbF8xMiA9PiB0aGlzLnRyYW5zZm9ybShlbF8xMikpLCByZXN0RWxlbWVudDogdGVybV8xMS5yZXN0RWxlbWVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMudHJhbnNmb3JtKHRlcm1fMTEucmVzdEVsZW1lbnQpfSk7XG4gIH1cbiAgdHJhbnNmb3JtQmluZGluZ0lkZW50aWZpZXIodGVybV8xMykge1xuICAgIGxldCBuYW1lXzE0ID0gdGVybV8xMy5uYW1lLmFkZFNjb3BlKHRoaXMuc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUyk7XG4gICAgbGV0IG5ld0JpbmRpbmdfMTUgPSBnZW5zeW0obmFtZV8xNC52YWwoKSk7XG4gICAgdGhpcy5jb250ZXh0LmVudi5zZXQobmV3QmluZGluZ18xNS50b1N0cmluZygpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShuYW1lXzE0KSk7XG4gICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChuYW1lXzE0LCB7YmluZGluZzogbmV3QmluZGluZ18xNSwgcGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSwgc2tpcER1cDogdHJ1ZX0pO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiBuYW1lXzE0fSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(11);

	var _termExpander = __webpack_require__(53);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _tokenExpander = __webpack_require__(49);

	var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

	var _scope = __webpack_require__(43);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Compiler {
	  constructor(phase_33, env_34, store_35, context_36) {
	    this.phase = phase_33;
	    this.env = env_34;
	    this.store = store_35;
	    this.context = context_36;
	  }
	  compile(stxl_37) {
	    let tokenExpander_38 = new _tokenExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store }));
	    let termExpander_39 = new _termExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store }));
	    return _.pipe(_.bind(tokenExpander_38.expand, tokenExpander_38), _.map(t_40 => termExpander_39.expand(t_40)))(stxl_37);
	  }
	}
	exports.default = Compiler;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDRSxNQUFNLFFBQU4sQ0FBZTtBQUM1QixjQUFZLFFBQVosRUFBc0IsTUFBdEIsRUFBOEIsUUFBOUIsRUFBd0MsVUFBeEMsRUFBb0Q7QUFDbEQsU0FBSyxLQUFMLEdBQWEsUUFBYjtBQUNBLFNBQUssR0FBTCxHQUFXLE1BQVg7QUFDQSxTQUFLLEtBQUwsR0FBYSxRQUFiO0FBQ0EsU0FBSyxPQUFMLEdBQWUsVUFBZjtBQUNEO0FBQ0QsVUFBUSxPQUFSLEVBQWlCO0FBQ2YsUUFBSSxtQkFBbUIsNEJBQWtCLEVBQUUsS0FBRixDQUFRLEtBQUssT0FBYixFQUFzQixFQUFDLE9BQU8sS0FBSyxLQUFiLEVBQW9CLEtBQUssS0FBSyxHQUE5QixFQUFtQyxPQUFPLEtBQUssS0FBL0MsRUFBdEIsQ0FBbEIsQ0FBdkI7QUFDQSxRQUFJLGtCQUFrQiwyQkFBaUIsRUFBRSxLQUFGLENBQVEsS0FBSyxPQUFiLEVBQXNCLEVBQUMsT0FBTyxLQUFLLEtBQWIsRUFBb0IsS0FBSyxLQUFLLEdBQTlCLEVBQW1DLE9BQU8sS0FBSyxLQUEvQyxFQUF0QixDQUFqQixDQUF0QjtBQUNBLFdBQU8sRUFBRSxJQUFGLENBQU8sRUFBRSxJQUFGLENBQU8saUJBQWlCLE1BQXhCLEVBQWdDLGdCQUFoQyxDQUFQLEVBQTBELEVBQUUsR0FBRixDQUFNLFFBQVEsZ0JBQWdCLE1BQWhCLENBQXVCLElBQXZCLENBQWQsQ0FBMUQsRUFBdUcsT0FBdkcsQ0FBUDtBQUNEO0FBWDJCO2tCQUFULFEiLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IFRva2VuRXhwYW5kZXIgZnJvbSBcIi4vdG9rZW4tZXhwYW5kZXJcIjtcbmltcG9ydCB7U2NvcGUsIGZyZXNoU2NvcGV9IGZyb20gXCIuL3Njb3BlXCI7XG5pbXBvcnQgICogYXMgXyBmcm9tIFwicmFtZGFcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVyIHtcbiAgY29uc3RydWN0b3IocGhhc2VfMzMsIGVudl8zNCwgc3RvcmVfMzUsIGNvbnRleHRfMzYpIHtcbiAgICB0aGlzLnBoYXNlID0gcGhhc2VfMzM7XG4gICAgdGhpcy5lbnYgPSBlbnZfMzQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlXzM1O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMzY7XG4gIH1cbiAgY29tcGlsZShzdHhsXzM3KSB7XG4gICAgbGV0IHRva2VuRXhwYW5kZXJfMzggPSBuZXcgVG9rZW5FeHBhbmRlcihfLm1lcmdlKHRoaXMuY29udGV4dCwge3BoYXNlOiB0aGlzLnBoYXNlLCBlbnY6IHRoaXMuZW52LCBzdG9yZTogdGhpcy5zdG9yZX0pKTtcbiAgICBsZXQgdGVybUV4cGFuZGVyXzM5ID0gbmV3IFRlcm1FeHBhbmRlcihfLm1lcmdlKHRoaXMuY29udGV4dCwge3BoYXNlOiB0aGlzLnBoYXNlLCBlbnY6IHRoaXMuZW52LCBzdG9yZTogdGhpcy5zdG9yZX0pKTtcbiAgICByZXR1cm4gXy5waXBlKF8uYmluZCh0b2tlbkV4cGFuZGVyXzM4LmV4cGFuZCwgdG9rZW5FeHBhbmRlcl8zOCksIF8ubWFwKHRfNDAgPT4gdGVybUV4cGFuZGVyXzM5LmV4cGFuZCh0XzQwKSkpKHN0eGxfMzcpO1xuICB9XG59XG4iXX0=

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.serializer = exports.makeDeserializer = undefined;

	var _transitJs = __webpack_require__(57);

	var _transitJs2 = _interopRequireDefault(_transitJs);

	var _immutable = __webpack_require__(11);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _symbol = __webpack_require__(44);

	var _tokenizer = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	let typeMap_591 = [_tokenizer.TokenType.STRING, _tokenizer.TokenType.EOS, _tokenizer.TokenType.LPAREN, _tokenizer.TokenType.RPAREN, _tokenizer.TokenType.LBRACK, _tokenizer.TokenType.RBRACK, _tokenizer.TokenType.LBRACE, _tokenizer.TokenType.RBRACE, _tokenizer.TokenType.COLON, _tokenizer.TokenType.SEMICOLON, _tokenizer.TokenType.PERIOD, _tokenizer.TokenType.ELLIPSIS, _tokenizer.TokenType.ARROW, _tokenizer.TokenType.CONDITIONAL, _tokenizer.TokenType.INC, _tokenizer.TokenType.DEC, _tokenizer.TokenType.ASSIGN, _tokenizer.TokenType.ASSIGN_BIT_OR, _tokenizer.TokenType.ASSIGN_BIT_XOR, _tokenizer.TokenType.ASSIGN_BIT_AND, _tokenizer.TokenType.ASSIGN_SHL, _tokenizer.TokenType.ASSIGN_SHR, _tokenizer.TokenType.ASSIGN_SHR_UNSIGNED, _tokenizer.TokenType.ASSIGN_ADD, _tokenizer.TokenType.ASSIGN_SUB, _tokenizer.TokenType.ASSIGN_MUL, _tokenizer.TokenType.ASSIGN_DIV, _tokenizer.TokenType.ASSIGN_MOD, _tokenizer.TokenType.COMMA, _tokenizer.TokenType.OR, _tokenizer.TokenType.AND, _tokenizer.TokenType.BIT_OR, _tokenizer.TokenType.BIT_XOR, _tokenizer.TokenType.BIT_AND, _tokenizer.TokenType.SHL, _tokenizer.TokenType.SHR, _tokenizer.TokenType.SHR_UNSIGNED, _tokenizer.TokenType.ADD, _tokenizer.TokenType.SUB, _tokenizer.TokenType.MUL, _tokenizer.TokenType.DIV, _tokenizer.TokenType.MOD, _tokenizer.TokenType.EQ, _tokenizer.TokenType.NE, _tokenizer.TokenType.EQ_STRICT, _tokenizer.TokenType.NE_STRICT, _tokenizer.TokenType.LT, _tokenizer.TokenType.GT, _tokenizer.TokenType.LTE, _tokenizer.TokenType.GTE, _tokenizer.TokenType.INSTANCEOF, _tokenizer.TokenType.IN, _tokenizer.TokenType.NOT, _tokenizer.TokenType.BIT_NOT, _tokenizer.TokenType.AWAIT, _tokenizer.TokenType.DELETE, _tokenizer.TokenType.TYPEOF, _tokenizer.TokenType.VOID, _tokenizer.TokenType.BREAK, _tokenizer.TokenType.CASE, _tokenizer.TokenType.CATCH, _tokenizer.TokenType.CLASS, _tokenizer.TokenType.CONTINUE, _tokenizer.TokenType.DEBUGGER, _tokenizer.TokenType.DEFAULT, _tokenizer.TokenType.DO, _tokenizer.TokenType.ELSE, _tokenizer.TokenType.EXPORT, _tokenizer.TokenType.EXTENDS, _tokenizer.TokenType.FINALLY, _tokenizer.TokenType.FOR, _tokenizer.TokenType.FUNCTION, _tokenizer.TokenType.IF, _tokenizer.TokenType.IMPORT, _tokenizer.TokenType.LET, _tokenizer.TokenType.NEW, _tokenizer.TokenType.RETURN, _tokenizer.TokenType.SUPER, _tokenizer.TokenType.SWITCH, _tokenizer.TokenType.THIS, _tokenizer.TokenType.THROW, _tokenizer.TokenType.TRY, _tokenizer.TokenType.VAR, _tokenizer.TokenType.WHILE, _tokenizer.TokenType.WITH, _tokenizer.TokenType.NULL, _tokenizer.TokenType.TRUE, _tokenizer.TokenType.FALSE, _tokenizer.TokenType.YIELD, _tokenizer.TokenType.NUMBER, _tokenizer.TokenType.STRING, _tokenizer.TokenType.REGEXP, _tokenizer.TokenType.IDENTIFIER, _tokenizer.TokenType.CONST, _tokenizer.TokenType.TEMPLATE, _tokenizer.TokenType.ILLEGAL];
	let ListHandler_592 = _transitJs2.default.makeWriteHandler({ tag: () => "array", rep: v_598 => v_598 });
	let MapHandler_593 = _transitJs2.default.makeWriteHandler({ tag: function tag(v_599) {
	    return "map";
	  }, rep: function rep(v_600) {
	    return v_600;
	  }, stringRep: function stringRep(v_601) {
	    return null;
	  } });
	let SyntaxHandler_594 = _transitJs2.default.makeWriteHandler({ tag: () => "stx", rep: v_602 => {
	    if (_immutable.List.isList(v_602.token)) {
	      return [v_602.token, v_602.scopesets];
	    } else {
	      let t = _transitJs2.default.objectToMap(v_602.token);
	      t.set("type", typeMap_591.indexOf(v_602.token.type));
	      return [t, v_602.scopesets];
	    }
	  } });
	let SymbolHandler_595 = _transitJs2.default.makeWriteHandler({ tag: () => "symb", rep: v_603 => [v_603.name] });
	let writer_596 = _transitJs2.default.writer("json", { handlers: _transitJs2.default.map([_immutable.List, ListHandler_592, _immutable.Map, MapHandler_593, _syntax2.default, SyntaxHandler_594, _symbol.SymbolClass, SymbolHandler_595]) });
	function makeReader_597(bindings_604) {
	  return _transitJs2.default.reader("json", { arrayBuilder: { init: node_605 => (0, _immutable.List)().asMutable(), add: (ret_606, val_607, node_608) => ret_606.push(val_607), finalize: (ret_609, node_610) => ret_609.asImmutable(), fromArray: (arr_611, node_612) => (0, _immutable.List)(arr_611) }, mapBuilder: { init: function init(node_613) {
	        return (0, _immutable.Map)().asMutable();
	      }, add: function add(ret_614, key_615, val_616, node_617) {
	        return ret_614.set(key_615, val_616);
	      }, finalize: function finalize(ret_618, node_619) {
	        return ret_618.asImmutable();
	      } }, handlers: { stx: rep_620 => {
	        let scopesets_621 = _transitJs2.default.mapToObject(rep_620[1]);
	        if (_immutable.List.isList(rep_620[0])) {
	          let token = rep_620[0];
	          return new _syntax2.default(token, { bindings: bindings_604, scopesets: scopesets_621 });
	        } else {
	          let token = _transitJs2.default.mapToObject(rep_620[0]);
	          token.type = typeMap_591[rep_620[0].get("type")];
	          token.slice = rep_620[0].has("slice") ? _transitJs2.default.mapToObject(rep_620[0].get("slice")) : undefined;
	          if (token.slice) {
	            token.slice.startLocation = _transitJs2.default.mapToObject(token.slice.startLocation);
	          }
	          return new _syntax2.default(token, { bindings: bindings_604, scopesets: scopesets_621 });
	        }
	      }, symb: rep_622 => {
	        return (0, _symbol.Symbol)(rep_622[0]);
	      } } });
	}
	exports.makeDeserializer = makeReader_597;
	exports.serializer = writer_596;
	//# sourceMappingURL=data:application/json;base64,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QUwsQ0FBWSxRQUFRLENBQVIsQ0FBWixDQUFKLEVBQTZCO0FBQzNCLGNBQUksUUFBUSxRQUFRLENBQVIsQ0FBWjtBQUNBLGlCQUFPLHFCQUFXLEtBQVgsRUFBa0IsRUFBQyxVQUFVLFlBQVgsRUFBeUIsV0FBVyxhQUFwQyxFQUFsQixDQUFQO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsY0FBSSxRQUFRLG9CQUFRLFdBQVIsQ0FBb0IsUUFBUSxDQUFSLENBQXBCLENBQVo7QUFDQSxnQkFBTSxJQUFOLEdBQWEsWUFBWSxRQUFRLENBQVIsRUFBVyxHQUFYLENBQWUsTUFBZixDQUFaLENBQWI7QUFDQSxnQkFBTSxLQUFOLEdBQWMsUUFBUSxDQUFSLEVBQVcsR0FBWCxDQUFlLE9BQWYsSUFBMEIsb0JBQVEsV0FBUixDQUFvQixRQUFRLENBQVIsRUFBVyxHQUFYLENBQWUsT0FBZixDQUFwQixDQUExQixHQUF5RSxTQUF2RjtBQUNBLGNBQUksTUFBTSxLQUFWLEVBQWlCO0FBQ2Ysa0JBQU0sS0FBTixDQUFZLGFBQVosR0FBNEIsb0JBQVEsV0FBUixDQUFvQixNQUFNLEtBQU4sQ0FBWSxhQUFoQyxDQUE1QjtBQUNEO0FBQ0QsaUJBQU8scUJBQVcsS0FBWCxFQUFrQixFQUFDLFVBQVUsWUFBWCxFQUF5QixXQUFXLGFBQXBDLEVBQWxCLENBQVA7QUFDRDtBQUNGLE9BZGEsRUFjWCxNQUFNLFdBQVc7QUFDbEIsZUFBTyxvQkFBTyxRQUFRLENBQVIsQ0FBUCxDQUFQO0FBQ0QsT0FoQmEsRUFOZ0IsRUFBdkIsQ0FBUDtBQXVCRDtRQUN5QixnQixHQUFsQixjO1FBQWtELFUsR0FBZCxVIiwiZmlsZSI6InNlcmlhbGl6ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHJhbnNpdCBmcm9tIFwidHJhbnNpdC1qc1wiO1xuaW1wb3J0IHtMaXN0LCBNYXB9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQge1N5bWJvbCwgZ2Vuc3ltLCBTeW1ib2xDbGFzc30gZnJvbSBcIi4vc3ltYm9sXCI7XG5pbXBvcnQge1Rva2VuQ2xhc3MsIFRva2VuVHlwZX0gZnJvbSBcInNoaWZ0LXBhcnNlci9kaXN0L3Rva2VuaXplclwiO1xubGV0IHR5cGVNYXBfNTkxID0gW1Rva2VuVHlwZS5TVFJJTkcsIFRva2VuVHlwZS5FT1MsIFRva2VuVHlwZS5MUEFSRU4sIFRva2VuVHlwZS5SUEFSRU4sIFRva2VuVHlwZS5MQlJBQ0ssIFRva2VuVHlwZS5SQlJBQ0ssIFRva2VuVHlwZS5MQlJBQ0UsIFRva2VuVHlwZS5SQlJBQ0UsIFRva2VuVHlwZS5DT0xPTiwgVG9rZW5UeXBlLlNFTUlDT0xPTiwgVG9rZW5UeXBlLlBFUklPRCwgVG9rZW5UeXBlLkVMTElQU0lTLCBUb2tlblR5cGUuQVJST1csIFRva2VuVHlwZS5DT05ESVRJT05BTCwgVG9rZW5UeXBlLklOQywgVG9rZW5UeXBlLkRFQywgVG9rZW5UeXBlLkFTU0lHTiwgVG9rZW5UeXBlLkFTU0lHTl9CSVRfT1IsIFRva2VuVHlwZS5BU1NJR05fQklUX1hPUiwgVG9rZW5UeXBlLkFTU0lHTl9CSVRfQU5ELCBUb2tlblR5cGUuQVNTSUdOX1NITCwgVG9rZW5UeXBlLkFTU0lHTl9TSFIsIFRva2VuVHlwZS5BU1NJR05fU0hSX1VOU0lHTkVELCBUb2tlblR5cGUuQVNTSUdOX0FERCwgVG9rZW5UeXBlLkFTU0lHTl9TVUIsIFRva2VuVHlwZS5BU1NJR05fTVVMLCBUb2tlblR5cGUuQVNTSUdOX0RJViwgVG9rZW5UeXBlLkFTU0lHTl9NT0QsIFRva2VuVHlwZS5DT01NQSwgVG9rZW5UeXBlLk9SLCBUb2tlblR5cGUuQU5ELCBUb2tlblR5cGUuQklUX09SLCBUb2tlblR5cGUuQklUX1hPUiwgVG9rZW5UeXBlLkJJVF9BTkQsIFRva2VuVHlwZS5TSEwsIFRva2VuVHlwZS5TSFIsIFRva2VuVHlwZS5TSFJfVU5TSUdORUQsIFRva2VuVHlwZS5BREQsIFRva2VuVHlwZS5TVUIsIFRva2VuVHlwZS5NVUwsIFRva2VuVHlwZS5ESVYsIFRva2VuVHlwZS5NT0QsIFRva2VuVHlwZS5FUSwgVG9rZW5UeXBlLk5FLCBUb2tlblR5cGUuRVFfU1RSSUNULCBUb2tlblR5cGUuTkVfU1RSSUNULCBUb2tlblR5cGUuTFQsIFRva2VuVHlwZS5HVCwgVG9rZW5UeXBlLkxURSwgVG9rZW5UeXBlLkdURSwgVG9rZW5UeXBlLklOU1RBTkNFT0YsIFRva2VuVHlwZS5JTiwgVG9rZW5UeXBlLk5PVCwgVG9rZW5UeXBlLkJJVF9OT1QsIFRva2VuVHlwZS5BV0FJVCwgVG9rZW5UeXBlLkRFTEVURSwgVG9rZW5UeXBlLlRZUEVPRiwgVG9rZW5UeXBlLlZPSUQsIFRva2VuVHlwZS5CUkVBSywgVG9rZW5UeXBlLkNBU0UsIFRva2VuVHlwZS5DQVRDSCwgVG9rZW5UeXBlLkNMQVNTLCBUb2tlblR5cGUuQ09OVElOVUUsIFRva2VuVHlwZS5ERUJVR0dFUiwgVG9rZW5UeXBlLkRFRkFVTFQsIFRva2VuVHlwZS5ETywgVG9rZW5UeXBlLkVMU0UsIFRva2VuVHlwZS5FWFBPUlQsIFRva2VuVHlwZS5FWFRFTkRTLCBUb2tlblR5cGUuRklOQUxMWSwgVG9rZW5UeXBlLkZPUiwgVG9rZW5UeXBlLkZVTkNUSU9OLCBUb2tlblR5cGUuSUYsIFRva2VuVHlwZS5JTVBPUlQsIFRva2VuVHlwZS5MRVQsIFRva2VuVHlwZS5ORVcsIFRva2VuVHlwZS5SRVRVUk4sIFRva2VuVHlwZS5TVVBFUiwgVG9rZW5UeXBlLlNXSVRDSCwgVG9rZW5UeXBlLlRISVMsIFRva2VuVHlwZS5USFJPVywgVG9rZW5UeXBlLlRSWSwgVG9rZW5UeXBlLlZBUiwgVG9rZW5UeXBlLldISUxFLCBUb2tlblR5cGUuV0lUSCwgVG9rZW5UeXBlLk5VTEwsIFRva2VuVHlwZS5UUlVFLCBUb2tlblR5cGUuRkFMU0UsIFRva2VuVHlwZS5ZSUVMRCwgVG9rZW5UeXBlLk5VTUJFUiwgVG9rZW5UeXBlLlNUUklORywgVG9rZW5UeXBlLlJFR0VYUCwgVG9rZW5UeXBlLklERU5USUZJRVIsIFRva2VuVHlwZS5DT05TVCwgVG9rZW5UeXBlLlRFTVBMQVRFLCBUb2tlblR5cGUuSUxMRUdBTF07XG5sZXQgTGlzdEhhbmRsZXJfNTkyID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6ICgpID0+IFwiYXJyYXlcIiwgcmVwOiB2XzU5OCA9PiB2XzU5OH0pO1xubGV0IE1hcEhhbmRsZXJfNTkzID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6IGZ1bmN0aW9uICh2XzU5OSkge1xuICByZXR1cm4gXCJtYXBcIjtcbn0sIHJlcDogZnVuY3Rpb24gKHZfNjAwKSB7XG4gIHJldHVybiB2XzYwMDtcbn0sIHN0cmluZ1JlcDogZnVuY3Rpb24gKHZfNjAxKSB7XG4gIHJldHVybiBudWxsO1xufX0pO1xubGV0IFN5bnRheEhhbmRsZXJfNTk0ID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6ICgpID0+IFwic3R4XCIsIHJlcDogdl82MDIgPT4ge1xuICBpZiAoTGlzdC5pc0xpc3Qodl82MDIudG9rZW4pKSB7XG4gICAgcmV0dXJuIFt2XzYwMi50b2tlbiwgdl82MDIuc2NvcGVzZXRzXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdCA9IHRyYW5zaXQub2JqZWN0VG9NYXAodl82MDIudG9rZW4pO1xuICAgIHQuc2V0KFwidHlwZVwiLCB0eXBlTWFwXzU5MS5pbmRleE9mKHZfNjAyLnRva2VuLnR5cGUpKTtcbiAgICByZXR1cm4gW3QsIHZfNjAyLnNjb3Blc2V0c107XG4gIH1cbn19KTtcbmxldCBTeW1ib2xIYW5kbGVyXzU5NSA9IHRyYW5zaXQubWFrZVdyaXRlSGFuZGxlcih7dGFnOiAoKSA9PiBcInN5bWJcIiwgcmVwOiB2XzYwMyA9PiBbdl82MDMubmFtZV19KTtcbmxldCB3cml0ZXJfNTk2ID0gdHJhbnNpdC53cml0ZXIoXCJqc29uXCIsIHtoYW5kbGVyczogdHJhbnNpdC5tYXAoW0xpc3QsIExpc3RIYW5kbGVyXzU5MiwgTWFwLCBNYXBIYW5kbGVyXzU5MywgU3ludGF4LCBTeW50YXhIYW5kbGVyXzU5NCwgU3ltYm9sQ2xhc3MsIFN5bWJvbEhhbmRsZXJfNTk1XSl9KTtcbmZ1bmN0aW9uIG1ha2VSZWFkZXJfNTk3KGJpbmRpbmdzXzYwNCkge1xuICByZXR1cm4gdHJhbnNpdC5yZWFkZXIoXCJqc29uXCIsIHthcnJheUJ1aWxkZXI6IHtpbml0OiBub2RlXzYwNSA9PiBMaXN0KCkuYXNNdXRhYmxlKCksIGFkZDogKHJldF82MDYsIHZhbF82MDcsIG5vZGVfNjA4KSA9PiByZXRfNjA2LnB1c2godmFsXzYwNyksIGZpbmFsaXplOiAocmV0XzYwOSwgbm9kZV82MTApID0+IHJldF82MDkuYXNJbW11dGFibGUoKSwgZnJvbUFycmF5OiAoYXJyXzYxMSwgbm9kZV82MTIpID0+IExpc3QoYXJyXzYxMSl9LCBtYXBCdWlsZGVyOiB7aW5pdDogZnVuY3Rpb24gKG5vZGVfNjEzKSB7XG4gICAgcmV0dXJuIE1hcCgpLmFzTXV0YWJsZSgpO1xuICB9LCBhZGQ6IGZ1bmN0aW9uIChyZXRfNjE0LCBrZXlfNjE1LCB2YWxfNjE2LCBub2RlXzYxNykge1xuICAgIHJldHVybiByZXRfNjE0LnNldChrZXlfNjE1LCB2YWxfNjE2KTtcbiAgfSwgZmluYWxpemU6IGZ1bmN0aW9uIChyZXRfNjE4LCBub2RlXzYxOSkge1xuICAgIHJldHVybiByZXRfNjE4LmFzSW1tdXRhYmxlKCk7XG4gIH19LCBoYW5kbGVyczoge3N0eDogcmVwXzYyMCA9PiB7XG4gICAgbGV0IHNjb3Blc2V0c182MjEgPSB0cmFuc2l0Lm1hcFRvT2JqZWN0KHJlcF82MjBbMV0pO1xuICAgIGlmIChMaXN0LmlzTGlzdChyZXBfNjIwWzBdKSkge1xuICAgICAgbGV0IHRva2VuID0gcmVwXzYyMFswXTtcbiAgICAgIHJldHVybiBuZXcgU3ludGF4KHRva2VuLCB7YmluZGluZ3M6IGJpbmRpbmdzXzYwNCwgc2NvcGVzZXRzOiBzY29wZXNldHNfNjIxfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0b2tlbiA9IHRyYW5zaXQubWFwVG9PYmplY3QocmVwXzYyMFswXSk7XG4gICAgICB0b2tlbi50eXBlID0gdHlwZU1hcF81OTFbcmVwXzYyMFswXS5nZXQoXCJ0eXBlXCIpXTtcbiAgICAgIHRva2VuLnNsaWNlID0gcmVwXzYyMFswXS5oYXMoXCJzbGljZVwiKSA/IHRyYW5zaXQubWFwVG9PYmplY3QocmVwXzYyMFswXS5nZXQoXCJzbGljZVwiKSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodG9rZW4uc2xpY2UpIHtcbiAgICAgICAgdG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbiA9IHRyYW5zaXQubWFwVG9PYmplY3QodG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN5bnRheCh0b2tlbiwge2JpbmRpbmdzOiBiaW5kaW5nc182MDQsIHNjb3Blc2V0czogc2NvcGVzZXRzXzYyMX0pO1xuICAgIH1cbiAgfSwgc3ltYjogcmVwXzYyMiA9PiB7XG4gICAgcmV0dXJuIFN5bWJvbChyZXBfNjIyWzBdKTtcbiAgfX19KTtcbn1cbmV4cG9ydCB7bWFrZVJlYWRlcl81OTcgYXMgbWFrZURlc2VyaWFsaXplciwgd3JpdGVyXzU5NiBhcyBzZXJpYWxpemVyfTtcbiJdfQ==

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.847
	// http://transit-format.org
	// 
	// Copyright 2014 Cognitect. All Rights Reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS-IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License..
	var COMPILED = !0, goog = goog || {};
	goog.global = this;
	goog.isDef = function(a) {
	  return void 0 !== a;
	};
	goog.exportPath_ = function(a, b, c) {
	  a = a.split(".");
	  c = c || goog.global;
	  a[0] in c || !c.execScript || c.execScript("var " + a[0]);
	  for (var d;a.length && (d = a.shift());) {
	    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
	  }
	};
	goog.define = function(a, b) {
	  var c = b;
	  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
	  goog.exportPath_(a, c);
	};
	goog.DEBUG = !0;
	goog.LOCALE = "en";
	goog.TRUSTED_SITE = !0;
	goog.STRICT_MODE_COMPATIBLE = !1;
	goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
	goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
	goog.provide = function(a) {
	  if (!COMPILED && goog.isProvided_(a)) {
	    throw Error('Namespace "' + a + '" already declared.');
	  }
	  goog.constructNamespace_(a);
	};
	goog.constructNamespace_ = function(a, b) {
	  if (!COMPILED) {
	    delete goog.implicitNamespaces_[a];
	    for (var c = a;(c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
	      goog.implicitNamespaces_[c] = !0;
	    }
	  }
	  goog.exportPath_(a, b);
	};
	goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	goog.module = function(a) {
	  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
	    throw Error("Invalid module identifier");
	  }
	  if (!goog.isInModuleLoader_()) {
	    throw Error("Module " + a + " has been loaded incorrectly.");
	  }
	  if (goog.moduleLoaderState_.moduleName) {
	    throw Error("goog.module may only be called once per module.");
	  }
	  goog.moduleLoaderState_.moduleName = a;
	  if (!COMPILED) {
	    if (goog.isProvided_(a)) {
	      throw Error('Namespace "' + a + '" already declared.');
	    }
	    delete goog.implicitNamespaces_[a];
	  }
	};
	goog.module.get = function(a) {
	  return goog.module.getInternal_(a);
	};
	goog.module.getInternal_ = function(a) {
	  if (!COMPILED) {
	    return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
	  }
	};
	goog.moduleLoaderState_ = null;
	goog.isInModuleLoader_ = function() {
	  return null != goog.moduleLoaderState_;
	};
	goog.module.declareTestMethods = function() {
	  if (!goog.isInModuleLoader_()) {
	    throw Error("goog.module.declareTestMethods must be called from within a goog.module");
	  }
	  goog.moduleLoaderState_.declareTestMethods = !0;
	};
	goog.module.declareLegacyNamespace = function() {
	  if (!COMPILED && !goog.isInModuleLoader_()) {
	    throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
	  }
	  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
	    throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
	  }
	  goog.moduleLoaderState_.declareLegacyNamespace = !0;
	};
	goog.setTestOnly = function(a) {
	  if (goog.DISALLOW_TEST_ONLY_CODE) {
	    throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
	  }
	};
	goog.forwardDeclare = function(a) {
	};
	COMPILED || (goog.isProvided_ = function(a) {
	  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
	}, goog.implicitNamespaces_ = {"goog.module":!0});
	goog.getObjectByName = function(a, b) {
	  for (var c = a.split("."), d = b || goog.global, e;e = c.shift();) {
	    if (goog.isDefAndNotNull(d[e])) {
	      d = d[e];
	    } else {
	      return null;
	    }
	  }
	  return d;
	};
	goog.globalize = function(a, b) {
	  var c = b || goog.global, d;
	  for (d in a) {
	    c[d] = a[d];
	  }
	};
	goog.addDependency = function(a, b, c, d) {
	  if (goog.DEPENDENCIES_ENABLED) {
	    var e;
	    a = a.replace(/\\/g, "/");
	    for (var f = goog.dependencies_, g = 0;e = b[g];g++) {
	      f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
	    }
	    for (d = 0;b = c[d];d++) {
	      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
	    }
	  }
	};
	goog.ENABLE_DEBUG_LOADER = !0;
	goog.logToConsole_ = function(a) {
	  goog.global.console && goog.global.console.error(a);
	};
	goog.require = function(a) {
	  if (!COMPILED) {
	    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
	    if (goog.isProvided_(a)) {
	      return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
	    }
	    if (goog.ENABLE_DEBUG_LOADER) {
	      var b = goog.getPathFromDeps_(a);
	      if (b) {
	        return goog.included_[b] = !0, goog.writeScripts_(), null;
	      }
	    }
	    a = "goog.require could not find: " + a;
	    goog.logToConsole_(a);
	    throw Error(a);
	  }
	};
	goog.basePath = "";
	goog.nullFunction = function() {
	};
	goog.abstractMethod = function() {
	  throw Error("unimplemented abstract method");
	};
	goog.addSingletonGetter = function(a) {
	  a.getInstance = function() {
	    if (a.instance_) {
	      return a.instance_;
	    }
	    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
	    return a.instance_ = new a;
	  };
	};
	goog.instantiatedSingletons_ = [];
	goog.LOAD_MODULE_USING_EVAL = !0;
	goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
	goog.loadedModules_ = {};
	goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
	goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {pathIsModule:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {
	  var a = goog.global.document;
	  return "undefined" != typeof a && "write" in a;
	}, goog.findBasePath_ = function() {
	  if (goog.global.CLOSURE_BASE_PATH) {
	    goog.basePath = goog.global.CLOSURE_BASE_PATH;
	  } else {
	    if (goog.inHtmlDocument_()) {
	      for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1;0 <= b;--b) {
	        var c = a[b].src, d = c.lastIndexOf("?"), d = -1 == d ? c.length : d;
	        if ("base.js" == c.substr(d - 7, 7)) {
	          goog.basePath = c.substr(0, d - 7);
	          break;
	        }
	      }
	    }
	  }
	}, goog.importScript_ = function(a, b) {
	  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
	}, goog.IS_OLD_IE_ = !goog.global.atob && goog.global.document && goog.global.document.all, goog.importModule_ = function(a) {
	  goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
	}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {
	  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
	}, goog.loadQueuedModules_ = function() {
	  var a = goog.queuedModules_.length;
	  if (0 < a) {
	    var b = goog.queuedModules_;
	    goog.queuedModules_ = [];
	    for (var c = 0;c < a;c++) {
	      goog.maybeProcessDeferredPath_(b[c]);
	    }
	  }
	}, goog.maybeProcessDeferredDep_ = function(a) {
	  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
	}, goog.isDeferredModule_ = function(a) {
	  return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
	}, goog.allDepsAreAvailable_ = function(a) {
	  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
	    for (var b in goog.dependencies_.requires[a]) {
	      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
	        return !1;
	      }
	    }
	  }
	  return !0;
	}, goog.maybeProcessDeferredPath_ = function(a) {
	  if (a in goog.dependencies_.deferred) {
	    var b = goog.dependencies_.deferred[a];
	    delete goog.dependencies_.deferred[a];
	    goog.globalEval(b);
	  }
	}, goog.loadModule = function(a) {
	  var b = goog.moduleLoaderState_;
	  try {
	    goog.moduleLoaderState_ = {moduleName:void 0, declareTestMethods:!1};
	    var c;
	    if (goog.isFunction(a)) {
	      c = a.call(goog.global, {});
	    } else {
	      if (goog.isString(a)) {
	        c = goog.loadModuleFromSource_.call(goog.global, a);
	      } else {
	        throw Error("Invalid module definition");
	      }
	    }
	    var d = goog.moduleLoaderState_.moduleName;
	    if (!goog.isString(d) || !d) {
	      throw Error('Invalid module name "' + d + '"');
	    }
	    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
	    goog.loadedModules_[d] = c;
	    if (goog.moduleLoaderState_.declareTestMethods) {
	      for (var e in c) {
	        if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
	          goog.global[e] = c[e];
	        }
	      }
	    }
	  } finally {
	    goog.moduleLoaderState_ = b;
	  }
	}, goog.loadModuleFromSource_ = function(a) {
	  eval(a);
	  return {};
	}, goog.writeScriptSrcNode_ = function(a) {
	  goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
	}, goog.appendScriptSrcNode_ = function(a) {
	  var b = goog.global.document, c = b.createElement("script");
	  c.type = "text/javascript";
	  c.src = a;
	  c.defer = !1;
	  c.async = !1;
	  b.head.appendChild(c);
	}, goog.writeScriptTag_ = function(a, b) {
	  if (goog.inHtmlDocument_()) {
	    var c = goog.global.document;
	    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
	      if (/\bdeps.js$/.test(a)) {
	        return !1;
	      }
	      throw Error('Cannot write "' + a + '" after document load');
	    }
	    var d = goog.IS_OLD_IE_;
	    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
	    return !0;
	  }
	  return !1;
	}, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {
	  "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
	  return !0;
	}, goog.writeScripts_ = function() {
	  function a(e) {
	    if (!(e in d.written)) {
	      if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
	        for (var f in d.requires[e]) {
	          if (!goog.isProvided_(f)) {
	            if (f in d.nameToPath) {
	              a(d.nameToPath[f]);
	            } else {
	              throw Error("Undefined nameToPath for " + f);
	            }
	          }
	        }
	      }
	      e in c || (c[e] = !0, b.push(e));
	    }
	  }
	  var b = [], c = {}, d = goog.dependencies_, e;
	  for (e in goog.included_) {
	    d.written[e] || a(e);
	  }
	  for (var f = 0;f < b.length;f++) {
	    e = b[f], goog.dependencies_.written[e] = !0;
	  }
	  var g = goog.moduleLoaderState_;
	  goog.moduleLoaderState_ = null;
	  for (f = 0;f < b.length;f++) {
	    if (e = b[f]) {
	      d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
	    } else {
	      throw goog.moduleLoaderState_ = g, Error("Undefined script input");
	    }
	  }
	  goog.moduleLoaderState_ = g;
	}, goog.getPathFromDeps_ = function(a) {
	  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
	}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
	goog.normalizePath_ = function(a) {
	  a = a.split("/");
	  for (var b = 0;b < a.length;) {
	    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
	  }
	  return a.join("/");
	};
	goog.loadFileSync_ = function(a) {
	  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
	    return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
	  }
	  var b = new goog.global.XMLHttpRequest;
	  b.open("get", a, !1);
	  b.send();
	  return b.responseText;
	};
	goog.retrieveAndExecModule_ = function(a) {
	  if (!COMPILED) {
	    var b = a;
	    a = goog.normalizePath_(a);
	    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, d = goog.loadFileSync_(a);
	    if (null != d) {
	      d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);
	    } else {
	      throw Error("load of " + a + "failed");
	    }
	  }
	};
	goog.typeOf = function(a) {
	  var b = typeof a;
	  if ("object" == b) {
	    if (a) {
	      if (a instanceof Array) {
	        return "array";
	      }
	      if (a instanceof Object) {
	        return b;
	      }
	      var c = Object.prototype.toString.call(a);
	      if ("[object Window]" == c) {
	        return "object";
	      }
	      if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
	        return "array";
	      }
	      if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
	        return "function";
	      }
	    } else {
	      return "null";
	    }
	  } else {
	    if ("function" == b && "undefined" == typeof a.call) {
	      return "object";
	    }
	  }
	  return b;
	};
	goog.isNull = function(a) {
	  return null === a;
	};
	goog.isDefAndNotNull = function(a) {
	  return null != a;
	};
	goog.isArray = function(a) {
	  return "array" == goog.typeOf(a);
	};
	goog.isArrayLike = function(a) {
	  var b = goog.typeOf(a);
	  return "array" == b || "object" == b && "number" == typeof a.length;
	};
	goog.isDateLike = function(a) {
	  return goog.isObject(a) && "function" == typeof a.getFullYear;
	};
	goog.isString = function(a) {
	  return "string" == typeof a;
	};
	goog.isBoolean = function(a) {
	  return "boolean" == typeof a;
	};
	goog.isNumber = function(a) {
	  return "number" == typeof a;
	};
	goog.isFunction = function(a) {
	  return "function" == goog.typeOf(a);
	};
	goog.isObject = function(a) {
	  var b = typeof a;
	  return "object" == b && null != a || "function" == b;
	};
	goog.getUid = function(a) {
	  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
	};
	goog.hasUid = function(a) {
	  return !!a[goog.UID_PROPERTY_];
	};
	goog.removeUid = function(a) {
	  "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
	  try {
	    delete a[goog.UID_PROPERTY_];
	  } catch (b) {
	  }
	};
	goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
	goog.uidCounter_ = 0;
	goog.getHashCode = goog.getUid;
	goog.removeHashCode = goog.removeUid;
	goog.cloneObject = function(a) {
	  var b = goog.typeOf(a);
	  if ("object" == b || "array" == b) {
	    if (a.clone) {
	      return a.clone();
	    }
	    var b = "array" == b ? [] : {}, c;
	    for (c in a) {
	      b[c] = goog.cloneObject(a[c]);
	    }
	    return b;
	  }
	  return a;
	};
	goog.bindNative_ = function(a, b, c) {
	  return a.call.apply(a.bind, arguments);
	};
	goog.bindJs_ = function(a, b, c) {
	  if (!a) {
	    throw Error();
	  }
	  if (2 < arguments.length) {
	    var d = Array.prototype.slice.call(arguments, 2);
	    return function() {
	      var c = Array.prototype.slice.call(arguments);
	      Array.prototype.unshift.apply(c, d);
	      return a.apply(b, c);
	    };
	  }
	  return function() {
	    return a.apply(b, arguments);
	  };
	};
	goog.bind = function(a, b, c) {
	  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
	  return goog.bind.apply(null, arguments);
	};
	goog.partial = function(a, b) {
	  var c = Array.prototype.slice.call(arguments, 1);
	  return function() {
	    var b = c.slice();
	    b.push.apply(b, arguments);
	    return a.apply(this, b);
	  };
	};
	goog.mixin = function(a, b) {
	  for (var c in b) {
	    a[c] = b[c];
	  }
	};
	goog.now = goog.TRUSTED_SITE && Date.now || function() {
	  return +new Date;
	};
	goog.globalEval = function(a) {
	  if (goog.global.execScript) {
	    goog.global.execScript(a, "JavaScript");
	  } else {
	    if (goog.global.eval) {
	      if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
	        goog.global.eval(a);
	      } else {
	        var b = goog.global.document, c = b.createElement("SCRIPT");
	        c.type = "text/javascript";
	        c.defer = !1;
	        c.appendChild(b.createTextNode(a));
	        b.body.appendChild(c);
	        b.body.removeChild(c);
	      }
	    } else {
	      throw Error("goog.globalEval not available");
	    }
	  }
	};
	goog.evalWorksForGlobals_ = null;
	goog.getCssName = function(a, b) {
	  var c = function(a) {
	    return goog.cssNameMapping_[a] || a;
	  }, d = function(a) {
	    a = a.split("-");
	    for (var b = [], d = 0;d < a.length;d++) {
	      b.push(c(a[d]));
	    }
	    return b.join("-");
	  }, d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function(a) {
	    return a;
	  };
	  return b ? a + "-" + d(b) : d(a);
	};
	goog.setCssNameMapping = function(a, b) {
	  goog.cssNameMapping_ = a;
	  goog.cssNameMappingStyle_ = b;
	};
	!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
	goog.getMsg = function(a, b) {
	  b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
	    return d in b ? b[d] : a;
	  }));
	  return a;
	};
	goog.getMsgWithFallback = function(a, b) {
	  return a;
	};
	goog.exportSymbol = function(a, b, c) {
	  goog.exportPath_(a, b, c);
	};
	goog.exportProperty = function(a, b, c) {
	  a[b] = c;
	};
	goog.inherits = function(a, b) {
	  function c() {
	  }
	  c.prototype = b.prototype;
	  a.superClass_ = b.prototype;
	  a.prototype = new c;
	  a.prototype.constructor = a;
	  a.base = function(a, c, f) {
	    for (var g = Array(arguments.length - 2), h = 2;h < arguments.length;h++) {
	      g[h - 2] = arguments[h];
	    }
	    return b.prototype[c].apply(a, g);
	  };
	};
	goog.base = function(a, b, c) {
	  var d = arguments.callee.caller;
	  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
	    throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
	  }
	  if (d.superClass_) {
	    for (var e = Array(arguments.length - 1), f = 1;f < arguments.length;f++) {
	      e[f - 1] = arguments[f];
	    }
	    return d.superClass_.constructor.apply(a, e);
	  }
	  e = Array(arguments.length - 2);
	  for (f = 2;f < arguments.length;f++) {
	    e[f - 2] = arguments[f];
	  }
	  for (var f = !1, g = a.constructor;g;g = g.superClass_ && g.superClass_.constructor) {
	    if (g.prototype[b] === d) {
	      f = !0;
	    } else {
	      if (f) {
	        return g.prototype[b].apply(a, e);
	      }
	    }
	  }
	  if (a[b] === d) {
	    return a.constructor.prototype[b].apply(a, e);
	  }
	  throw Error("goog.base called from a method of one name to a method of a different name");
	};
	goog.scope = function(a) {
	  a.call(goog.global);
	};
	COMPILED || (goog.global.COMPILED = COMPILED);
	goog.defineClass = function(a, b) {
	  var c = b.constructor, d = b.statics;
	  c && c != Object.prototype.constructor || (c = function() {
	    throw Error("cannot instantiate an interface (no constructor defined).");
	  });
	  c = goog.defineClass.createSealingConstructor_(c, a);
	  a && goog.inherits(c, a);
	  delete b.constructor;
	  delete b.statics;
	  goog.defineClass.applyProperties_(c.prototype, b);
	  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
	  return c;
	};
	goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
	goog.defineClass.createSealingConstructor_ = function(a, b) {
	  if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
	    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
	      return a;
	    }
	    var c = function() {
	      var b = a.apply(this, arguments) || this;
	      b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
	      this.constructor === c && Object.seal(b);
	      return b;
	    };
	    return c;
	  }
	  return a;
	};
	goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.defineClass.applyProperties_ = function(a, b) {
	  for (var c in b) {
	    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
	  }
	  for (var d = 0;d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++) {
	    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
	  }
	};
	goog.tagUnsealableClass = function(a) {
	  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
	};
	goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
	goog.math = {};
	goog.math.Long = function(a, b) {
	  this.low_ = a | 0;
	  this.high_ = b | 0;
	};
	goog.math.Long.IntCache_ = {};
	goog.math.Long.fromInt = function(a) {
	  if (-128 <= a && 128 > a) {
	    var b = goog.math.Long.IntCache_[a];
	    if (b) {
	      return b;
	    }
	  }
	  b = new goog.math.Long(a | 0, 0 > a ? -1 : 0);
	  -128 <= a && 128 > a && (goog.math.Long.IntCache_[a] = b);
	  return b;
	};
	goog.math.Long.fromNumber = function(a) {
	  return isNaN(a) || !isFinite(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);
	};
	goog.math.Long.fromBits = function(a, b) {
	  return new goog.math.Long(a, b);
	};
	goog.math.Long.fromString = function(a, b) {
	  if (0 == a.length) {
	    throw Error("number format error: empty string");
	  }
	  var c = b || 10;
	  if (2 > c || 36 < c) {
	    throw Error("radix out of range: " + c);
	  }
	  if ("-" == a.charAt(0)) {
	    return goog.math.Long.fromString(a.substring(1), c).negate();
	  }
	  if (0 <= a.indexOf("-")) {
	    throw Error('number format error: interior "-" character: ' + a);
	  }
	  for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0;f < a.length;f += 8) {
	    var g = Math.min(8, a.length - f), h = parseInt(a.substring(f, f + g), c);
	    8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));
	  }
	  return e;
	};
	goog.math.Long.TWO_PWR_16_DBL_ = 65536;
	goog.math.Long.getTwoPwr24DBL_ = 16777216;
	goog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
	goog.math.Long.TWO_PWR_31_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ / 2;
	goog.math.Long.TWO_PWR_48_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
	goog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;
	goog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;
	goog.math.Long.getZero = function() {
	  goog.math.Long.ZERO_ || (goog.math.Long.ZERO_ = goog.math.Long.fromInt(0));
	  return goog.math.Long.ZERO_;
	};
	goog.math.Long.getOne = function() {
	  goog.math.Long.ONE_ || (goog.math.Long.ONE_ = goog.math.Long.fromInt(1));
	  return goog.math.Long.ONE_;
	};
	goog.math.Long.getNegOne = function() {
	  goog.math.Long.NEG_ONE_ || (goog.math.Long.NEG_ONE_ = goog.math.Long.fromInt(-1));
	  return goog.math.Long.NEG_ONE_;
	};
	goog.math.Long.getMaxValue = function() {
	  goog.math.Long.MAX_VALUE_ || (goog.math.Long.MAX_VALUE_ = goog.math.Long.fromBits(-1, 2147483647));
	  return goog.math.Long.MAX_VALUE_;
	};
	goog.math.Long.getMinValue = function() {
	  goog.math.Long.MIN_VALUE_ || (goog.math.Long.MIN_VALUE_ = goog.math.Long.fromBits(0, -2147483648));
	  return goog.math.Long.MIN_VALUE_;
	};
	goog.math.Long.getTwoPwr24 = function() {
	  goog.math.Long.TWO_PWR_24_ || (goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(16777216));
	  return goog.math.Long.TWO_PWR_24_;
	};
	goog.math.Long.prototype.toInt = function() {
	  return this.low_;
	};
	goog.math.Long.prototype.toNumber = function() {
	  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
	};
	goog.math.Long.prototype.toString = function(a) {
	  a = a || 10;
	  if (2 > a || 36 < a) {
	    throw Error("radix out of range: " + a);
	  }
	  if (this.isZero()) {
	    return "0";
	  }
	  if (this.isNegative()) {
	    if (this.equals(goog.math.Long.getMinValue())) {
	      var b = goog.math.Long.fromNumber(a), c = this.div(b), b = c.multiply(b).subtract(this);
	      return c.toString(a) + b.toInt().toString(a);
	    }
	    return "-" + this.negate().toString(a);
	  }
	  for (var c = goog.math.Long.fromNumber(Math.pow(a, 6)), b = this, d = "";;) {
	    var e = b.div(c), f = b.subtract(e.multiply(c)).toInt().toString(a), b = e;
	    if (b.isZero()) {
	      return f + d;
	    }
	    for (;6 > f.length;) {
	      f = "0" + f;
	    }
	    d = "" + f + d;
	  }
	};
	goog.math.Long.prototype.getHighBits = function() {
	  return this.high_;
	};
	goog.math.Long.prototype.getLowBits = function() {
	  return this.low_;
	};
	goog.math.Long.prototype.getLowBitsUnsigned = function() {
	  return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
	};
	goog.math.Long.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
	  }
	  for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31;0 < b && 0 == (a & 1 << b);b--) {
	  }
	  return 0 != this.high_ ? b + 33 : b + 1;
	};
	goog.math.Long.prototype.isZero = function() {
	  return 0 == this.high_ && 0 == this.low_;
	};
	goog.math.Long.prototype.isNegative = function() {
	  return 0 > this.high_;
	};
	goog.math.Long.prototype.isOdd = function() {
	  return 1 == (this.low_ & 1);
	};
	goog.math.Long.prototype.equals = function(a) {
	  return this.high_ == a.high_ && this.low_ == a.low_;
	};
	goog.math.Long.prototype.notEquals = function(a) {
	  return this.high_ != a.high_ || this.low_ != a.low_;
	};
	goog.math.Long.prototype.lessThan = function(a) {
	  return 0 > this.compare(a);
	};
	goog.math.Long.prototype.lessThanOrEqual = function(a) {
	  return 0 >= this.compare(a);
	};
	goog.math.Long.prototype.greaterThan = function(a) {
	  return 0 < this.compare(a);
	};
	goog.math.Long.prototype.greaterThanOrEqual = function(a) {
	  return 0 <= this.compare(a);
	};
	goog.math.Long.prototype.compare = function(a) {
	  if (this.equals(a)) {
	    return 0;
	  }
	  var b = this.isNegative(), c = a.isNegative();
	  return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;
	};
	goog.math.Long.prototype.negate = function() {
	  return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());
	};
	goog.math.Long.prototype.add = function(a) {
	  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = a.high_ >>> 16, f = a.high_ & 65535, g = a.low_ >>> 16, h;
	  h = 0 + ((this.low_ & 65535) + (a.low_ & 65535));
	  a = 0 + (h >>> 16);
	  a += d + g;
	  d = 0 + (a >>> 16);
	  d += c + f;
	  c = 0 + (d >>> 16);
	  c = c + (b + e) & 65535;
	  return goog.math.Long.fromBits((a & 65535) << 16 | h & 65535, c << 16 | d & 65535);
	};
	goog.math.Long.prototype.subtract = function(a) {
	  return this.add(a.negate());
	};
	goog.math.Long.prototype.multiply = function(a) {
	  if (this.isZero() || a.isZero()) {
	    return goog.math.Long.getZero();
	  }
	  if (this.equals(goog.math.Long.getMinValue())) {
	    return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
	  }
	  if (a.equals(goog.math.Long.getMinValue())) {
	    return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
	  }
	  if (this.isNegative()) {
	    return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
	  }
	  if (a.isNegative()) {
	    return this.multiply(a.negate()).negate();
	  }
	  if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {
	    return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());
	  }
	  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = this.low_ & 65535, f = a.high_ >>> 16, g = a.high_ & 65535, h = a.low_ >>> 16;
	  a = a.low_ & 65535;
	  var m, k, l, n;
	  n = 0 + e * a;
	  l = 0 + (n >>> 16);
	  l += d * a;
	  k = 0 + (l >>> 16);
	  l = (l & 65535) + e * h;
	  k += l >>> 16;
	  l &= 65535;
	  k += c * a;
	  m = 0 + (k >>> 16);
	  k = (k & 65535) + d * h;
	  m += k >>> 16;
	  k &= 65535;
	  k += e * g;
	  m += k >>> 16;
	  k &= 65535;
	  m = m + (b * a + c * h + d * g + e * f) & 65535;
	  return goog.math.Long.fromBits(l << 16 | n & 65535, m << 16 | k);
	};
	goog.math.Long.prototype.div = function(a) {
	  if (a.isZero()) {
	    throw Error("division by zero");
	  }
	  if (this.isZero()) {
	    return goog.math.Long.getZero();
	  }
	  if (this.equals(goog.math.Long.getMinValue())) {
	    if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {
	      return goog.math.Long.getMinValue();
	    }
	    if (a.equals(goog.math.Long.getMinValue())) {
	      return goog.math.Long.getOne();
	    }
	    var b = this.shiftRight(1).div(a).shiftLeft(1);
	    if (b.equals(goog.math.Long.getZero())) {
	      return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();
	    }
	    var c = this.subtract(a.multiply(b));
	    return b.add(c.div(a));
	  }
	  if (a.equals(goog.math.Long.getMinValue())) {
	    return goog.math.Long.getZero();
	  }
	  if (this.isNegative()) {
	    return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
	  }
	  if (a.isNegative()) {
	    return this.div(a.negate()).negate();
	  }
	  for (var d = goog.math.Long.getZero(), c = this;c.greaterThanOrEqual(a);) {
	    for (var b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())), e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a);g.isNegative() || g.greaterThan(c);) {
	      b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);
	    }
	    f.isZero() && (f = goog.math.Long.getOne());
	    d = d.add(f);
	    c = c.subtract(g);
	  }
	  return d;
	};
	goog.math.Long.prototype.modulo = function(a) {
	  return this.subtract(this.div(a).multiply(a));
	};
	goog.math.Long.prototype.not = function() {
	  return goog.math.Long.fromBits(~this.low_, ~this.high_);
	};
	goog.math.Long.prototype.and = function(a) {
	  return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);
	};
	goog.math.Long.prototype.or = function(a) {
	  return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);
	};
	goog.math.Long.prototype.xor = function(a) {
	  return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);
	};
	goog.math.Long.prototype.shiftLeft = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.low_;
	  return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);
	};
	goog.math.Long.prototype.shiftRight = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.high_;
	  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);
	};
	goog.math.Long.prototype.shiftRightUnsigned = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.high_;
	  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);
	};
	goog.object = {};
	goog.object.forEach = function(a, b, c) {
	  for (var d in a) {
	    b.call(c, a[d], d, a);
	  }
	};
	goog.object.filter = function(a, b, c) {
	  var d = {}, e;
	  for (e in a) {
	    b.call(c, a[e], e, a) && (d[e] = a[e]);
	  }
	  return d;
	};
	goog.object.map = function(a, b, c) {
	  var d = {}, e;
	  for (e in a) {
	    d[e] = b.call(c, a[e], e, a);
	  }
	  return d;
	};
	goog.object.some = function(a, b, c) {
	  for (var d in a) {
	    if (b.call(c, a[d], d, a)) {
	      return !0;
	    }
	  }
	  return !1;
	};
	goog.object.every = function(a, b, c) {
	  for (var d in a) {
	    if (!b.call(c, a[d], d, a)) {
	      return !1;
	    }
	  }
	  return !0;
	};
	goog.object.getCount = function(a) {
	  var b = 0, c;
	  for (c in a) {
	    b++;
	  }
	  return b;
	};
	goog.object.getAnyKey = function(a) {
	  for (var b in a) {
	    return b;
	  }
	};
	goog.object.getAnyValue = function(a) {
	  for (var b in a) {
	    return a[b];
	  }
	};
	goog.object.contains = function(a, b) {
	  return goog.object.containsValue(a, b);
	};
	goog.object.getValues = function(a) {
	  var b = [], c = 0, d;
	  for (d in a) {
	    b[c++] = a[d];
	  }
	  return b;
	};
	goog.object.getKeys = function(a) {
	  var b = [], c = 0, d;
	  for (d in a) {
	    b[c++] = d;
	  }
	  return b;
	};
	goog.object.getValueByKeys = function(a, b) {
	  for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1;c < d.length && (a = a[d[c]], goog.isDef(a));c++) {
	  }
	  return a;
	};
	goog.object.containsKey = function(a, b) {
	  return b in a;
	};
	goog.object.containsValue = function(a, b) {
	  for (var c in a) {
	    if (a[c] == b) {
	      return !0;
	    }
	  }
	  return !1;
	};
	goog.object.findKey = function(a, b, c) {
	  for (var d in a) {
	    if (b.call(c, a[d], d, a)) {
	      return d;
	    }
	  }
	};
	goog.object.findValue = function(a, b, c) {
	  return (b = goog.object.findKey(a, b, c)) && a[b];
	};
	goog.object.isEmpty = function(a) {
	  for (var b in a) {
	    return !1;
	  }
	  return !0;
	};
	goog.object.clear = function(a) {
	  for (var b in a) {
	    delete a[b];
	  }
	};
	goog.object.remove = function(a, b) {
	  var c;
	  (c = b in a) && delete a[b];
	  return c;
	};
	goog.object.add = function(a, b, c) {
	  if (b in a) {
	    throw Error('The object already contains the key "' + b + '"');
	  }
	  goog.object.set(a, b, c);
	};
	goog.object.get = function(a, b, c) {
	  return b in a ? a[b] : c;
	};
	goog.object.set = function(a, b, c) {
	  a[b] = c;
	};
	goog.object.setIfUndefined = function(a, b, c) {
	  return b in a ? a[b] : a[b] = c;
	};
	goog.object.setWithReturnValueIfNotSet = function(a, b, c) {
	  if (b in a) {
	    return a[b];
	  }
	  c = c();
	  return a[b] = c;
	};
	goog.object.equals = function(a, b) {
	  for (var c in a) {
	    if (!(c in b) || a[c] !== b[c]) {
	      return !1;
	    }
	  }
	  for (c in b) {
	    if (!(c in a)) {
	      return !1;
	    }
	  }
	  return !0;
	};
	goog.object.clone = function(a) {
	  var b = {}, c;
	  for (c in a) {
	    b[c] = a[c];
	  }
	  return b;
	};
	goog.object.unsafeClone = function(a) {
	  var b = goog.typeOf(a);
	  if ("object" == b || "array" == b) {
	    if (a.clone) {
	      return a.clone();
	    }
	    var b = "array" == b ? [] : {}, c;
	    for (c in a) {
	      b[c] = goog.object.unsafeClone(a[c]);
	    }
	    return b;
	  }
	  return a;
	};
	goog.object.transpose = function(a) {
	  var b = {}, c;
	  for (c in a) {
	    b[a[c]] = c;
	  }
	  return b;
	};
	goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.object.extend = function(a, b) {
	  for (var c, d, e = 1;e < arguments.length;e++) {
	    d = arguments[e];
	    for (c in d) {
	      a[c] = d[c];
	    }
	    for (var f = 0;f < goog.object.PROTOTYPE_FIELDS_.length;f++) {
	      c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
	    }
	  }
	};
	goog.object.create = function(a) {
	  var b = arguments.length;
	  if (1 == b && goog.isArray(arguments[0])) {
	    return goog.object.create.apply(null, arguments[0]);
	  }
	  if (b % 2) {
	    throw Error("Uneven number of arguments");
	  }
	  for (var c = {}, d = 0;d < b;d += 2) {
	    c[arguments[d]] = arguments[d + 1];
	  }
	  return c;
	};
	goog.object.createSet = function(a) {
	  var b = arguments.length;
	  if (1 == b && goog.isArray(arguments[0])) {
	    return goog.object.createSet.apply(null, arguments[0]);
	  }
	  for (var c = {}, d = 0;d < b;d++) {
	    c[arguments[d]] = !0;
	  }
	  return c;
	};
	goog.object.createImmutableView = function(a) {
	  var b = a;
	  Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
	  return b;
	};
	goog.object.isImmutableView = function(a) {
	  return !!Object.isFrozen && Object.isFrozen(a);
	};
	var com = {cognitect:{}};
	com.cognitect.transit = {};
	com.cognitect.transit.delimiters = {};
	com.cognitect.transit.delimiters.ESC = "~";
	com.cognitect.transit.delimiters.TAG = "#";
	com.cognitect.transit.delimiters.SUB = "^";
	com.cognitect.transit.delimiters.RES = "`";
	com.cognitect.transit.delimiters.ESC_TAG = "~#";
	com.cognitect.transit.caching = {};
	com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
	com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
	com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
	com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
	com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
	com.cognitect.transit.caching.isCacheable = function(a, b) {
	  if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
	    if (b) {
	      return !0;
	    }
	    var c = a.charAt(0), d = a.charAt(1);
	    return c === com.cognitect.transit.delimiters.ESC ? ":" === d || "$" === d || "#" === d : !1;
	  }
	  return !1;
	};
	com.cognitect.transit.caching.idxToCode = function(a) {
	  var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
	  a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
	  return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;
	};
	com.cognitect.transit.caching.WriteCache = function() {
	  this.cacheSize = this.gen = this.idx = 0;
	  this.cache = {};
	};
	com.cognitect.transit.caching.WriteCache.prototype.write = function(a, b) {
	  if (com.cognitect.transit.caching.isCacheable(a, b)) {
	    this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();
	    var c = this.cache[a];
	    return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];
	  }
	  return a;
	};
	com.cognitect.transit.caching.WriteCache.prototype.clear = function() {
	  this.idx = 0;
	  this.gen++;
	};
	com.cognitect.transit.caching.writeCache = function() {
	  return new com.cognitect.transit.caching.WriteCache;
	};
	com.cognitect.transit.caching.isCacheCode = function(a) {
	  return a.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a.charAt(1);
	};
	com.cognitect.transit.caching.codeToIdx = function(a) {
	  if (2 === a.length) {
	    return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
	  }
	  var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
	  a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
	  return b + a;
	};
	com.cognitect.transit.caching.ReadCache = function() {
	  this.idx = 0;
	  this.cache = [];
	};
	com.cognitect.transit.caching.ReadCache.prototype.write = function(a, b) {
	  this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
	  this.cache[this.idx] = a;
	  this.idx++;
	  return a;
	};
	com.cognitect.transit.caching.ReadCache.prototype.read = function(a, b) {
	  return this.cache[com.cognitect.transit.caching.codeToIdx(a)];
	};
	com.cognitect.transit.caching.ReadCache.prototype.clear = function() {
	  this.idx = 0;
	};
	com.cognitect.transit.caching.readCache = function() {
	  return new com.cognitect.transit.caching.ReadCache;
	};
	com.cognitect.transit.util = {};
	com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function(a) {
	  return Object.keys(a);
	} : function(a) {
	  return goog.object.getKeys(a);
	};
	com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function(a) {
	  return Array.isArray(a);
	} : function(a) {
	  return "array" === goog.typeOf(a);
	};
	com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	com.cognitect.transit.util.randInt = function(a) {
	  return Math.round(Math.random() * a);
	};
	com.cognitect.transit.util.randHex = function() {
	  return com.cognitect.transit.util.randInt(15).toString(16);
	};
	com.cognitect.transit.util.randomUUID = function() {
	  var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
	  return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + 
	  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + 
	  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
	};
	com.cognitect.transit.util.btoa = function(a) {
	  if ("undefined" != typeof btoa) {
	    return btoa(a);
	  }
	  a = String(a);
	  for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = "";a.charAt(d | 0) || (e = "=", d % 1);f += e.charAt(63 & b >> 8 - d % 1 * 8)) {
	    c = a.charCodeAt(d += .75);
	    if (255 < c) {
	      throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	    }
	    b = b << 8 | c;
	  }
	  return f;
	};
	com.cognitect.transit.util.atob = function(a) {
	  if ("undefined" != typeof atob) {
	    return atob(a);
	  }
	  a = String(a).replace(/=+$/, "");
	  if (1 == a.length % 4) {
	    throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
	  }
	  for (var b = 0, c, d, e = 0, f = "";d = a.charAt(e++);~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {
	    d = com.cognitect.transit.util.chars.indexOf(d);
	  }
	  return f;
	};
	com.cognitect.transit.util.Uint8ToBase64 = function(a) {
	  for (var b = 0, c = a.length, d = "", e = null;b < c;) {
	    e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;
	  }
	  return com.cognitect.transit.util.btoa(d);
	};
	com.cognitect.transit.util.Base64ToUint8 = function(a) {
	  a = com.cognitect.transit.util.atob(a);
	  for (var b = a.length, c = new Uint8Array(b), d = 0;d < b;d++) {
	    var e = a.charCodeAt(d);
	    c[d] = e;
	  }
	  return c;
	};
	com.cognitect.transit.eq = {};
	com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
	com.cognitect.transit.eq.hashCodeCounter = 1;
	com.cognitect.transit.eq.equals = function(a, b) {
	  if (null == a) {
	    return null == b;
	  }
	  if (a === b) {
	    return !0;
	  }
	  if ("object" === typeof a) {
	    if (com.cognitect.transit.util.isArray(a)) {
	      if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {
	        for (var c = 0;c < a.length;c++) {
	          if (!com.cognitect.transit.eq.equals(a[c], b[c])) {
	            return !1;
	          }
	        }
	        return !0;
	      }
	      return !1;
	    }
	    if (a.com$cognitect$transit$equals) {
	      return a.com$cognitect$transit$equals(b);
	    }
	    if (null != b && "object" === typeof b) {
	      if (b.com$cognitect$transit$equals) {
	        return b.com$cognitect$transit$equals(a);
	      }
	      var c = 0, d = com.cognitect.transit.util.objectKeys(b).length, e;
	      for (e in a) {
	        if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {
	          return !1;
	        }
	      }
	      return c === d;
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.eq.hashCombine = function(a, b) {
	  return a ^ b + 2654435769 + (a << 6) + (a >> 2);
	};
	com.cognitect.transit.eq.stringCodeCache = {};
	com.cognitect.transit.eq.stringCodeCacheSize = 0;
	com.cognitect.transit.eq.STR_CACHE_MAX = 256;
	com.cognitect.transit.eq.hashString = function(a) {
	  var b = com.cognitect.transit.eq.stringCodeCache[a];
	  if (null != b) {
	    return b;
	  }
	  for (var c = b = 0;c < a.length;++c) {
	    b = 31 * b + a.charCodeAt(c), b %= 4294967296;
	  }
	  com.cognitect.transit.eq.stringCodeCacheSize++;
	  com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
	  return com.cognitect.transit.eq.stringCodeCache[a] = b;
	};
	com.cognitect.transit.eq.hashMapLike = function(a) {
	  var b = 0;
	  if (null != a.forEach) {
	    a.forEach(function(a, c, d) {
	      b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;
	    });
	  } else {
	    for (var c = com.cognitect.transit.util.objectKeys(a), d = 0;d < c.length;d++) {
	      var e = c[d], f = a[e], b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496
	    }
	  }
	  return b;
	};
	com.cognitect.transit.eq.hashArrayLike = function(a) {
	  var b = 0;
	  if (com.cognitect.transit.util.isArray(a)) {
	    for (var c = 0;c < a.length;c++) {
	      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));
	    }
	  } else {
	    a.forEach && a.forEach(function(a, c) {
	      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));
	    });
	  }
	  return b;
	};
	com.cognitect.transit.eq.hashCode = function(a) {
	  if (null == a) {
	    return 0;
	  }
	  switch(typeof a) {
	    case "number":
	      return a;
	    case "boolean":
	      return !0 === a ? 1 : 0;
	    case "string":
	      return com.cognitect.transit.eq.hashString(a);
	    case "function":
	      var b = a[com.cognitect.transit.eq.hashCodeProperty];
	      b || (b = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, {value:b, enumerable:!1}) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);
	      return b;
	    default:
	      return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);
	  }
	};
	com.cognitect.transit.eq.extendToEQ = function(a, b) {
	  a.com$cognitect$transit$hashCode = b.hashCode;
	  a.com$cognitect$transit$equals = b.equals;
	  return a;
	};
	com.cognitect.transit.types = {};
	com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
	com.cognitect.transit.types.TaggedValue = function(a, b) {
	  this.tag = a;
	  this.rep = b;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.TaggedValue.prototype.toString = function() {
	  return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
	};
	com.cognitect.transit.types.TaggedValue.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
	com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;
	};
	com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
	  return this.hashCode;
	};
	com.cognitect.transit.types.taggedValue = function(a, b) {
	  return new com.cognitect.transit.types.TaggedValue(a, b);
	};
	com.cognitect.transit.types.isTaggedValue = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue;
	};
	com.cognitect.transit.types.nullValue = function() {
	  return null;
	};
	com.cognitect.transit.types.boolValue = function(a) {
	  return "t" === a;
	};
	com.cognitect.transit.types.MAX_INT = goog.math.Long.fromString("9007199254740991");
	com.cognitect.transit.types.MIN_INT = goog.math.Long.fromString("-9007199254740991");
	com.cognitect.transit.types.intValue = function(a) {
	  if ("number" === typeof a || a instanceof goog.math.Long) {
	    return a;
	  }
	  a = goog.math.Long.fromString(a, 10);
	  return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();
	};
	goog.math.Long.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	goog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;
	goog.math.Long.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof goog.math.Long && this.equals(a);
	};
	goog.math.Long.prototype.com$cognitect$transit$hashCode = function() {
	  return this.toInt();
	};
	com.cognitect.transit.types.isInteger = function(a) {
	  return a instanceof goog.math.Long ? !0 : "number" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);
	};
	com.cognitect.transit.types.floatValue = function(a) {
	  return parseFloat(a);
	};
	com.cognitect.transit.types.bigInteger = function(a) {
	  return com.cognitect.transit.types.taggedValue("n", a);
	};
	com.cognitect.transit.types.isBigInteger = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "n" === a.tag;
	};
	com.cognitect.transit.types.bigDecimalValue = function(a) {
	  return com.cognitect.transit.types.taggedValue("f", a);
	};
	com.cognitect.transit.types.isBigDecimal = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "f" === a.tag;
	};
	com.cognitect.transit.types.charValue = function(a) {
	  return a;
	};
	com.cognitect.transit.types.Keyword = function(a) {
	  this._name = a;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.Keyword.prototype.toString = function() {
	  return ":" + this._name;
	};
	com.cognitect.transit.types.Keyword.prototype.namespace = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(0, a) : null;
	};
	com.cognitect.transit.types.Keyword.prototype.name = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
	};
	com.cognitect.transit.types.Keyword.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
	com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;
	};
	com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
	  return this.hashCode;
	};
	com.cognitect.transit.types.keyword = function(a) {
	  return new com.cognitect.transit.types.Keyword(a);
	};
	com.cognitect.transit.types.isKeyword = function(a) {
	  return a instanceof com.cognitect.transit.types.Keyword;
	};
	com.cognitect.transit.types.Symbol = function(a) {
	  this._name = a;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.Symbol.prototype.namespace = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(0, a) : null;
	};
	com.cognitect.transit.types.Symbol.prototype.name = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
	};
	com.cognitect.transit.types.Symbol.prototype.toString = function() {
	  return this._name;
	};
	com.cognitect.transit.types.Symbol.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
	com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;
	};
	com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
	  return this.hashCode;
	};
	com.cognitect.transit.types.symbol = function(a) {
	  return new com.cognitect.transit.types.Symbol(a);
	};
	com.cognitect.transit.types.isSymbol = function(a) {
	  return a instanceof com.cognitect.transit.types.Symbol;
	};
	com.cognitect.transit.types.hexFor = function(a, b, c) {
	  var d = "";
	  c = c || b + 1;
	  for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e);b < c;b++, e -= 8, f = f.shiftRightUnsigned(8)) {
	    var g = a.and(f).shiftRightUnsigned(e).toString(16);
	    1 == g.length && (g = "0" + g);
	    d += g;
	  }
	  return d;
	};
	com.cognitect.transit.types.UUID = function(a, b) {
	  this.high = a;
	  this.low = b;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {
	  return this.low;
	};
	com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {
	  return this.high;
	};
	com.cognitect.transit.types.UUID.prototype.toString = function() {
	  var a, b = this.high, c = this.low;
	  a = "" + (com.cognitect.transit.types.hexFor(b, 0, 4) + "-");
	  a += com.cognitect.transit.types.hexFor(b, 4, 6) + "-";
	  a += com.cognitect.transit.types.hexFor(b, 6, 8) + "-";
	  a += com.cognitect.transit.types.hexFor(c, 0, 2) + "-";
	  return a += com.cognitect.transit.types.hexFor(c, 2, 8);
	};
	com.cognitect.transit.types.UUID.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
	com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);
	};
	com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
	  return this.hashCode;
	};
	com.cognitect.transit.types.UUIDfromString = function(a) {
	  a = a.replace(/-/g, "");
	  for (var b = null, c = null, d = c = 0, e = 24, f = 0, f = c = 0, e = 24;8 > f;f += 2, e -= 8) {
	    c |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  d = 0;
	  f = 8;
	  for (e = 24;16 > f;f += 2, e -= 8) {
	    d |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  b = goog.math.Long.fromBits(d, c);
	  c = 0;
	  f = 16;
	  for (e = 24;24 > f;f += 2, e -= 8) {
	    c |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  d = 0;
	  for (e = f = 24;32 > f;f += 2, e -= 8) {
	    d |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  c = goog.math.Long.fromBits(d, c);
	  return new com.cognitect.transit.types.UUID(b, c);
	};
	com.cognitect.transit.types.uuid = function(a) {
	  return com.cognitect.transit.types.UUIDfromString(a);
	};
	com.cognitect.transit.types.isUUID = function(a) {
	  return a instanceof com.cognitect.transit.types.UUID;
	};
	com.cognitect.transit.types.date = function(a) {
	  a = "number" === typeof a ? a : parseInt(a, 10);
	  return new Date(a);
	};
	com.cognitect.transit.types.verboseDate = function(a) {
	  return new Date(a);
	};
	Date.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof Date ? this.valueOf() === a.valueOf() : !1;
	};
	Date.prototype.com$cognitect$transit$hashCode = function() {
	  return this.valueOf();
	};
	com.cognitect.transit.types.binary = function(a, b) {
	  return b && !1 === b.preferBuffers || "undefined" == typeof Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue("b", a) : new Buffer(a, "base64");
	};
	com.cognitect.transit.types.isBinary = function(a) {
	  return "undefined" != typeof Buffer && a instanceof Buffer ? !0 : "undefined" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && "b" === a.tag;
	};
	com.cognitect.transit.types.uri = function(a) {
	  return com.cognitect.transit.types.taggedValue("r", a);
	};
	com.cognitect.transit.types.isURI = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "r" === a.tag;
	};
	com.cognitect.transit.types.KEYS = 0;
	com.cognitect.transit.types.VALUES = 1;
	com.cognitect.transit.types.ENTRIES = 2;
	com.cognitect.transit.types.TransitArrayMapIterator = function(a, b) {
	  this.entries = a;
	  this.type = b || com.cognitect.transit.types.KEYS;
	  this.idx = 0;
	};
	com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {
	  if (this.idx < this.entries.length) {
	    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], a = {value:a, done:!1};
	    this.idx += 2;
	    return a;
	  }
	  return {value:null, done:!0};
	};
	com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
	com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this;
	};
	com.cognitect.transit.types.TransitMapIterator = function(a, b) {
	  this.map = a;
	  this.type = b || com.cognitect.transit.types.KEYS;
	  this.keys = this.map.getKeys();
	  this.idx = 0;
	  this.bucket = null;
	  this.bucketIdx = 0;
	};
	com.cognitect.transit.types.TransitMapIterator.prototype.next = function() {
	  if (this.idx < this.map.size) {
	    null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
	    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], a = {value:a, done:!1};
	    this.idx++;
	    this.bucketIdx += 2;
	    return a;
	  }
	  return {value:null, done:!0};
	};
	com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
	com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this;
	};
	com.cognitect.transit.types.mapEquals = function(a, b) {
	  if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {
	    if (a.size !== b.size) {
	      return !1;
	    }
	    for (var c in a.map) {
	      for (var d = a.map[c], e = 0;e < d.length;e += 2) {
	        if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {
	          return !1;
	        }
	      }
	    }
	    return !0;
	  }
	  if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {
	    if (a.size !== b.size) {
	      return !1;
	    }
	    c = a._entries;
	    for (e = 0;e < c.length;e += 2) {
	      if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {
	        return !1;
	      }
	    }
	    return !0;
	  }
	  if (null != b && "object" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {
	    for (d = 0;d < c;d++) {
	      var f = e[d];
	      if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {
	        return !1;
	      }
	    }
	    return !0;
	  }
	  return !1;
	};
	com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
	com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
	com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
	com.cognitect.transit.types.print = function(a) {
	  return null == a ? "null" : goog.isArray(a) ? "[" + a.toString() + "]" : goog.isString(a) ? '"' + a + '"' : a.toString();
	};
	com.cognitect.transit.types.printMap = function(a) {
	  var b = 0, c = "TransitMap {";
	  a.forEach(function(d, e) {
	    c += com.cognitect.transit.types.print(e) + " => " + com.cognitect.transit.types.print(d);
	    b < a.size - 1 && (c += ", ");
	    b++;
	  });
	  return c + "}";
	};
	com.cognitect.transit.types.printSet = function(a) {
	  var b = 0, c = "TransitSet {";
	  a.forEach(function(d) {
	    c += com.cognitect.transit.types.print(d);
	    b < a.size - 1 && (c += ", ");
	    b++;
	  });
	  return c + "}";
	};
	com.cognitect.transit.types.TransitArrayMap = function(a) {
	  this._entries = a;
	  this.backingMap = null;
	  this.hashCode = -1;
	  this.size = a.length / 2;
	  this.accesses = 0;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {
	  return com.cognitect.transit.types.printMap(this);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {
	  if (this.backingMap) {
	    throw Error("Invalid operation, already converted");
	  }
	  if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
	    return !1;
	  }
	  this.accesses++;
	  return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {
	  this.hashCode = -1;
	  this.backingMap ? this.backingMap.clear() : this._entries = [];
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
	com.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {
	  return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
	com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {
	  if (this.backingMap) {
	    return this.backingMap.keySet();
	  }
	  for (var a = [], b = 0, c = 0;c < this._entries.length;b++, c += 2) {
	    a[b] = this._entries[c];
	  }
	  return a;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
	com.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {
	  return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
	com.cognitect.transit.types.TransitArrayMap.prototype.values = function() {
	  return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
	com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a) {
	  if (this.backingMap) {
	    this.backingMap.forEach(a);
	  } else {
	    for (var b = 0;b < this._entries.length;b += 2) {
	      a(this._entries[b + 1], this._entries[b]);
	    }
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
	com.cognitect.transit.types.TransitArrayMap.prototype.get = function(a, b) {
	  if (this.backingMap) {
	    return this.backingMap.get(a);
	  }
	  if (this.convert()) {
	    return this.get(a);
	  }
	  for (var c = 0;c < this._entries.length;c += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
	      return this._entries[c + 1];
	    }
	  }
	  return b;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
	com.cognitect.transit.types.TransitArrayMap.prototype.has = function(a) {
	  if (this.backingMap) {
	    return this.backingMap.has(a);
	  }
	  if (this.convert()) {
	    return this.has(a);
	  }
	  for (var b = 0;b < this._entries.length;b += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
	      return !0;
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
	com.cognitect.transit.types.TransitArrayMap.prototype.set = function(a, b) {
	  this.hashCode = -1;
	  if (this.backingMap) {
	    this.backingMap.set(a, b), this.size = this.backingMap.size;
	  } else {
	    for (var c = 0;c < this._entries.length;c += 2) {
	      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
	        this._entries[c + 1] = b;
	        return;
	      }
	    }
	    this._entries.push(a);
	    this._entries.push(b);
	    this.size++;
	    this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
	com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function(a) {
	  this.hashCode = -1;
	  if (this.backingMap) {
	    return a = this.backingMap["delete"](a), this.size = this.backingMap.size, a;
	  }
	  for (var b = 0;b < this._entries.length;b += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
	      return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;
	    }
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {
	  var a = com.cognitect.transit.types.map();
	  this.forEach(function(b, c) {
	    a.set(c, b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
	com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.entries();
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {
	  if (this.backingMap) {
	    return this.backingMap.com$cognitect$transit$hashCode();
	  }
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
	  return this.hashCode;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a) {
	  return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);
	};
	com.cognitect.transit.types.TransitMap = function(a, b, c) {
	  this.map = b || {};
	  this._keys = a || [];
	  this.size = c || 0;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.TransitMap.prototype.toString = function() {
	  return com.cognitect.transit.types.printMap(this);
	};
	com.cognitect.transit.types.TransitMap.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitMap.prototype.clear = function() {
	  this.hashCode = -1;
	  this.map = {};
	  this._keys = [];
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
	com.cognitect.transit.types.TransitMap.prototype.getKeys = function() {
	  return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
	};
	com.cognitect.transit.types.TransitMap.prototype["delete"] = function(a) {
	  this.hashCode = -1;
	  this._keys = null;
	  for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0;d < c.length;d += 2) {
	    if (com.cognitect.transit.eq.equals(a, c[d])) {
	      return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;
	    }
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.entries = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
	};
	com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
	com.cognitect.transit.types.TransitMap.prototype.forEach = function(a) {
	  for (var b = this.getKeys(), c = 0;c < b.length;c++) {
	    for (var d = this.map[b[c]], e = 0;e < d.length;e += 2) {
	      a(d[e + 1], d[e], this);
	    }
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
	com.cognitect.transit.types.TransitMap.prototype.get = function(a, b) {
	  var c = com.cognitect.transit.eq.hashCode(a), c = this.map[c];
	  if (null != c) {
	    for (var d = 0;d < c.length;d += 2) {
	      if (com.cognitect.transit.eq.equals(a, c[d])) {
	        return c[d + 1];
	      }
	    }
	  } else {
	    return b;
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
	com.cognitect.transit.types.TransitMap.prototype.has = function(a) {
	  var b = com.cognitect.transit.eq.hashCode(a), b = this.map[b];
	  if (null != b) {
	    for (var c = 0;c < b.length;c += 2) {
	      if (com.cognitect.transit.eq.equals(a, b[c])) {
	        return !0;
	      }
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
	com.cognitect.transit.types.TransitMap.prototype.keys = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
	};
	com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
	com.cognitect.transit.types.TransitMap.prototype.keySet = function() {
	  for (var a = this.getKeys(), b = [], c = 0;c < a.length;c++) {
	    for (var d = this.map[a[c]], e = 0;e < d.length;e += 2) {
	      b.push(d[e]);
	    }
	  }
	  return b;
	};
	com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
	com.cognitect.transit.types.TransitMap.prototype.set = function(a, b) {
	  this.hashCode = -1;
	  var c = com.cognitect.transit.eq.hashCode(a), d = this.map[c];
	  if (null == d) {
	    this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;
	  } else {
	    for (var c = !0, e = 0;e < d.length;e += 2) {
	      if (com.cognitect.transit.eq.equals(b, d[e])) {
	        c = !1;
	        d[e] = b;
	        break;
	      }
	    }
	    c && (d.push(a), d.push(b), this.size++);
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
	com.cognitect.transit.types.TransitMap.prototype.values = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
	};
	com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
	com.cognitect.transit.types.TransitMap.prototype.clone = function() {
	  var a = com.cognitect.transit.types.map();
	  this.forEach(function(b, c) {
	    a.set(c, b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
	com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.entries();
	};
	com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
	  return this.hashCode;
	};
	com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a) {
	  return com.cognitect.transit.types.mapEquals(this, a);
	};
	com.cognitect.transit.types.map = function(a, b, c) {
	  a = a || [];
	  b = !1 === b ? b : !0;
	  if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
	    if (b) {
	      var d = a;
	      a = [];
	      for (b = 0;b < d.length;b += 2) {
	        var e = !1;
	        for (c = 0;c < a.length;c += 2) {
	          if (com.cognitect.transit.eq.equals(a[c], d[b])) {
	            a[c + 1] = d[b + 1];
	            e = !0;
	            break;
	          }
	        }
	        e || (a.push(d[b]), a.push(d[b + 1]));
	      }
	    }
	    return new com.cognitect.transit.types.TransitArrayMap(a);
	  }
	  var d = {}, e = [], f = 0;
	  for (b = 0;b < a.length;b += 2) {
	    c = com.cognitect.transit.eq.hashCode(a[b]);
	    var g = d[c];
	    if (null == g) {
	      e.push(c), d[c] = [a[b], a[b + 1]], f++;
	    } else {
	      var h = !0;
	      for (c = 0;c < g.length;c += 2) {
	        if (com.cognitect.transit.eq.equals(g[c], a[b])) {
	          g[c + 1] = a[b + 1];
	          h = !1;
	          break;
	        }
	      }
	      h && (g.push(a[b]), g.push(a[b + 1]), f++);
	    }
	  }
	  return new com.cognitect.transit.types.TransitMap(e, d, f);
	};
	com.cognitect.transit.types.isArrayMap = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitArrayMap;
	};
	com.cognitect.transit.types.isMap = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;
	};
	com.cognitect.transit.types.TransitSet = function(a) {
	  this.map = a;
	  this.size = a.size;
	};
	com.cognitect.transit.types.TransitSet.prototype.toString = function() {
	  return com.cognitect.transit.types.printSet(this);
	};
	com.cognitect.transit.types.TransitSet.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitSet.prototype.add = function(a) {
	  this.map.set(a, a);
	  this.size = this.map.size;
	};
	com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
	com.cognitect.transit.types.TransitSet.prototype.clear = function() {
	  this.map = new com.cognitect.transit.types.TransitMap;
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
	com.cognitect.transit.types.TransitSet.prototype["delete"] = function(a) {
	  a = this.map["delete"](a);
	  this.size = this.map.size;
	  return a;
	};
	com.cognitect.transit.types.TransitSet.prototype.entries = function() {
	  return this.map.entries();
	};
	com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
	com.cognitect.transit.types.TransitSet.prototype.forEach = function(a, b) {
	  var c = this;
	  this.map.forEach(function(b, e, f) {
	    a(e, c);
	  });
	};
	com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
	com.cognitect.transit.types.TransitSet.prototype.has = function(a) {
	  return this.map.has(a);
	};
	com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
	com.cognitect.transit.types.TransitSet.prototype.keys = function() {
	  return this.map.keys();
	};
	com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
	com.cognitect.transit.types.TransitSet.prototype.keySet = function() {
	  return this.map.keySet();
	};
	com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
	com.cognitect.transit.types.TransitSet.prototype.values = function() {
	  return this.map.values();
	};
	com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
	com.cognitect.transit.types.TransitSet.prototype.clone = function() {
	  var a = com.cognitect.transit.types.set();
	  this.forEach(function(b) {
	    a.add(b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
	com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.values();
	};
	com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a) {
	  if (a instanceof com.cognitect.transit.types.TransitSet) {
	    if (this.size === a.size) {
	      return com.cognitect.transit.eq.equals(this.map, a.map);
	    }
	  } else {
	    return !1;
	  }
	};
	com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a) {
	  return com.cognitect.transit.eq.hashCode(this.map);
	};
	com.cognitect.transit.types.set = function(a) {
	  a = a || [];
	  for (var b = {}, c = [], d = 0, e = 0;e < a.length;e++) {
	    var f = com.cognitect.transit.eq.hashCode(a[e]), g = b[f];
	    if (null == g) {
	      c.push(f), b[f] = [a[e], a[e]], d++;
	    } else {
	      for (var f = !0, h = 0;h < g.length;h += 2) {
	        if (com.cognitect.transit.eq.equals(g[h], a[e])) {
	          f = !1;
	          break;
	        }
	      }
	      f && (g.push(a[e]), g.push(a[e]), d++);
	    }
	  }
	  return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));
	};
	com.cognitect.transit.types.isSet = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitSet;
	};
	com.cognitect.transit.types.quoted = function(a) {
	  return com.cognitect.transit.types.taggedValue("'", a);
	};
	com.cognitect.transit.types.isQuoted = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "'" === a.tag;
	};
	com.cognitect.transit.types.list = function(a) {
	  return com.cognitect.transit.types.taggedValue("list", a);
	};
	com.cognitect.transit.types.isList = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "list" === a.tag;
	};
	com.cognitect.transit.types.link = function(a) {
	  return com.cognitect.transit.types.taggedValue("link", a);
	};
	com.cognitect.transit.types.isLink = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "link" === a.tag;
	};
	com.cognitect.transit.types.specialDouble = function(a) {
	  switch(a) {
	    case "-INF":
	      return -Infinity;
	    case "INF":
	      return Infinity;
	    case "NaN":
	      return NaN;
	    default:
	      throw Error("Invalid special double value " + a);;
	  }
	};
	com.cognitect.transit.handlers = {};
	com.cognitect.transit.handlers.ctorGuid = 0;
	com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
	com.cognitect.transit.handlers.typeTag = function(a) {
	  if (null == a) {
	    return "null";
	  }
	  if (a === String) {
	    return "string";
	  }
	  if (a === Boolean) {
	    return "boolean";
	  }
	  if (a === Number) {
	    return "number";
	  }
	  if (a === Array) {
	    return "array";
	  }
	  if (a === Object) {
	    return "map";
	  }
	  var b = a[com.cognitect.transit.handlers.ctorGuidProperty];
	  null == b && ("undefined" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, {value:b, enumerable:!1})) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);
	  return b;
	};
	com.cognitect.transit.handlers.constructor = function(a) {
	  return null == a ? null : a.constructor;
	};
	com.cognitect.transit.handlers.padZeros = function(a, b) {
	  for (var c = a.toString(), d = c.length;d < b;d++) {
	    c = "0" + c;
	  }
	  return c;
	};
	com.cognitect.transit.handlers.stringableKeys = function(a) {
	  a = com.cognitect.transit.util.objectKeys(a);
	  for (var b = 0;b < a.length;b++) {
	  }
	  return !0;
	};
	com.cognitect.transit.handlers.NilHandler = function() {
	};
	com.cognitect.transit.handlers.NilHandler.prototype.tag = function(a) {
	  return "_";
	};
	com.cognitect.transit.handlers.NilHandler.prototype.rep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a) {
	  return "null";
	};
	com.cognitect.transit.handlers.StringHandler = function() {
	};
	com.cognitect.transit.handlers.StringHandler.prototype.tag = function(a) {
	  return "s";
	};
	com.cognitect.transit.handlers.StringHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.NumberHandler = function() {
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a) {
	  return "i";
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.IntegerHandler = function() {
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a) {
	  return "i";
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.BooleanHandler = function() {
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a) {
	  return "?";
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.ArrayHandler = function() {
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a) {
	  return "array";
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.MapHandler = function() {
	};
	com.cognitect.transit.handlers.MapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.MapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.VerboseDateHandler = function() {
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a) {
	  return "t";
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a) {
	  return a.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + "Z";
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.DateHandler = function() {
	};
	com.cognitect.transit.handlers.DateHandler.prototype.tag = function(a) {
	  return "m";
	};
	com.cognitect.transit.handlers.DateHandler.prototype.rep = function(a) {
	  return a.valueOf();
	};
	com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a) {
	  return a.valueOf().toString();
	};
	com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a) {
	  return new com.cognitect.transit.handlers.VerboseDateHandler;
	};
	com.cognitect.transit.handlers.UUIDHandler = function() {
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a) {
	  return "u";
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.KeywordHandler = function() {
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a) {
	  return ":";
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a) {
	  return a._name;
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.SymbolHandler = function() {
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a) {
	  return "$";
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a) {
	  return a._name;
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.TaggedHandler = function() {
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a) {
	  return a.tag;
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a) {
	  return a.rep;
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitSetHandler = function() {
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a) {
	  return "set";
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a) {
	  var b = [];
	  a.forEach(function(a, d) {
	    b.push(a);
	  });
	  return com.cognitect.transit.types.taggedValue("array", b);
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler = function() {
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitMapHandler = function() {
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.BufferHandler = function() {
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a) {
	  return "b";
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a) {
	  return a.toString("base64");
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler = function() {
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a) {
	  return "b";
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a) {
	  return com.cognitect.transit.util.Uint8ToBase64(a);
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.defaultHandlers = function(a) {
	  a.set(null, new com.cognitect.transit.handlers.NilHandler);
	  a.set(String, new com.cognitect.transit.handlers.StringHandler);
	  a.set(Number, new com.cognitect.transit.handlers.NumberHandler);
	  a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler);
	  a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler);
	  a.set(Array, new com.cognitect.transit.handlers.ArrayHandler);
	  a.set(Object, new com.cognitect.transit.handlers.MapHandler);
	  a.set(Date, new com.cognitect.transit.handlers.DateHandler);
	  a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler);
	  a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler);
	  a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler);
	  a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler);
	  a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler);
	  a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler);
	  a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler);
	  "undefined" != typeof Buffer && a.set(Buffer, new com.cognitect.transit.handlers.BufferHandler);
	  "undefined" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler);
	  return a;
	};
	com.cognitect.transit.handlers.Handlers = function() {
	  this.handlers = {};
	  com.cognitect.transit.handlers.defaultHandlers(this);
	};
	com.cognitect.transit.handlers.Handlers.prototype.get = function(a) {
	  var b = null, b = "string" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];
	  return null != b ? b : this.handlers["default"];
	};
	com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
	com.cognitect.transit.handlers.validTag = function(a) {
	  switch(a) {
	    case "null":
	    ;
	    case "string":
	    ;
	    case "boolean":
	    ;
	    case "number":
	    ;
	    case "array":
	    ;
	    case "map":
	      return !1;
	  }
	  return !0;
	};
	com.cognitect.transit.handlers.Handlers.prototype.set = function(a, b) {
	  "string" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;
	};
	com.cognitect.transit.impl = {};
	com.cognitect.transit.impl.decoder = {};
	com.cognitect.transit.impl.decoder.Tag = function(a) {
	  this.str = a;
	};
	com.cognitect.transit.impl.decoder.tag = function(a) {
	  return new com.cognitect.transit.impl.decoder.Tag(a);
	};
	com.cognitect.transit.impl.decoder.isTag = function(a) {
	  return a && a instanceof com.cognitect.transit.impl.decoder.Tag;
	};
	com.cognitect.transit.impl.decoder.isGroundHandler = function(a) {
	  switch(a) {
	    case "_":
	    ;
	    case "s":
	    ;
	    case "?":
	    ;
	    case "i":
	    ;
	    case "d":
	    ;
	    case "b":
	    ;
	    case "'":
	    ;
	    case "array":
	    ;
	    case "map":
	      return !0;
	  }
	  return !1;
	};
	com.cognitect.transit.impl.decoder.Decoder = function(a) {
	  this.options = a || {};
	  this.handlers = {};
	  for (var b in this.defaults.handlers) {
	    this.handlers[b] = this.defaults.handlers[b];
	  }
	  for (b in this.options.handlers) {
	    if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {
	      throw Error('Cannot override handler for ground type "' + b + '"');
	    }
	    this.handlers[b] = this.options.handlers[b];
	  }
	  this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
	  this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
	  this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
	  this.mapBuilder = this.options.mapBuilder;
	  this.arrayBuilder = this.options.arrayBuilder;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = {handlers:{_:function(a, b) {
	  return com.cognitect.transit.types.nullValue();
	}, "?":function(a, b) {
	  return com.cognitect.transit.types.boolValue(a);
	}, b:function(a, b) {
	  return com.cognitect.transit.types.binary(a, b);
	}, i:function(a, b) {
	  return com.cognitect.transit.types.intValue(a);
	}, n:function(a, b) {
	  return com.cognitect.transit.types.bigInteger(a);
	}, d:function(a, b) {
	  return com.cognitect.transit.types.floatValue(a);
	}, f:function(a, b) {
	  return com.cognitect.transit.types.bigDecimalValue(a);
	}, c:function(a, b) {
	  return com.cognitect.transit.types.charValue(a);
	}, ":":function(a, b) {
	  return com.cognitect.transit.types.keyword(a);
	}, $:function(a, b) {
	  return com.cognitect.transit.types.symbol(a);
	}, r:function(a, b) {
	  return com.cognitect.transit.types.uri(a);
	}, z:function(a, b) {
	  return com.cognitect.transit.types.specialDouble(a);
	}, "'":function(a, b) {
	  return a;
	}, m:function(a, b) {
	  return com.cognitect.transit.types.date(a);
	}, t:function(a, b) {
	  return com.cognitect.transit.types.verboseDate(a);
	}, u:function(a, b) {
	  return com.cognitect.transit.types.uuid(a);
	}, set:function(a, b) {
	  return com.cognitect.transit.types.set(a);
	}, list:function(a, b) {
	  return com.cognitect.transit.types.list(a);
	}, link:function(a, b) {
	  return com.cognitect.transit.types.link(a);
	}, cmap:function(a, b) {
	  return com.cognitect.transit.types.map(a, !1);
	}}, defaultHandler:function(a, b) {
	  return com.cognitect.transit.types.taggedValue(a, b);
	}, preferStrings:!0, preferBuffers:!0};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a, b, c, d) {
	  if (null == a) {
	    return null;
	  }
	  switch(typeof a) {
	    case "string":
	      return this.decodeString(a, b, c, d);
	    case "object":
	      return com.cognitect.transit.util.isArray(a) ? "^ " === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);
	  }
	  return a;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a, b, c, d) {
	  return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a, b, c, d) {
	  c = com.cognitect.transit.util.objectKeys(a);
	  var e = c[0];
	  d = 1 == c.length ? this.decode(e, b, !1, !1) : null;
	  if (com.cognitect.transit.impl.decoder.isTag(d)) {
	    return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));
	  }
	  if (this.mapBuilder) {
	    if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
	      var f = [];
	      for (d = 0;d < c.length;d++) {
	        e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
	      }
	      return this.mapBuilder.fromArray(f, a);
	    }
	    f = this.mapBuilder.init(a);
	    for (d = 0;d < c.length;d++) {
	      e = c[d], f = this.mapBuilder.add(f, this.decode(e, b, !0, !1), this.decode(a[e], b, !1, !1), a);
	    }
	    return this.mapBuilder.finalize(f, a);
	  }
	  f = [];
	  for (d = 0;d < c.length;d++) {
	    e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
	  }
	  return com.cognitect.transit.types.map(f, !1);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a, b, c, d) {
	  if (this.mapBuilder) {
	    if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
	      d = [];
	      for (c = 1;c < a.length;c += 2) {
	        d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
	      }
	      return this.mapBuilder.fromArray(d, a);
	    }
	    d = this.mapBuilder.init(a);
	    for (c = 1;c < a.length;c += 2) {
	      d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);
	    }
	    return this.mapBuilder.finalize(d, a);
	  }
	  d = [];
	  for (c = 1;c < a.length;c += 2) {
	    d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
	  }
	  return com.cognitect.transit.types.map(d, !1);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a, b, c, d) {
	  if (d) {
	    var e = [];
	    for (d = 0;d < a.length;d++) {
	      e.push(this.decode(a[d], b, c, !1));
	    }
	    return e;
	  }
	  e = b && b.idx;
	  if (2 === a.length && "string" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {
	    return a = a[1], e = this.handlers[d.str], null != e ? e = e(this.decode(a, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, c, !1));
	  }
	  b && e != b.idx && (b.idx = e);
	  if (this.arrayBuilder) {
	    if (32 >= a.length && this.arrayBuilder.fromArray) {
	      e = [];
	      for (d = 0;d < a.length;d++) {
	        e.push(this.decode(a[d], b, c, !1));
	      }
	      return this.arrayBuilder.fromArray(e, a);
	    }
	    e = this.arrayBuilder.init(a);
	    for (d = 0;d < a.length;d++) {
	      e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);
	    }
	    return this.arrayBuilder.finalize(e, a);
	  }
	  e = [];
	  for (d = 0;d < a.length;d++) {
	    e.push(this.decode(a[d], b, c, !1));
	  }
	  return e;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a, b, c) {
	  if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {
	    b = a.charAt(1);
	    if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {
	      return a.substring(1);
	    }
	    if (b === com.cognitect.transit.delimiters.TAG) {
	      return com.cognitect.transit.impl.decoder.tag(a.substring(2));
	    }
	    c = this.handlers[b];
	    return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);
	  }
	  return a;
	};
	com.cognitect.transit.impl.decoder.decoder = function(a) {
	  return new com.cognitect.transit.impl.decoder.Decoder(a);
	};
	com.cognitect.transit.impl.reader = {};
	com.cognitect.transit.impl.reader.JSONUnmarshaller = function(a) {
	  this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);
	};
	com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a, b) {
	  return this.decoder.decode(JSON.parse(a), b);
	};
	com.cognitect.transit.impl.reader.Reader = function(a, b) {
	  this.unmarshaller = a;
	  this.options = b || {};
	  this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache;
	};
	com.cognitect.transit.impl.reader.Reader.prototype.read = function(a) {
	  a = this.unmarshaller.unmarshal(a, this.cache);
	  this.cache.clear();
	  return a;
	};
	com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
	com.cognitect.transit.impl.writer = {};
	com.cognitect.transit.impl.writer.escape = function(a) {
	  if (0 < a.length) {
	    var b = a.charAt(0);
	    return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;
	  }
	  return a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller = function(a) {
	  this.opts = a || {};
	  this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;
	  this.objectBuilder = this.opts.objectBuilder || null;
	  this.handlers = new com.cognitect.transit.handlers.Handlers;
	  if (a = this.opts.handlers) {
	    if (com.cognitect.transit.util.isArray(a) || !a.forEach) {
	      throw Error('transit writer "handlers" option must be a map');
	    }
	    var b = this;
	    a.forEach(function(a, d) {
	      if (void 0 !== d) {
	        b.handlers.set(d, a);
	      } else {
	        throw Error("Cannot create handler for JavaScript undefined");
	      }
	    });
	  }
	  this.handlerForForeign = this.opts.handlerForForeign;
	  this.unpack = this.opts.unpack || function(a) {
	    return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;
	  };
	  this.verbose = this.opts && this.opts.verbose || !1;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a) {
	  var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));
	  return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a, b) {
	  this.handlers.set(a, b);
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a, b) {
	  return a ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a, b) : null;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a, b, c, d, e) {
	  a = a + b + c;
	  return e ? e.write(a, d) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a, b, c) {
	  return b ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a.toString()[0], b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a, b, c) {
	  return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b, c) : b || "string" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a.toString(), b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a, b, c) {
	  return b ? this.emitString(a.ESC, "d", a, b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a, b, c) {
	  return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a, b, c);
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a, b, c) {
	  if (a.verbose) {
	    a = {};
	    var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c);
	    a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);
	    return a;
	  }
	  return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];
	};
	com.cognitect.transit.impl.writer.emitObjects = function(a, b, c) {
	  var d = [];
	  if (com.cognitect.transit.util.isArray(b)) {
	    for (var e = 0;e < b.length;e++) {
	      d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));
	    }
	  } else {
	    b.forEach(function(b, e) {
	      d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));
	    });
	  }
	  return d;
	};
	com.cognitect.transit.impl.writer.emitArray = function(a, b, c, d) {
	  return com.cognitect.transit.impl.writer.emitObjects(a, b, d);
	};
	com.cognitect.transit.impl.writer.isStringableKey = function(a, b) {
	  if ("string" !== typeof b) {
	    var c = a.handler(b);
	    return c && 1 === c.tag(b).length;
	  }
	  return !0;
	};
	com.cognitect.transit.impl.writer.stringableKeys = function(a, b) {
	  var c = a.unpack(b), d = !0;
	  if (c) {
	    for (var e = 0;e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d);e += 2) {
	    }
	    return d;
	  }
	  if (b.keys && (c = b.keys(), e = null, c.next)) {
	    for (e = c.next();!e.done;) {
	      d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);
	      if (!d) {
	        break;
	      }
	      e = c.next();
	    }
	    return d;
	  }
	  if (b.forEach) {
	    return b.forEach(function(b, c) {
	      d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);
	    }), d;
	  }
	  throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b).name);
	};
	com.cognitect.transit.impl.writer.isForeignObject = function(a) {
	  if (a.constructor.transit$isObject) {
	    return !0;
	  }
	  var b = a.constructor.toString(), b = b.substr(9), b = b.substr(0, b.indexOf("("));
	  isObject = "Object" == b;
	  "undefined" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, "transit$isObject", {value:isObject, enumerable:!1}) : a.constructor.transit$isObject = isObject;
	  return isObject;
	};
	com.cognitect.transit.impl.writer.emitMap = function(a, b, c, d) {
	  var e = null, f = null, g = null, e = null;
	  c = 0;
	  if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {
	    if (a.verbose) {
	      if (null != b.forEach) {
	        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
	          var h = {};
	          b.forEach(function(b, c) {
	            h[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
	          });
	        } else {
	          e = a.unpack(b);
	          f = [];
	          g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
	          if (e) {
	            for (;c < e.length;c += 2) {
	              f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, !1)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	            }
	          } else {
	            b.forEach(function(b, c) {
	              f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, !1));
	              f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	            });
	          }
	          h = {};
	          h[g] = f;
	        }
	      } else {
	        for (e = com.cognitect.transit.util.objectKeys(b), h = {};c < e.length;c++) {
	          h[com.cognitect.transit.impl.writer.marshal(a, e[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d);
	        }
	      }
	      return h;
	    }
	    if (null != b.forEach) {
	      if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
	        e = a.unpack(b);
	        h = ["^ "];
	        if (e) {
	          for (;c < e.length;c += 2) {
	            h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	          }
	        } else {
	          b.forEach(function(b, c) {
	            h.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
	            h.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	          });
	        }
	        return h;
	      }
	      e = a.unpack(b);
	      f = [];
	      g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
	      if (e) {
	        for (;c < e.length;c += 2) {
	          f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, d)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	        }
	      } else {
	        b.forEach(function(b, c) {
	          f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, d));
	          f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	        });
	      }
	      return [g, f];
	    }
	    h = ["^ "];
	    for (e = com.cognitect.transit.util.objectKeys(b);c < e.length;c++) {
	      h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d));
	    }
	    return h;
	  }
	  if (null != a.objectBuilder) {
	    return a.objectBuilder(b, function(b) {
	      return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);
	    }, function(b) {
	      return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
	    });
	  }
	  c = com.cognitect.transit.handlers.constructor(b).name;
	  e = Error("Cannot write " + c);
	  e.data = {obj:b, type:c};
	  throw e;
	};
	com.cognitect.transit.impl.writer.emitTaggedMap = function(a, b, c, d, e) {
	  return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];
	};
	com.cognitect.transit.impl.writer.emitEncoded = function(a, b, c, d, e, f, g) {
	  if (1 === c.length) {
	    if ("string" === typeof d) {
	      return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
	    }
	    if (f || a.preferStrings) {
	      (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);
	      if (null !== d) {
	        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
	      }
	      a = Error('Tag "' + c + '" cannot be encoded as string');
	      a.data = {tag:c, rep:d, obj:e};
	      throw a;
	    }
	  }
	  return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);
	};
	com.cognitect.transit.impl.writer.marshal = function(a, b, c, d) {
	  var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null), f = e ? e.tag(b) : null, g = e ? e.rep(b) : null;
	  if (null != e && null != f) {
	    switch(f) {
	      case "_":
	        return a.emitNil(c, d);
	      case "s":
	        return a.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c, d);
	      case "?":
	        return a.emitBoolean(g, c, d);
	      case "i":
	        return a.emitInteger(g, c, d);
	      case "d":
	        return a.emitDouble(g, c, d);
	      case "b":
	        return a.emitBinary(g, c, d);
	      case "'":
	        return a.emitQuoted(a, g, d);
	      case "array":
	        return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);
	      case "map":
	        return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);
	      default:
	        return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);
	    }
	  } else {
	    throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error("Cannot write " + a), c.data = {obj:b, type:a}, c;
	  }
	};
	com.cognitect.transit.impl.writer.maybeQuoted = function(a, b) {
	  var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);
	  if (null != c) {
	    return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;
	  }
	  var c = com.cognitect.transit.handlers.constructor(b).name, d = Error("Cannot write " + c);
	  d.data = {obj:b, type:c};
	  throw d;
	};
	com.cognitect.transit.impl.writer.marshalTop = function(a, b, c, d) {
	  return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));
	};
	com.cognitect.transit.impl.writer.Writer = function(a, b) {
	  this._marshaller = a;
	  this.options = b || {};
	  this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {
	  return this._marshaller;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
	com.cognitect.transit.impl.writer.Writer.prototype.write = function(a, b) {
	  var c = null, c = b || {}, d = c.asMapKey || !1, e = this._marshaller.verbose ? !1 : this.cache, c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);
	  null != this.cache && this.cache.clear();
	  return c;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
	com.cognitect.transit.impl.writer.Writer.prototype.register = function(a, b) {
	  this._marshaller.registerHandler(a, b);
	};
	com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
	var TRANSIT_DEV = !0, TRANSIT_NODE_TARGET = !0, TRANSIT_BROWSER_TARGET = !1, TRANSIT_BROWSER_AMD_TARGET = !1;
	com.cognitect.transit.reader = function(a, b) {
	  if ("json" === a || "json-verbose" === a || null == a) {
	    var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);
	    return new com.cognitect.transit.impl.reader.Reader(c, b);
	  }
	  throw Error("Cannot create reader of type " + a);
	};
	com.cognitect.transit.writer = function(a, b) {
	  if ("json" === a || "json-verbose" === a || null == a) {
	    "json-verbose" === a && (null == b && (b = {}), b.verbose = !0);
	    var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);
	    return new com.cognitect.transit.impl.writer.Writer(c, b);
	  }
	  c = Error('Type must be "json"');
	  c.data = {type:a};
	  throw c;
	};
	com.cognitect.transit.makeWriteHandler = function(a) {
	  var b = function() {
	  };
	  b.prototype.tag = a.tag;
	  b.prototype.rep = a.rep;
	  b.prototype.stringRep = a.stringRep;
	  b.prototype.getVerboseHandler = a.getVerboseHandler;
	  return new b;
	};
	com.cognitect.transit.makeBuilder = function(a) {
	  var b = function() {
	  };
	  b.prototype.init = a.init;
	  b.prototype.add = a.add;
	  b.prototype.finalize = a.finalize;
	  b.prototype.fromArray = a.fromArray;
	  return new b;
	};
	com.cognitect.transit.date = com.cognitect.transit.types.date;
	com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
	com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
	com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
	com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
	com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
	com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
	com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
	com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
	com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
	com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
	com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
	com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
	com.cognitect.transit.binary = com.cognitect.transit.types.binary;
	com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
	com.cognitect.transit.uri = com.cognitect.transit.types.uri;
	com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
	com.cognitect.transit.map = com.cognitect.transit.types.map;
	com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
	com.cognitect.transit.set = com.cognitect.transit.types.set;
	com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
	com.cognitect.transit.list = com.cognitect.transit.types.list;
	com.cognitect.transit.isList = com.cognitect.transit.types.isList;
	com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
	com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
	com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
	com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
	com.cognitect.transit.link = com.cognitect.transit.types.link;
	com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
	com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
	com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
	com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
	com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
	com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
	com.cognitect.transit.mapToObject = function(a) {
	  var b = {};
	  a.forEach(function(a, d) {
	    if ("string" !== typeof d) {
	      throw Error("Cannot convert map with non-string keys");
	    }
	    b[d] = a;
	  });
	  return b;
	};
	com.cognitect.transit.objectToMap = function(a) {
	  var b = com.cognitect.transit.map(), c;
	  for (c in a) {
	    a.hasOwnProperty(c) && b.set(c, a[c]);
	  }
	  return b;
	};
	com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
	com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
	com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
	com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
	com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
	com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
	TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol("transit.isInteger", 
	com.cognitect.transit.types.isInteger), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), 
	goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), 
	goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol("transit.quoted", 
	com.cognitect.transit.types.quoted), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol("transit.hashMapLike", 
	com.cognitect.transit.eq.hashMapLike), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), 
	goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
	TRANSIT_NODE_TARGET && (module.exports = {reader:com.cognitect.transit.reader, writer:com.cognitect.transit.writer, makeBuilder:com.cognitect.transit.makeBuilder, makeWriteHandler:com.cognitect.transit.makeWriteHandler, date:com.cognitect.transit.types.date, integer:com.cognitect.transit.types.intValue, isInteger:com.cognitect.transit.types.isInteger, uuid:com.cognitect.transit.types.uuid, isUUID:com.cognitect.transit.types.isUUID, bigInt:com.cognitect.transit.types.bigInteger, isBigInt:com.cognitect.transit.types.isBigInteger, 
	bigDec:com.cognitect.transit.types.bigDecimalValue, isBigDec:com.cognitect.transit.types.isBigDecimal, keyword:com.cognitect.transit.types.keyword, isKeyword:com.cognitect.transit.types.isKeyword, symbol:com.cognitect.transit.types.symbol, isSymbol:com.cognitect.transit.types.isSymbol, binary:com.cognitect.transit.types.binary, isBinary:com.cognitect.transit.types.isBinary, uri:com.cognitect.transit.types.uri, isURI:com.cognitect.transit.types.isURI, map:com.cognitect.transit.types.map, isMap:com.cognitect.transit.types.isMap, 
	set:com.cognitect.transit.types.set, isSet:com.cognitect.transit.types.isSet, list:com.cognitect.transit.types.list, isList:com.cognitect.transit.types.isList, quoted:com.cognitect.transit.types.quoted, isQuoted:com.cognitect.transit.types.isQuoted, tagged:com.cognitect.transit.types.taggedValue, isTaggedValue:com.cognitect.transit.types.isTaggedValue, link:com.cognitect.transit.types.link, isLink:com.cognitect.transit.types.isLink, hash:com.cognitect.transit.eq.hashCode, hashArrayLike:com.cognitect.transit.eq.hashArrayLike, 
	hashMapLike:com.cognitect.transit.eq.hashMapLike, equals:com.cognitect.transit.eq.equals, extendToEQ:com.cognitect.transit.eq.extendToEQ, mapToObject:com.cognitect.transit.mapToObject, objectToMap:com.cognitect.transit.objectToMap, decoder:com.cognitect.transit.impl.decoder.decoder, UUIDfromString:com.cognitect.transit.types.UUIDfromString, randomUUID:com.cognitect.transit.util.randomUUID, stringableKeys:com.cognitect.transit.impl.writer.stringableKeys, readCache:com.cognitect.transit.caching.readCache, 
	writeCache:com.cognitect.transit.caching.writeCache});


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(58).Buffer))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(59)
	var ieee754 = __webpack_require__(60)
	var isArray = __webpack_require__(61)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(58).Buffer, (function() { return this; }())))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 60 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 61 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.replaceTemplate = exports.processTemplate = undefined;

	var _immutable = __webpack_require__(11);

	var _ramdaFantasy = __webpack_require__(15);

	var _ramda = __webpack_require__(27);

	var _ramda2 = _interopRequireDefault(_ramda);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _errors = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const isDolar_910 = s_921 => s_921 && s_921 instanceof _syntax2.default && s_921.match("identifier") && s_921.val() === "$";
	const isDelimiter_911 = s_922 => s_922 && typeof s_922.match === "function" && s_922.match("delimiter");
	const isBraces_912 = s_923 => s_923 && typeof s_923.match === "function" && s_923.match("braces");
	const isParens_913 = s_924 => s_924 && typeof s_924.match === "function" && s_924.match("parens");
	const isBrackets_914 = s_925 => s_925 && typeof s_925.match === "function" && s_925.match("brackets");
	const insertIntoDelimiter_915 = _ramda2.default.cond([[isBraces_912, (s_926, r_927) => _syntax2.default.from("braces", r_927, s_926)], [isParens_913, (s_928, r_929) => _syntax2.default.from("parens", r_929, s_928)], [isBrackets_914, (s_930, r_931) => _syntax2.default.from("brackets", r_931, s_930)]]);
	const process_916 = (acc_932, s_933) => {
	  if (isBraces_912(s_933) && isDolar_910(acc_932.template.last())) {
	    return { template: acc_932.template.push(_syntax2.default.from("braces", _immutable.List.of(_syntax2.default.from("number", acc_932.interp.size)), s_933)), interp: acc_932.interp.push(s_933.inner()) };
	  } else if (isDelimiter_911(s_933)) {
	    let innerResult = processTemplate_919(s_933.inner(), acc_932.interp);
	    return { template: acc_932.template.push(insertIntoDelimiter_915(s_933, innerResult.template)), interp: innerResult.interp };
	  } else {
	    return { template: acc_932.template.push(s_933), interp: acc_932.interp };
	  }
	};
	function cloneLineNumber_917(to_934, from_935) {
	  if (from_935 && to_934 && typeof to_934.setLineNumber === "function") {
	    return to_934.setLineNumber(from_935.lineNumber());
	  }
	  return to_934;
	}
	const replace_918 = (acc_936, s_937) => {
	  let last_938 = acc_936.template.get(-1);
	  let beforeLast_939 = acc_936.template.get(-2);
	  if (isBraces_912(s_937) && isDolar_910(last_938)) {
	    let index = s_937.inner().first().val();
	    (0, _errors.assert)(acc_936.rep.size > index, "unknown replacement value");
	    let replacement = cloneLineNumber_917(acc_936.rep.get(index), beforeLast_939);
	    return { template: acc_936.template.pop().concat(replacement), rep: acc_936.rep };
	  } else if (isDelimiter_911(s_937)) {
	    let innerResult = replaceTemplate_920(s_937.inner(), acc_936.rep);
	    return { template: acc_936.template.push(insertIntoDelimiter_915(s_937, innerResult)), rep: acc_936.rep };
	  } else {
	    return { template: acc_936.template.push(s_937), rep: acc_936.rep };
	  }
	};
	function processTemplate_919(temp_940) {
	  let interp_941 = arguments.length <= 1 || arguments[1] === undefined ? (0, _immutable.List)() : arguments[1];

	  return temp_940.reduce(process_916, { template: (0, _immutable.List)(), interp: interp_941 });
	}
	function replaceTemplate_920(temp_942, rep_943) {
	  return temp_942.reduce(replace_918, { template: (0, _immutable.List)(), rep: rep_943 }).template;
	}
	exports.processTemplate = processTemplate_919;
	exports.replaceTemplate = replaceTemplate_920;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3RlbXBsYXRlLXByb2Nlc3Nvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0EsTUFBTSxjQUFjLFNBQVMsU0FBUyxpQ0FBVCxJQUFvQyxNQUFNLEtBQU4sQ0FBWSxZQUFaLENBQXBDLElBQWlFLE1BQU0sR0FBTixPQUFnQixHQUE5RztBQUNBLE1BQU0sa0JBQWtCLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxXQUFaLENBQS9FO0FBQ0EsTUFBTSxlQUFlLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxRQUFaLENBQTVFO0FBQ0EsTUFBTSxlQUFlLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxRQUFaLENBQTVFO0FBQ0EsTUFBTSxpQkFBaUIsU0FBUyxTQUFTLE9BQU8sTUFBTSxLQUFiLEtBQXVCLFVBQWhDLElBQThDLE1BQU0sS0FBTixDQUFZLFVBQVosQ0FBOUU7QUFDQSxNQUFNLDBCQUEwQixnQkFBRSxJQUFGLENBQU8sQ0FBQyxDQUFDLFlBQUQsRUFBZSxDQUFDLEtBQUQsRUFBUSxLQUFSLEtBQWtCLGlCQUFPLElBQVAsQ0FBWSxRQUFaLEVBQXNCLEtBQXRCLEVBQTZCLEtBQTdCLENBQWpDLENBQUQsRUFBd0UsQ0FBQyxZQUFELEVBQWUsQ0FBQyxLQUFELEVBQVEsS0FBUixLQUFrQixpQkFBTyxJQUFQLENBQVksUUFBWixFQUFzQixLQUF0QixFQUE2QixLQUE3QixDQUFqQyxDQUF4RSxFQUErSSxDQUFDLGNBQUQsRUFBaUIsQ0FBQyxLQUFELEVBQVEsS0FBUixLQUFrQixpQkFBTyxJQUFQLENBQVksVUFBWixFQUF3QixLQUF4QixFQUErQixLQUEvQixDQUFuQyxDQUEvSSxD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aEIsRUFBNkIsRUFBQyxVQUFVLHNCQUFYLEVBQW1CLFFBQVEsVUFBM0IsRUFBN0IsQ0FBUDtBQUNEO0FBQ0QsU0FBUyxtQkFBVCxDQUE2QixRQUE3QixFQUF1QyxPQUF2QyxFQUFnRDtBQUM5QyxTQUFPLFNBQVMsTUFBVCxDQUFnQixXQUFoQixFQUE2QixFQUFDLFVBQVUsc0JBQVgsRUFBbUIsS0FBSyxPQUF4QixFQUE3QixFQUErRCxRQUF0RTtBQUNEO1FBQzhCLGUsR0FBdkIsbUI7UUFDdUIsZSxHQUF2QixtQiIsImZpbGUiOiJ0ZW1wbGF0ZS1wcm9jZXNzb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCB7TWF5YmV9IGZyb20gXCJyYW1kYS1mYW50YXN5XCI7XG5pbXBvcnQgXyBmcm9tIFwicmFtZGFcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5jb25zdCBpc0RvbGFyXzkxMCA9IHNfOTIxID0+IHNfOTIxICYmIHNfOTIxIGluc3RhbmNlb2YgU3ludGF4ICYmIHNfOTIxLm1hdGNoKFwiaWRlbnRpZmllclwiKSAmJiBzXzkyMS52YWwoKSA9PT0gXCIkXCI7XG5jb25zdCBpc0RlbGltaXRlcl85MTEgPSBzXzkyMiA9PiBzXzkyMiAmJiB0eXBlb2Ygc185MjIubWF0Y2ggPT09IFwiZnVuY3Rpb25cIiAmJiBzXzkyMi5tYXRjaChcImRlbGltaXRlclwiKTtcbmNvbnN0IGlzQnJhY2VzXzkxMiA9IHNfOTIzID0+IHNfOTIzICYmIHR5cGVvZiBzXzkyMy5tYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIHNfOTIzLm1hdGNoKFwiYnJhY2VzXCIpO1xuY29uc3QgaXNQYXJlbnNfOTEzID0gc185MjQgPT4gc185MjQgJiYgdHlwZW9mIHNfOTI0Lm1hdGNoID09PSBcImZ1bmN0aW9uXCIgJiYgc185MjQubWF0Y2goXCJwYXJlbnNcIik7XG5jb25zdCBpc0JyYWNrZXRzXzkxNCA9IHNfOTI1ID0+IHNfOTI1ICYmIHR5cGVvZiBzXzkyNS5tYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIHNfOTI1Lm1hdGNoKFwiYnJhY2tldHNcIik7XG5jb25zdCBpbnNlcnRJbnRvRGVsaW1pdGVyXzkxNSA9IF8uY29uZChbW2lzQnJhY2VzXzkxMiwgKHNfOTI2LCByXzkyNykgPT4gU3ludGF4LmZyb20oXCJicmFjZXNcIiwgcl85MjcsIHNfOTI2KV0sIFtpc1BhcmVuc185MTMsIChzXzkyOCwgcl85MjkpID0+IFN5bnRheC5mcm9tKFwicGFyZW5zXCIsIHJfOTI5LCBzXzkyOCldLCBbaXNCcmFja2V0c185MTQsIChzXzkzMCwgcl85MzEpID0+IFN5bnRheC5mcm9tKFwiYnJhY2tldHNcIiwgcl85MzEsIHNfOTMwKV1dKTtcbmNvbnN0IHByb2Nlc3NfOTE2ID0gKGFjY185MzIsIHNfOTMzKSA9PiB7XG4gIGlmIChpc0JyYWNlc185MTIoc185MzMpICYmIGlzRG9sYXJfOTEwKGFjY185MzIudGVtcGxhdGUubGFzdCgpKSkge1xuICAgIHJldHVybiB7dGVtcGxhdGU6IGFjY185MzIudGVtcGxhdGUucHVzaChTeW50YXguZnJvbShcImJyYWNlc1wiLCBMaXN0Lm9mKFN5bnRheC5mcm9tKFwibnVtYmVyXCIsIGFjY185MzIuaW50ZXJwLnNpemUpKSwgc185MzMpKSwgaW50ZXJwOiBhY2NfOTMyLmludGVycC5wdXNoKHNfOTMzLmlubmVyKCkpfTtcbiAgfSBlbHNlIGlmIChpc0RlbGltaXRlcl85MTEoc185MzMpKSB7XG4gICAgbGV0IGlubmVyUmVzdWx0ID0gcHJvY2Vzc1RlbXBsYXRlXzkxOShzXzkzMy5pbm5lcigpLCBhY2NfOTMyLmludGVycCk7XG4gICAgcmV0dXJuIHt0ZW1wbGF0ZTogYWNjXzkzMi50ZW1wbGF0ZS5wdXNoKGluc2VydEludG9EZWxpbWl0ZXJfOTE1KHNfOTMzLCBpbm5lclJlc3VsdC50ZW1wbGF0ZSkpLCBpbnRlcnA6IGlubmVyUmVzdWx0LmludGVycH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt0ZW1wbGF0ZTogYWNjXzkzMi50ZW1wbGF0ZS5wdXNoKHNfOTMzKSwgaW50ZXJwOiBhY2NfOTMyLmludGVycH07XG4gIH1cbn07XG5mdW5jdGlvbiBjbG9uZUxpbmVOdW1iZXJfOTE3KHRvXzkzNCwgZnJvbV85MzUpIHtcbiAgaWYgKGZyb21fOTM1ICYmIHRvXzkzNCAmJiB0eXBlb2YgdG9fOTM0LnNldExpbmVOdW1iZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0b185MzQuc2V0TGluZU51bWJlcihmcm9tXzkzNS5saW5lTnVtYmVyKCkpO1xuICB9XG4gIHJldHVybiB0b185MzQ7XG59XG5jb25zdCByZXBsYWNlXzkxOCA9IChhY2NfOTM2LCBzXzkzNykgPT4ge1xuICBsZXQgbGFzdF85MzggPSBhY2NfOTM2LnRlbXBsYXRlLmdldCgtMSk7XG4gIGxldCBiZWZvcmVMYXN0XzkzOSA9IGFjY185MzYudGVtcGxhdGUuZ2V0KC0yKTtcbiAgaWYgKGlzQnJhY2VzXzkxMihzXzkzNykgJiYgaXNEb2xhcl85MTAobGFzdF85MzgpKSB7XG4gICAgbGV0IGluZGV4ID0gc185MzcuaW5uZXIoKS5maXJzdCgpLnZhbCgpO1xuICAgIGFzc2VydChhY2NfOTM2LnJlcC5zaXplID4gaW5kZXgsIFwidW5rbm93biByZXBsYWNlbWVudCB2YWx1ZVwiKTtcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSBjbG9uZUxpbmVOdW1iZXJfOTE3KGFjY185MzYucmVwLmdldChpbmRleCksIGJlZm9yZUxhc3RfOTM5KTtcbiAgICByZXR1cm4ge3RlbXBsYXRlOiBhY2NfOTM2LnRlbXBsYXRlLnBvcCgpLmNvbmNhdChyZXBsYWNlbWVudCksIHJlcDogYWNjXzkzNi5yZXB9O1xuICB9IGVsc2UgaWYgKGlzRGVsaW1pdGVyXzkxMShzXzkzNykpIHtcbiAgICBsZXQgaW5uZXJSZXN1bHQgPSByZXBsYWNlVGVtcGxhdGVfOTIwKHNfOTM3LmlubmVyKCksIGFjY185MzYucmVwKTtcbiAgICByZXR1cm4ge3RlbXBsYXRlOiBhY2NfOTM2LnRlbXBsYXRlLnB1c2goaW5zZXJ0SW50b0RlbGltaXRlcl85MTUoc185MzcsIGlubmVyUmVzdWx0KSksIHJlcDogYWNjXzkzNi5yZXB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7dGVtcGxhdGU6IGFjY185MzYudGVtcGxhdGUucHVzaChzXzkzNyksIHJlcDogYWNjXzkzNi5yZXB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlXzkxOSh0ZW1wXzk0MCwgaW50ZXJwXzk0MSA9IExpc3QoKSkge1xuICByZXR1cm4gdGVtcF85NDAucmVkdWNlKHByb2Nlc3NfOTE2LCB7dGVtcGxhdGU6IExpc3QoKSwgaW50ZXJwOiBpbnRlcnBfOTQxfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGVfOTIwKHRlbXBfOTQyLCByZXBfOTQzKSB7XG4gIHJldHVybiB0ZW1wXzk0Mi5yZWR1Y2UocmVwbGFjZV85MTgsIHt0ZW1wbGF0ZTogTGlzdCgpLCByZXA6IHJlcF85NDN9KS50ZW1wbGF0ZTtcbn1cbmV4cG9ydCB7cHJvY2Vzc1RlbXBsYXRlXzkxOSBhcyBwcm9jZXNzVGVtcGxhdGV9O1xuZXhwb3J0IHtyZXBsYWNlVGVtcGxhdGVfOTIwIGFzIHJlcGxhY2VUZW1wbGF0ZX0iXX0=

/***/ },
/* 63 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class ASTDispatcher {
	  constructor(prefix_16, errorIfMissing_17) {
	    this.errorIfMissing = errorIfMissing_17;
	    this.prefix = prefix_16;
	  }
	  dispatch(term_18) {
	    let field_19 = this.prefix + term_18.type;
	    if (typeof this[field_19] === "function") {
	      return this[field_19](term_18);
	    } else if (!this.errorIfMissing) {
	      return term_18;
	    }
	    throw new Error(`Missing implementation for: ${ field_19 }`);
	  }
	}
	exports.default = ASTDispatcher;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2FzdC1kaXNwYXRjaGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWUsTUFBTSxhQUFOLENBQW9CO0FBQ2pDLGNBQVksU0FBWixFQUF1QixpQkFBdkIsRUFBMEM7QUFDeEMsU0FBSyxjQUFMLEdBQXNCLGlCQUF0QjtBQUNBLFNBQUssTUFBTCxHQUFjLFNBQWQ7QUFDRDtBQUNELFdBQVMsT0FBVCxFQUFrQjtBQUNoQixRQUFJLFdBQVcsS0FBSyxNQUFMLEdBQWMsUUFBUSxJQUFyQztBQUNBLFFBQUksT0FBTyxLQUFLLFFBQUwsQ0FBUCxLQUEwQixVQUE5QixFQUEwQztBQUN4QyxhQUFPLEtBQUssUUFBTCxFQUFlLE9BQWYsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsS0FBSyxjQUFWLEVBQTBCO0FBQy9CLGFBQU8sT0FBUDtBQUNEO0FBQ0QsVUFBTSxJQUFJLEtBQUosQ0FBVyxnQ0FBOEIsUUFBUyxHQUFsRCxDQUFOO0FBQ0Q7QUFiZ0M7a0JBQWQsYSIsImZpbGUiOiJhc3QtZGlzcGF0Y2hlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFTVERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihwcmVmaXhfMTYsIGVycm9ySWZNaXNzaW5nXzE3KSB7XG4gICAgdGhpcy5lcnJvcklmTWlzc2luZyA9IGVycm9ySWZNaXNzaW5nXzE3O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4XzE2O1xuICB9XG4gIGRpc3BhdGNoKHRlcm1fMTgpIHtcbiAgICBsZXQgZmllbGRfMTkgPSB0aGlzLnByZWZpeCArIHRlcm1fMTgudHlwZTtcbiAgICBpZiAodHlwZW9mIHRoaXNbZmllbGRfMTldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpZWxkXzE5XSh0ZXJtXzE4KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmVycm9ySWZNaXNzaW5nKSB7XG4gICAgICByZXR1cm4gdGVybV8xODtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGltcGxlbWVudGF0aW9uIGZvcjogJHtmaWVsZF8xOX1gKTtcbiAgfVxufVxuIl19

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unwrap = exports.SyntaxOrTermWrapper = undefined;

	var _mapSyntaxReducer = __webpack_require__(65);

	var _mapSyntaxReducer2 = _interopRequireDefault(_mapSyntaxReducer);

	var _shiftReducer = __webpack_require__(32);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _errors = __webpack_require__(13);

	var _immutable = __webpack_require__(11);

	var _enforester = __webpack_require__(50);

	var _syntax = __webpack_require__(12);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramdaFantasy = __webpack_require__(15);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const Just_376 = _ramdaFantasy.Maybe.Just;
	const Nothing_377 = _ramdaFantasy.Maybe.Nothing;
	const symWrap_378 = Symbol("wrapper");
	const privateData_379 = new WeakMap();
	const getLineNumber_380 = t_384 => {
	  if (t_384 instanceof _syntax2.default) {
	    return t_384.lineNumber();
	  }
	  throw new Error("Line numbers on terms not implemented yet");
	};
	const getVal_381 = t_385 => {
	  if (t_385.match("delimiter")) {
	    return null;
	  }
	  if (t_385 instanceof _syntax2.default) {
	    return t_385.val();
	  }
	  return null;
	};
	class SyntaxOrTermWrapper_382 {
	  constructor(s_386) {
	    let context_387 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    this[symWrap_378] = s_386;
	    this.context = context_387;
	  }
	  match(type_388, value_389) {
	    let stx_390 = this[symWrap_378];
	    if (stx_390 instanceof _syntax2.default) {
	      return stx_390.match(type_388, value_389);
	    }
	  }
	  isIdentifier(value_391) {
	    return this.match("identifier", value_391);
	  }
	  isAssign(value_392) {
	    return this.match("assign", value_392);
	  }
	  isBooleanLiteral(value_393) {
	    return this.match("boolean", value_393);
	  }
	  isKeyword(value_394) {
	    return this.match("keyword", value_394);
	  }
	  isNullLiteral(value_395) {
	    return this.match("null", value_395);
	  }
	  isNumericLiteral(value_396) {
	    return this.match("number", value_396);
	  }
	  isPunctuator(value_397) {
	    return this.match("punctuator", value_397);
	  }
	  isStringLiteral(value_398) {
	    return this.match("string", value_398);
	  }
	  isRegularExpression(value_399) {
	    return this.match("regularExpression", value_399);
	  }
	  isTemplate(value_400) {
	    return this.match("template", value_400);
	  }
	  isDelimiter(value_401) {
	    return this.match("delimiter", value_401);
	  }
	  isParens(value_402) {
	    return this.match("parens", value_402);
	  }
	  isBraces(value_403) {
	    return this.match("braces", value_403);
	  }
	  isBrackets(value_404) {
	    return this.match("brackets", value_404);
	  }
	  isSyntaxTemplate(value_405) {
	    return this.match("syntaxTemplate", value_405);
	  }
	  isEOF(value_406) {
	    return this.match("eof", value_406);
	  }
	  lineNumber() {
	    return getLineNumber_380(this[symWrap_378]);
	  }
	  val() {
	    return getVal_381(this[symWrap_378]);
	  }
	  inner() {
	    let stx_407 = this[symWrap_378];
	    if (!stx_407.match("delimiter")) {
	      throw new Error("Can only get inner syntax on a delimiter");
	    }
	    let enf_408 = new _enforester.Enforester(stx_407.inner(), (0, _immutable.List)(), this.context);
	    return new MacroContext(enf_408, "inner", this.context);
	  }
	}
	function unwrap_383(x_409) {
	  if (x_409 instanceof SyntaxOrTermWrapper_382) {
	    return x_409[symWrap_378];
	  }
	  return x_409;
	}
	class MacroContext {
	  constructor(enf_410, name_411, context_412, useScope_413, introducedScope_414) {
	    const priv_415 = { backup: enf_410, name: name_411, context: context_412 };
	    if (useScope_413 && introducedScope_414) {
	      priv_415.noScopes = false;
	      priv_415.useScope = useScope_413;
	      priv_415.introducedScope = introducedScope_414;
	    } else {
	      priv_415.noScopes = true;
	    }
	    privateData_379.set(this, priv_415);
	    this.reset();
	    this[Symbol.iterator] = () => this;
	  }
	  name() {
	    var _privateData_379$get = privateData_379.get(this);

	    const name = _privateData_379$get.name;
	    const context = _privateData_379$get.context;

	    return new SyntaxOrTermWrapper_382(name, context);
	  }
	  expand(type_416) {
	    var _privateData_379$get2 = privateData_379.get(this);

	    const enf = _privateData_379$get2.enf;
	    const context = _privateData_379$get2.context;

	    if (enf.rest.size === 0) {
	      return { done: true, value: null };
	    }
	    enf.expandMacro();
	    let originalRest_417 = enf.rest;
	    let value_418;
	    switch (type_416) {
	      case "AssignmentExpression":
	      case "expr":
	        value_418 = enf.enforestExpressionLoop();
	        break;
	      case "Expression":
	        value_418 = enf.enforestExpression();
	        break;
	      case "Statement":
	      case "stmt":
	        value_418 = enf.enforestStatement();
	        break;
	      case "BlockStatement":
	      case "WhileStatement":
	      case "IfStatement":
	      case "ForStatement":
	      case "SwitchStatement":
	      case "BreakStatement":
	      case "ContinueStatement":
	      case "DebuggerStatement":
	      case "WithStatement":
	      case "TryStatement":
	      case "ThrowStatement":
	      case "ClassDeclaration":
	      case "FunctionDeclaration":
	      case "LabeledStatement":
	      case "VariableDeclarationStatement":
	      case "ReturnStatement":
	      case "ExpressionStatement":
	        value_418 = enf.enforestStatement();
	        (0, _errors.expect)(_.whereEq({ type: type_416 }, value_418), `Expecting a ${ type_416 }`, value_418, originalRest_417);
	        break;
	      case "YieldExpression":
	        value_418 = enf.enforestYieldExpression();
	        break;
	      case "ClassExpression":
	        value_418 = enf.enforestClass({ isExpr: true });
	        break;
	      case "ArrowExpression":
	        value_418 = enf.enforestArrowExpression();
	        break;
	      case "NewExpression":
	        value_418 = enf.enforestNewExpression();
	        break;
	      case "ThisExpression":
	      case "FunctionExpression":
	      case "IdentifierExpression":
	      case "LiteralNumericExpression":
	      case "LiteralInfinityExpression":
	      case "LiteralStringExpression":
	      case "TemplateExpression":
	      case "LiteralBooleanExpression":
	      case "LiteralNullExpression":
	      case "LiteralRegExpExpression":
	      case "ObjectExpression":
	      case "ArrayExpression":
	        value_418 = enf.enforestPrimaryExpression();
	        break;
	      case "UnaryExpression":
	      case "UpdateExpression":
	      case "BinaryExpression":
	      case "StaticMemberExpression":
	      case "ComputedMemberExpression":
	      case "AssignmentExpression":
	      case "CompoundAssignmentExpression":
	      case "ConditionalExpression":
	        value_418 = enf.enforestExpressionLoop();
	        (0, _errors.expect)(_.whereEq({ type: type_416 }, value_418), `Expecting a ${ type_416 }`, value_418, originalRest_417);
	        break;
	      default:
	        throw new Error("Unknown term type: " + type_416);
	    }
	    return { done: false, value: new SyntaxOrTermWrapper_382(value_418, context) };
	  }
	  _rest(enf_419) {
	    const priv_420 = privateData_379.get(this);
	    if (priv_420.backup === enf_419) {
	      return priv_420.enf.rest;
	    }
	    throw Error("Unauthorized access!");
	  }
	  reset() {
	    const priv_421 = privateData_379.get(this);
	    var _priv_421$backup = priv_421.backup;
	    const rest = _priv_421$backup.rest;
	    const prev = _priv_421$backup.prev;
	    const context = _priv_421$backup.context;

	    priv_421.enf = new _enforester.Enforester(rest, prev, context);
	  }
	  next() {
	    var _privateData_379$get3 = privateData_379.get(this);

	    const enf = _privateData_379$get3.enf;
	    const noScopes = _privateData_379$get3.noScopes;
	    const useScope = _privateData_379$get3.useScope;
	    const introducedScope = _privateData_379$get3.introducedScope;
	    const context = _privateData_379$get3.context;

	    if (enf.rest.size === 0) {
	      return { done: true, value: null };
	    }
	    let value_422 = enf.advance();
	    if (!noScopes) {
	      value_422 = value_422.addScope(useScope, context.bindings, _syntax.ALL_PHASES).addScope(introducedScope, context.bindings, _syntax.ALL_PHASES, { flip: true });
	    }
	    return { done: false, value: new SyntaxOrTermWrapper_382(value_422, context) };
	  }
	}
	exports.default = MacroContext;
	exports.SyntaxOrTermWrapper = SyntaxOrTermWrapper_382;
	exports.unwrap = unwrap_383;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L21hY3JvLWNvbnRleHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztJQUFhLEM7Ozs7OztBQUNiLE1BQU0sV0FBVyxvQkFBTSxJQUF2QjtBQUNBLE1BQU0sY0FBYyxvQkFBTSxPQUExQjtBQUNBLE1BQU0sY0FBYyxPQUFPLFNBQVAsQ0FBcEI7QUFDQSxNQUFNLGtCQUFrQixJQUFJLE9BQUosRUFBeEI7QUFDQSxNQUFNLG9CQUFvQixTQUFTO0FBQ2pDLE1BQUksaUNBQUosRUFBNkI7QUFDM0IsV0FBTyxNQUFNLFVBQU4sRUFBUDtBQUNEO0FBQ0QsUUFBTSxJQUFJLEtBQUosQ0FBVSwyQ0FBVixDQUFOO0FBQ0QsQ0FMRDtBQU1BLE1BQU0sYUFBYSxTQUFTO0FBQzFCLE1BQUksTUFBTSxLQUFOLENBQVksV0FBWixDQUFKLEVBQThCO0FBQzVCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSSxpQ0FBSixFQUE2QjtBQUMzQixXQUFPLE1BQU0sR0FBTixFQUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVJEO0FBU0EsTUFBTSx1QkFBTixDQUE4QjtBQUM1QixjQUFZLEtBQVosRUFBcUM7QUFBQSxRQUFsQixXQUFrQix5REFBSixFQUFJOztBQUNuQyxTQUFLLFdBQUwsSUFBb0IsS0FBcEI7QUFDQSxTQUFLLE9BQUwsR0FBZSxXQUFmO0FBQ0Q7QUFDRCxRQUFNLFFBQU4sRUFBZ0IsU0FBaEIsRUFBMkI7QUFDekIsUUFBSSxVQUFVLEtBQUssV0FBTCxDQUFkO0FBQ0EsUUFBSSxtQ0FBSixFQUErQjtBQUM3QixhQUFPLFFBQVEsS0FBUixDQUFjLFFBQWQsRUFBd0IsU0FBeEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxlQUFhLFNBQWIsRUFBd0I7QUFDdEIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxZQUFYLEVBQXlCLFNBQXpCLENBQVA7QUFDRDtB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QzRDLE9BRDVDLHlCQUM0QyxPQUQ1Qzs7QUFFTCxRQUFJLElBQUksSUFBSixDQUFTLElBQVQsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsYUFBTyxFQUFDLE1BQU0sSUFBUCxFQUFhLE9BQU8sSUFBcEIsRUFBUDtBQUNEO0FBQ0QsUUFBSSxZQUFZLElBQUksT0FBSixFQUFoQjtBQUNBLFFBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixrQkFBWSxVQUFVLFFBQVYsQ0FBbUIsUUFBbkIsRUFBNkIsUUFBUSxRQUFyQyxzQkFBMkQsUUFBM0QsQ0FBb0UsZUFBcEUsRUFBcUYsUUFBUSxRQUE3RixzQkFBbUgsRUFBQyxNQUFNLElBQVAsRUFBbkgsQ0FBWjtBQUNEO0FBQ0QsV0FBTyxFQUFDLE1BQU0sS0FBUCxFQUFjLE9BQU8sSUFBSSx1QkFBSixDQUE0QixTQUE1QixFQUF1QyxPQUF2QyxDQUFyQixFQUFQO0FBQ0Q7QUExSCtCO2tCQUFiLFk7UUE0SGMsbUIsR0FBM0IsdUI7UUFDYyxNLEdBQWQsVSIsImZpbGUiOiJtYWNyby1jb250ZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hcFN5bnRheFJlZHVjZXIgZnJvbSBcIi4vbWFwLXN5bnRheC1yZWR1Y2VyXCI7XG5pbXBvcnQgcmVkdWNlciBmcm9tIFwic2hpZnQtcmVkdWNlclwiO1xuaW1wb3J0IHtleHBlY3R9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQge0VuZm9yZXN0ZXJ9IGZyb20gXCIuL2VuZm9yZXN0ZXJcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7TWF5YmV9IGZyb20gXCJyYW1kYS1mYW50YXN5XCI7XG5pbXBvcnQgICogYXMgXyBmcm9tIFwicmFtZGFcIjtcbmNvbnN0IEp1c3RfMzc2ID0gTWF5YmUuSnVzdDtcbmNvbnN0IE5vdGhpbmdfMzc3ID0gTWF5YmUuTm90aGluZztcbmNvbnN0IHN5bVdyYXBfMzc4ID0gU3ltYm9sKFwid3JhcHBlclwiKTtcbmNvbnN0IHByaXZhdGVEYXRhXzM3OSA9IG5ldyBXZWFrTWFwO1xuY29uc3QgZ2V0TGluZU51bWJlcl8zODAgPSB0XzM4NCA9PiB7XG4gIGlmICh0XzM4NCBpbnN0YW5jZW9mIFN5bnRheCkge1xuICAgIHJldHVybiB0XzM4NC5saW5lTnVtYmVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTGluZSBudW1iZXJzIG9uIHRlcm1zIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG59O1xuY29uc3QgZ2V0VmFsXzM4MSA9IHRfMzg1ID0+IHtcbiAgaWYgKHRfMzg1Lm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRfMzg1IGluc3RhbmNlb2YgU3ludGF4KSB7XG4gICAgcmV0dXJuIHRfMzg1LnZhbCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNsYXNzIFN5bnRheE9yVGVybVdyYXBwZXJfMzgyIHtcbiAgY29uc3RydWN0b3Ioc18zODYsIGNvbnRleHRfMzg3ID0ge30pIHtcbiAgICB0aGlzW3N5bVdyYXBfMzc4XSA9IHNfMzg2O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMzg3O1xuICB9XG4gIG1hdGNoKHR5cGVfMzg4LCB2YWx1ZV8zODkpIHtcbiAgICBsZXQgc3R4XzM5MCA9IHRoaXNbc3ltV3JhcF8zNzhdO1xuICAgIGlmIChzdHhfMzkwIGluc3RhbmNlb2YgU3ludGF4KSB7XG4gICAgICByZXR1cm4gc3R4XzM5MC5tYXRjaCh0eXBlXzM4OCwgdmFsdWVfMzg5KTtcbiAgICB9XG4gIH1cbiAgaXNJZGVudGlmaWVyKHZhbHVlXzM5MSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiaWRlbnRpZmllclwiLCB2YWx1ZV8zOTEpO1xuICB9XG4gIGlzQXNzaWduKHZhbHVlXzM5Mikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiYXNzaWduXCIsIHZhbHVlXzM5Mik7XG4gIH1cbiAgaXNCb29sZWFuTGl0ZXJhbCh2YWx1ZV8zOTMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJvb2xlYW5cIiwgdmFsdWVfMzkzKTtcbiAgfVxuICBpc0tleXdvcmQodmFsdWVfMzk0KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJrZXl3b3JkXCIsIHZhbHVlXzM5NCk7XG4gIH1cbiAgaXNOdWxsTGl0ZXJhbCh2YWx1ZV8zOTUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcIm51bGxcIiwgdmFsdWVfMzk1KTtcbiAgfVxuICBpc051bWVyaWNMaXRlcmFsKHZhbHVlXzM5Nikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwibnVtYmVyXCIsIHZhbHVlXzM5Nik7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHZhbHVlXzM5Nykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwicHVuY3R1YXRvclwiLCB2YWx1ZV8zOTcpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh2YWx1ZV8zOTgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcInN0cmluZ1wiLCB2YWx1ZV8zOTgpO1xuICB9XG4gIGlzUmVndWxhckV4cHJlc3Npb24odmFsdWVfMzk5KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJyZWd1bGFyRXhwcmVzc2lvblwiLCB2YWx1ZV8zOTkpO1xuICB9XG4gIGlzVGVtcGxhdGUodmFsdWVfNDAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJ0ZW1wbGF0ZVwiLCB2YWx1ZV80MDApO1xuICB9XG4gIGlzRGVsaW1pdGVyKHZhbHVlXzQwMSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIsIHZhbHVlXzQwMSk7XG4gIH1cbiAgaXNQYXJlbnModmFsdWVfNDAyKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJwYXJlbnNcIiwgdmFsdWVfNDAyKTtcbiAgfVxuICBpc0JyYWNlcyh2YWx1ZV80MDMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJyYWNlc1wiLCB2YWx1ZV80MDMpO1xuICB9XG4gIGlzQnJhY2tldHModmFsdWVfNDA0KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJicmFja2V0c1wiLCB2YWx1ZV80MDQpO1xuICB9XG4gIGlzU3ludGF4VGVtcGxhdGUodmFsdWVfNDA1KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJzeW50YXhUZW1wbGF0ZVwiLCB2YWx1ZV80MDUpO1xuICB9XG4gIGlzRU9GKHZhbHVlXzQwNikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZW9mXCIsIHZhbHVlXzQwNik7XG4gIH1cbiAgbGluZU51bWJlcigpIHtcbiAgICByZXR1cm4gZ2V0TGluZU51bWJlcl8zODAodGhpc1tzeW1XcmFwXzM3OF0pO1xuICB9XG4gIHZhbCgpIHtcbiAgICByZXR1cm4gZ2V0VmFsXzM4MSh0aGlzW3N5bVdyYXBfMzc4XSk7XG4gIH1cbiAgaW5uZXIoKSB7XG4gICAgbGV0IHN0eF80MDcgPSB0aGlzW3N5bVdyYXBfMzc4XTtcbiAgICBpZiAoIXN0eF80MDcubWF0Y2goXCJkZWxpbWl0ZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGdldCBpbm5lciBzeW50YXggb24gYSBkZWxpbWl0ZXJcIik7XG4gICAgfVxuICAgIGxldCBlbmZfNDA4ID0gbmV3IEVuZm9yZXN0ZXIoc3R4XzQwNy5pbm5lcigpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgcmV0dXJuIG5ldyBNYWNyb0NvbnRleHQoZW5mXzQwOCwgXCJpbm5lclwiLCB0aGlzLmNvbnRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB1bndyYXBfMzgzKHhfNDA5KSB7XG4gIGlmICh4XzQwOSBpbnN0YW5jZW9mIFN5bnRheE9yVGVybVdyYXBwZXJfMzgyKSB7XG4gICAgcmV0dXJuIHhfNDA5W3N5bVdyYXBfMzc4XTtcbiAgfVxuICByZXR1cm4geF80MDk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWNyb0NvbnRleHQge1xuICBjb25zdHJ1Y3RvcihlbmZfNDEwLCBuYW1lXzQxMSwgY29udGV4dF80MTIsIHVzZVNjb3BlXzQxMywgaW50cm9kdWNlZFNjb3BlXzQxNCkge1xuICAgIGNvbnN0IHByaXZfNDE1ID0ge2JhY2t1cDogZW5mXzQxMCwgbmFtZTogbmFtZV80MTEsIGNvbnRleHQ6IGNvbnRleHRfNDEyfTtcbiAgICBpZiAodXNlU2NvcGVfNDEzICYmIGludHJvZHVjZWRTY29wZV80MTQpIHtcbiAgICAgIHByaXZfNDE1Lm5vU2NvcGVzID0gZmFsc2U7XG4gICAgICBwcml2XzQxNS51c2VTY29wZSA9IHVzZVNjb3BlXzQxMztcbiAgICAgIHByaXZfNDE1LmludHJvZHVjZWRTY29wZSA9IGludHJvZHVjZWRTY29wZV80MTQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaXZfNDE1Lm5vU2NvcGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJpdmF0ZURhdGFfMzc5LnNldCh0aGlzLCBwcml2XzQxNSk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXNbU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHRoaXM7XG4gIH1cbiAgbmFtZSgpIHtcbiAgICBjb25zdCB7bmFtZSwgY29udGV4dH0gPSBwcml2YXRlRGF0YV8zNzkuZ2V0KHRoaXMpO1xuICAgIHJldHVybiBuZXcgU3ludGF4T3JUZXJtV3JhcHBlcl8zODIobmFtZSwgY29udGV4dCk7XG4gIH1cbiAgZXhwYW5kKHR5cGVfNDE2KSB7XG4gICAgY29uc3Qge2VuZiwgY29udGV4dH0gPSBwcml2YXRlRGF0YV8zNzkuZ2V0KHRoaXMpO1xuICAgIGlmIChlbmYucmVzdC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IHRydWUsIHZhbHVlOiBudWxsfTtcbiAgICB9XG4gICAgZW5mLmV4cGFuZE1hY3JvKCk7XG4gICAgbGV0IG9yaWdpbmFsUmVzdF80MTcgPSBlbmYucmVzdDtcbiAgICBsZXQgdmFsdWVfNDE4O1xuICAgIHN3aXRjaCAodHlwZV80MTYpIHtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcImV4cHJcIjpcbiAgICAgICAgdmFsdWVfNDE4ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblwiOlxuICAgICAgICB2YWx1ZV80MTggPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcInN0bXRcIjpcbiAgICAgICAgdmFsdWVfNDE4ID0gZW5mLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIldpdGhTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgIHZhbHVlXzQxOCA9IGVuZi5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgICAgICBleHBlY3QoXy53aGVyZUVxKHt0eXBlOiB0eXBlXzQxNn0sIHZhbHVlXzQxOCksIGBFeHBlY3RpbmcgYSAke3R5cGVfNDE2fWAsIHZhbHVlXzQxOCwgb3JpZ2luYWxSZXN0XzQxNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIllpZWxkRXhwcmVzc2lvblwiOlxuICAgICAgICB2YWx1ZV80MTggPSBlbmYuZW5mb3Jlc3RZaWVsZEV4cHJlc3Npb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgIHZhbHVlXzQxOCA9IGVuZi5lbmZvcmVzdENsYXNzKHtpc0V4cHI6IHRydWV9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dFeHByZXNzaW9uXCI6XG4gICAgICAgIHZhbHVlXzQxOCA9IGVuZi5lbmZvcmVzdEFycm93RXhwcmVzc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgIHZhbHVlXzQxOCA9IGVuZi5lbmZvcmVzdE5ld0V4cHJlc3Npb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVGhpc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxOdW1lcmljRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxJbmZpbml0eUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJMaXRlcmFsU3RyaW5nRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxCb29sZWFuRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxOdWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxSZWdFeHBFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICB2YWx1ZV80MTggPSBlbmYuZW5mb3Jlc3RQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmFsdWVfNDE4ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgZXhwZWN0KF8ud2hlcmVFcSh7dHlwZTogdHlwZV80MTZ9LCB2YWx1ZV80MTgpLCBgRXhwZWN0aW5nIGEgJHt0eXBlXzQxNn1gLCB2YWx1ZV80MTgsIG9yaWdpbmFsUmVzdF80MTcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGVybSB0eXBlOiBcIiArIHR5cGVfNDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHtkb25lOiBmYWxzZSwgdmFsdWU6IG5ldyBTeW50YXhPclRlcm1XcmFwcGVyXzM4Mih2YWx1ZV80MTgsIGNvbnRleHQpfTtcbiAgfVxuICBfcmVzdChlbmZfNDE5KSB7XG4gICAgY29uc3QgcHJpdl80MjAgPSBwcml2YXRlRGF0YV8zNzkuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2XzQyMC5iYWNrdXAgPT09IGVuZl80MTkpIHtcbiAgICAgIHJldHVybiBwcml2XzQyMC5lbmYucmVzdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzIVwiKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zdCBwcml2XzQyMSA9IHByaXZhdGVEYXRhXzM3OS5nZXQodGhpcyk7XG4gICAgY29uc3Qge3Jlc3QsIHByZXYsIGNvbnRleHR9ID0gcHJpdl80MjEuYmFja3VwO1xuICAgIHByaXZfNDIxLmVuZiA9IG5ldyBFbmZvcmVzdGVyKHJlc3QsIHByZXYsIGNvbnRleHQpO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3Qge2VuZiwgbm9TY29wZXMsIHVzZVNjb3BlLCBpbnRyb2R1Y2VkU2NvcGUsIGNvbnRleHR9ID0gcHJpdmF0ZURhdGFfMzc5LmdldCh0aGlzKTtcbiAgICBpZiAoZW5mLnJlc3Quc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtkb25lOiB0cnVlLCB2YWx1ZTogbnVsbH07XG4gICAgfVxuICAgIGxldCB2YWx1ZV80MjIgPSBlbmYuYWR2YW5jZSgpO1xuICAgIGlmICghbm9TY29wZXMpIHtcbiAgICAgIHZhbHVlXzQyMiA9IHZhbHVlXzQyMi5hZGRTY29wZSh1c2VTY29wZSwgY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUykuYWRkU2NvcGUoaW50cm9kdWNlZFNjb3BlLCBjb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTLCB7ZmxpcDogdHJ1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4ge2RvbmU6IGZhbHNlLCB2YWx1ZTogbmV3IFN5bnRheE9yVGVybVdyYXBwZXJfMzgyKHZhbHVlXzQyMiwgY29udGV4dCl9O1xuICB9XG59XG5leHBvcnQge1N5bnRheE9yVGVybVdyYXBwZXJfMzgyIGFzIFN5bnRheE9yVGVybVdyYXBwZXJ9O1xuZXhwb3J0IHt1bndyYXBfMzgzIGFzIHVud3JhcH0iXX0=

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReducer = __webpack_require__(32);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class MapSyntaxReducer extends _shiftReducer.CloneReducer {
	  constructor(fn_423) {
	    super();
	    this.fn = fn_423;
	  }
	  reduceBindingIdentifier(node_424, state_425) {
	    let name_426 = this.fn(node_424.name);
	    return new _terms2.default("BindingIdentifier", { name: name_426 });
	  }
	  reduceIdentifierExpression(node_427, state_428) {
	    let name_429 = this.fn(node_427.name);
	    return new _terms2.default("IdentifierExpression", { name: name_429 });
	  }
	}
	exports.default = MapSyntaxReducer;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L21hcC1zeW50YXgtcmVkdWNlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ2UsTUFBTSxnQkFBTixvQ0FBNEM7QUFDekQsY0FBWSxNQUFaLEVBQW9CO0FBQ2xCO0FBQ0EsU0FBSyxFQUFMLEdBQVUsTUFBVjtBQUNEO0FBQ0QsMEJBQXdCLFFBQXhCLEVBQWtDLFNBQWxDLEVBQTZDO0FBQzNDLFFBQUksV0FBVyxLQUFLLEVBQUwsQ0FBUSxTQUFTLElBQWpCLENBQWY7QUFDQSxXQUFPLG9CQUFTLG1CQUFULEVBQThCLEVBQUMsTUFBTSxRQUFQLEVBQTlCLENBQVA7QUFDRDtBQUNELDZCQUEyQixRQUEzQixFQUFxQyxTQUFyQyxFQUFnRDtBQUM5QyxRQUFJLFdBQVcsS0FBSyxFQUFMLENBQVEsU0FBUyxJQUFqQixDQUFmO0FBQ0EsV0FBTyxvQkFBUyxzQkFBVCxFQUFpQyxFQUFDLE1BQU0sUUFBUCxFQUFqQyxDQUFQO0FBQ0Q7QUFad0Q7a0JBQXRDLGdCIiwiZmlsZSI6Im1hcC1zeW50YXgtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge0Nsb25lUmVkdWNlcn0gZnJvbSBcInNoaWZ0LXJlZHVjZXJcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcFN5bnRheFJlZHVjZXIgZXh0ZW5kcyBDbG9uZVJlZHVjZXIge1xuICBjb25zdHJ1Y3Rvcihmbl80MjMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm4gPSBmbl80MjM7XG4gIH1cbiAgcmVkdWNlQmluZGluZ0lkZW50aWZpZXIobm9kZV80MjQsIHN0YXRlXzQyNSkge1xuICAgIGxldCBuYW1lXzQyNiA9IHRoaXMuZm4obm9kZV80MjQubmFtZSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfNDI2fSk7XG4gIH1cbiAgcmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24obm9kZV80MjcsIHN0YXRlXzQyOCkge1xuICAgIGxldCBuYW1lXzQyOSA9IHRoaXMuZm4obm9kZV80MjcubmFtZSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IG5hbWVfNDI5fSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.collectBindings = exports.CollectBindingSyntax = undefined;

	var _symbol = __webpack_require__(44);

	var _transforms = __webpack_require__(31);

	var _errors = __webpack_require__(13);

	var _terms = __webpack_require__(28);

	var _terms2 = _interopRequireDefault(_terms);

	var _immutable = __webpack_require__(11);

	var _astDispatcher = __webpack_require__(63);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	var _ramda = __webpack_require__(27);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class CollectBindingSyntax_326 extends _astDispatcher2.default {
	  constructor() {
	    super("collect", true);
	    this.names = (0, _immutable.List)();
	  }
	  collect(term_328) {
	    return this.dispatch(term_328);
	  }
	  collectBindingIdentifier(term_329) {
	    return this.names.concat(term_329.name);
	  }
	  collectBindingPropertyIdentifier(term_330) {
	    return this.collect(term_330.binding);
	  }
	  collectBindingPropertyProperty(term_331) {
	    return this.collect(term_331.binding);
	  }
	  collectArrayBinding(term_332) {
	    let restElement_333 = null;
	    if (term_332.restElement != null) {
	      restElement_333 = this.collect(term_332.restElement);
	    }
	    return this.names.concat(restElement_333).concat(term_332.elements.filter(el_334 => el_334 != null).flatMap(el_335 => this.collect(el_335)));
	  }
	  collectObjectBinding(term_336) {
	    return (0, _immutable.List)();
	  }
	}
	function collectBindings_327(term_337) {
	  return new CollectBindingSyntax_326().collect(term_337);
	}
	exports.CollectBindingSyntax = CollectBindingSyntax_326;
	exports.collectBindings = collectBindings_327;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2h5Z2llbmUtdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDYixNQUFNLHdCQUFOLGlDQUFxRDtBQUNuRCxnQkFBYztBQUNaLFVBQU0sU0FBTixFQUFpQixJQUFqQjtBQUNBLFNBQUssS0FBTCxHQUFhLHNCQUFiO0FBQ0Q7QUFDRCxVQUFRLFFBQVIsRUFBa0I7QUFDaEIsV0FBTyxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQVA7QUFDRDtBQUNELDJCQUF5QixRQUF6QixFQUFtQztBQUNqQyxXQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsU0FBUyxJQUEzQixDQUFQO0FBQ0Q7QUFDRCxtQ0FBaUMsUUFBakMsRUFBMkM7QUFDekMsV0FBTyxLQUFLLE9BQUwsQ0FBYSxTQUFTLE9BQXRCLENBQVA7QUFDRDtBQUNELGlDQUErQixRQUEvQixFQUF5QztBQUN2QyxXQUFPLEtBQUssT0FBTCxDQUFhLFNBQVMsT0FBdEIsQ0FBUDtBQUNEO0FBQ0Qsc0JBQW9CLFFBQXBCLEVBQThCO0FBQzVCLFFBQUksa0JBQWtCLElBQXRCO0FBQ0EsUUFBSSxTQUFTLFdBQVQsSUFBd0IsSUFBNUIsRUFBa0M7QUFDaEMsd0JBQWtCLEtBQUssT0FBTCxDQUFhLFNBQVMsV0FBdEIsQ0FBbEI7QUFDRDtBQUNELFdBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixlQUFsQixFQUFtQyxNQUFuQyxDQUEwQyxTQUFTLFFBQVQsQ0FBa0IsTUFBbEIsQ0FBeUIsVUFBVSxVQUFVLElBQTdDLEVBQW1ELE9BQW5ELENBQTJELFVBQVUsS0FBSyxPQUFMLENBQWEsTUFBYixDQUFyRSxDQUExQyxDQUFQO0FBQ0Q7QUFDRCx1QkFBcUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBTyxzQkFBUDtBQUNEO0FBMUJrRDtBQTRCckQsU0FBUyxtQkFBVCxDQUE2QixRQUE3QixFQUF1QztBQUNyQyxTQUFRLElBQUksd0JBQUosRUFBRCxDQUErQixPQUEvQixDQUF1QyxRQUF2QyxDQUFQO0FBQ0Q7UUFDbUMsb0IsR0FBNUIsd0I7UUFDdUIsZSxHQUF2QixtQiIsImZpbGUiOiJoeWdpZW5lLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZW5zeW19IGZyb20gXCIuL3N5bWJvbFwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgVGVybSwge2lzRU9GLCBpc0JpbmRpbmdJZGVudGlmaWVyLCBpc0JpbmRpbmdQcm9wZXJ0eVByb3BlcnR5LCBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIsIGlzT2JqZWN0QmluZGluZywgaXNBcnJheUJpbmRpbmcsIGlzRnVuY3Rpb25EZWNsYXJhdGlvbiwgaXNGdW5jdGlvbkV4cHJlc3Npb24sIGlzRnVuY3Rpb25UZXJtLCBpc0Z1bmN0aW9uV2l0aE5hbWUsIGlzU3ludGF4RGVjbGFyYXRpb24sIGlzU3ludGF4cmVjRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50LCBpc0ltcG9ydCwgaXNFeHBvcnQsIGlzUHJhZ21hLCBpc0V4cG9ydFN5bnRheH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IEFTVERpc3BhdGNoZXIgZnJvbSBcIi4vYXN0LWRpc3BhdGNoZXJcIjtcbmltcG9ydCAgKiBhcyBfIGZyb20gXCJyYW1kYVwiO1xuY2xhc3MgQ29sbGVjdEJpbmRpbmdTeW50YXhfMzI2IGV4dGVuZHMgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiY29sbGVjdFwiLCB0cnVlKTtcbiAgICB0aGlzLm5hbWVzID0gTGlzdCgpO1xuICB9XG4gIGNvbGxlY3QodGVybV8zMjgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0ZXJtXzMyOCk7XG4gIH1cbiAgY29sbGVjdEJpbmRpbmdJZGVudGlmaWVyKHRlcm1fMzI5KSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuY29uY2F0KHRlcm1fMzI5Lm5hbWUpO1xuICB9XG4gIGNvbGxlY3RCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyKHRlcm1fMzMwKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCh0ZXJtXzMzMC5iaW5kaW5nKTtcbiAgfVxuICBjb2xsZWN0QmluZGluZ1Byb3BlcnR5UHJvcGVydHkodGVybV8zMzEpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KHRlcm1fMzMxLmJpbmRpbmcpO1xuICB9XG4gIGNvbGxlY3RBcnJheUJpbmRpbmcodGVybV8zMzIpIHtcbiAgICBsZXQgcmVzdEVsZW1lbnRfMzMzID0gbnVsbDtcbiAgICBpZiAodGVybV8zMzIucmVzdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgcmVzdEVsZW1lbnRfMzMzID0gdGhpcy5jb2xsZWN0KHRlcm1fMzMyLnJlc3RFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuY29uY2F0KHJlc3RFbGVtZW50XzMzMykuY29uY2F0KHRlcm1fMzMyLmVsZW1lbnRzLmZpbHRlcihlbF8zMzQgPT4gZWxfMzM0ICE9IG51bGwpLmZsYXRNYXAoZWxfMzM1ID0+IHRoaXMuY29sbGVjdChlbF8zMzUpKSk7XG4gIH1cbiAgY29sbGVjdE9iamVjdEJpbmRpbmcodGVybV8zMzYpIHtcbiAgICByZXR1cm4gTGlzdCgpO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0QmluZGluZ3NfMzI3KHRlcm1fMzM3KSB7XG4gIHJldHVybiAobmV3IENvbGxlY3RCaW5kaW5nU3ludGF4XzMyNikuY29sbGVjdCh0ZXJtXzMzNyk7XG59XG5leHBvcnQge0NvbGxlY3RCaW5kaW5nU3ludGF4XzMyNiBhcyBDb2xsZWN0QmluZGluZ1N5bnRheH07XG5leHBvcnQge2NvbGxlY3RCaW5kaW5nc18zMjcgYXMgY29sbGVjdEJpbmRpbmdzfSJdfQ==

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// MODULES //

	var isString = __webpack_require__( 68 ),
		re = __webpack_require__( 69 );


	// DIRNAME //

	/**
	* FUNCTION: dirname( path )
	*	Returns a path dirname.
	*
	* @param {String} path - path
	* @returns {String} directory name
	*/
	function dirname( path ) {
		if ( !isString( path ) ) {
			throw new TypeError( 'invalid input argument. Path must be a primitive string. Value: `' + path + '`.' );
		}
		return re.exec( path )[ 1 ];
	} // end FUNCTION dirname()


	// EXPORTS //

	module.exports = dirname;


/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	*
	*	VALIDATE: string-primitive
	*
	*
	*	DESCRIPTION:
	*		- Validates if a value is a string primitive.
	*
	*
	*	NOTES:
	*		[1]
	*
	*
	*	TODO:
	*		[1]
	*
	*
	*	LICENSE:
	*		MIT
	*
	*	Copyright (c) 2015. Athan Reines.
	*
	*
	*	AUTHOR:
	*		Athan Reines. kgryte@gmail.com. 2015.
	*
	*/

	'use strict';

	/**
	* FUNCTION: isString( value )
	*	Validates if a value is a string primitive.
	*
	* @param {*} value - value to be validated
	* @returns {Boolean} boolean indicating if a value is a string primitive
	*/
	function isString( value ) {
		return typeof value === 'string';
	} // end FUNCTION isString()


	// EXPORTS //

	module.exports = isString;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// MODULES //

	var isWindows = __webpack_require__( 70 );


	// REGEX //

	var posix,
		win32,
		re;

	posix = __webpack_require__( 72 );
	win32 = __webpack_require__( 73 );

	if ( isWindows ) {
		re = win32;
	} else {
		re = posix;
	}


	// EXPORTS //

	module.exports = re;
	module.exports.posix = posix;
	module.exports.win32 = win32;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// MODULES //

	var platform = __webpack_require__( 71 );


	// EXPORTS //

	module.exports = ( platform === 'win32' );


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// EXPORTS //

	module.exports = process.platform;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';

	/**
	* REGEX: /^((?:\.(?![^\/]))|(?:(?:\/?|)(?:[\s\S]*?)))(?:\/+?|)(?:(?:\.{1,2}|[^\/]+?|)(?:\.[^.\/]*|))(?:[\/]*)$/
	*	Captures a POSIX path dirname. Modified from Node.js [source]{@link https://github.com/nodejs/node/blob/1a3b295d0f46b2189bd853800b1e63ab4d106b66/lib/path.js#L406}.
	*
	*	\^
	*		-	match any string which begins with
	*	()
	*		-	capture (includes root and dirname)
	*	(?:)
	*		-	capture but do not remember (handles '.' and './' cases)
	*	\.(?![^\/])
	*		-	a . literal if the . literal is NOT followed by something other than a / literal
	*	|
	*		-	OR
	*	(?:)
	*		-	capture but do not remember (handles root+dirname case)
	*	(?:)
	*		-	capture but do not remember (root)
	*	\/?
	*		-	match a / literal 0 or 1 time
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (directory)
	*	[\s\S]
	*		-	any space or non-space character
	*	*?
	*		-	zero or more times, but non-greedily (shortest possible match)
	*	(?:)
	*		-	capture but do not remember (slash)
	*	\/+?
	*		-	a / literal 1 or more times, but do so non-greedily
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (basename)
	*	\.{1,2}
	*		-	match a . literal 1 or 2 times
	*	|
	*		-	OR
	*	[^\/]+?
	*		-	match anything which is not a / literal 1 or more times, but do so non-greedily
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (extname)
	*	\.
	*		-	match a . literal
	*	[^.\/]
	*		-	match anything which is not a . or / literal
	*	*
	*		-	zero or more times
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (trailing slash)
	*	[\/]
	*		-	match a / literal
	*	*
	*		-	zero or more times
	*	$
	*		-	end of string
	*/
	var re = /^((?:\.(?![^\/]))|(?:(?:\/?|)(?:[\s\S]*?)))(?:\/+?|)(?:(?:\.{1,2}|[^\/]+?|)(?:\.[^.\/]*|))(?:[\/]*)$/;


	// EXPORTS //

	module.exports = re;


/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';

	/**
	* REGEX: /^((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+|)(?:[\\\/]|)(?:[\s\S]*?))(?:[\\\/]+?|)(?:(?:\.{1,2}|[^\\\/]+?|)(?:\.[^.\/\\]*|))(?:[\\\/]*)$/
	*	Capture a Windows path dirname. Modified from Node.js [source]{@link https://github.com/nodejs/node/blob/1a3b295d0f46b2189bd853800b1e63ab4d106b66/lib/path.js#L65}.
	*
	*	^
	*		-	match any string which begins with
	*	()
	*		-	capture (includes the device, slash, and dirname)
	*	(?:)
	*		-	capture but do not remember (device)
	*	[a-zA-Z]:
	*		-	match any upper or lowercase letter and a : literal
	*	|
	*		-	OR
	*	[\\\/]
	*		-	match a \ or / literal character
	*	{2}
	*		-	exactly 2 times
	*	[^\\\/]+
	*		-	match anything but a \ or / literal one or more times
	*	[\\\/]+
	*		-	match a \ or / literal one or more times
	*	[^\\\/]+
	*		-	match anything but a \ or / literal one or more times
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (slash)
	*	[\\\/]
	*		-	match a \ or / literal
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (dirname)
	*	[\s\S]
	*		-	match any space or non-space character
	*	*?
	*		-	zero or more times but do so non-greedily
	*	(?:)
	*		-	capture but do not remember (slash before basename)
	*	[\\\/]+?
	*		-	match a \ or / literal one or more times, but do so non-greedily
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (basename)
	*	(?:)
	*		-	capture but do not remember
	*	\.{1,2}
	*		-	match a . literal one or two times
	*	|
	*		-	OR
	*	[^\\\/]+?
	*		-	match anything but a \ or / literal one or more times, but do so non-greedily
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (extname)
	*	\.
	*		-	match a . literal
	*	[^.\/\\]*
	*		-	match anything but a ., /, or \ literal zero or more times
	*	|)
	*		-	OR capture nothing
	*	(?:)
	*		-	capture but do not remember (trailing slash)
	*	[\\\/]*
	*		-	match a \ or / literal zero or more times
	*	$
	*		-	end of string
	*/
	var re = /^((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+|)(?:[\\\/]|)(?:[\s\S]*?))(?:[\\\/]+?|)(?:(?:\.{1,2}|[^\\\/]+?|)(?:\.[^.\/\\]*|))(?:[\\\/]*)$/;


	// EXPORTS //

	module.exports = re;


/***/ },
/* 74 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 75 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 76 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.compile = exports.parse = exports.expand = undefined;

		var _shiftReader = __webpack_require__(1);

		var _shiftReader2 = _interopRequireDefault(_shiftReader);

		var _immutable = __webpack_require__(9);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _env = __webpack_require__(28);

		var _env2 = _interopRequireDefault(_env);

		var _shiftReducer = __webpack_require__(30);

		var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

		var _parseReducer = __webpack_require__(34);

		var _parseReducer2 = _interopRequireDefault(_parseReducer);

		var _shiftCodegen = __webpack_require__(35);

		var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

		var _scope = __webpack_require__(41);

		var _bindingMap = __webpack_require__(12);

		var _bindingMap2 = _interopRequireDefault(_bindingMap);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _modules = __webpack_require__(43);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function expand_751(source_754) {
		  let options_755 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		  let bindings_756 = new _bindingMap2.default();
		  let modules_757 = new _modules.Modules({ cwd: options_755.cwd, filename: options_755.filename, transform: options_755.transform ? options_755.transform : function (x_760) {
		      return { code: x_760 };
		    }, moduleResolver: options_755.moduleResolver, moduleLoader: options_755.moduleLoader, bindings: bindings_756 });
		  let compiledMod_758 = modules_757.compileEntrypoint(source_754, options_755.filename, options_755.enforcePragma);
		  let nativeImports_759 = compiledMod_758.importEntries.filter(imp_761 => !modules_757.has(imp_761.moduleSpecifier.val()));
		  return new _terms2.default("Module", { directives: (0, _immutable.List)(), items: nativeImports_759.concat(compiledMod_758.body).concat(compiledMod_758.exportEntries.interpose(new _terms2.default("EmptyStatement", {}))) });
		}
		function parse_752(source_762, options_763) {
		  let includeImports_764 = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

		  return (0, _shiftReducer2.default)(new _parseReducer2.default({ phase: 0 }), expand_751(source_762, options_763).gen({ includeImports: includeImports_764 }));
		}
		function compile_753(source_765) {
		  let options_766 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		  let ast_767 = parse_752(source_765, options_766, options_766.includeImports);
		  let gen_768 = (0, _shiftCodegen2.default)(ast_767, new _shiftCodegen.FormattedCodeGen());
		  return options_766.transform && !options_766.noBabel ? options_766.transform(gen_768, { babelrc: true, filename: options_766.filename }) : { code: gen_768 };
		}
		exports.expand = expand_751;
		exports.parse = parse_752;
		exports.compile = compile_753;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N3ZWV0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQSxTQUFTLFVBQVQsQ0FBb0IsVUFBcEIsRUFBa0Q7QUFBQSxNQUFsQixXQUFrQix5REFBSixFQUFJOztBQUNoRCxNQUFJLGVBQWUsMEJBQW5CO0FBQ0EsTUFBSSxjQUFjLHFCQUFZLEVBQUMsS0FBSyxZQUFZLEdBQWxCLEVBQXVCLFVBQVUsWUFBWSxRQUE3QyxFQUF1RCxXQUFXLFlBQVksU0FBWixHQUF3QixZQUFZLFNBQXBDLEdBQWdELFVBQVUsS0FBVixFQUFpQjtBQUMvSixhQUFPLEVBQUMsTUFBTSxLQUFQLEVBQVA7QUFDRCxLQUY2QixFQUUzQixnQkFBZ0IsWUFBWSxjQUZELEVBRWlCLGNBQWMsWUFBWSxZQUYzQyxFQUV5RCxVQUFVLFlBRm5FLEVBQVosQ0FBbEI7QUFHQSxNQUFJLGtCQUFrQixZQUFZLGlCQUFaLENBQThCLFVBQTlCLEVBQTBDLFlBQVksUUFBdEQsRUFBZ0UsWUFBWSxhQUE1RSxDQUF0QjtBQUNBLE1BQUksb0JBQW9CLGdCQUFnQixhQUFoQixDQUE4QixNQUE5QixDQUFxQyxXQUFXLENBQUMsWUFBWSxHQUFaLENBQWdCLFFBQVEsZUFBUixDQUF3QixHQUF4QixFQUFoQixDQUFqRCxDQUF4QjtBQUNBLFNBQU8sb0JBQVMsUUFBVCxFQUFtQixFQUFDLFlBQVksc0JBQWIsRUFBcUIsT0FBTyxrQkFBa0IsTUFBbEIsQ0FBeUIsZ0JBQWdCLElBQXpDLEVBQStDLE1BQS9DLENBQXNELGdCQUFnQixhQUFoQixDQUE4QixTQUE5QixDQUF3QyxvQkFBUyxnQkFBVCxFQUEyQixFQUEzQixDQUF4QyxDQUF0RCxDQUE1QixFQUFuQixDQUFQO0FBQ0Q7QUFDRCxTQUFTLFNBQVQsQ0FBbUIsVUFBbkIsRUFBK0IsV0FBL0IsRUFBdUU7QUFBQSxNQUEzQixrQkFBMkIseURBQU4sSUFBTTs7QUFDckUsU0FBTyw0QkFBTywyQkFBaUIsRUFBQyxPQUFPLENBQVIsRUFBakIsQ0FBUCxFQUFxQyxXQUFXLFVBQVgsRUFBdUIsV0FBdkIsRUFBb0MsR0FBcEMsQ0FBd0MsRUFBQyxnQkFBZ0Isa0JBQWpCLEVBQXhDLENBQXJDLENBQVA7QUFDRDtBQUNELFNBQVMsV0FBVCxDQUFxQixVQUFyQixFQUFtRDtBQUFBLE1BQWxCLFdBQWtCLHlEQUFKLEVBQUk7O0FBQ2pELE1BQUksVUFBVSxVQUFVLFVBQVYsRUFBc0IsV0FBdEIsRUFBbUMsWUFBWSxjQUEvQyxDQUFkO0FBQ0EsTUFBSSxVQUFVLDRCQUFRLE9BQVIsRUFBaUIsb0NBQWpCLENBQWQ7QUFDQSxTQUFPLFlBQVksU0FBWixJQUF5QixDQUFDLFlBQVksT0FBdEMsR0FBZ0QsWUFBWSxTQUFaLENBQXNCLE9BQXRCLEVBQStCLEVBQUMsU0FBUyxJQUFWLEVBQWdCLFVBQVUsWUFBWSxRQUF0QyxFQUEvQixDQUFoRCxHQUFrSSxFQUFDLE1BQU0sT0FBUCxFQUF6STtBQUNEO1FBQ3FCLE0sR0FBZCxVO1FBQ2EsSyxHQUFiLFM7UUFDZSxPLEdBQWYsVyIsImZpbGUiOiJzd2VldC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFkZXIgZnJvbSBcIi4vc2hpZnQtcmVhZGVyXCI7XG5pbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQgRW52IGZyb20gXCIuL2VudlwiO1xuaW1wb3J0IHJlZHVjZSBmcm9tIFwic2hpZnQtcmVkdWNlclwiO1xuaW1wb3J0IFBhcnNlUmVkdWNlciBmcm9tIFwiLi9wYXJzZS1yZWR1Y2VyXCI7XG5pbXBvcnQgY29kZWdlbiwge0Zvcm1hdHRlZENvZGVHZW59IGZyb20gXCJzaGlmdC1jb2RlZ2VuXCI7XG5pbXBvcnQge1Njb3BlLCBmcmVzaFNjb3BlfSBmcm9tIFwiLi9zY29wZVwiO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSBcIi4vYmluZGluZy1tYXAuanNcIjtcbmltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge01vZHVsZXN9IGZyb20gXCIuL21vZHVsZXNcIjtcbmZ1bmN0aW9uIGV4cGFuZF83NTEoc291cmNlXzc1NCwgb3B0aW9uc183NTUgPSB7fSkge1xuICBsZXQgYmluZGluZ3NfNzU2ID0gbmV3IEJpbmRpbmdNYXA7XG4gIGxldCBtb2R1bGVzXzc1NyA9IG5ldyBNb2R1bGVzKHtjd2Q6IG9wdGlvbnNfNzU1LmN3ZCwgZmlsZW5hbWU6IG9wdGlvbnNfNzU1LmZpbGVuYW1lLCB0cmFuc2Zvcm06IG9wdGlvbnNfNzU1LnRyYW5zZm9ybSA/IG9wdGlvbnNfNzU1LnRyYW5zZm9ybSA6IGZ1bmN0aW9uICh4Xzc2MCkge1xuICAgIHJldHVybiB7Y29kZTogeF83NjB9O1xuICB9LCBtb2R1bGVSZXNvbHZlcjogb3B0aW9uc183NTUubW9kdWxlUmVzb2x2ZXIsIG1vZHVsZUxvYWRlcjogb3B0aW9uc183NTUubW9kdWxlTG9hZGVyLCBiaW5kaW5nczogYmluZGluZ3NfNzU2fSk7XG4gIGxldCBjb21waWxlZE1vZF83NTggPSBtb2R1bGVzXzc1Ny5jb21waWxlRW50cnlwb2ludChzb3VyY2VfNzU0LCBvcHRpb25zXzc1NS5maWxlbmFtZSwgb3B0aW9uc183NTUuZW5mb3JjZVByYWdtYSk7XG4gIGxldCBuYXRpdmVJbXBvcnRzXzc1OSA9IGNvbXBpbGVkTW9kXzc1OC5pbXBvcnRFbnRyaWVzLmZpbHRlcihpbXBfNzYxID0+ICFtb2R1bGVzXzc1Ny5oYXMoaW1wXzc2MS5tb2R1bGVTcGVjaWZpZXIudmFsKCkpKTtcbiAgcmV0dXJuIG5ldyBUZXJtKFwiTW9kdWxlXCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIGl0ZW1zOiBuYXRpdmVJbXBvcnRzXzc1OS5jb25jYXQoY29tcGlsZWRNb2RfNzU4LmJvZHkpLmNvbmNhdChjb21waWxlZE1vZF83NTguZXhwb3J0RW50cmllcy5pbnRlcnBvc2UobmV3IFRlcm0oXCJFbXB0eVN0YXRlbWVudFwiLCB7fSkpKX0pO1xufVxuZnVuY3Rpb24gcGFyc2VfNzUyKHNvdXJjZV83NjIsIG9wdGlvbnNfNzYzLCBpbmNsdWRlSW1wb3J0c183NjQgPSB0cnVlKSB7XG4gIHJldHVybiByZWR1Y2UobmV3IFBhcnNlUmVkdWNlcih7cGhhc2U6IDB9KSwgZXhwYW5kXzc1MShzb3VyY2VfNzYyLCBvcHRpb25zXzc2MykuZ2VuKHtpbmNsdWRlSW1wb3J0czogaW5jbHVkZUltcG9ydHNfNzY0fSkpO1xufVxuZnVuY3Rpb24gY29tcGlsZV83NTMoc291cmNlXzc2NSwgb3B0aW9uc183NjYgPSB7fSkge1xuICBsZXQgYXN0Xzc2NyA9IHBhcnNlXzc1Mihzb3VyY2VfNzY1LCBvcHRpb25zXzc2Niwgb3B0aW9uc183NjYuaW5jbHVkZUltcG9ydHMpO1xuICBsZXQgZ2VuXzc2OCA9IGNvZGVnZW4oYXN0Xzc2NywgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICByZXR1cm4gb3B0aW9uc183NjYudHJhbnNmb3JtICYmICFvcHRpb25zXzc2Ni5ub0JhYmVsID8gb3B0aW9uc183NjYudHJhbnNmb3JtKGdlbl83NjgsIHtiYWJlbHJjOiB0cnVlLCBmaWxlbmFtZTogb3B0aW9uc183NjYuZmlsZW5hbWV9KSA6IHtjb2RlOiBnZW5fNzY4fTtcbn1cbmV4cG9ydCB7ZXhwYW5kXzc1MSBhcyBleHBhbmR9O1xuZXhwb3J0IHtwYXJzZV83NTIgYXMgcGFyc2V9O1xuZXhwb3J0IHtjb21waWxlXzc1MyBhcyBjb21waWxlfSJdfQ==

	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _tokenizer = __webpack_require__(2);

		var _tokenizer2 = _interopRequireDefault(_tokenizer);

		var _immutable = __webpack_require__(9);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _ramdaFantasy = __webpack_require__(13);

		var _errors = __webpack_require__(11);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _ramda = __webpack_require__(25);

		var R = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const Just_616 = _ramdaFantasy.Maybe.Just;
		const Nothing_617 = _ramdaFantasy.Maybe.Nothing;
		const LSYNTAX_618 = { name: "left-syntax" };
		const RSYNTAX_619 = { name: "right-syntax" };
		const AT_620 = { klass: _tokenizer.TokenClass.Punctuator, name: "@" };
		const literalKeywords_621 = ["this", "null", "true", "false"];
		const isLeftBracket_622 = R.whereEq({ type: _tokenizer.TokenType.LBRACK });
		const isLeftBrace_623 = R.whereEq({ type: _tokenizer.TokenType.LBRACE });
		const isLeftParen_624 = R.whereEq({ type: _tokenizer.TokenType.LPAREN });
		const isRightBracket_625 = R.whereEq({ type: _tokenizer.TokenType.RBRACK });
		const isRightBrace_626 = R.whereEq({ type: _tokenizer.TokenType.RBRACE });
		const isRightParen_627 = R.whereEq({ type: _tokenizer.TokenType.RPAREN });
		const isEOS_628 = R.whereEq({ type: _tokenizer.TokenType.EOS });
		const isHash_629 = R.whereEq({ type: _tokenizer.TokenType.IDENTIFIER, value: "#" });
		const isLeftSyntax_630 = R.whereEq({ type: LSYNTAX_618 });
		const isRightSyntax_631 = R.whereEq({ type: RSYNTAX_619 });
		const isLeftDelimiter_632 = R.anyPass([isLeftBracket_622, isLeftBrace_623, isLeftParen_624, isLeftSyntax_630]);
		const isRightDelimiter_633 = R.anyPass([isRightBracket_625, isRightBrace_626, isRightParen_627, isRightSyntax_631]);
		const isMatchingDelimiters_634 = R.cond([[isLeftBracket_622, (__675, b_676) => isRightBracket_625(b_676)], [isLeftBrace_623, (__677, b_678) => isRightBrace_626(b_678)], [isLeftParen_624, (__679, b_680) => isRightParen_627(b_680)], [isLeftSyntax_630, (__681, b_682) => isRightSyntax_631(b_682)], [R.T, R.F]]);
		const assignOps_635 = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","];
		const binaryOps_636 = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"];
		const unaryOps_637 = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"];
		const isEmpty_638 = R.whereEq({ size: 0 });
		const isPunctuator_639 = s_683 => s_683.match("punctuator");
		const isKeyword_640 = s_684 => s_684.match("keyword");
		const isDelimiter_641 = s_685 => s_685.match("delimiter");
		const isParens_642 = s_686 => s_686.match("parens");
		const isBraces_643 = s_687 => s_687.match("braces");
		const isBrackets_644 = s_688 => s_688.match("brackets");
		const isIdentifier_645 = s_689 => s_689.match("identifier");
		const val_646 = s_690 => s_690.val();
		const isVal_647 = R.curry((v_691, s_692) => s_692.val() === v_691);
		const isDot_648 = R.allPass([isPunctuator_639, isVal_647(".")]);
		const isColon_649 = R.allPass([isPunctuator_639, isVal_647(":")]);
		const isFunctionKeyword_650 = R.allPass([isKeyword_640, isVal_647("function")]);
		const isOperator_651 = s_693 => (s_693.match("punctuator") || s_693.match("keyword")) && R.any(R.equals(s_693.val()), assignOps_635.concat(binaryOps_636).concat(unaryOps_637));
		const isNonLiteralKeyword_652 = R.allPass([isKeyword_640, s_694 => R.none(R.equals(s_694.val()), literalKeywords_621)]);
		const isKeywordExprPrefix_653 = R.allPass([isKeyword_640, s_695 => R.any(R.equals(s_695.val()), ["instanceof", "typeof", "delete", "void", "yield", "throw", "new", "case"])]);
		let last_654 = p_696 => p_696.last();
		let safeLast_655 = R.pipe(R.cond([[isEmpty_638, R.always(Nothing_617())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last_654)]]));
		let stuffTrue_656 = R.curry((p_697, b_698) => b_698 ? Just_616(p_697) : Nothing_617());
		let stuffFalse_657 = R.curry((p_699, b_700) => !b_700 ? Just_616(p_699) : Nothing_617());
		let isTopColon_658 = R.pipe(safeLast_655, R.map(isColon_649), _ramdaFantasy.Maybe.maybe(false, R.identity));
		let isTopPunctuator_659 = R.pipe(safeLast_655, R.map(isPunctuator_639), _ramdaFantasy.Maybe.maybe(false, R.identity));
		let isExprReturn_660 = R.curry((l_701, p_702) => {
		  let retKwd_703 = safeLast_655(p_702);
		  let maybeDot_704 = pop_671(p_702).chain(safeLast_655);
		  if (maybeDot_704.map(isDot_648).getOrElse(false)) {
		    return true;
		  }
		  return retKwd_703.map(s_705 => {
		    return s_705.match("keyword") && s_705.val() === "return" && s_705.lineNumber() === l_701;
		  }).getOrElse(false);
		});
		const isTopOperator_661 = R.pipe(safeLast_655, R.map(isOperator_651), _ramdaFantasy.Maybe.maybe(false, R.identity));
		const isTopKeywordExprPrefix_662 = R.pipe(safeLast_655, R.map(isKeywordExprPrefix_653), _ramdaFantasy.Maybe.maybe(false, R.identity));
		let isExprPrefix_663 = R.curry((l_706, b_707) => R.cond([[isEmpty_638, R.always(b_707)], [isTopColon_658, R.always(b_707)], [isTopKeywordExprPrefix_662, R.T], [isTopOperator_661, R.T], [isTopPunctuator_659, R.always(b_707)], [isExprReturn_660(l_706), R.T], [R.T, R.F]]));
		let curly_664 = p_708 => safeLast_655(p_708).map(isBraces_643).chain(stuffTrue_656(p_708));
		let paren_665 = p_709 => safeLast_655(p_709).map(isParens_642).chain(stuffTrue_656(p_709));
		let func_666 = p_710 => safeLast_655(p_710).map(isFunctionKeyword_650).chain(stuffTrue_656(p_710));
		let ident_667 = p_711 => safeLast_655(p_711).map(isIdentifier_645).chain(stuffTrue_656(p_711));
		let nonLiteralKeyword_668 = p_712 => safeLast_655(p_712).map(isNonLiteralKeyword_652).chain(stuffTrue_656(p_712));
		let opt_669 = R.curry((a_713, b_714, p_715) => {
		  let result_716 = R.pipeK(a_713, b_714)(_ramdaFantasy.Maybe.of(p_715));
		  return _ramdaFantasy.Maybe.isJust(result_716) ? result_716 : _ramdaFantasy.Maybe.of(p_715);
		});
		let notDot_670 = R.ifElse(R.whereEq({ size: 0 }), Just_616, p_717 => safeLast_655(p_717).map(s_718 => !(s_718.match("punctuator") && s_718.val() === ".")).chain(stuffTrue_656(p_717)));
		let pop_671 = R.compose(Just_616, p_719 => p_719.pop());
		const functionPrefix_672 = R.pipeK(curly_664, pop_671, paren_665, pop_671, opt_669(ident_667, pop_671), func_666);
		const isRegexPrefix_673 = b_720 => R.anyPass([isEmpty_638, isTopPunctuator_659, R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword_668, pop_671, notDot_670), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren_665, pop_671, nonLiteralKeyword_668, pop_671, notDot_670), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, functionPrefix_672, R.chain(p_721 => {
		  return safeLast_655(p_721).map(s_722 => s_722.lineNumber()).chain(fnLine_723 => {
		    return pop_671(p_721).map(isExprPrefix_663(fnLine_723, b_720));
		  }).chain(stuffFalse_657(p_721));
		}), _ramdaFantasy.Maybe.isJust), p_724 => {
		  let isCurly_725 = _ramdaFantasy.Maybe.isJust(safeLast_655(p_724).map(isBraces_643));
		  let alreadyCheckedFunction_726 = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix_672, _ramdaFantasy.Maybe.isJust)(p_724);
		  if (alreadyCheckedFunction_726) {
		    return false;
		  }
		  return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly_664), R.chain(p_727 => {
		    return safeLast_655(p_727).map(s_728 => s_728.lineNumber()).chain(curlyLine_729 => {
		      return pop_671(p_727).map(isExprPrefix_663(curlyLine_729, b_720));
		    }).chain(stuffFalse_657(p_727));
		  }), _ramdaFantasy.Maybe.isJust)(p_724);
		}]);
		function lastEl_674(l_730) {
		  return l_730[l_730.length - 1];
		}
		class Reader extends _tokenizer2.default {
		  constructor(strings_731, context_732, replacements_733) {
		    super(Array.isArray(strings_731) ? strings_731.join("") : strings_731);
		    this.delimStack = new Map();
		    this.insideSyntaxTemplate = [false];
		    this.context = context_732;
		    if (Array.isArray(strings_731)) {
		      let totalIndex = 0;
		      this.replacementIndex = R.reduce((acc_734, strRep_735) => {
		        acc_734.push({ index: totalIndex + strRep_735[0].length, replacement: strRep_735[1] });
		        totalIndex += strRep_735[0].length;
		        return acc_734;
		      }, [], R.zip(strings_731, replacements_733));
		    }
		  }
		  read() {
		    let stack_736 = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
		    let b_737 = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
		    let singleDelimiter_738 = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

		    let prefix_739 = (0, _immutable.List)();
		    while (true) {
		      let tok = this.advance(prefix_739, b_737);
		      if (tok instanceof _syntax2.default || tok instanceof _terms2.default) {
		        stack_736.push(tok);
		        continue;
		      }
		      if (Array.isArray(tok)) {
		        Array.prototype.push.apply(stack_736, tok);
		        continue;
		      }
		      if (_immutable.List.isList(tok)) {
		        Array.prototype.push.apply(stack_736, tok.toArray());
		        continue;
		      }
		      if (isEOS_628(tok)) {
		        if (stack_736[0] && isLeftDelimiter_632(stack_736[0].token)) {
		          throw this.createUnexpected(tok);
		        }
		        break;
		      }
		      if (isLeftDelimiter_632(tok)) {
		        if (isLeftSyntax_630(tok)) {
		          this.insideSyntaxTemplate.push(true);
		        }
		        let line = tok.slice.startLocation.line;
		        let innerB = isLeftBrace_623(tok) ? isExprPrefix_663(line, b_737)(prefix_739) : true;
		        let inner = this.read([new _syntax2.default(tok, this.context)], innerB, false);
		        let stx = new _syntax2.default(inner, this.context);
		        prefix_739 = prefix_739.concat(stx);
		        stack_736.push(stx);
		        if (singleDelimiter_738) {
		          break;
		        }
		      } else if (isRightDelimiter_633(tok)) {
		        if (stack_736[0] && !isMatchingDelimiters_634(stack_736[0].token, tok)) {
		          throw this.createUnexpected(tok);
		        }
		        let stx = new _syntax2.default(tok, this.context);
		        stack_736.push(stx);
		        if (lastEl_674(this.insideSyntaxTemplate) && isRightSyntax_631(tok)) {
		          this.insideSyntaxTemplate.pop();
		        }
		        break;
		      } else {
		        let stx = new _syntax2.default(tok, this.context);
		        prefix_739 = prefix_739.concat(stx);
		        stack_736.push(stx);
		      }
		    }
		    return (0, _immutable.List)(stack_736);
		  }
		  advance(prefix_740, b_741) {
		    let startLocation_742 = this.getLocation();
		    this.lastIndex = this.index;
		    this.lastLine = this.line;
		    this.lastLineStart = this.lineStart;
		    this.skipComment();
		    this.startIndex = this.index;
		    this.startLine = this.line;
		    this.startLineStart = this.lineStart;
		    if (this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
		      let rep = this.replacementIndex[0].replacement;
		      this.replacementIndex.shift();
		      return rep;
		    }
		    let charCode_743 = this.source.charCodeAt(this.index);
		    if (charCode_743 === 96) {
		      let element,
		          items = [];
		      let startLocation_742 = this.getLocation();
		      let start = this.index;
		      this.index++;
		      if (lastEl_674(this.insideSyntaxTemplate)) {
		        let slice = this.getSlice(start, startLocation_742);
		        return { type: RSYNTAX_619, value: "`", slice: slice };
		      }
		      do {
		        element = this.scanTemplateElement();
		        items.push(element);
		        if (element.interp) {
		          element = this.read([], false, true);
		          (0, _errors.assert)(element.size === 1, "should only have read a single delimiter inside a template");
		          items.push(element.get(0));
		        }
		      } while (!element.tail);
		      return { type: _tokenizer.TokenType.TEMPLATE, items: (0, _immutable.List)(items) };
		    } else if (charCode_743 === 35) {
		      let startLocation_742 = this.getLocation();
		      let start = this.index;
		      let slice = this.getSlice(start, startLocation_742);
		      this.index++;
		      if (this.source.charCodeAt(this.index) === 96) {
		        this.index++;
		        return { type: LSYNTAX_618, value: "#`", slice: slice };
		      }
		      return { type: _tokenizer.TokenType.IDENTIFIER, value: "#", slice: slice };
		    } else if (charCode_743 === 64) {
		      let startLocation_742 = this.getLocation();
		      let start = this.index;
		      let slice = this.getSlice(start, startLocation_742);
		      this.index++;
		      return { type: AT_620, value: "@", slice: slice };
		    }
		    let lookahead_744 = super.advance();
		    if (lookahead_744.type === _tokenizer.TokenType.DIV && isRegexPrefix_673(b_741)(prefix_740)) {
		      return super.scanRegExp("/");
		    }
		    return lookahead_744;
		  }
		  scanTemplateElement() {
		    let startLocation_745 = this.getLocation();
		    let start_746 = this.index;
		    while (this.index < this.source.length) {
		      let ch = this.source.charCodeAt(this.index);
		      switch (ch) {
		        case 96:
		          let slice = this.getSlice(start_746, startLocation_745);
		          this.index++;
		          return { type: _tokenizer.TokenType.TEMPLATE, tail: true, interp: false, slice: slice };
		        case 36:
		          if (this.source.charCodeAt(this.index + 1) === 123) {
		            let slice = this.getSlice(start_746, startLocation_745);
		            this.index += 1;
		            return { type: _tokenizer.TokenType.TEMPLATE, tail: false, interp: true, slice: slice };
		          }
		          this.index++;
		          break;
		        case 92:
		          {
		            let octal = this.scanStringEscape("", null)[1];
		            if (octal != null) {
		              throw this.createILLEGAL();
		            }
		            break;
		          }
		        default:
		          this.index++;
		      }
		    }
		    throw this.createILLEGAL();
		  }
		}
		exports.default = Reader;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3NoaWZ0LXJlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDYixNQUFNLFdBQVcsb0JBQU0sSUFBdkI7QUFDQSxNQUFNLGNBQWMsb0JBQU0sT0FBMUI7QUFDQSxNQUFNLGNBQWMsRUFBQyxNQUFNLGFBQVAsRUFBcEI7QUFDQSxNQUFNLGNBQWMsRUFBQyxNQUFNLGNBQVAsRUFBcEI7QUFDQSxNQUFNLFNBQVMsRUFBQyxPQUFPLHNCQUFXLFVBQW5CLEVBQStCLE1BQU0sR0FBckMsRUFBZjtBQUNBLE1BQU0sc0JBQXNCLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUIsT0FBekIsQ0FBNUI7QUFDQSxNQUFNLG9CQUFvQixFQUFFLE9BQUYsQ0FBVSxFQUFDLE1BQU0scUJBQVUsTUFBakIsRUFBVixDQUExQjtBQUNBLE1BQU0sa0JBQWtCLEVBQUUsT0FBRixDQUFVLEVBQUMsTUFBTSxxQkFBVSxNQUFqQixFQUFWLENBQXhCO0FBQ0EsTUFBTSxrQkFBa0IsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLE1BQWpCLEVBQVYsQ0FBeEI7QUFDQSxNQUFNLHFCQUFxQixFQUFFLE9BQUYsQ0FBVSxFQUFDLE1BQU0scUJBQVUsTUFBakIsRUFBVixDQUEzQjtBQUNBLE1BQU0sbUJBQW1CLEVBQUUsT0FBRixDQUFVLEVBQUMsTUFBTSxxQkFBVSxNQUFqQixFQUFWLENBQXpCO0FBQ0EsTUFBTSxtQkFBbUIsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLE1BQWpCLEVBQVYsQ0FBekI7QUFDQSxNQUFNLFlBQVksRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLEdBQWpCLEVBQVYsQ0FBbEI7QUFDQSxNQUFNLGFBQWEsRUFBRSxPQUFGLENBQVUsRUFBQyxNQUFNLHFCQUFVLFVBQWpCLEVB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O0FBQ0U7QUFDRSxnQkFBSSxRQUFRLEtBQUssZ0JBQUwsQ0FBc0IsRUFBdEIsRUFBMEIsSUFBMUIsRUFBZ0MsQ0FBaEMsQ0FBWjtBQUNBLGdCQUFJLFNBQVMsSUFBYixFQUFtQjtBQUNqQixvQkFBTSxLQUFLLGFBQUwsRUFBTjtBQUNEO0FBQ0Q7QUFDRDtBQUNIO0FBQ0UsZUFBSyxLQUFMO0FBdEJKO0FBd0JEO0FBQ0QsVUFBTSxLQUFLLGFBQUwsRUFBTjtBQUNEO0FBNUoyQztrQkFBekIsTSIsImZpbGUiOiJzaGlmdC1yZWFkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVG9rZW5pemVyIGZyb20gXCJzaGlmdC1wYXJzZXIvZGlzdC90b2tlbml6ZXJcIjtcbmltcG9ydCB7VG9rZW5DbGFzcywgVG9rZW5UeXBlfSBmcm9tIFwic2hpZnQtcGFyc2VyL2Rpc3QvdG9rZW5pemVyXCI7XG5pbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQge01heWJlfSBmcm9tIFwicmFtZGEtZmFudGFzeVwiO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IFRlcm0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCAgKiBhcyBSIGZyb20gXCJyYW1kYVwiO1xuY29uc3QgSnVzdF82MTYgPSBNYXliZS5KdXN0O1xuY29uc3QgTm90aGluZ182MTcgPSBNYXliZS5Ob3RoaW5nO1xuY29uc3QgTFNZTlRBWF82MTggPSB7bmFtZTogXCJsZWZ0LXN5bnRheFwifTtcbmNvbnN0IFJTWU5UQVhfNjE5ID0ge25hbWU6IFwicmlnaHQtc3ludGF4XCJ9O1xuY29uc3QgQVRfNjIwID0ge2tsYXNzOiBUb2tlbkNsYXNzLlB1bmN0dWF0b3IsIG5hbWU6IFwiQFwifTtcbmNvbnN0IGxpdGVyYWxLZXl3b3Jkc182MjEgPSBbXCJ0aGlzXCIsIFwibnVsbFwiLCBcInRydWVcIiwgXCJmYWxzZVwiXTtcbmNvbnN0IGlzTGVmdEJyYWNrZXRfNjIyID0gUi53aGVyZUVxKHt0eXBlOiBUb2tlblR5cGUuTEJSQUNLfSk7XG5jb25zdCBpc0xlZnRCcmFjZV82MjMgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5MQlJBQ0V9KTtcbmNvbnN0IGlzTGVmdFBhcmVuXzYyNCA9IFIud2hlcmVFcSh7dHlwZTogVG9rZW5UeXBlLkxQQVJFTn0pO1xuY29uc3QgaXNSaWdodEJyYWNrZXRfNjI1ID0gUi53aGVyZUVxKHt0eXBlOiBUb2tlblR5cGUuUkJSQUNLfSk7XG5jb25zdCBpc1JpZ2h0QnJhY2VfNjI2ID0gUi53aGVyZUVxKHt0eXBlOiBUb2tlblR5cGUuUkJSQUNFfSk7XG5jb25zdCBpc1JpZ2h0UGFyZW5fNjI3ID0gUi53aGVyZUVxKHt0eXBlOiBUb2tlblR5cGUuUlBBUkVOfSk7XG5jb25zdCBpc0VPU182MjggPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5FT1N9KTtcbmNvbnN0IGlzSGFzaF82MjkgPSBSLndoZXJlRXEoe3R5cGU6IFRva2VuVHlwZS5JREVOVElGSUVSLCB2YWx1ZTogXCIjXCJ9KTtcbmNvbnN0IGlzTGVmdFN5bnRheF82MzAgPSBSLndoZXJlRXEoe3R5cGU6IExTWU5UQVhfNjE4fSk7XG5jb25zdCBpc1JpZ2h0U3ludGF4XzYzMSA9IFIud2hlcmVFcSh7dHlwZTogUlNZTlRBWF82MTl9KTtcbmNvbnN0IGlzTGVmdERlbGltaXRlcl82MzIgPSBSLmFueVBhc3MoW2lzTGVmdEJyYWNrZXRfNjIyLCBpc0xlZnRCcmFjZV82MjMsIGlzTGVmdFBhcmVuXzYyNCwgaXNMZWZ0U3ludGF4XzYzMF0pO1xuY29uc3QgaXNSaWdodERlbGltaXRlcl82MzMgPSBSLmFueVBhc3MoW2lzUmlnaHRCcmFja2V0XzYyNSwgaXNSaWdodEJyYWNlXzYyNiwgaXNSaWdodFBhcmVuXzYyNywgaXNSaWdodFN5bnRheF82MzFdKTtcbmNvbnN0IGlzTWF0Y2hpbmdEZWxpbWl0ZXJzXzYzNCA9IFIuY29uZChbW2lzTGVmdEJyYWNrZXRfNjIyLCAoX182NzUsIGJfNjc2KSA9PiBpc1JpZ2h0QnJhY2tldF82MjUoYl82NzYpXSwgW2lzTGVmdEJyYWNlXzYyMywgKF9fNjc3LCBiXzY3OCkgPT4gaXNSaWdodEJyYWNlXzYyNihiXzY3OCldLCBbaXNMZWZ0UGFyZW5fNjI0LCAoX182NzksIGJfNjgwKSA9PiBpc1JpZ2h0UGFyZW5fNjI3KGJfNjgwKV0sIFtpc0xlZnRTeW50YXhfNjMwLCAoX182ODEsIGJfNjgyKSA9PiBpc1JpZ2h0U3ludGF4XzYzMShiXzY4MildLCBbUi5ULCBSLkZdXSk7XG5jb25zdCBhc3NpZ25PcHNfNjM1ID0gW1wiPVwiLCBcIis9XCIsIFwiLT1cIiwgXCIqPVwiLCBcIi89XCIsIFwiJT1cIiwgXCI8PD1cIiwgXCI+Pj1cIiwgXCI+Pj49XCIsIFwiJj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiLFwiXTtcbmNvbnN0IGJpbmFyeU9wc182MzYgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIsIFwiJVwiLCBcIjw8XCIsIFwiPj5cIiwgXCI+Pj5cIiwgXCImXCIsIFwifFwiLCBcIl5cIiwgXCImJlwiLCBcInx8XCIsIFwiP1wiLCBcIjpcIiwgXCI9PT1cIiwgXCI9PVwiLCBcIj49XCIsIFwiPD1cIiwgXCI8XCIsIFwiPlwiLCBcIiE9XCIsIFwiIT09XCIsIFwiaW5zdGFuY2VvZlwiXTtcbmNvbnN0IHVuYXJ5T3BzXzYzNyA9IFtcIisrXCIsIFwiLS1cIiwgXCJ+XCIsIFwiIVwiLCBcImRlbGV0ZVwiLCBcInZvaWRcIiwgXCJ0eXBlb2ZcIiwgXCJ5aWVsZFwiLCBcInRocm93XCIsIFwibmV3XCJdO1xuY29uc3QgaXNFbXB0eV82MzggPSBSLndoZXJlRXEoe3NpemU6IDB9KTtcbmNvbnN0IGlzUHVuY3R1YXRvcl82MzkgPSBzXzY4MyA9PiBzXzY4My5tYXRjaChcInB1bmN0dWF0b3JcIik7XG5jb25zdCBpc0tleXdvcmRfNjQwID0gc182ODQgPT4gc182ODQubWF0Y2goXCJrZXl3b3JkXCIpO1xuY29uc3QgaXNEZWxpbWl0ZXJfNjQxID0gc182ODUgPT4gc182ODUubWF0Y2goXCJkZWxpbWl0ZXJcIik7XG5jb25zdCBpc1BhcmVuc182NDIgPSBzXzY4NiA9PiBzXzY4Ni5tYXRjaChcInBhcmVuc1wiKTtcbmNvbnN0IGlzQnJhY2VzXzY0MyA9IHNfNjg3ID0+IHNfNjg3Lm1hdGNoKFwiYnJhY2VzXCIpO1xuY29uc3QgaXNCcmFja2V0c182NDQgPSBzXzY4OCA9PiBzXzY4OC5tYXRjaChcImJyYWNrZXRzXCIpO1xuY29uc3QgaXNJZGVudGlmaWVyXzY0NSA9IHNfNjg5ID0+IHNfNjg5Lm1hdGNoKFwiaWRlbnRpZmllclwiKTtcbmNvbnN0IHZhbF82NDYgPSBzXzY5MCA9PiBzXzY5MC52YWwoKTtcbmNvbnN0IGlzVmFsXzY0NyA9IFIuY3VycnkoKHZfNjkxLCBzXzY5MikgPT4gc182OTIudmFsKCkgPT09IHZfNjkxKTtcbmNvbnN0IGlzRG90XzY0OCA9IFIuYWxsUGFzcyhbaXNQdW5jdHVhdG9yXzYzOSwgaXNWYWxfNjQ3KFwiLlwiKV0pO1xuY29uc3QgaXNDb2xvbl82NDkgPSBSLmFsbFBhc3MoW2lzUHVuY3R1YXRvcl82MzksIGlzVmFsXzY0NyhcIjpcIildKTtcbmNvbnN0IGlzRnVuY3Rpb25LZXl3b3JkXzY1MCA9IFIuYWxsUGFzcyhbaXNLZXl3b3JkXzY0MCwgaXNWYWxfNjQ3KFwiZnVuY3Rpb25cIildKTtcbmNvbnN0IGlzT3BlcmF0b3JfNjUxID0gc182OTMgPT4gKHNfNjkzLm1hdGNoKFwicHVuY3R1YXRvclwiKSB8fCBzXzY5My5tYXRjaChcImtleXdvcmRcIikpICYmIFIuYW55KFIuZXF1YWxzKHNfNjkzLnZhbCgpKSwgYXNzaWduT3BzXzYzNS5jb25jYXQoYmluYXJ5T3BzXzYzNikuY29uY2F0KHVuYXJ5T3BzXzYzNykpO1xuY29uc3QgaXNOb25MaXRlcmFsS2V5d29yZF82NTIgPSBSLmFsbFBhc3MoW2lzS2V5d29yZF82NDAsIHNfNjk0ID0+IFIubm9uZShSLmVxdWFscyhzXzY5NC52YWwoKSksIGxpdGVyYWxLZXl3b3Jkc182MjEpXSk7XG5jb25zdCBpc0tleXdvcmRFeHByUHJlZml4XzY1MyA9IFIuYWxsUGFzcyhbaXNLZXl3b3JkXzY0MCwgc182OTUgPT4gUi5hbnkoUi5lcXVhbHMoc182OTUudmFsKCkpLCBbXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwiZGVsZXRlXCIsIFwidm9pZFwiLCBcInlpZWxkXCIsIFwidGhyb3dcIiwgXCJuZXdcIiwgXCJjYXNlXCJdKV0pO1xubGV0IGxhc3RfNjU0ID0gcF82OTYgPT4gcF82OTYubGFzdCgpO1xubGV0IHNhZmVMYXN0XzY1NSA9IFIucGlwZShSLmNvbmQoW1tpc0VtcHR5XzYzOCwgUi5hbHdheXMoTm90aGluZ182MTcoKSldLCBbUi5ULCBSLmNvbXBvc2UoTWF5YmUub2YsIGxhc3RfNjU0KV1dKSk7XG5sZXQgc3R1ZmZUcnVlXzY1NiA9IFIuY3VycnkoKHBfNjk3LCBiXzY5OCkgPT4gYl82OTggPyBKdXN0XzYxNihwXzY5NykgOiBOb3RoaW5nXzYxNygpKTtcbmxldCBzdHVmZkZhbHNlXzY1NyA9IFIuY3VycnkoKHBfNjk5LCBiXzcwMCkgPT4gIWJfNzAwID8gSnVzdF82MTYocF82OTkpIDogTm90aGluZ182MTcoKSk7XG5sZXQgaXNUb3BDb2xvbl82NTggPSBSLnBpcGUoc2FmZUxhc3RfNjU1LCBSLm1hcChpc0NvbG9uXzY0OSksIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KSk7XG5sZXQgaXNUb3BQdW5jdHVhdG9yXzY1OSA9IFIucGlwZShzYWZlTGFzdF82NTUsIFIubWFwKGlzUHVuY3R1YXRvcl82MzkpLCBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSkpO1xubGV0IGlzRXhwclJldHVybl82NjAgPSBSLmN1cnJ5KChsXzcwMSwgcF83MDIpID0+IHtcbiAgbGV0IHJldEt3ZF83MDMgPSBzYWZlTGFzdF82NTUocF83MDIpO1xuICBsZXQgbWF5YmVEb3RfNzA0ID0gcG9wXzY3MShwXzcwMikuY2hhaW4oc2FmZUxhc3RfNjU1KTtcbiAgaWYgKG1heWJlRG90XzcwNC5tYXAoaXNEb3RfNjQ4KS5nZXRPckVsc2UoZmFsc2UpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldEt3ZF83MDMubWFwKHNfNzA1ID0+IHtcbiAgICByZXR1cm4gc183MDUubWF0Y2goXCJrZXl3b3JkXCIpICYmIHNfNzA1LnZhbCgpID09PSBcInJldHVyblwiICYmIHNfNzA1LmxpbmVOdW1iZXIoKSA9PT0gbF83MDE7XG4gIH0pLmdldE9yRWxzZShmYWxzZSk7XG59KTtcbmNvbnN0IGlzVG9wT3BlcmF0b3JfNjYxID0gUi5waXBlKHNhZmVMYXN0XzY1NSwgUi5tYXAoaXNPcGVyYXRvcl82NTEpLCBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSkpO1xuY29uc3QgaXNUb3BLZXl3b3JkRXhwclByZWZpeF82NjIgPSBSLnBpcGUoc2FmZUxhc3RfNjU1LCBSLm1hcChpc0tleXdvcmRFeHByUHJlZml4XzY1MyksIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KSk7XG5sZXQgaXNFeHByUHJlZml4XzY2MyA9IFIuY3VycnkoKGxfNzA2LCBiXzcwNykgPT4gUi5jb25kKFtbaXNFbXB0eV82MzgsIFIuYWx3YXlzKGJfNzA3KV0sIFtpc1RvcENvbG9uXzY1OCwgUi5hbHdheXMoYl83MDcpXSwgW2lzVG9wS2V5d29yZEV4cHJQcmVmaXhfNjYyLCBSLlRdLCBbaXNUb3BPcGVyYXRvcl82NjEsIFIuVF0sIFtpc1RvcFB1bmN0dWF0b3JfNjU5LCBSLmFsd2F5cyhiXzcwNyldLCBbaXNFeHByUmV0dXJuXzY2MChsXzcwNiksIFIuVF0sIFtSLlQsIFIuRl1dKSk7XG5sZXQgY3VybHlfNjY0ID0gcF83MDggPT4gc2FmZUxhc3RfNjU1KHBfNzA4KS5tYXAoaXNCcmFjZXNfNjQzKS5jaGFpbihzdHVmZlRydWVfNjU2KHBfNzA4KSk7XG5sZXQgcGFyZW5fNjY1ID0gcF83MDkgPT4gc2FmZUxhc3RfNjU1KHBfNzA5KS5tYXAoaXNQYXJlbnNfNjQyKS5jaGFpbihzdHVmZlRydWVfNjU2KHBfNzA5KSk7XG5sZXQgZnVuY182NjYgPSBwXzcxMCA9PiBzYWZlTGFzdF82NTUocF83MTApLm1hcChpc0Z1bmN0aW9uS2V5d29yZF82NTApLmNoYWluKHN0dWZmVHJ1ZV82NTYocF83MTApKTtcbmxldCBpZGVudF82NjcgPSBwXzcxMSA9PiBzYWZlTGFzdF82NTUocF83MTEpLm1hcChpc0lkZW50aWZpZXJfNjQ1KS5jaGFpbihzdHVmZlRydWVfNjU2KHBfNzExKSk7XG5sZXQgbm9uTGl0ZXJhbEtleXdvcmRfNjY4ID0gcF83MTIgPT4gc2FmZUxhc3RfNjU1KHBfNzEyKS5tYXAoaXNOb25MaXRlcmFsS2V5d29yZF82NTIpLmNoYWluKHN0dWZmVHJ1ZV82NTYocF83MTIpKTtcbmxldCBvcHRfNjY5ID0gUi5jdXJyeSgoYV83MTMsIGJfNzE0LCBwXzcxNSkgPT4ge1xuICBsZXQgcmVzdWx0XzcxNiA9IFIucGlwZUsoYV83MTMsIGJfNzE0KShNYXliZS5vZihwXzcxNSkpO1xuICByZXR1cm4gTWF5YmUuaXNKdXN0KHJlc3VsdF83MTYpID8gcmVzdWx0XzcxNiA6IE1heWJlLm9mKHBfNzE1KTtcbn0pO1xubGV0IG5vdERvdF82NzAgPSBSLmlmRWxzZShSLndoZXJlRXEoe3NpemU6IDB9KSwgSnVzdF82MTYsIHBfNzE3ID0+IHNhZmVMYXN0XzY1NShwXzcxNykubWFwKHNfNzE4ID0+ICEoc183MTgubWF0Y2goXCJwdW5jdHVhdG9yXCIpICYmIHNfNzE4LnZhbCgpID09PSBcIi5cIikpLmNoYWluKHN0dWZmVHJ1ZV82NTYocF83MTcpKSk7XG5sZXQgcG9wXzY3MSA9IFIuY29tcG9zZShKdXN0XzYxNiwgcF83MTkgPT4gcF83MTkucG9wKCkpO1xuY29uc3QgZnVuY3Rpb25QcmVmaXhfNjcyID0gUi5waXBlSyhjdXJseV82NjQsIHBvcF82NzEsIHBhcmVuXzY2NSwgcG9wXzY3MSwgb3B0XzY2OShpZGVudF82NjcsIHBvcF82NzEpLCBmdW5jXzY2Nik7XG5jb25zdCBpc1JlZ2V4UHJlZml4XzY3MyA9IGJfNzIwID0+IFIuYW55UGFzcyhbaXNFbXB0eV82MzgsIGlzVG9wUHVuY3R1YXRvcl82NTksIFIucGlwZShNYXliZS5vZiwgUi5waXBlSyhub25MaXRlcmFsS2V5d29yZF82NjgsIHBvcF82NzEsIG5vdERvdF82NzApLCBNYXliZS5pc0p1c3QpLCBSLnBpcGUoTWF5YmUub2YsIFIucGlwZUsocGFyZW5fNjY1LCBwb3BfNjcxLCBub25MaXRlcmFsS2V5d29yZF82NjgsIHBvcF82NzEsIG5vdERvdF82NzApLCBNYXliZS5pc0p1c3QpLCBSLnBpcGUoTWF5YmUub2YsIGZ1bmN0aW9uUHJlZml4XzY3MiwgUi5jaGFpbihwXzcyMSA9PiB7XG4gIHJldHVybiBzYWZlTGFzdF82NTUocF83MjEpLm1hcChzXzcyMiA9PiBzXzcyMi5saW5lTnVtYmVyKCkpLmNoYWluKGZuTGluZV83MjMgPT4ge1xuICAgIHJldHVybiBwb3BfNjcxKHBfNzIxKS5tYXAoaXNFeHByUHJlZml4XzY2MyhmbkxpbmVfNzIzLCBiXzcyMCkpO1xuICB9KS5jaGFpbihzdHVmZkZhbHNlXzY1NyhwXzcyMSkpO1xufSksIE1heWJlLmlzSnVzdCksIHBfNzI0ID0+IHtcbiAgbGV0IGlzQ3VybHlfNzI1ID0gTWF5YmUuaXNKdXN0KHNhZmVMYXN0XzY1NShwXzcyNCkubWFwKGlzQnJhY2VzXzY0MykpO1xuICBsZXQgYWxyZWFkeUNoZWNrZWRGdW5jdGlvbl83MjYgPSBSLnBpcGUoTWF5YmUub2YsIGZ1bmN0aW9uUHJlZml4XzY3MiwgTWF5YmUuaXNKdXN0KShwXzcyNCk7XG4gIGlmIChhbHJlYWR5Q2hlY2tlZEZ1bmN0aW9uXzcyNikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gUi5waXBlKE1heWJlLm9mLCBSLmNoYWluKGN1cmx5XzY2NCksIFIuY2hhaW4ocF83MjcgPT4ge1xuICAgIHJldHVybiBzYWZlTGFzdF82NTUocF83MjcpLm1hcChzXzcyOCA9PiBzXzcyOC5saW5lTnVtYmVyKCkpLmNoYWluKGN1cmx5TGluZV83MjkgPT4ge1xuICAgICAgcmV0dXJuIHBvcF82NzEocF83MjcpLm1hcChpc0V4cHJQcmVmaXhfNjYzKGN1cmx5TGluZV83MjksIGJfNzIwKSk7XG4gICAgfSkuY2hhaW4oc3R1ZmZGYWxzZV82NTcocF83MjcpKTtcbiAgfSksIE1heWJlLmlzSnVzdCkocF83MjQpO1xufV0pO1xuZnVuY3Rpb24gbGFzdEVsXzY3NChsXzczMCkge1xuICByZXR1cm4gbF83MzBbbF83MzAubGVuZ3RoIC0gMV07XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFkZXIgZXh0ZW5kcyBUb2tlbml6ZXIge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzXzczMSwgY29udGV4dF83MzIsIHJlcGxhY2VtZW50c183MzMpIHtcbiAgICBzdXBlcihBcnJheS5pc0FycmF5KHN0cmluZ3NfNzMxKSA/IHN0cmluZ3NfNzMxLmpvaW4oXCJcIikgOiBzdHJpbmdzXzczMSk7XG4gICAgdGhpcy5kZWxpbVN0YWNrID0gbmV3IE1hcDtcbiAgICB0aGlzLmluc2lkZVN5bnRheFRlbXBsYXRlID0gW2ZhbHNlXTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XzczMjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJpbmdzXzczMSkpIHtcbiAgICAgIGxldCB0b3RhbEluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRJbmRleCA9IFIucmVkdWNlKChhY2NfNzM0LCBzdHJSZXBfNzM1KSA9PiB7XG4gICAgICAgIGFjY183MzQucHVzaCh7aW5kZXg6IHRvdGFsSW5kZXggKyBzdHJSZXBfNzM1WzBdLmxlbmd0aCwgcmVwbGFjZW1lbnQ6IHN0clJlcF83MzVbMV19KTtcbiAgICAgICAgdG90YWxJbmRleCArPSBzdHJSZXBfNzM1WzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGFjY183MzQ7XG4gICAgICB9LCBbXSwgUi56aXAoc3RyaW5nc183MzEsIHJlcGxhY2VtZW50c183MzMpKTtcbiAgICB9XG4gIH1cbiAgcmVhZChzdGFja183MzYgPSBbXSwgYl83MzcgPSBmYWxzZSwgc2luZ2xlRGVsaW1pdGVyXzczOCA9IGZhbHNlKSB7XG4gICAgbGV0IHByZWZpeF83MzkgPSBMaXN0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCB0b2sgPSB0aGlzLmFkdmFuY2UocHJlZml4XzczOSwgYl83MzcpO1xuICAgICAgaWYgKHRvayBpbnN0YW5jZW9mIFN5bnRheCB8fCB0b2sgaW5zdGFuY2VvZiBUZXJtKSB7XG4gICAgICAgIHN0YWNrXzczNi5wdXNoKHRvayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzdGFja183MzYsIHRvayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKExpc3QuaXNMaXN0KHRvaykpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoc3RhY2tfNzM2LCB0b2sudG9BcnJheSgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNFT1NfNjI4KHRvaykpIHtcbiAgICAgICAgaWYgKHN0YWNrXzczNlswXSAmJiBpc0xlZnREZWxpbWl0ZXJfNjMyKHN0YWNrXzczNlswXS50b2tlbikpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZVVuZXhwZWN0ZWQodG9rKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc0xlZnREZWxpbWl0ZXJfNjMyKHRvaykpIHtcbiAgICAgICAgaWYgKGlzTGVmdFN5bnRheF82MzAodG9rKSkge1xuICAgICAgICAgIHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUucHVzaCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IHRvay5zbGljZS5zdGFydExvY2F0aW9uLmxpbmU7XG4gICAgICAgIGxldCBpbm5lckIgPSBpc0xlZnRCcmFjZV82MjModG9rKSA/IGlzRXhwclByZWZpeF82NjMobGluZSwgYl83MzcpKHByZWZpeF83MzkpIDogdHJ1ZTtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5yZWFkKFtuZXcgU3ludGF4KHRvaywgdGhpcy5jb250ZXh0KV0sIGlubmVyQiwgZmFsc2UpO1xuICAgICAgICBsZXQgc3R4ID0gbmV3IFN5bnRheChpbm5lciwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgcHJlZml4XzczOSA9IHByZWZpeF83MzkuY29uY2F0KHN0eCk7XG4gICAgICAgIHN0YWNrXzczNi5wdXNoKHN0eCk7XG4gICAgICAgIGlmIChzaW5nbGVEZWxpbWl0ZXJfNzM4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNSaWdodERlbGltaXRlcl82MzModG9rKSkge1xuICAgICAgICBpZiAoc3RhY2tfNzM2WzBdICYmICFpc01hdGNoaW5nRGVsaW1pdGVyc182MzQoc3RhY2tfNzM2WzBdLnRva2VuLCB0b2spKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVVbmV4cGVjdGVkKHRvayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0eCA9IG5ldyBTeW50YXgodG9rLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICBzdGFja183MzYucHVzaChzdHgpO1xuICAgICAgICBpZiAobGFzdEVsXzY3NCh0aGlzLmluc2lkZVN5bnRheFRlbXBsYXRlKSAmJiBpc1JpZ2h0U3ludGF4XzYzMSh0b2spKSB7XG4gICAgICAgICAgdGhpcy5pbnNpZGVTeW50YXhUZW1wbGF0ZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzdHggPSBuZXcgU3ludGF4KHRvaywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgcHJlZml4XzczOSA9IHByZWZpeF83MzkuY29uY2F0KHN0eCk7XG4gICAgICAgIHN0YWNrXzczNi5wdXNoKHN0eCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHN0YWNrXzczNik7XG4gIH1cbiAgYWR2YW5jZShwcmVmaXhfNzQwLCBiXzc0MSkge1xuICAgIGxldCBzdGFydExvY2F0aW9uXzc0MiA9IHRoaXMuZ2V0TG9jYXRpb24oKTtcbiAgICB0aGlzLmxhc3RJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgdGhpcy5sYXN0TGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLmxhc3RMaW5lU3RhcnQgPSB0aGlzLmxpbmVTdGFydDtcbiAgICB0aGlzLnNraXBDb21tZW50KCk7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLnN0YXJ0TGluZVN0YXJ0ID0gdGhpcy5saW5lU3RhcnQ7XG4gICAgaWYgKHRoaXMucmVwbGFjZW1lbnRJbmRleCAmJiB0aGlzLnJlcGxhY2VtZW50SW5kZXhbMF0gJiYgdGhpcy5pbmRleCA+PSB0aGlzLnJlcGxhY2VtZW50SW5kZXhbMF0uaW5kZXgpIHtcbiAgICAgIGxldCByZXAgPSB0aGlzLnJlcGxhY2VtZW50SW5kZXhbMF0ucmVwbGFjZW1lbnQ7XG4gICAgICB0aGlzLnJlcGxhY2VtZW50SW5kZXguc2hpZnQoKTtcbiAgICAgIHJldHVybiByZXA7XG4gICAgfVxuICAgIGxldCBjaGFyQ29kZV83NDMgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgIGlmIChjaGFyQ29kZV83NDMgPT09IDk2KSB7XG4gICAgICBsZXQgZWxlbWVudCwgaXRlbXMgPSBbXTtcbiAgICAgIGxldCBzdGFydExvY2F0aW9uXzc0MiA9IHRoaXMuZ2V0TG9jYXRpb24oKTtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgICBpZiAobGFzdEVsXzY3NCh0aGlzLmluc2lkZVN5bnRheFRlbXBsYXRlKSkge1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBzdGFydExvY2F0aW9uXzc0Mik7XG4gICAgICAgIHJldHVybiB7dHlwZTogUlNZTlRBWF82MTksIHZhbHVlOiBcImBcIiwgc2xpY2U6IHNsaWNlfTtcbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuc2NhblRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBpdGVtcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5pbnRlcnApIHtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5yZWFkKFtdLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgYXNzZXJ0KGVsZW1lbnQuc2l6ZSA9PT0gMSwgXCJzaG91bGQgb25seSBoYXZlIHJlYWQgYSBzaW5nbGUgZGVsaW1pdGVyIGluc2lkZSBhIHRlbXBsYXRlXCIpO1xuICAgICAgICAgIGl0ZW1zLnB1c2goZWxlbWVudC5nZXQoMCkpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghZWxlbWVudC50YWlsKTtcbiAgICAgIHJldHVybiB7dHlwZTogVG9rZW5UeXBlLlRFTVBMQVRFLCBpdGVtczogTGlzdChpdGVtcyl9O1xuICAgIH0gZWxzZSBpZiAoY2hhckNvZGVfNzQzID09PSAzNSkge1xuICAgICAgbGV0IHN0YXJ0TG9jYXRpb25fNzQyID0gdGhpcy5nZXRMb2NhdGlvbigpO1xuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgIGxldCBzbGljZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIHN0YXJ0TG9jYXRpb25fNzQyKTtcbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSA5Nikge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB7dHlwZTogTFNZTlRBWF82MTgsIHZhbHVlOiBcIiNgXCIsIHNsaWNlOiBzbGljZX07XG4gICAgICB9XG4gICAgICByZXR1cm4ge3R5cGU6IFRva2VuVHlwZS5JREVOVElGSUVSLCB2YWx1ZTogXCIjXCIsIHNsaWNlOiBzbGljZX07XG4gICAgfSBlbHNlIGlmIChjaGFyQ29kZV83NDMgPT09IDY0KSB7XG4gICAgICBsZXQgc3RhcnRMb2NhdGlvbl83NDIgPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydCwgc3RhcnRMb2NhdGlvbl83NDIpO1xuICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgcmV0dXJuIHt0eXBlOiBBVF82MjAsIHZhbHVlOiBcIkBcIiwgc2xpY2U6IHNsaWNlfTtcbiAgICB9XG4gICAgbGV0IGxvb2thaGVhZF83NDQgPSBzdXBlci5hZHZhbmNlKCk7XG4gICAgaWYgKGxvb2thaGVhZF83NDQudHlwZSA9PT0gVG9rZW5UeXBlLkRJViAmJiBpc1JlZ2V4UHJlZml4XzY3MyhiXzc0MSkocHJlZml4Xzc0MCkpIHtcbiAgICAgIHJldHVybiBzdXBlci5zY2FuUmVnRXhwKFwiL1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2thaGVhZF83NDQ7XG4gIH1cbiAgc2NhblRlbXBsYXRlRWxlbWVudCgpIHtcbiAgICBsZXQgc3RhcnRMb2NhdGlvbl83NDUgPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgbGV0IHN0YXJ0Xzc0NiA9IHRoaXMuaW5kZXg7XG4gICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIGxldCBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgOTY6XG4gICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydF83NDYsIHN0YXJ0TG9jYXRpb25fNzQ1KTtcbiAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBUb2tlblR5cGUuVEVNUExBVEUsIHRhaWw6IHRydWUsIGludGVycDogZmFsc2UsIHNsaWNlOiBzbGljZX07XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAxMjMpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnRfNzQ2LCBzdGFydExvY2F0aW9uXzc0NSk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRva2VuVHlwZS5URU1QTEFURSwgdGFpbDogZmFsc2UsIGludGVycDogdHJ1ZSwgc2xpY2U6IHNsaWNlfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxldCBvY3RhbCA9IHRoaXMuc2NhblN0cmluZ0VzY2FwZShcIlwiLCBudWxsKVsxXTtcbiAgICAgICAgICAgIGlmIChvY3RhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKCk7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.JsError = exports.TokenType = exports.TokenClass = undefined;

		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		var _utils = __webpack_require__(3);

		var _errors = __webpack_require__(8);

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014 Shape Security, Inc.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License")
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

		var TokenClass = exports.TokenClass = {
		  Eof: { name: "<End>" },
		  Ident: { name: "Identifier", isIdentifierName: true },
		  Keyword: { name: "Keyword", isIdentifierName: true },
		  NumericLiteral: { name: "Numeric" },
		  TemplateElement: { name: "Template" },
		  Punctuator: { name: "Punctuator" },
		  StringLiteral: { name: "String" },
		  RegularExpression: { name: "RegularExpression" },
		  Illegal: { name: "Illegal" }
		};

		var TokenType = exports.TokenType = {
		  EOS: { klass: TokenClass.Eof, name: "EOS" },
		  LPAREN: { klass: TokenClass.Punctuator, name: "(" },
		  RPAREN: { klass: TokenClass.Punctuator, name: ")" },
		  LBRACK: { klass: TokenClass.Punctuator, name: "[" },
		  RBRACK: { klass: TokenClass.Punctuator, name: "]" },
		  LBRACE: { klass: TokenClass.Punctuator, name: "{" },
		  RBRACE: { klass: TokenClass.Punctuator, name: "}" },
		  COLON: { klass: TokenClass.Punctuator, name: ":" },
		  SEMICOLON: { klass: TokenClass.Punctuator, name: ";" },
		  PERIOD: { klass: TokenClass.Punctuator, name: "." },
		  ELLIPSIS: { klass: TokenClass.Punctuator, name: "..." },
		  ARROW: { klass: TokenClass.Punctuator, name: "=>" },
		  CONDITIONAL: { klass: TokenClass.Punctuator, name: "?" },
		  INC: { klass: TokenClass.Punctuator, name: "++" },
		  DEC: { klass: TokenClass.Punctuator, name: "--" },
		  ASSIGN: { klass: TokenClass.Punctuator, name: "=" },
		  ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: "|=" },
		  ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: "^=" },
		  ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: "&=" },
		  ASSIGN_SHL: { klass: TokenClass.Punctuator, name: "<<=" },
		  ASSIGN_SHR: { klass: TokenClass.Punctuator, name: ">>=" },
		  ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>=" },
		  ASSIGN_ADD: { klass: TokenClass.Punctuator, name: "+=" },
		  ASSIGN_SUB: { klass: TokenClass.Punctuator, name: "-=" },
		  ASSIGN_MUL: { klass: TokenClass.Punctuator, name: "*=" },
		  ASSIGN_DIV: { klass: TokenClass.Punctuator, name: "/=" },
		  ASSIGN_MOD: { klass: TokenClass.Punctuator, name: "%=" },
		  COMMA: { klass: TokenClass.Punctuator, name: "," },
		  OR: { klass: TokenClass.Punctuator, name: "||" },
		  AND: { klass: TokenClass.Punctuator, name: "&&" },
		  BIT_OR: { klass: TokenClass.Punctuator, name: "|" },
		  BIT_XOR: { klass: TokenClass.Punctuator, name: "^" },
		  BIT_AND: { klass: TokenClass.Punctuator, name: "&" },
		  SHL: { klass: TokenClass.Punctuator, name: "<<" },
		  SHR: { klass: TokenClass.Punctuator, name: ">>" },
		  SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>" },
		  ADD: { klass: TokenClass.Punctuator, name: "+" },
		  SUB: { klass: TokenClass.Punctuator, name: "-" },
		  MUL: { klass: TokenClass.Punctuator, name: "*" },
		  DIV: { klass: TokenClass.Punctuator, name: "/" },
		  MOD: { klass: TokenClass.Punctuator, name: "%" },
		  EQ: { klass: TokenClass.Punctuator, name: "==" },
		  NE: { klass: TokenClass.Punctuator, name: "!=" },
		  EQ_STRICT: { klass: TokenClass.Punctuator, name: "===" },
		  NE_STRICT: { klass: TokenClass.Punctuator, name: "!==" },
		  LT: { klass: TokenClass.Punctuator, name: "<" },
		  GT: { klass: TokenClass.Punctuator, name: ">" },
		  LTE: { klass: TokenClass.Punctuator, name: "<=" },
		  GTE: { klass: TokenClass.Punctuator, name: ">=" },
		  INSTANCEOF: { klass: TokenClass.Keyword, name: "instanceof" },
		  IN: { klass: TokenClass.Keyword, name: "in" },
		  NOT: { klass: TokenClass.Punctuator, name: "!" },
		  BIT_NOT: { klass: TokenClass.Punctuator, name: "~" },
		  AWAIT: { klass: TokenClass.Keyword, name: "await" },
		  DELETE: { klass: TokenClass.Keyword, name: "delete" },
		  TYPEOF: { klass: TokenClass.Keyword, name: "typeof" },
		  VOID: { klass: TokenClass.Keyword, name: "void" },
		  BREAK: { klass: TokenClass.Keyword, name: "break" },
		  CASE: { klass: TokenClass.Keyword, name: "case" },
		  CATCH: { klass: TokenClass.Keyword, name: "catch" },
		  CLASS: { klass: TokenClass.Keyword, name: "class" },
		  CONTINUE: { klass: TokenClass.Keyword, name: "continue" },
		  DEBUGGER: { klass: TokenClass.Keyword, name: "debugger" },
		  DEFAULT: { klass: TokenClass.Keyword, name: "default" },
		  DO: { klass: TokenClass.Keyword, name: "do" },
		  ELSE: { klass: TokenClass.Keyword, name: "else" },
		  EXPORT: { klass: TokenClass.Keyword, name: "export" },
		  EXTENDS: { klass: TokenClass.Keyword, name: "extends" },
		  FINALLY: { klass: TokenClass.Keyword, name: "finally" },
		  FOR: { klass: TokenClass.Keyword, name: "for" },
		  FUNCTION: { klass: TokenClass.Keyword, name: "function" },
		  IF: { klass: TokenClass.Keyword, name: "if" },
		  IMPORT: { klass: TokenClass.Keyword, name: "import" },
		  LET: { klass: TokenClass.Keyword, name: "let" },
		  NEW: { klass: TokenClass.Keyword, name: "new" },
		  RETURN: { klass: TokenClass.Keyword, name: "return" },
		  SUPER: { klass: TokenClass.Keyword, name: "super" },
		  SWITCH: { klass: TokenClass.Keyword, name: "switch" },
		  THIS: { klass: TokenClass.Keyword, name: "this" },
		  THROW: { klass: TokenClass.Keyword, name: "throw" },
		  TRY: { klass: TokenClass.Keyword, name: "try" },
		  VAR: { klass: TokenClass.Keyword, name: "var" },
		  WHILE: { klass: TokenClass.Keyword, name: "while" },
		  WITH: { klass: TokenClass.Keyword, name: "with" },
		  NULL: { klass: TokenClass.Keyword, name: "null" },
		  TRUE: { klass: TokenClass.Keyword, name: "true" },
		  FALSE: { klass: TokenClass.Keyword, name: "false" },
		  YIELD: { klass: TokenClass.Keyword, name: "yield" },
		  NUMBER: { klass: TokenClass.NumericLiteral, name: "" },
		  STRING: { klass: TokenClass.StringLiteral, name: "" },
		  REGEXP: { klass: TokenClass.RegularExpression, name: "" },
		  IDENTIFIER: { klass: TokenClass.Ident, name: "" },
		  CONST: { klass: TokenClass.Keyword, name: "const" },
		  TEMPLATE: { klass: TokenClass.TemplateElement, name: "" },
		  ILLEGAL: { klass: TokenClass.Illegal, name: "" }
		};

		var TT = TokenType;
		var I = TT.ILLEGAL;
		var F = false;
		var T = true;

		var ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];

		var PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];

		var JsError = exports.JsError = function (_Error) {
		  _inherits(JsError, _Error);

		  function JsError(index, line, column, msg) {
		    _classCallCheck(this, JsError);

		    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JsError).call(this, msg));

		    _this.index = index;
		    _this.line = line;
		    _this.column = column;
		    _this.description = msg;
		    _this.message = "[" + line + ":" + column + "]: " + msg;
		    return _this;
		  }

		  return JsError;
		}(Error);

		function fromCodePoint(cp) {
		  if (cp <= 0xFFFF) return String.fromCharCode(cp);
		  var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
		  var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
		  return cu1 + cu2;
		}

		function decodeUtf16(lead, trail) {
		  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
		}

		var Tokenizer = function () {
		  function Tokenizer(source) {
		    _classCallCheck(this, Tokenizer);

		    this.source = source;
		    this.index = 0;
		    this.line = 0;
		    this.lineStart = 0;
		    this.startIndex = 0;
		    this.startLine = 0;
		    this.startLineStart = 0;
		    this.lastIndex = 0;
		    this.lastLine = 0;
		    this.lastLineStart = 0;
		    this.hasLineTerminatorBeforeNext = false;
		    this.tokenIndex = 0;
		  }

		  _createClass(Tokenizer, [{
		    key: "saveLexerState",
		    value: function saveLexerState() {
		      return {
		        source: this.source,
		        index: this.index,
		        line: this.line,
		        lineStart: this.lineStart,
		        startIndex: this.startIndex,
		        startLine: this.startLine,
		        startLineStart: this.startLineStart,
		        lastIndex: this.lastIndex,
		        lastLine: this.lastLine,
		        lastLineStart: this.lastLineStart,
		        lookahead: this.lookahead,
		        hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,
		        tokenIndex: this.tokenIndex
		      };
		    }
		  }, {
		    key: "restoreLexerState",
		    value: function restoreLexerState(state) {
		      this.source = state.source;
		      this.index = state.index;
		      this.line = state.line;
		      this.lineStart = state.lineStart;
		      this.startIndex = state.startIndex;
		      this.startLine = state.startLine;
		      this.startLineStart = state.startLineStart;
		      this.lastIndex = state.lastIndex;
		      this.lastLine = state.lastLine;
		      this.lastLineStart = state.lastLineStart;
		      this.lookahead = state.lookahead;
		      this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;
		      this.tokenIndex = state.tokenIndex;
		    }
		  }, {
		    key: "createILLEGAL",
		    value: function createILLEGAL() {
		      this.startIndex = this.index;
		      this.startLine = this.line;
		      this.startLineStart = this.lineStart;
		      return this.index < this.source.length ? this.createError(_errors.ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index)) : this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
		    }
		  }, {
		    key: "createUnexpected",
		    value: function createUnexpected(token) {
		      switch (token.type.klass) {
		        case TokenClass.Eof:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
		        case TokenClass.Ident:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_IDENTIFIER);
		        case TokenClass.Keyword:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);
		        case TokenClass.NumericLiteral:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_NUMBER);
		        case TokenClass.TemplateElement:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_TEMPLATE);
		        case TokenClass.Punctuator:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
		        case TokenClass.StringLiteral:
		          return this.createError(_errors.ErrorMessages.UNEXPECTED_STRING);
		        // the other token classes are RegularExpression and Illegal, but they cannot reach here
		      }
		    }
		  }, {
		    key: "createError",
		    value: function createError(message) {
		      var _arguments = arguments;

		      /* istanbul ignore next */
		      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
		        return JSON.stringify(_arguments[+n + 1]);
		      });
		      return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);
		    }
		  }, {
		    key: "createErrorWithLocation",
		    value: function createErrorWithLocation(location, message) {
		      var _arguments2 = arguments;

		      /* istanbul ignore next */
		      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
		        return JSON.stringify(_arguments2[+n + 2]);
		      });
		      if (location.slice && location.slice.startLocation) {
		        location = location.slice.startLocation;
		      }
		      return new JsError(location.offset, location.line, location.column + 1, msg);
		    }
		  }, {
		    key: "getKeyword",
		    value: function getKeyword(id) {
		      if (id.length === 1 || id.length > 10) {
		        return TokenType.IDENTIFIER;
		      }

		      /* istanbul ignore next */
		      switch (id.length) {
		        case 2:
		          switch (id.charAt(0)) {
		            case "i":
		              switch (id.charAt(1)) {
		                case "f":
		                  return TokenType.IF;
		                case "n":
		                  return TokenType.IN;
		                default:
		                  break;
		              }
		              break;
		            case "d":
		              if (id.charAt(1) === "o") {
		                return TokenType.DO;
		              }
		              break;
		          }
		          break;
		        case 3:
		          switch (id.charAt(0)) {
		            case "v":
		              if (Tokenizer.cse2(id, "a", "r")) {
		                return TokenType.VAR;
		              }
		              break;
		            case "f":
		              if (Tokenizer.cse2(id, "o", "r")) {
		                return TokenType.FOR;
		              }
		              break;
		            case "n":
		              if (Tokenizer.cse2(id, "e", "w")) {
		                return TokenType.NEW;
		              }
		              break;
		            case "t":
		              if (Tokenizer.cse2(id, "r", "y")) {
		                return TokenType.TRY;
		              }
		              break;
		            case "l":
		              if (Tokenizer.cse2(id, "e", "t")) {
		                return TokenType.LET;
		              }
		              break;
		          }
		          break;
		        case 4:
		          switch (id.charAt(0)) {
		            case "t":
		              if (Tokenizer.cse3(id, "h", "i", "s")) {
		                return TokenType.THIS;
		              } else if (Tokenizer.cse3(id, "r", "u", "e")) {
		                return TokenType.TRUE;
		              }
		              break;
		            case "n":
		              if (Tokenizer.cse3(id, "u", "l", "l")) {
		                return TokenType.NULL;
		              }
		              break;
		            case "e":
		              if (Tokenizer.cse3(id, "l", "s", "e")) {
		                return TokenType.ELSE;
		              }
		              break;
		            case "c":
		              if (Tokenizer.cse3(id, "a", "s", "e")) {
		                return TokenType.CASE;
		              }
		              break;
		            case "v":
		              if (Tokenizer.cse3(id, "o", "i", "d")) {
		                return TokenType.VOID;
		              }
		              break;
		            case "w":
		              if (Tokenizer.cse3(id, "i", "t", "h")) {
		                return TokenType.WITH;
		              }
		              break;
		          }
		          break;
		        case 5:
		          switch (id.charAt(0)) {
		            case "a":
		              if (this.moduleIsTheGoalSymbol && Tokenizer.cse4(id, "w", "a", "i", "t")) {
		                return TokenType.AWAIT;
		              }
		              break;
		            case "w":
		              if (Tokenizer.cse4(id, "h", "i", "l", "e")) {
		                return TokenType.WHILE;
		              }
		              break;
		            case "b":
		              if (Tokenizer.cse4(id, "r", "e", "a", "k")) {
		                return TokenType.BREAK;
		              }
		              break;
		            case "f":
		              if (Tokenizer.cse4(id, "a", "l", "s", "e")) {
		                return TokenType.FALSE;
		              }
		              break;
		            case "c":
		              if (Tokenizer.cse4(id, "a", "t", "c", "h")) {
		                return TokenType.CATCH;
		              } else if (Tokenizer.cse4(id, "o", "n", "s", "t")) {
		                return TokenType.CONST;
		              } else if (Tokenizer.cse4(id, "l", "a", "s", "s")) {
		                return TokenType.CLASS;
		              }
		              break;
		            case "t":
		              if (Tokenizer.cse4(id, "h", "r", "o", "w")) {
		                return TokenType.THROW;
		              }
		              break;
		            case "y":
		              if (Tokenizer.cse4(id, "i", "e", "l", "d")) {
		                return TokenType.YIELD;
		              }
		              break;
		            case "s":
		              if (Tokenizer.cse4(id, "u", "p", "e", "r")) {
		                return TokenType.SUPER;
		              }
		              break;
		          }
		          break;
		        case 6:
		          switch (id.charAt(0)) {
		            case "r":
		              if (Tokenizer.cse5(id, "e", "t", "u", "r", "n")) {
		                return TokenType.RETURN;
		              }
		              break;
		            case "t":
		              if (Tokenizer.cse5(id, "y", "p", "e", "o", "f")) {
		                return TokenType.TYPEOF;
		              }
		              break;
		            case "d":
		              if (Tokenizer.cse5(id, "e", "l", "e", "t", "e")) {
		                return TokenType.DELETE;
		              }
		              break;
		            case "s":
		              if (Tokenizer.cse5(id, "w", "i", "t", "c", "h")) {
		                return TokenType.SWITCH;
		              }
		              break;
		            case "e":
		              if (Tokenizer.cse5(id, "x", "p", "o", "r", "t")) {
		                return TokenType.EXPORT;
		              }
		              break;
		            case "i":
		              if (Tokenizer.cse5(id, "m", "p", "o", "r", "t")) {
		                return TokenType.IMPORT;
		              }
		              break;
		          }
		          break;
		        case 7:
		          switch (id.charAt(0)) {
		            case "d":
		              if (Tokenizer.cse6(id, "e", "f", "a", "u", "l", "t")) {
		                return TokenType.DEFAULT;
		              }
		              break;
		            case "f":
		              if (Tokenizer.cse6(id, "i", "n", "a", "l", "l", "y")) {
		                return TokenType.FINALLY;
		              }
		              break;
		            case "e":
		              if (Tokenizer.cse6(id, "x", "t", "e", "n", "d", "s")) {
		                return TokenType.EXTENDS;
		              }
		              break;
		          }
		          break;
		        case 8:
		          switch (id.charAt(0)) {
		            case "f":
		              if (Tokenizer.cse7(id, "u", "n", "c", "t", "i", "o", "n")) {
		                return TokenType.FUNCTION;
		              }
		              break;
		            case "c":
		              if (Tokenizer.cse7(id, "o", "n", "t", "i", "n", "u", "e")) {
		                return TokenType.CONTINUE;
		              }
		              break;
		            case "d":
		              if (Tokenizer.cse7(id, "e", "b", "u", "g", "g", "e", "r")) {
		                return TokenType.DEBUGGER;
		              }
		              break;
		          }
		          break;
		        case 10:
		          if (id === "instanceof") {
		            return TokenType.INSTANCEOF;
		          }
		          break;
		      }
		      return TokenType.IDENTIFIER;
		    }
		  }, {
		    key: "skipSingleLineComment",
		    value: function skipSingleLineComment(offset) {
		      this.index += offset;
		      while (this.index < this.source.length) {
		        /**
		         * @type {Number}
		         */
		        var chCode = this.source.charCodeAt(this.index);
		        this.index++;
		        if ((0, _utils.isLineTerminator)(chCode)) {
		          this.hasLineTerminatorBeforeNext = true;
		          if (chCode === 0xD /* "\r" */ && this.source.charCodeAt(this.index) === 0xA /*"\n" */) {
		              this.index++;
		            }
		          this.lineStart = this.index;
		          this.line++;
		          return;
		        }
		      }
		    }
		  }, {
		    key: "skipMultiLineComment",
		    value: function skipMultiLineComment() {
		      this.index += 2;
		      var length = this.source.length;
		      var isLineStart = false;
		      while (this.index < length) {
		        var chCode = this.source.charCodeAt(this.index);
		        if (chCode < 0x80) {
		          switch (chCode) {
		            case 42:
		              // "*"
		              // Block comment ends with "*/".
		              if (this.source.charAt(this.index + 1) === "/") {
		                this.index = this.index + 2;
		                return isLineStart;
		              }
		              this.index++;
		              break;
		            case 10:
		              // "\n"
		              isLineStart = true;
		              this.hasLineTerminatorBeforeNext = true;
		              this.index++;
		              this.lineStart = this.index;
		              this.line++;
		              break;
		            case 13:
		              // "\r":
		              isLineStart = true;
		              this.hasLineTerminatorBeforeNext = true;
		              if (this.source.charAt(this.index + 1) === "\n") {
		                this.index++;
		              }
		              this.index++;
		              this.lineStart = this.index;
		              this.line++;
		              break;
		            default:
		              this.index++;
		          }
		        } else if (chCode === 0x2028 || chCode === 0x2029) {
		          isLineStart = true;
		          this.hasLineTerminatorBeforeNext = true;
		          this.index++;
		          this.lineStart = this.index;
		          this.line++;
		        } else {
		          this.index++;
		        }
		      }
		      throw this.createILLEGAL();
		    }
		  }, {
		    key: "skipComment",
		    value: function skipComment() {
		      this.hasLineTerminatorBeforeNext = false;

		      var isLineStart = this.index === 0;
		      var length = this.source.length;

		      while (this.index < length) {
		        var chCode = this.source.charCodeAt(this.index);
		        if ((0, _utils.isWhiteSpace)(chCode)) {
		          this.index++;
		        } else if ((0, _utils.isLineTerminator)(chCode)) {
		          this.hasLineTerminatorBeforeNext = true;
		          this.index++;
		          if (chCode === 13 /* "\r" */ && this.source.charAt(this.index) === "\n") {
		            this.index++;
		          }
		          this.lineStart = this.index;
		          this.line++;
		          isLineStart = true;
		        } else if (chCode === 47 /* "/" */) {
		            if (this.index + 1 >= length) {
		              break;
		            }
		            chCode = this.source.charCodeAt(this.index + 1);
		            if (chCode === 47 /* "/" */) {
		                this.skipSingleLineComment(2);
		                isLineStart = true;
		              } else if (chCode === 42 /* "*" */) {
		                isLineStart = this.skipMultiLineComment() || isLineStart;
		              } else {
		              break;
		            }
		          } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* "-" */) {
		            if (this.index + 2 >= length) {
		              break;
		            }
		            // U+003E is ">"
		            if (this.source.charAt(this.index + 1) === "-" && this.source.charAt(this.index + 2) === ">") {
		              // "-->" is a single-line comment
		              this.skipSingleLineComment(3);
		            } else {
		              break;
		            }
		          } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* "<" */) {
		            if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
		              this.skipSingleLineComment(4);
		            } else {
		              break;
		            }
		          } else {
		          break;
		        }
		      }
		    }
		  }, {
		    key: "scanHexEscape2",
		    value: function scanHexEscape2() {
		      if (this.index + 2 > this.source.length) {
		        return -1;
		      }
		      var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
		      if (r1 === -1) {
		        return -1;
		      }
		      var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
		      if (r2 === -1) {
		        return -1;
		      }
		      this.index += 2;
		      return r1 << 4 | r2;
		    }
		  }, {
		    key: "scanUnicode",
		    value: function scanUnicode() {
		      if (this.source.charAt(this.index) === "{") {
		        //\u{HexDigits}
		        var i = this.index + 1;
		        var hexDigits = 0,
		            ch = void 0;
		        while (i < this.source.length) {
		          ch = this.source.charAt(i);
		          var hex = (0, _utils.getHexValue)(ch);
		          if (hex === -1) {
		            break;
		          }
		          hexDigits = hexDigits << 4 | hex;
		          if (hexDigits > 0x10FFFF) {
		            throw this.createILLEGAL();
		          }
		          i++;
		        }
		        if (ch !== "}") {
		          throw this.createILLEGAL();
		        }
		        if (i === this.index + 1) {
		          ++this.index; // This is so that the error is 'Unexpected "}"' instead of 'Unexpected "{"'.
		          throw this.createILLEGAL();
		        }
		        this.index = i + 1;
		        return hexDigits;
		      } else {
		        //\uHex4Digits
		        if (this.index + 4 > this.source.length) {
		          return -1;
		        }
		        var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
		        if (r1 === -1) {
		          return -1;
		        }
		        var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
		        if (r2 === -1) {
		          return -1;
		        }
		        var r3 = (0, _utils.getHexValue)(this.source.charAt(this.index + 2));
		        if (r3 === -1) {
		          return -1;
		        }
		        var r4 = (0, _utils.getHexValue)(this.source.charAt(this.index + 3));
		        if (r4 === -1) {
		          return -1;
		        }
		        this.index += 4;
		        return r1 << 12 | r2 << 8 | r3 << 4 | r4;
		      }
		    }
		  }, {
		    key: "getEscapedIdentifier",
		    value: function getEscapedIdentifier() {
		      var id = "";
		      var check = _utils.isIdentifierStart;

		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        var code = ch.charCodeAt(0);
		        var start = this.index;
		        ++this.index;
		        if (ch === "\\") {
		          if (this.index >= this.source.length) {
		            throw this.createILLEGAL();
		          }
		          if (this.source.charAt(this.index) !== "u") {
		            throw this.createILLEGAL();
		          }
		          ++this.index;
		          code = this.scanUnicode();
		          if (code < 0) {
		            throw this.createILLEGAL();
		          }
		          ch = fromCodePoint(code);
		        } else if (0xD800 <= code && code <= 0xDBFF) {
		          if (this.index >= this.source.length) {
		            throw this.createILLEGAL();
		          }
		          var lowSurrogateCode = this.source.charCodeAt(this.index);
		          ++this.index;
		          if (!(0xDC00 <= lowSurrogateCode && lowSurrogateCode <= 0xDFFF)) {
		            throw this.createILLEGAL();
		          }
		          code = decodeUtf16(code, lowSurrogateCode);
		          ch = fromCodePoint(code);
		        }
		        if (!check(code)) {
		          if (id.length < 1) {
		            throw this.createILLEGAL();
		          }
		          this.index = start;
		          return id;
		        }
		        check = _utils.isIdentifierPart;
		        id += ch;
		      }
		      return id;
		    }
		  }, {
		    key: "getIdentifier",
		    value: function getIdentifier() {
		      var start = this.index;
		      var l = this.source.length;
		      var i = this.index;
		      var check = _utils.isIdentifierStart;
		      while (i < l) {
		        var ch = this.source.charAt(i);
		        var code = ch.charCodeAt(0);
		        if (ch === "\\" || 0xD800 <= code && code <= 0xDBFF) {
		          // Go back and try the hard one.
		          this.index = start;
		          return this.getEscapedIdentifier();
		        }
		        if (!check(code)) {
		          this.index = i;
		          return this.source.slice(start, i);
		        }
		        ++i;
		        check = _utils.isIdentifierPart;
		      }
		      this.index = i;
		      return this.source.slice(start, i);
		    }
		  }, {
		    key: "scanIdentifier",
		    value: function scanIdentifier() {
		      var startLocation = this.getLocation();
		      var start = this.index;

		      // Backslash (U+005C) starts an escaped character.
		      var id = this.source.charAt(this.index) === "\\" ? this.getEscapedIdentifier() : this.getIdentifier();

		      // There is no keyword or literal with only one character.
		      // Thus, it must be an identifier.
		      var slice = this.getSlice(start, startLocation);
		      slice.text = id;

		      return { type: this.getKeyword(id), value: id, slice: slice };
		    }
		  }, {
		    key: "getLocation",
		    value: function getLocation() {
		      return {
		        line: this.startLine + 1,
		        column: this.startIndex - this.startLineStart,
		        offset: this.startIndex
		      };
		    }
		  }, {
		    key: "getSlice",
		    value: function getSlice(start, startLocation) {
		      return { text: this.source.slice(start, this.index), start: start, startLocation: startLocation, end: this.index };
		    }
		  }, {
		    key: "scanPunctuatorHelper",
		    value: function scanPunctuatorHelper() {
		      var ch1 = this.source.charAt(this.index);

		      switch (ch1) {
		        // Check for most common single-character punctuators.
		        case ".":
		          var ch2 = this.source.charAt(this.index + 1);
		          if (ch2 !== ".") return TokenType.PERIOD;
		          var ch3 = this.source.charAt(this.index + 2);
		          if (ch3 !== ".") return TokenType.PERIOD;
		          return TokenType.ELLIPSIS;
		        case "(":
		          return TokenType.LPAREN;
		        case ")":
		        case ";":
		        case ",":
		          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
		        case "{":
		          return TokenType.LBRACE;
		        case "}":
		        case "[":
		        case "]":
		        case ":":
		        case "?":
		        case "~":
		          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
		        default:
		          // "=" (U+003D) marks an assignment or comparison operator.
		          if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === "=") {
		            switch (ch1) {
		              case "=":
		                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
		                  return TokenType.EQ_STRICT;
		                }
		                return TokenType.EQ;
		              case "!":
		                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
		                  return TokenType.NE_STRICT;
		                }
		                return TokenType.NE;
		              case "|":
		                return TokenType.ASSIGN_BIT_OR;
		              case "+":
		                return TokenType.ASSIGN_ADD;
		              case "-":
		                return TokenType.ASSIGN_SUB;
		              case "*":
		                return TokenType.ASSIGN_MUL;
		              case "<":
		                return TokenType.LTE;
		              case ">":
		                return TokenType.GTE;
		              case "/":
		                return TokenType.ASSIGN_DIV;
		              case "%":
		                return TokenType.ASSIGN_MOD;
		              case "^":
		                return TokenType.ASSIGN_BIT_XOR;
		              case "&":
		                return TokenType.ASSIGN_BIT_AND;
		              // istanbul ignore next
		              default:
		                break; //failed
		            }
		          }
		      }

		      if (this.index + 1 < this.source.length) {
		        var _ch = this.source.charAt(this.index + 1);
		        if (ch1 === _ch) {
		          if (this.index + 2 < this.source.length) {
		            var _ch2 = this.source.charAt(this.index + 2);
		            if (ch1 === ">" && _ch2 === ">") {
		              // 4-character punctuator: >>>=
		              if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === "=") {
		                return TokenType.ASSIGN_SHR_UNSIGNED;
		              }
		              return TokenType.SHR_UNSIGNED;
		            }

		            if (ch1 === "<" && _ch2 === "=") {
		              return TokenType.ASSIGN_SHL;
		            }

		            if (ch1 === ">" && _ch2 === "=") {
		              return TokenType.ASSIGN_SHR;
		            }
		          }
		          // Other 2-character punctuators: ++ -- << >> && ||
		          switch (ch1) {
		            case "+":
		              return TokenType.INC;
		            case "-":
		              return TokenType.DEC;
		            case "<":
		              return TokenType.SHL;
		            case ">":
		              return TokenType.SHR;
		            case "&":
		              return TokenType.AND;
		            case "|":
		              return TokenType.OR;
		            // istanbul ignore next
		            default:
		              break; //failed
		          }
		        } else if (ch1 === "=" && _ch === ">") {
		            return TokenType.ARROW;
		          }
		      }

		      return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
		    }

		    // 7.7 Punctuators

		  }, {
		    key: "scanPunctuator",
		    value: function scanPunctuator() {
		      var startLocation = this.getLocation();
		      var start = this.index;
		      var subType = this.scanPunctuatorHelper();
		      this.index += subType.name.length;
		      return { type: subType, value: subType.name, slice: this.getSlice(start, startLocation) };
		    }
		  }, {
		    key: "scanHexLiteral",
		    value: function scanHexLiteral(start, startLocation) {
		      var i = this.index;
		      while (i < this.source.length) {
		        var ch = this.source.charAt(i);
		        var hex = (0, _utils.getHexValue)(ch);
		        if (hex === -1) {
		          break;
		        }
		        i++;
		      }

		      if (this.index === i) {
		        throw this.createILLEGAL();
		      }

		      if (i < this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(i))) {
		        throw this.createILLEGAL();
		      }

		      this.index = i;

		      var slice = this.getSlice(start, startLocation);
		      return { type: TokenType.NUMBER, value: parseInt(slice.text.substr(2), 16), slice: slice };
		    }
		  }, {
		    key: "scanBinaryLiteral",
		    value: function scanBinaryLiteral(start, startLocation) {
		      var offset = this.index - start;

		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        if (ch !== "0" && ch !== "1") {
		          break;
		        }
		        this.index++;
		      }

		      if (this.index - start <= offset) {
		        throw this.createILLEGAL();
		      }

		      if (this.index < this.source.length && ((0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index)) || (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index)))) {
		        throw this.createILLEGAL();
		      }

		      return {
		        type: TokenType.NUMBER,
		        value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),
		        slice: this.getSlice(start, startLocation),
		        octal: false,
		        noctal: false
		      };
		    }
		  }, {
		    key: "scanOctalLiteral",
		    value: function scanOctalLiteral(start, startLocation) {
		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        if ("0" <= ch && ch <= "7") {
		          this.index++;
		        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
		          throw this.createILLEGAL();
		        } else {
		          break;
		        }
		      }

		      if (this.index - start === 2) {
		        throw this.createILLEGAL();
		      }

		      return {
		        type: TokenType.NUMBER,
		        value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),
		        slice: this.getSlice(start, startLocation),
		        octal: false,
		        noctal: false
		      };
		    }
		  }, {
		    key: "scanLegacyOctalLiteral",
		    value: function scanLegacyOctalLiteral(start, startLocation) {
		      var isOctal = true;

		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        if ("0" <= ch && ch <= "7") {
		          this.index++;
		        } else if (ch === "8" || ch === "9") {
		          isOctal = false;
		          this.index++;
		        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
		          throw this.createILLEGAL();
		        } else {
		          break;
		        }
		      }

		      var slice = this.getSlice(start, startLocation);
		      if (!isOctal) {
		        this.eatDecimalLiteralSuffix();
		        return {
		          type: TokenType.NUMBER,
		          slice: slice,
		          value: +slice.text,
		          octal: true,
		          noctal: !isOctal
		        };
		      }

		      return {
		        type: TokenType.NUMBER,
		        slice: slice,
		        value: parseInt(slice.text.substr(1), 8),
		        octal: true,
		        noctal: !isOctal
		      };
		    }
		  }, {
		    key: "scanNumericLiteral",
		    value: function scanNumericLiteral() {
		      var ch = this.source.charAt(this.index);
		      // assert(ch === "." || "0" <= ch && ch <= "9")
		      var startLocation = this.getLocation();
		      var start = this.index;

		      if (ch === "0") {
		        this.index++;
		        if (this.index < this.source.length) {
		          ch = this.source.charAt(this.index);
		          if (ch === "x" || ch === "X") {
		            this.index++;
		            return this.scanHexLiteral(start, startLocation);
		          } else if (ch === "b" || ch === "B") {
		            this.index++;
		            return this.scanBinaryLiteral(start, startLocation);
		          } else if (ch === "o" || ch === "O") {
		            this.index++;
		            return this.scanOctalLiteral(start, startLocation);
		          } else if ("0" <= ch && ch <= "9") {
		            return this.scanLegacyOctalLiteral(start, startLocation);
		          }
		        } else {
		          var _slice = this.getSlice(start, startLocation);
		          return {
		            type: TokenType.NUMBER,
		            value: +_slice.text,
		            slice: _slice,
		            octal: false,
		            noctal: false
		          };
		        }
		      } else if (ch !== ".") {
		        // Must be "1".."9"
		        ch = this.source.charAt(this.index);
		        while ("0" <= ch && ch <= "9") {
		          this.index++;
		          if (this.index === this.source.length) {
		            var _slice2 = this.getSlice(start, startLocation);
		            return {
		              type: TokenType.NUMBER,
		              value: +_slice2.text,
		              slice: _slice2,
		              octal: false,
		              noctal: false
		            };
		          }
		          ch = this.source.charAt(this.index);
		        }
		      }

		      this.eatDecimalLiteralSuffix();

		      if (this.index !== this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index))) {
		        throw this.createILLEGAL();
		      }

		      var slice = this.getSlice(start, startLocation);
		      return {
		        type: TokenType.NUMBER,
		        value: +slice.text,
		        slice: slice,
		        octal: false,
		        noctal: false
		      };
		    }
		  }, {
		    key: "eatDecimalLiteralSuffix",
		    value: function eatDecimalLiteralSuffix() {
		      var ch = this.source.charAt(this.index);
		      if (ch === ".") {
		        this.index++;
		        if (this.index === this.source.length) {
		          return;
		        }

		        ch = this.source.charAt(this.index);
		        while ("0" <= ch && ch <= "9") {
		          this.index++;
		          if (this.index === this.source.length) {
		            return;
		          }
		          ch = this.source.charAt(this.index);
		        }
		      }

		      // EOF not reached here
		      if (ch === "e" || ch === "E") {
		        this.index++;
		        if (this.index === this.source.length) {
		          throw this.createILLEGAL();
		        }

		        ch = this.source.charAt(this.index);
		        if (ch === "+" || ch === "-") {
		          this.index++;
		          if (this.index === this.source.length) {
		            throw this.createILLEGAL();
		          }
		          ch = this.source.charAt(this.index);
		        }

		        if ("0" <= ch && ch <= "9") {
		          while ("0" <= ch && ch <= "9") {
		            this.index++;
		            if (this.index === this.source.length) {
		              break;
		            }
		            ch = this.source.charAt(this.index);
		          }
		        } else {
		          throw this.createILLEGAL();
		        }
		      }
		    }
		  }, {
		    key: "scanStringEscape",
		    value: function scanStringEscape(str, octal) {
		      this.index++;
		      if (this.index === this.source.length) {
		        throw this.createILLEGAL();
		      }
		      var ch = this.source.charAt(this.index);
		      if (!(0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
		        switch (ch) {
		          case "n":
		            str += "\n";
		            this.index++;
		            break;
		          case "r":
		            str += "\r";
		            this.index++;
		            break;
		          case "t":
		            str += "\t";
		            this.index++;
		            break;
		          case "u":
		          case "x":
		            var unescaped = void 0;
		            this.index++;
		            if (this.index >= this.source.length) {
		              throw this.createILLEGAL();
		            }
		            unescaped = ch === "u" ? this.scanUnicode() : this.scanHexEscape2();
		            if (unescaped < 0) {
		              throw this.createILLEGAL();
		            }
		            str += fromCodePoint(unescaped);
		            break;
		          case "b":
		            str += "\b";
		            this.index++;
		            break;
		          case "f":
		            str += "\f";
		            this.index++;
		            break;
		          case "v":
		            str += "\u000b";
		            this.index++;
		            break;
		          default:
		            if ("0" <= ch && ch <= "7") {
		              var octalStart = this.index;
		              var octLen = 1;
		              // 3 digits are only allowed when string starts
		              // with 0, 1, 2, 3
		              if ("0" <= ch && ch <= "3") {
		                octLen = 0;
		              }
		              var code = 0;
		              while (octLen < 3 && "0" <= ch && ch <= "7") {
		                this.index++;
		                if (octLen > 0 || ch !== "0") {
		                  octal = this.source.slice(octalStart, this.index);
		                }
		                code *= 8;
		                code += ch - "0";
		                octLen++;
		                if (this.index === this.source.length) {
		                  throw this.createILLEGAL();
		                }
		                ch = this.source.charAt(this.index);
		              }
		              str += String.fromCharCode(code);
		            } else if (ch === "8" || ch === "9") {
		              throw this.createILLEGAL();
		            } else {
		              str += ch;
		              this.index++;
		            }
		        }
		      } else {
		        this.index++;
		        if (ch === "\r" && this.source.charAt(this.index) === "\n") {
		          this.index++;
		        }
		        this.lineStart = this.index;
		        this.line++;
		      }
		      return [str, octal];
		    }
		    // 7.8.4 String Literals

		  }, {
		    key: "scanStringLiteral",
		    value: function scanStringLiteral() {
		      var str = "";

		      var quote = this.source.charAt(this.index);
		      //  assert((quote === "\"" || quote === """), "String literal must starts with a quote")

		      var startLocation = this.getLocation();
		      var start = this.index;
		      this.index++;

		      var octal = null;
		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        if (ch === quote) {
		          this.index++;
		          return { type: TokenType.STRING, slice: this.getSlice(start, startLocation), str: str, octal: octal };
		        } else if (ch === "\\") {
		          var _scanStringEscape = this.scanStringEscape(str, octal);

		          var _scanStringEscape2 = _slicedToArray(_scanStringEscape, 2);

		          str = _scanStringEscape2[0];
		          octal = _scanStringEscape2[1];
		        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
		          throw this.createILLEGAL();
		        } else {
		          str += ch;
		          this.index++;
		        }
		      }

		      throw this.createILLEGAL();
		    }
		  }, {
		    key: "scanTemplateElement",
		    value: function scanTemplateElement() {
		      var startLocation = this.getLocation();
		      var start = this.index;
		      this.index++;
		      while (this.index < this.source.length) {
		        var ch = this.source.charCodeAt(this.index);
		        switch (ch) {
		          case 0x60:
		            // `
		            this.index++;
		            return { type: TokenType.TEMPLATE, tail: true, slice: this.getSlice(start, startLocation) };
		          case 0x24:
		            // $
		            if (this.source.charCodeAt(this.index + 1) === 0x7B) {
		              // {
		              this.index += 2;
		              return { type: TokenType.TEMPLATE, tail: false, slice: this.getSlice(start, startLocation) };
		            }
		            this.index++;
		            break;
		          case 0x5C:
		            // \\
		            {
		              var octal = this.scanStringEscape("", null)[1];
		              if (octal != null) {
		                throw this.createILLEGAL();
		              }
		              break;
		            }
		          default:
		            this.index++;
		        }
		      }

		      throw this.createILLEGAL();
		    }
		  }, {
		    key: "scanRegExp",
		    value: function scanRegExp(str) {
		      var startLocation = this.getLocation();
		      var start = this.index;

		      var terminated = false;
		      var classMarker = false;
		      while (this.index < this.source.length) {
		        var ch = this.source.charAt(this.index);
		        if (ch === "\\") {
		          str += ch;
		          this.index++;
		          ch = this.source.charAt(this.index);
		          // ECMA-262 7.8.5
		          if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
		            throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
		          }
		          str += ch;
		          this.index++;
		        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
		          throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
		        } else {
		          if (classMarker) {
		            if (ch === "]") {
		              classMarker = false;
		            }
		          } else {
		            if (ch === "/") {
		              terminated = true;
		              str += ch;
		              this.index++;
		              break;
		            } else if (ch === "[") {
		              classMarker = true;
		            }
		          }
		          str += ch;
		          this.index++;
		        }
		      }

		      if (!terminated) {
		        throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
		      }

		      while (this.index < this.source.length) {
		        var _ch3 = this.source.charAt(this.index);
		        if (_ch3 === "\\") {
		          throw this.createError(_errors.ErrorMessages.INVALID_REGEXP_FLAGS);
		        }
		        if (!(0, _utils.isIdentifierPart)(_ch3.charCodeAt(0))) {
		          break;
		        }
		        this.index++;
		        str += _ch3;
		      }
		      return { type: TokenType.REGEXP, value: str, slice: this.getSlice(start, startLocation) };
		    }
		  }, {
		    key: "advance",
		    value: function advance() {
		      var startLocation = this.getLocation();

		      this.lastIndex = this.index;
		      this.lastLine = this.line;
		      this.lastLineStart = this.lineStart;

		      this.skipComment();

		      this.startIndex = this.index;
		      this.startLine = this.line;
		      this.startLineStart = this.lineStart;

		      if (this.lastIndex === 0) {
		        this.lastIndex = this.index;
		        this.lastLine = this.line;
		        this.lastLineStart = this.lineStart;
		      }

		      if (this.index >= this.source.length) {
		        return { type: TokenType.EOS, slice: this.getSlice(this.index, startLocation) };
		      }

		      var charCode = this.source.charCodeAt(this.index);

		      if (charCode < 0x80) {
		        if (PUNCTUATOR_START[charCode]) {
		          return this.scanPunctuator();
		        }

		        if ((0, _utils.isIdentifierStart)(charCode) || charCode === 0x5C /* backslash (\) */) {
		            return this.scanIdentifier();
		          }

		        // Dot (.) U+002E can also start a floating-point number, hence the need
		        // to check the next character.
		        if (charCode === 0x2E) {
		          if (this.index + 1 < this.source.length && (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index + 1))) {
		            return this.scanNumericLiteral();
		          }
		          return this.scanPunctuator();
		        }

		        // String literal starts with single quote (U+0027) or double quote (U+0022).
		        if (charCode === 0x27 || charCode === 0x22) {
		          return this.scanStringLiteral();
		        }

		        // Template literal starts with back quote (U+0060)
		        if (charCode === 0x60) {
		          return this.scanTemplateElement();
		        }

		        if (0x30 /* "0" */ <= charCode && charCode <= 0x39 /* "9" */) {
		            return this.scanNumericLiteral();
		          }

		        // Slash (/) U+002F can also start a regex.
		        throw this.createILLEGAL();
		      } else {
		        if ((0, _utils.isIdentifierStart)(charCode) || 0xD800 <= charCode && charCode <= 0xDBFF) {
		          return this.scanIdentifier();
		        }

		        throw this.createILLEGAL();
		      }
		    }
		  }, {
		    key: "eof",
		    value: function eof() {
		      return this.lookahead.type === TokenType.EOS;
		    }
		  }, {
		    key: "lex",
		    value: function lex() {
		      var prevToken = this.lookahead;
		      this.lookahead = this.advance();
		      this.tokenIndex++;
		      return prevToken;
		    }
		  }], [{
		    key: "cse2",
		    value: function cse2(id, ch1, ch2) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2;
		    }
		  }, {
		    key: "cse3",
		    value: function cse3(id, ch1, ch2, ch3) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;
		    }
		  }, {
		    key: "cse4",
		    value: function cse4(id, ch1, ch2, ch3, ch4) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;
		    }
		  }, {
		    key: "cse5",
		    value: function cse5(id, ch1, ch2, ch3, ch4, ch5) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;
		    }
		  }, {
		    key: "cse6",
		    value: function cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;
		    }
		  }, {
		    key: "cse7",
		    value: function cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {
		      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;
		    }
		  }]);

		  return Tokenizer;
		}();

		exports.default = Tokenizer;

	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isDecimalDigit = exports.isLineTerminator = exports.isWhiteSpace = exports.isIdentifierPart = exports.isIdentifierStart = exports.isRestrictedWord = undefined;
		exports.isStrictModeReservedWord = isStrictModeReservedWord;
		exports.getHexValue = getHexValue;

		var _esutils = __webpack_require__(4);

		var isReservedWordES6 = _esutils.keyword.isReservedWordES6; /**
		                                                             * Copyright 2014 Shape Security, Inc.
		                                                             *
		                                                             * Licensed under the Apache License, Version 2.0 (the "License")
		                                                             * you may not use this file except in compliance with the License.
		                                                             * You may obtain a copy of the License at
		                                                             *
		                                                             *     http://www.apache.org/licenses/LICENSE-2.0
		                                                             *
		                                                             * Unless required by applicable law or agreed to in writing, software
		                                                             * distributed under the License is distributed on an "AS IS" BASIS,
		                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		                                                             * See the License for the specific language governing permissions and
		                                                             * limitations under the License.
		                                                             */

		var isRestrictedWord = _esutils.keyword.isRestrictedWord;
		var isIdentifierStartES6 = _esutils.code.isIdentifierStartES6;
		var isIdentifierPartES6 = _esutils.code.isIdentifierPartES6;
		var isWhiteSpace = _esutils.code.isWhiteSpace;
		var isLineTerminator = _esutils.code.isLineTerminator;
		var isDecimalDigit = _esutils.code.isDecimalDigit;
		exports.isRestrictedWord = isRestrictedWord;
		exports.isIdentifierStart = isIdentifierStartES6;
		exports.isIdentifierPart = isIdentifierPartES6;
		exports.isWhiteSpace = isWhiteSpace;
		exports.isLineTerminator = isLineTerminator;
		exports.isDecimalDigit = isDecimalDigit;
		function isStrictModeReservedWord(id) {
		  return isReservedWordES6(id, true);
		}

		function getHexValue(rune) {
		  if ("0" <= rune && rune <= "9") {
		    return rune.charCodeAt(0) - 48;
		  }
		  if ("a" <= rune && rune <= "f") {
		    return rune.charCodeAt(0) - 87;
		  }
		  if ("A" <= rune && rune <= "F") {
		    return rune.charCodeAt(0) - 55;
		  }
		  return -1;
		}

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		/*
		  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

		  Redistribution and use in source and binary forms, with or without
		  modification, are permitted provided that the following conditions are met:

		    * Redistributions of source code must retain the above copyright
		      notice, this list of conditions and the following disclaimer.
		    * Redistributions in binary form must reproduce the above copyright
		      notice, this list of conditions and the following disclaimer in the
		      documentation and/or other materials provided with the distribution.

		  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
		  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
		  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
		  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/


		(function () {
		    'use strict';

		    exports.ast = __webpack_require__(5);
		    exports.code = __webpack_require__(6);
		    exports.keyword = __webpack_require__(7);
		}());
		/* vim: set sw=4 ts=4 et tw=80 : */


	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		/*
		  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

		  Redistribution and use in source and binary forms, with or without
		  modification, are permitted provided that the following conditions are met:

		    * Redistributions of source code must retain the above copyright
		      notice, this list of conditions and the following disclaimer.
		    * Redistributions in binary form must reproduce the above copyright
		      notice, this list of conditions and the following disclaimer in the
		      documentation and/or other materials provided with the distribution.

		  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
		  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
		  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
		  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
		  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/

		(function () {
		    'use strict';

		    function isExpression(node) {
		        if (node == null) { return false; }
		        switch (node.type) {
		            case 'ArrayExpression':
		            case 'AssignmentExpression':
		            case 'BinaryExpression':
		            case 'CallExpression':
		            case 'ConditionalExpression':
		            case 'FunctionExpression':
		            case 'Identifier':
		            case 'Literal':
		            case 'LogicalExpression':
		            case 'MemberExpression':
		            case 'NewExpression':
		            case 'ObjectExpression':
		            case 'SequenceExpression':
		            case 'ThisExpression':
		            case 'UnaryExpression':
		            case 'UpdateExpression':
		                return true;
		        }
		        return false;
		    }

		    function isIterationStatement(node) {
		        if (node == null) { return false; }
		        switch (node.type) {
		            case 'DoWhileStatement':
		            case 'ForInStatement':
		            case 'ForStatement':
		            case 'WhileStatement':
		                return true;
		        }
		        return false;
		    }

		    function isStatement(node) {
		        if (node == null) { return false; }
		        switch (node.type) {
		            case 'BlockStatement':
		            case 'BreakStatement':
		            case 'ContinueStatement':
		            case 'DebuggerStatement':
		            case 'DoWhileStatement':
		            case 'EmptyStatement':
		            case 'ExpressionStatement':
		            case 'ForInStatement':
		            case 'ForStatement':
		            case 'IfStatement':
		            case 'LabeledStatement':
		            case 'ReturnStatement':
		            case 'SwitchStatement':
		            case 'ThrowStatement':
		            case 'TryStatement':
		            case 'VariableDeclaration':
		            case 'WhileStatement':
		            case 'WithStatement':
		                return true;
		        }
		        return false;
		    }

		    function isSourceElement(node) {
		      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
		    }

		    function trailingStatement(node) {
		        switch (node.type) {
		        case 'IfStatement':
		            if (node.alternate != null) {
		                return node.alternate;
		            }
		            return node.consequent;

		        case 'LabeledStatement':
		        case 'ForStatement':
		        case 'ForInStatement':
		        case 'WhileStatement':
		        case 'WithStatement':
		            return node.body;
		        }
		        return null;
		    }

		    function isProblematicIfStatement(node) {
		        var current;

		        if (node.type !== 'IfStatement') {
		            return false;
		        }
		        if (node.alternate == null) {
		            return false;
		        }
		        current = node.consequent;
		        do {
		            if (current.type === 'IfStatement') {
		                if (current.alternate == null)  {
		                    return true;
		                }
		            }
		            current = trailingStatement(current);
		        } while (current);

		        return false;
		    }

		    module.exports = {
		        isExpression: isExpression,
		        isStatement: isStatement,
		        isIterationStatement: isIterationStatement,
		        isSourceElement: isSourceElement,
		        isProblematicIfStatement: isProblematicIfStatement,

		        trailingStatement: trailingStatement
		    };
		}());
		/* vim: set sw=4 ts=4 et tw=80 : */


	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		/*
		  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
		  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

		  Redistribution and use in source and binary forms, with or without
		  modification, are permitted provided that the following conditions are met:

		    * Redistributions of source code must retain the above copyright
		      notice, this list of conditions and the following disclaimer.
		    * Redistributions in binary form must reproduce the above copyright
		      notice, this list of conditions and the following disclaimer in the
		      documentation and/or other materials provided with the distribution.

		  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
		  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
		  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
		  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/

		(function () {
		    'use strict';

		    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

		    // See `tools/generate-identifier-regex.js`.
		    ES5Regex = {
		        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
		        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
		        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
		        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
		    };

		    ES6Regex = {
		        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
		        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
		        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
		        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
		    };

		    function isDecimalDigit(ch) {
		        return 0x30 <= ch && ch <= 0x39;  // 0..9
		    }

		    function isHexDigit(ch) {
		        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
		            0x61 <= ch && ch <= 0x66 ||     // a..f
		            0x41 <= ch && ch <= 0x46;       // A..F
		    }

		    function isOctalDigit(ch) {
		        return ch >= 0x30 && ch <= 0x37;  // 0..7
		    }

		    // 7.2 White Space

		    NON_ASCII_WHITESPACES = [
		        0x1680, 0x180E,
		        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
		        0x202F, 0x205F,
		        0x3000,
		        0xFEFF
		    ];

		    function isWhiteSpace(ch) {
		        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
		            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
		    }

		    // 7.3 Line Terminators

		    function isLineTerminator(ch) {
		        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
		    }

		    // 7.6 Identifier Names and Identifiers

		    function fromCodePoint(cp) {
		        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
		        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
		        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
		        return cu1 + cu2;
		    }

		    IDENTIFIER_START = new Array(0x80);
		    for(ch = 0; ch < 0x80; ++ch) {
		        IDENTIFIER_START[ch] =
		            ch >= 0x61 && ch <= 0x7A ||  // a..z
		            ch >= 0x41 && ch <= 0x5A ||  // A..Z
		            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
		    }

		    IDENTIFIER_PART = new Array(0x80);
		    for(ch = 0; ch < 0x80; ++ch) {
		        IDENTIFIER_PART[ch] =
		            ch >= 0x61 && ch <= 0x7A ||  // a..z
		            ch >= 0x41 && ch <= 0x5A ||  // A..Z
		            ch >= 0x30 && ch <= 0x39 ||  // 0..9
		            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
		    }

		    function isIdentifierStartES5(ch) {
		        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
		    }

		    function isIdentifierPartES5(ch) {
		        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
		    }

		    function isIdentifierStartES6(ch) {
		        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
		    }

		    function isIdentifierPartES6(ch) {
		        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
		    }

		    module.exports = {
		        isDecimalDigit: isDecimalDigit,
		        isHexDigit: isHexDigit,
		        isOctalDigit: isOctalDigit,
		        isWhiteSpace: isWhiteSpace,
		        isLineTerminator: isLineTerminator,
		        isIdentifierStartES5: isIdentifierStartES5,
		        isIdentifierPartES5: isIdentifierPartES5,
		        isIdentifierStartES6: isIdentifierStartES6,
		        isIdentifierPartES6: isIdentifierPartES6
		    };
		}());
		/* vim: set sw=4 ts=4 et tw=80 : */


	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		/*
		  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

		  Redistribution and use in source and binary forms, with or without
		  modification, are permitted provided that the following conditions are met:

		    * Redistributions of source code must retain the above copyright
		      notice, this list of conditions and the following disclaimer.
		    * Redistributions in binary form must reproduce the above copyright
		      notice, this list of conditions and the following disclaimer in the
		      documentation and/or other materials provided with the distribution.

		  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
		  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
		  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
		  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/

		(function () {
		    'use strict';

		    var code = __webpack_require__(6);

		    function isStrictModeReservedWordES6(id) {
		        switch (id) {
		        case 'implements':
		        case 'interface':
		        case 'package':
		        case 'private':
		        case 'protected':
		        case 'public':
		        case 'static':
		        case 'let':
		            return true;
		        default:
		            return false;
		        }
		    }

		    function isKeywordES5(id, strict) {
		        // yield should not be treated as keyword under non-strict mode.
		        if (!strict && id === 'yield') {
		            return false;
		        }
		        return isKeywordES6(id, strict);
		    }

		    function isKeywordES6(id, strict) {
		        if (strict && isStrictModeReservedWordES6(id)) {
		            return true;
		        }

		        switch (id.length) {
		        case 2:
		            return (id === 'if') || (id === 'in') || (id === 'do');
		        case 3:
		            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
		        case 4:
		            return (id === 'this') || (id === 'else') || (id === 'case') ||
		                (id === 'void') || (id === 'with') || (id === 'enum');
		        case 5:
		            return (id === 'while') || (id === 'break') || (id === 'catch') ||
		                (id === 'throw') || (id === 'const') || (id === 'yield') ||
		                (id === 'class') || (id === 'super');
		        case 6:
		            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
		                (id === 'switch') || (id === 'export') || (id === 'import');
		        case 7:
		            return (id === 'default') || (id === 'finally') || (id === 'extends');
		        case 8:
		            return (id === 'function') || (id === 'continue') || (id === 'debugger');
		        case 10:
		            return (id === 'instanceof');
		        default:
		            return false;
		        }
		    }

		    function isReservedWordES5(id, strict) {
		        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
		    }

		    function isReservedWordES6(id, strict) {
		        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
		    }

		    function isRestrictedWord(id) {
		        return id === 'eval' || id === 'arguments';
		    }

		    function isIdentifierNameES5(id) {
		        var i, iz, ch;

		        if (id.length === 0) { return false; }

		        ch = id.charCodeAt(0);
		        if (!code.isIdentifierStartES5(ch)) {
		            return false;
		        }

		        for (i = 1, iz = id.length; i < iz; ++i) {
		            ch = id.charCodeAt(i);
		            if (!code.isIdentifierPartES5(ch)) {
		                return false;
		            }
		        }
		        return true;
		    }

		    function decodeUtf16(lead, trail) {
		        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
		    }

		    function isIdentifierNameES6(id) {
		        var i, iz, ch, lowCh, check;

		        if (id.length === 0) { return false; }

		        check = code.isIdentifierStartES6;
		        for (i = 0, iz = id.length; i < iz; ++i) {
		            ch = id.charCodeAt(i);
		            if (0xD800 <= ch && ch <= 0xDBFF) {
		                ++i;
		                if (i >= iz) { return false; }
		                lowCh = id.charCodeAt(i);
		                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
		                    return false;
		                }
		                ch = decodeUtf16(ch, lowCh);
		            }
		            if (!check(ch)) {
		                return false;
		            }
		            check = code.isIdentifierPartES6;
		        }
		        return true;
		    }

		    function isIdentifierES5(id, strict) {
		        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
		    }

		    function isIdentifierES6(id, strict) {
		        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
		    }

		    module.exports = {
		        isKeywordES5: isKeywordES5,
		        isKeywordES6: isKeywordES6,
		        isReservedWordES5: isReservedWordES5,
		        isReservedWordES6: isReservedWordES6,
		        isRestrictedWord: isRestrictedWord,
		        isIdentifierNameES5: isIdentifierNameES5,
		        isIdentifierNameES6: isIdentifierNameES6,
		        isIdentifierES5: isIdentifierES5,
		        isIdentifierES6: isIdentifierES6
		    };
		}());
		/* vim: set sw=4 ts=4 et tw=80 : */


	/***/ },
	/* 8 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		/**
		 * Copyright 2014 Shape Security, Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License")
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */

		var ErrorMessages = exports.ErrorMessages = {
		  UNEXPECTED_TOKEN: "Unexpected token {0}",
		  UNEXPECTED_ILLEGAL_TOKEN: "Unexpected {0}",
		  UNEXPECTED_NUMBER: "Unexpected number",
		  UNEXPECTED_STRING: "Unexpected string",
		  UNEXPECTED_IDENTIFIER: "Unexpected identifier",
		  UNEXPECTED_RESERVED_WORD: "Unexpected reserved word",
		  UNEXPECTED_TEMPLATE: "Unexpected template",
		  UNEXPECTED_EOS: "Unexpected end of input",
		  UNEXPECTED_LINE_TERMINATOR: "Unexpected line terminator",
		  NEWLINE_AFTER_THROW: "Illegal newline after throw",
		  UNTERMINATED_REGEXP: "Invalid regular expression: missing /",
		  INVALID_REGEXP_FLAGS: "Invalid regular expression flags",
		  INVALID_LHS_IN_ASSIGNMENT: "Invalid left-hand side in assignment",
		  INVALID_LHS_IN_FOR_IN: "Invalid left-hand side in for-in",
		  INVALID_LHS_IN_FOR_OF: "Invalid left-hand side in for-of",
		  INVALID_UPDATE_OPERAND: "Increment/decrement target must be an identifier or member expression",
		  MULTIPLE_DEFAULTS_IN_SWITCH: "More than one default clause in switch statement",
		  NO_CATCH_OR_FINALLY: "Missing catch or finally after try",
		  ILLEGAL_RETURN: "Illegal return statement",
		  ILLEGAL_ARROW_FUNCTION_PARAMS: "Illegal arrow function parameter list",
		  INVALID_VAR_INIT_FOR_IN: "Invalid variable declaration in for-in statement",
		  INVALID_VAR_INIT_FOR_OF: "Invalid variable declaration in for-of statement",
		  ILLEGAL_PROPERTY: "Illegal property initializer"
		};

	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 *  Copyright (c) 2014-2015, Facebook, Inc.
		 *  All rights reserved.
		 *
		 *  This source code is licensed under the BSD-style license found in the
		 *  LICENSE file in the root directory of this source tree. An additional grant
		 *  of patent rights can be found in the PATENTS file in the same directory.
		 */

		(function (global, factory) {
		   true ? module.exports = factory() :
		  typeof define === 'function' && define.amd ? define(factory) :
		  (global.Immutable = factory());
		}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

		  function createClass(ctor, superClass) {
		    if (superClass) {
		      ctor.prototype = Object.create(superClass.prototype);
		    }
		    ctor.prototype.constructor = ctor;
		  }

		  function Iterable(value) {
		      return isIterable(value) ? value : Seq(value);
		    }


		  createClass(KeyedIterable, Iterable);
		    function KeyedIterable(value) {
		      return isKeyed(value) ? value : KeyedSeq(value);
		    }


		  createClass(IndexedIterable, Iterable);
		    function IndexedIterable(value) {
		      return isIndexed(value) ? value : IndexedSeq(value);
		    }


		  createClass(SetIterable, Iterable);
		    function SetIterable(value) {
		      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
		    }



		  function isIterable(maybeIterable) {
		    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
		  }

		  function isKeyed(maybeKeyed) {
		    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
		  }

		  function isIndexed(maybeIndexed) {
		    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
		  }

		  function isAssociative(maybeAssociative) {
		    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
		  }

		  function isOrdered(maybeOrdered) {
		    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
		  }

		  Iterable.isIterable = isIterable;
		  Iterable.isKeyed = isKeyed;
		  Iterable.isIndexed = isIndexed;
		  Iterable.isAssociative = isAssociative;
		  Iterable.isOrdered = isOrdered;

		  Iterable.Keyed = KeyedIterable;
		  Iterable.Indexed = IndexedIterable;
		  Iterable.Set = SetIterable;


		  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

		  // Used for setting prototype methods that IE8 chokes on.
		  var DELETE = 'delete';

		  // Constants describing the size of trie nodes.
		  var SHIFT = 5; // Resulted in best performance after ______?
		  var SIZE = 1 << SHIFT;
		  var MASK = SIZE - 1;

		  // A consistent shared value representing "not set" which equals nothing other
		  // than itself, and nothing that could be provided externally.
		  var NOT_SET = {};

		  // Boolean references, Rough equivalent of `bool &`.
		  var CHANGE_LENGTH = { value: false };
		  var DID_ALTER = { value: false };

		  function MakeRef(ref) {
		    ref.value = false;
		    return ref;
		  }

		  function SetRef(ref) {
		    ref && (ref.value = true);
		  }

		  // A function which returns a value representing an "owner" for transient writes
		  // to tries. The return value will only ever equal itself, and will not equal
		  // the return of any subsequent call of this function.
		  function OwnerID() {}

		  // http://jsperf.com/copy-array-inline
		  function arrCopy(arr, offset) {
		    offset = offset || 0;
		    var len = Math.max(0, arr.length - offset);
		    var newArr = new Array(len);
		    for (var ii = 0; ii < len; ii++) {
		      newArr[ii] = arr[ii + offset];
		    }
		    return newArr;
		  }

		  function ensureSize(iter) {
		    if (iter.size === undefined) {
		      iter.size = iter.__iterate(returnTrue);
		    }
		    return iter.size;
		  }

		  function wrapIndex(iter, index) {
		    // This implements "is array index" which the ECMAString spec defines as:
		    //
		    //     A String property name P is an array index if and only if
		    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
		    //     to 2^32−1.
		    //
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
		    if (typeof index !== 'number') {
		      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
		      if ('' + uint32Index !== index || uint32Index === 4294967295) {
		        return NaN;
		      }
		      index = uint32Index;
		    }
		    return index < 0 ? ensureSize(iter) + index : index;
		  }

		  function returnTrue() {
		    return true;
		  }

		  function wholeSlice(begin, end, size) {
		    return (begin === 0 || (size !== undefined && begin <= -size)) &&
		      (end === undefined || (size !== undefined && end >= size));
		  }

		  function resolveBegin(begin, size) {
		    return resolveIndex(begin, size, 0);
		  }

		  function resolveEnd(end, size) {
		    return resolveIndex(end, size, size);
		  }

		  function resolveIndex(index, size, defaultIndex) {
		    return index === undefined ?
		      defaultIndex :
		      index < 0 ?
		        Math.max(0, size + index) :
		        size === undefined ?
		          index :
		          Math.min(size, index);
		  }

		  /* global Symbol */

		  var ITERATE_KEYS = 0;
		  var ITERATE_VALUES = 1;
		  var ITERATE_ENTRIES = 2;

		  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		  var FAUX_ITERATOR_SYMBOL = '@@iterator';

		  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


		  function Iterator(next) {
		      this.next = next;
		    }

		    Iterator.prototype.toString = function() {
		      return '[Iterator]';
		    };


		  Iterator.KEYS = ITERATE_KEYS;
		  Iterator.VALUES = ITERATE_VALUES;
		  Iterator.ENTRIES = ITERATE_ENTRIES;

		  Iterator.prototype.inspect =
		  Iterator.prototype.toSource = function () { return this.toString(); }
		  Iterator.prototype[ITERATOR_SYMBOL] = function () {
		    return this;
		  };


		  function iteratorValue(type, k, v, iteratorResult) {
		    var value = type === 0 ? k : type === 1 ? v : [k, v];
		    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
		      value: value, done: false
		    });
		    return iteratorResult;
		  }

		  function iteratorDone() {
		    return { value: undefined, done: true };
		  }

		  function hasIterator(maybeIterable) {
		    return !!getIteratorFn(maybeIterable);
		  }

		  function isIterator(maybeIterator) {
		    return maybeIterator && typeof maybeIterator.next === 'function';
		  }

		  function getIterator(iterable) {
		    var iteratorFn = getIteratorFn(iterable);
		    return iteratorFn && iteratorFn.call(iterable);
		  }

		  function getIteratorFn(iterable) {
		    var iteratorFn = iterable && (
		      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
		      iterable[FAUX_ITERATOR_SYMBOL]
		    );
		    if (typeof iteratorFn === 'function') {
		      return iteratorFn;
		    }
		  }

		  function isArrayLike(value) {
		    return value && typeof value.length === 'number';
		  }

		  createClass(Seq, Iterable);
		    function Seq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        isIterable(value) ? value.toSeq() : seqFromValue(value);
		    }

		    Seq.of = function(/*...values*/) {
		      return Seq(arguments);
		    };

		    Seq.prototype.toSeq = function() {
		      return this;
		    };

		    Seq.prototype.toString = function() {
		      return this.__toString('Seq {', '}');
		    };

		    Seq.prototype.cacheResult = function() {
		      if (!this._cache && this.__iterateUncached) {
		        this._cache = this.entrySeq().toArray();
		        this.size = this._cache.length;
		      }
		      return this;
		    };

		    // abstract __iterateUncached(fn, reverse)

		    Seq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, true);
		    };

		    // abstract __iteratorUncached(type, reverse)

		    Seq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, true);
		    };



		  createClass(KeyedSeq, Seq);
		    function KeyedSeq(value) {
		      return value === null || value === undefined ?
		        emptySequence().toKeyedSeq() :
		        isIterable(value) ?
		          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
		          keyedSeqFromValue(value);
		    }

		    KeyedSeq.prototype.toKeyedSeq = function() {
		      return this;
		    };



		  createClass(IndexedSeq, Seq);
		    function IndexedSeq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
		    }

		    IndexedSeq.of = function(/*...values*/) {
		      return IndexedSeq(arguments);
		    };

		    IndexedSeq.prototype.toIndexedSeq = function() {
		      return this;
		    };

		    IndexedSeq.prototype.toString = function() {
		      return this.__toString('Seq [', ']');
		    };

		    IndexedSeq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, false);
		    };

		    IndexedSeq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, false);
		    };



		  createClass(SetSeq, Seq);
		    function SetSeq(value) {
		      return (
		        value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value
		      ).toSetSeq();
		    }

		    SetSeq.of = function(/*...values*/) {
		      return SetSeq(arguments);
		    };

		    SetSeq.prototype.toSetSeq = function() {
		      return this;
		    };



		  Seq.isSeq = isSeq;
		  Seq.Keyed = KeyedSeq;
		  Seq.Set = SetSeq;
		  Seq.Indexed = IndexedSeq;

		  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

		  Seq.prototype[IS_SEQ_SENTINEL] = true;



		  createClass(ArraySeq, IndexedSeq);
		    function ArraySeq(array) {
		      this._array = array;
		      this.size = array.length;
		    }

		    ArraySeq.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
		    };

		    ArraySeq.prototype.__iterate = function(fn, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    ArraySeq.prototype.__iterator = function(type, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      var ii = 0;
		      return new Iterator(function() 
		        {return ii > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
		      );
		    };



		  createClass(ObjectSeq, KeyedSeq);
		    function ObjectSeq(object) {
		      var keys = Object.keys(object);
		      this._object = object;
		      this._keys = keys;
		      this.size = keys.length;
		    }

		    ObjectSeq.prototype.get = function(key, notSetValue) {
		      if (notSetValue !== undefined && !this.has(key)) {
		        return notSetValue;
		      }
		      return this._object[key];
		    };

		    ObjectSeq.prototype.has = function(key) {
		      return this._object.hasOwnProperty(key);
		    };

		    ObjectSeq.prototype.__iterate = function(fn, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        if (fn(object[key], key, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    ObjectSeq.prototype.__iterator = function(type, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      var ii = 0;
		      return new Iterator(function()  {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, key, object[key]);
		      });
		    };

		  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


		  createClass(IterableSeq, IndexedSeq);
		    function IterableSeq(iterable) {
		      this._iterable = iterable;
		      this.size = iterable.length || iterable.size;
		    }

		    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      var iterations = 0;
		      if (isIterator(iterator)) {
		        var step;
		        while (!(step = iterator.next()).done) {
		          if (fn(step.value, iterations++, this) === false) {
		            break;
		          }
		        }
		      }
		      return iterations;
		    };

		    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      if (!isIterator(iterator)) {
		        return new Iterator(iteratorDone);
		      }
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step : iteratorValue(type, iterations++, step.value);
		      });
		    };



		  createClass(IteratorSeq, IndexedSeq);
		    function IteratorSeq(iterator) {
		      this._iterator = iterator;
		      this._iteratorCache = [];
		    }

		    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      while (iterations < cache.length) {
		        if (fn(cache[iterations], iterations++, this) === false) {
		          return iterations;
		        }
		      }
		      var step;
		      while (!(step = iterator.next()).done) {
		        var val = step.value;
		        cache[iterations] = val;
		        if (fn(val, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };

		    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      return new Iterator(function()  {
		        if (iterations >= cache.length) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          cache[iterations] = step.value;
		        }
		        return iteratorValue(type, iterations, cache[iterations++]);
		      });
		    };




		  // # pragma Helper functions

		  function isSeq(maybeSeq) {
		    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
		  }

		  var EMPTY_SEQ;

		  function emptySequence() {
		    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
		  }

		  function keyedSeqFromValue(value) {
		    var seq =
		      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
		      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
		      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
		      typeof value === 'object' ? new ObjectSeq(value) :
		      undefined;
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of [k, v] entries, '+
		        'or keyed object: ' + value
		      );
		    }
		    return seq;
		  }

		  function indexedSeqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value);
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values: ' + value
		      );
		    }
		    return seq;
		  }

		  function seqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value) ||
		      (typeof value === 'object' && new ObjectSeq(value));
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values, or keyed object: ' + value
		      );
		    }
		    return seq;
		  }

		  function maybeIndexedSeqFromValue(value) {
		    return (
		      isArrayLike(value) ? new ArraySeq(value) :
		      isIterator(value) ? new IteratorSeq(value) :
		      hasIterator(value) ? new IterableSeq(value) :
		      undefined
		    );
		  }

		  function seqIterate(seq, fn, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    }
		    return seq.__iterateUncached(fn, reverse);
		  }

		  function seqIterator(seq, type, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      var ii = 0;
		      return new Iterator(function()  {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
		      });
		    }
		    return seq.__iteratorUncached(type, reverse);
		  }

		  function fromJS(json, converter) {
		    return converter ?
		      fromJSWith(converter, json, '', {'': json}) :
		      fromJSDefault(json);
		  }

		  function fromJSWith(converter, json, key, parentJSON) {
		    if (Array.isArray(json)) {
		      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    if (isPlainObj(json)) {
		      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    return json;
		  }

		  function fromJSDefault(json) {
		    if (Array.isArray(json)) {
		      return IndexedSeq(json).map(fromJSDefault).toList();
		    }
		    if (isPlainObj(json)) {
		      return KeyedSeq(json).map(fromJSDefault).toMap();
		    }
		    return json;
		  }

		  function isPlainObj(value) {
		    return value && (value.constructor === Object || value.constructor === undefined);
		  }

		  /**
		   * An extension of the "same-value" algorithm as [described for use by ES6 Map
		   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
		   *
		   * NaN is considered the same as NaN, however -0 and 0 are considered the same
		   * value, which is different from the algorithm described by
		   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
		   *
		   * This is extended further to allow Objects to describe the values they
		   * represent, by way of `valueOf` or `equals` (and `hashCode`).
		   *
		   * Note: because of this extension, the key equality of Immutable.Map and the
		   * value equality of Immutable.Set will differ from ES6 Map and Set.
		   *
		   * ### Defining custom values
		   *
		   * The easiest way to describe the value an object represents is by implementing
		   * `valueOf`. For example, `Date` represents a value by returning a unix
		   * timestamp for `valueOf`:
		   *
		   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
		   *     var date2 = new Date(1234567890000);
		   *     date1.valueOf(); // 1234567890000
		   *     assert( date1 !== date2 );
		   *     assert( Immutable.is( date1, date2 ) );
		   *
		   * Note: overriding `valueOf` may have other implications if you use this object
		   * where JavaScript expects a primitive, such as implicit string coercion.
		   *
		   * For more complex types, especially collections, implementing `valueOf` may
		   * not be performant. An alternative is to implement `equals` and `hashCode`.
		   *
		   * `equals` takes another object, presumably of similar type, and returns true
		   * if the it is equal. Equality is symmetrical, so the same result should be
		   * returned if this and the argument are flipped.
		   *
		   *     assert( a.equals(b) === b.equals(a) );
		   *
		   * `hashCode` returns a 32bit integer number representing the object which will
		   * be used to determine how to store the value object in a Map or Set. You must
		   * provide both or neither methods, one must not exist without the other.
		   *
		   * Also, an important relationship between these methods must be upheld: if two
		   * values are equal, they *must* return the same hashCode. If the values are not
		   * equal, they might have the same hashCode; this is called a hash collision,
		   * and while undesirable for performance reasons, it is acceptable.
		   *
		   *     if (a.equals(b)) {
		   *       assert( a.hashCode() === b.hashCode() );
		   *     }
		   *
		   * All Immutable collections implement `equals` and `hashCode`.
		   *
		   */
		  function is(valueA, valueB) {
		    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		      return true;
		    }
		    if (!valueA || !valueB) {
		      return false;
		    }
		    if (typeof valueA.valueOf === 'function' &&
		        typeof valueB.valueOf === 'function') {
		      valueA = valueA.valueOf();
		      valueB = valueB.valueOf();
		      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		        return true;
		      }
		      if (!valueA || !valueB) {
		        return false;
		      }
		    }
		    if (typeof valueA.equals === 'function' &&
		        typeof valueB.equals === 'function' &&
		        valueA.equals(valueB)) {
		      return true;
		    }
		    return false;
		  }

		  function deepEqual(a, b) {
		    if (a === b) {
		      return true;
		    }

		    if (
		      !isIterable(b) ||
		      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
		      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
		      isKeyed(a) !== isKeyed(b) ||
		      isIndexed(a) !== isIndexed(b) ||
		      isOrdered(a) !== isOrdered(b)
		    ) {
		      return false;
		    }

		    if (a.size === 0 && b.size === 0) {
		      return true;
		    }

		    var notAssociative = !isAssociative(a);

		    if (isOrdered(a)) {
		      var entries = a.entries();
		      return b.every(function(v, k)  {
		        var entry = entries.next().value;
		        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
		      }) && entries.next().done;
		    }

		    var flipped = false;

		    if (a.size === undefined) {
		      if (b.size === undefined) {
		        if (typeof a.cacheResult === 'function') {
		          a.cacheResult();
		        }
		      } else {
		        flipped = true;
		        var _ = a;
		        a = b;
		        b = _;
		      }
		    }

		    var allEqual = true;
		    var bSize = b.__iterate(function(v, k)  {
		      if (notAssociative ? !a.has(v) :
		          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
		        allEqual = false;
		        return false;
		      }
		    });

		    return allEqual && a.size === bSize;
		  }

		  createClass(Repeat, IndexedSeq);

		    function Repeat(value, times) {
		      if (!(this instanceof Repeat)) {
		        return new Repeat(value, times);
		      }
		      this._value = value;
		      this.size = times === undefined ? Infinity : Math.max(0, times);
		      if (this.size === 0) {
		        if (EMPTY_REPEAT) {
		          return EMPTY_REPEAT;
		        }
		        EMPTY_REPEAT = this;
		      }
		    }

		    Repeat.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Repeat []';
		      }
		      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
		    };

		    Repeat.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._value : notSetValue;
		    };

		    Repeat.prototype.includes = function(searchValue) {
		      return is(this._value, searchValue);
		    };

		    Repeat.prototype.slice = function(begin, end) {
		      var size = this.size;
		      return wholeSlice(begin, end, size) ? this :
		        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
		    };

		    Repeat.prototype.reverse = function() {
		      return this;
		    };

		    Repeat.prototype.indexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return 0;
		      }
		      return -1;
		    };

		    Repeat.prototype.lastIndexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return this.size;
		      }
		      return -1;
		    };

		    Repeat.prototype.__iterate = function(fn, reverse) {
		      for (var ii = 0; ii < this.size; ii++) {
		        if (fn(this._value, ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      var ii = 0;
		      return new Iterator(function() 
		        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
		      );
		    };

		    Repeat.prototype.equals = function(other) {
		      return other instanceof Repeat ?
		        is(this._value, other._value) :
		        deepEqual(other);
		    };


		  var EMPTY_REPEAT;

		  function invariant(condition, error) {
		    if (!condition) throw new Error(error);
		  }

		  createClass(Range, IndexedSeq);

		    function Range(start, end, step) {
		      if (!(this instanceof Range)) {
		        return new Range(start, end, step);
		      }
		      invariant(step !== 0, 'Cannot step a Range by 0');
		      start = start || 0;
		      if (end === undefined) {
		        end = Infinity;
		      }
		      step = step === undefined ? 1 : Math.abs(step);
		      if (end < start) {
		        step = -step;
		      }
		      this._start = start;
		      this._end = end;
		      this._step = step;
		      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
		      if (this.size === 0) {
		        if (EMPTY_RANGE) {
		          return EMPTY_RANGE;
		        }
		        EMPTY_RANGE = this;
		      }
		    }

		    Range.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Range []';
		      }
		      return 'Range [ ' +
		        this._start + '...' + this._end +
		        (this._step !== 1 ? ' by ' + this._step : '') +
		      ' ]';
		    };

		    Range.prototype.get = function(index, notSetValue) {
		      return this.has(index) ?
		        this._start + wrapIndex(this, index) * this._step :
		        notSetValue;
		    };

		    Range.prototype.includes = function(searchValue) {
		      var possibleIndex = (searchValue - this._start) / this._step;
		      return possibleIndex >= 0 &&
		        possibleIndex < this.size &&
		        possibleIndex === Math.floor(possibleIndex);
		    };

		    Range.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      begin = resolveBegin(begin, this.size);
		      end = resolveEnd(end, this.size);
		      if (end <= begin) {
		        return new Range(0, 0);
		      }
		      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
		    };

		    Range.prototype.indexOf = function(searchValue) {
		      var offsetValue = searchValue - this._start;
		      if (offsetValue % this._step === 0) {
		        var index = offsetValue / this._step;
		        if (index >= 0 && index < this.size) {
		          return index
		        }
		      }
		      return -1;
		    };

		    Range.prototype.lastIndexOf = function(searchValue) {
		      return this.indexOf(searchValue);
		    };

		    Range.prototype.__iterate = function(fn, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(value, ii, this) === false) {
		          return ii + 1;
		        }
		        value += reverse ? -step : step;
		      }
		      return ii;
		    };

		    Range.prototype.__iterator = function(type, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      var ii = 0;
		      return new Iterator(function()  {
		        var v = value;
		        value += reverse ? -step : step;
		        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
		      });
		    };

		    Range.prototype.equals = function(other) {
		      return other instanceof Range ?
		        this._start === other._start &&
		        this._end === other._end &&
		        this._step === other._step :
		        deepEqual(this, other);
		    };


		  var EMPTY_RANGE;

		  createClass(Collection, Iterable);
		    function Collection() {
		      throw TypeError('Abstract');
		    }


		  createClass(KeyedCollection, Collection);function KeyedCollection() {}

		  createClass(IndexedCollection, Collection);function IndexedCollection() {}

		  createClass(SetCollection, Collection);function SetCollection() {}


		  Collection.Keyed = KeyedCollection;
		  Collection.Indexed = IndexedCollection;
		  Collection.Set = SetCollection;

		  var imul =
		    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
		    Math.imul :
		    function imul(a, b) {
		      a = a | 0; // int
		      b = b | 0; // int
		      var c = a & 0xffff;
		      var d = b & 0xffff;
		      // Shift by 0 fixes the sign on the high part.
		      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
		    };

		  // v8 has an optimization for storing 31-bit signed numbers.
		  // Values which have either 00 or 11 as the high order bits qualify.
		  // This function drops the highest order bit in a signed number, maintaining
		  // the sign bit.
		  function smi(i32) {
		    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
		  }

		  function hash(o) {
		    if (o === false || o === null || o === undefined) {
		      return 0;
		    }
		    if (typeof o.valueOf === 'function') {
		      o = o.valueOf();
		      if (o === false || o === null || o === undefined) {
		        return 0;
		      }
		    }
		    if (o === true) {
		      return 1;
		    }
		    var type = typeof o;
		    if (type === 'number') {
		      if (o !== o || o === Infinity) {
		        return 0;
		      }
		      var h = o | 0;
		      if (h !== o) {
		        h ^= o * 0xFFFFFFFF;
		      }
		      while (o > 0xFFFFFFFF) {
		        o /= 0xFFFFFFFF;
		        h ^= o;
		      }
		      return smi(h);
		    }
		    if (type === 'string') {
		      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
		    }
		    if (typeof o.hashCode === 'function') {
		      return o.hashCode();
		    }
		    if (type === 'object') {
		      return hashJSObj(o);
		    }
		    if (typeof o.toString === 'function') {
		      return hashString(o.toString());
		    }
		    throw new Error('Value type ' + type + ' cannot be hashed.');
		  }

		  function cachedHashString(string) {
		    var hash = stringHashCache[string];
		    if (hash === undefined) {
		      hash = hashString(string);
		      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
		        STRING_HASH_CACHE_SIZE = 0;
		        stringHashCache = {};
		      }
		      STRING_HASH_CACHE_SIZE++;
		      stringHashCache[string] = hash;
		    }
		    return hash;
		  }

		  // http://jsperf.com/hashing-strings
		  function hashString(string) {
		    // This is the hash from JVM
		    // The hash code for a string is computed as
		    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
		    // where s[i] is the ith character of the string and n is the length of
		    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
		    // (exclusive) by dropping high bits.
		    var hash = 0;
		    for (var ii = 0; ii < string.length; ii++) {
		      hash = 31 * hash + string.charCodeAt(ii) | 0;
		    }
		    return smi(hash);
		  }

		  function hashJSObj(obj) {
		    var hash;
		    if (usingWeakMap) {
		      hash = weakMap.get(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }

		    hash = obj[UID_HASH_KEY];
		    if (hash !== undefined) {
		      return hash;
		    }

		    if (!canDefineProperty) {
		      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
		      if (hash !== undefined) {
		        return hash;
		      }

		      hash = getIENodeHash(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }

		    hash = ++objHashUID;
		    if (objHashUID & 0x40000000) {
		      objHashUID = 0;
		    }

		    if (usingWeakMap) {
		      weakMap.set(obj, hash);
		    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
		      throw new Error('Non-extensible objects are not allowed as keys.');
		    } else if (canDefineProperty) {
		      Object.defineProperty(obj, UID_HASH_KEY, {
		        'enumerable': false,
		        'configurable': false,
		        'writable': false,
		        'value': hash
		      });
		    } else if (obj.propertyIsEnumerable !== undefined &&
		               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
		      // Since we can't define a non-enumerable property on the object
		      // we'll hijack one of the less-used non-enumerable properties to
		      // save our hash on it. Since this is a function it will not show up in
		      // `JSON.stringify` which is what we want.
		      obj.propertyIsEnumerable = function() {
		        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
		      };
		      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
		    } else if (obj.nodeType !== undefined) {
		      // At this point we couldn't get the IE `uniqueID` to use as a hash
		      // and we couldn't use a non-enumerable property to exploit the
		      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
		      // itself.
		      obj[UID_HASH_KEY] = hash;
		    } else {
		      throw new Error('Unable to set a non-enumerable property on object.');
		    }

		    return hash;
		  }

		  // Get references to ES5 object methods.
		  var isExtensible = Object.isExtensible;

		  // True if Object.defineProperty works as expected. IE8 fails this test.
		  var canDefineProperty = (function() {
		    try {
		      Object.defineProperty({}, '@', {});
		      return true;
		    } catch (e) {
		      return false;
		    }
		  }());

		  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
		  // and avoid memory leaks from the IE cloneNode bug.
		  function getIENodeHash(node) {
		    if (node && node.nodeType > 0) {
		      switch (node.nodeType) {
		        case 1: // Element
		          return node.uniqueID;
		        case 9: // Document
		          return node.documentElement && node.documentElement.uniqueID;
		      }
		    }
		  }

		  // If possible, use a WeakMap.
		  var usingWeakMap = typeof WeakMap === 'function';
		  var weakMap;
		  if (usingWeakMap) {
		    weakMap = new WeakMap();
		  }

		  var objHashUID = 0;

		  var UID_HASH_KEY = '__immutablehash__';
		  if (typeof Symbol === 'function') {
		    UID_HASH_KEY = Symbol(UID_HASH_KEY);
		  }

		  var STRING_HASH_CACHE_MIN_STRLEN = 16;
		  var STRING_HASH_CACHE_MAX_SIZE = 255;
		  var STRING_HASH_CACHE_SIZE = 0;
		  var stringHashCache = {};

		  function assertNotInfinite(size) {
		    invariant(
		      size !== Infinity,
		      'Cannot perform this action with an infinite size.'
		    );
		  }

		  createClass(Map, KeyedCollection);

		    // @pragma Construction

		    function Map(value) {
		      return value === null || value === undefined ? emptyMap() :
		        isMap(value) && !isOrdered(value) ? value :
		        emptyMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }

		    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
		      return emptyMap().withMutations(function(map ) {
		        for (var i = 0; i < keyValues.length; i += 2) {
		          if (i + 1 >= keyValues.length) {
		            throw new Error('Missing value for key: ' + keyValues[i]);
		          }
		          map.set(keyValues[i], keyValues[i + 1]);
		        }
		      });
		    };

		    Map.prototype.toString = function() {
		      return this.__toString('Map {', '}');
		    };

		    // @pragma Access

		    Map.prototype.get = function(k, notSetValue) {
		      return this._root ?
		        this._root.get(0, undefined, k, notSetValue) :
		        notSetValue;
		    };

		    // @pragma Modification

		    Map.prototype.set = function(k, v) {
		      return updateMap(this, k, v);
		    };

		    Map.prototype.setIn = function(keyPath, v) {
		      return this.updateIn(keyPath, NOT_SET, function()  {return v});
		    };

		    Map.prototype.remove = function(k) {
		      return updateMap(this, k, NOT_SET);
		    };

		    Map.prototype.deleteIn = function(keyPath) {
		      return this.updateIn(keyPath, function()  {return NOT_SET});
		    };

		    Map.prototype.update = function(k, notSetValue, updater) {
		      return arguments.length === 1 ?
		        k(this) :
		        this.updateIn([k], notSetValue, updater);
		    };

		    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
		      if (!updater) {
		        updater = notSetValue;
		        notSetValue = undefined;
		      }
		      var updatedValue = updateInDeepMap(
		        this,
		        forceIterator(keyPath),
		        notSetValue,
		        updater
		      );
		      return updatedValue === NOT_SET ? undefined : updatedValue;
		    };

		    Map.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._root = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyMap();
		    };

		    // @pragma Composition

		    Map.prototype.merge = function(/*...iters*/) {
		      return mergeIntoMapWith(this, undefined, arguments);
		    };

		    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, merger, iters);
		    };

		    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.merge === 'function' ?
		          m.merge.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };

		    Map.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoMapWith(this, deepMerger, arguments);
		    };

		    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
		    };

		    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.mergeDeep === 'function' ?
		          m.mergeDeep.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };

		    Map.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator));
		    };

		    Map.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator, mapper));
		    };

		    // @pragma Mutability

		    Map.prototype.withMutations = function(fn) {
		      var mutable = this.asMutable();
		      fn(mutable);
		      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
		    };

		    Map.prototype.asMutable = function() {
		      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
		    };

		    Map.prototype.asImmutable = function() {
		      return this.__ensureOwner();
		    };

		    Map.prototype.wasAltered = function() {
		      return this.__altered;
		    };

		    Map.prototype.__iterator = function(type, reverse) {
		      return new MapIterator(this, type, reverse);
		    };

		    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      this._root && this._root.iterate(function(entry ) {
		        iterations++;
		        return fn(entry[1], entry[0], this$0);
		      }, reverse);
		      return iterations;
		    };

		    Map.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeMap(this.size, this._root, ownerID, this.__hash);
		    };


		  function isMap(maybeMap) {
		    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
		  }

		  Map.isMap = isMap;

		  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

		  var MapPrototype = Map.prototype;
		  MapPrototype[IS_MAP_SENTINEL] = true;
		  MapPrototype[DELETE] = MapPrototype.remove;
		  MapPrototype.removeIn = MapPrototype.deleteIn;


		  // #pragma Trie Nodes



		    function ArrayMapNode(ownerID, entries) {
		      this.ownerID = ownerID;
		      this.entries = entries;
		    }

		    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };

		    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;

		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;

		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }

		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);

		      if (removed && entries.length === 1) {
		        return; // undefined
		      }

		      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
		        return createNodes(ownerID, entries, key, value);
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);

		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }

		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }

		      return new ArrayMapNode(ownerID, newEntries);
		    };




		    function BitmapIndexedNode(ownerID, bitmap, nodes) {
		      this.ownerID = ownerID;
		      this.bitmap = bitmap;
		      this.nodes = nodes;
		    }

		    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
		      var bitmap = this.bitmap;
		      return (bitmap & bit) === 0 ? notSetValue :
		        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
		    };

		    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var bit = 1 << keyHashFrag;
		      var bitmap = this.bitmap;
		      var exists = (bitmap & bit) !== 0;

		      if (!exists && value === NOT_SET) {
		        return this;
		      }

		      var idx = popCount(bitmap & (bit - 1));
		      var nodes = this.nodes;
		      var node = exists ? nodes[idx] : undefined;
		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

		      if (newNode === node) {
		        return this;
		      }

		      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
		        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
		      }

		      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
		        return nodes[idx ^ 1];
		      }

		      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
		        return newNode;
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
		      var newNodes = exists ? newNode ?
		        setIn(nodes, idx, newNode, isEditable) :
		        spliceOut(nodes, idx, isEditable) :
		        spliceIn(nodes, idx, newNode, isEditable);

		      if (isEditable) {
		        this.bitmap = newBitmap;
		        this.nodes = newNodes;
		        return this;
		      }

		      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
		    };




		    function HashArrayMapNode(ownerID, count, nodes) {
		      this.ownerID = ownerID;
		      this.count = count;
		      this.nodes = nodes;
		    }

		    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var node = this.nodes[idx];
		      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
		    };

		    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var removed = value === NOT_SET;
		      var nodes = this.nodes;
		      var node = nodes[idx];

		      if (removed && !node) {
		        return this;
		      }

		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
		      if (newNode === node) {
		        return this;
		      }

		      var newCount = this.count;
		      if (!node) {
		        newCount++;
		      } else if (!newNode) {
		        newCount--;
		        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
		          return packNodes(ownerID, nodes, newCount, idx);
		        }
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newNodes = setIn(nodes, idx, newNode, isEditable);

		      if (isEditable) {
		        this.count = newCount;
		        this.nodes = newNodes;
		        return this;
		      }

		      return new HashArrayMapNode(ownerID, newCount, newNodes);
		    };




		    function HashCollisionNode(ownerID, keyHash, entries) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entries = entries;
		    }

		    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };

		    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }

		      var removed = value === NOT_SET;

		      if (keyHash !== this.keyHash) {
		        if (removed) {
		          return this;
		        }
		        SetRef(didAlter);
		        SetRef(didChangeSize);
		        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
		      }

		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;

		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }

		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);

		      if (removed && len === 2) {
		        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);

		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }

		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }

		      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
		    };




		    function ValueNode(ownerID, keyHash, entry) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entry = entry;
		    }

		    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
		    };

		    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;
		      var keyMatch = is(key, this.entry[0]);
		      if (keyMatch ? value === this.entry[1] : removed) {
		        return this;
		      }

		      SetRef(didAlter);

		      if (removed) {
		        SetRef(didChangeSize);
		        return; // undefined
		      }

		      if (keyMatch) {
		        if (ownerID && ownerID === this.ownerID) {
		          this.entry[1] = value;
		          return this;
		        }
		        return new ValueNode(ownerID, this.keyHash, [key, value]);
		      }

		      SetRef(didChangeSize);
		      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
		    };



		  // #pragma Iterators

		  ArrayMapNode.prototype.iterate =
		  HashCollisionNode.prototype.iterate = function (fn, reverse) {
		    var entries = this.entries;
		    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
		      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
		        return false;
		      }
		    }
		  }

		  BitmapIndexedNode.prototype.iterate =
		  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
		    var nodes = this.nodes;
		    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
		      var node = nodes[reverse ? maxIndex - ii : ii];
		      if (node && node.iterate(fn, reverse) === false) {
		        return false;
		      }
		    }
		  }

		  ValueNode.prototype.iterate = function (fn, reverse) {
		    return fn(this.entry);
		  }

		  createClass(MapIterator, Iterator);

		    function MapIterator(map, type, reverse) {
		      this._type = type;
		      this._reverse = reverse;
		      this._stack = map._root && mapIteratorFrame(map._root);
		    }

		    MapIterator.prototype.next = function() {
		      var type = this._type;
		      var stack = this._stack;
		      while (stack) {
		        var node = stack.node;
		        var index = stack.index++;
		        var maxIndex;
		        if (node.entry) {
		          if (index === 0) {
		            return mapIteratorValue(type, node.entry);
		          }
		        } else if (node.entries) {
		          maxIndex = node.entries.length - 1;
		          if (index <= maxIndex) {
		            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
		          }
		        } else {
		          maxIndex = node.nodes.length - 1;
		          if (index <= maxIndex) {
		            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
		            if (subNode) {
		              if (subNode.entry) {
		                return mapIteratorValue(type, subNode.entry);
		              }
		              stack = this._stack = mapIteratorFrame(subNode, stack);
		            }
		            continue;
		          }
		        }
		        stack = this._stack = this._stack.__prev;
		      }
		      return iteratorDone();
		    };


		  function mapIteratorValue(type, entry) {
		    return iteratorValue(type, entry[0], entry[1]);
		  }

		  function mapIteratorFrame(node, prev) {
		    return {
		      node: node,
		      index: 0,
		      __prev: prev
		    };
		  }

		  function makeMap(size, root, ownerID, hash) {
		    var map = Object.create(MapPrototype);
		    map.size = size;
		    map._root = root;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }

		  var EMPTY_MAP;
		  function emptyMap() {
		    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
		  }

		  function updateMap(map, k, v) {
		    var newRoot;
		    var newSize;
		    if (!map._root) {
		      if (v === NOT_SET) {
		        return map;
		      }
		      newSize = 1;
		      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
		    } else {
		      var didChangeSize = MakeRef(CHANGE_LENGTH);
		      var didAlter = MakeRef(DID_ALTER);
		      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
		      if (!didAlter.value) {
		        return map;
		      }
		      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
		    }
		    if (map.__ownerID) {
		      map.size = newSize;
		      map._root = newRoot;
		      map.__hash = undefined;
		      map.__altered = true;
		      return map;
		    }
		    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
		  }

		  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		    if (!node) {
		      if (value === NOT_SET) {
		        return node;
		      }
		      SetRef(didAlter);
		      SetRef(didChangeSize);
		      return new ValueNode(ownerID, keyHash, [key, value]);
		    }
		    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
		  }

		  function isLeafNode(node) {
		    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
		  }

		  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
		    if (node.keyHash === keyHash) {
		      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
		    }

		    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
		    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

		    var newNode;
		    var nodes = idx1 === idx2 ?
		      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
		      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

		    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
		  }

		  function createNodes(ownerID, entries, key, value) {
		    if (!ownerID) {
		      ownerID = new OwnerID();
		    }
		    var node = new ValueNode(ownerID, hash(key), [key, value]);
		    for (var ii = 0; ii < entries.length; ii++) {
		      var entry = entries[ii];
		      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
		    }
		    return node;
		  }

		  function packNodes(ownerID, nodes, count, excluding) {
		    var bitmap = 0;
		    var packedII = 0;
		    var packedNodes = new Array(count);
		    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
		      var node = nodes[ii];
		      if (node !== undefined && ii !== excluding) {
		        bitmap |= bit;
		        packedNodes[packedII++] = node;
		      }
		    }
		    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
		  }

		  function expandNodes(ownerID, nodes, bitmap, including, node) {
		    var count = 0;
		    var expandedNodes = new Array(SIZE);
		    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
		      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
		    }
		    expandedNodes[including] = node;
		    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
		  }

		  function mergeIntoMapWith(map, merger, iterables) {
		    var iters = [];
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = KeyedIterable(value);
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    return mergeIntoCollectionWith(map, merger, iters);
		  }

		  function deepMerger(existing, value, key) {
		    return existing && existing.mergeDeep && isIterable(value) ?
		      existing.mergeDeep(value) :
		      is(existing, value) ? existing : value;
		  }

		  function deepMergerWith(merger) {
		    return function(existing, value, key)  {
		      if (existing && existing.mergeDeepWith && isIterable(value)) {
		        return existing.mergeDeepWith(merger, value);
		      }
		      var nextValue = merger(existing, value, key);
		      return is(existing, nextValue) ? existing : nextValue;
		    };
		  }

		  function mergeIntoCollectionWith(collection, merger, iters) {
		    iters = iters.filter(function(x ) {return x.size !== 0});
		    if (iters.length === 0) {
		      return collection;
		    }
		    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
		      return collection.constructor(iters[0]);
		    }
		    return collection.withMutations(function(collection ) {
		      var mergeIntoMap = merger ?
		        function(value, key)  {
		          collection.update(key, NOT_SET, function(existing )
		            {return existing === NOT_SET ? value : merger(existing, value, key)}
		          );
		        } :
		        function(value, key)  {
		          collection.set(key, value);
		        }
		      for (var ii = 0; ii < iters.length; ii++) {
		        iters[ii].forEach(mergeIntoMap);
		      }
		    });
		  }

		  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
		    var isNotSet = existing === NOT_SET;
		    var step = keyPathIter.next();
		    if (step.done) {
		      var existingValue = isNotSet ? notSetValue : existing;
		      var newValue = updater(existingValue);
		      return newValue === existingValue ? existing : newValue;
		    }
		    invariant(
		      isNotSet || (existing && existing.set),
		      'invalid keyPath'
		    );
		    var key = step.value;
		    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
		    var nextUpdated = updateInDeepMap(
		      nextExisting,
		      keyPathIter,
		      notSetValue,
		      updater
		    );
		    return nextUpdated === nextExisting ? existing :
		      nextUpdated === NOT_SET ? existing.remove(key) :
		      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
		  }

		  function popCount(x) {
		    x = x - ((x >> 1) & 0x55555555);
		    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		    x = (x + (x >> 4)) & 0x0f0f0f0f;
		    x = x + (x >> 8);
		    x = x + (x >> 16);
		    return x & 0x7f;
		  }

		  function setIn(array, idx, val, canEdit) {
		    var newArray = canEdit ? array : arrCopy(array);
		    newArray[idx] = val;
		    return newArray;
		  }

		  function spliceIn(array, idx, val, canEdit) {
		    var newLen = array.length + 1;
		    if (canEdit && idx + 1 === newLen) {
		      array[idx] = val;
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        newArray[ii] = val;
		        after = -1;
		      } else {
		        newArray[ii] = array[ii + after];
		      }
		    }
		    return newArray;
		  }

		  function spliceOut(array, idx, canEdit) {
		    var newLen = array.length - 1;
		    if (canEdit && idx === newLen) {
		      array.pop();
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        after = 1;
		      }
		      newArray[ii] = array[ii + after];
		    }
		    return newArray;
		  }

		  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
		  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
		  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

		  createClass(List, IndexedCollection);

		    // @pragma Construction

		    function List(value) {
		      var empty = emptyList();
		      if (value === null || value === undefined) {
		        return empty;
		      }
		      if (isList(value)) {
		        return value;
		      }
		      var iter = IndexedIterable(value);
		      var size = iter.size;
		      if (size === 0) {
		        return empty;
		      }
		      assertNotInfinite(size);
		      if (size > 0 && size < SIZE) {
		        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
		      }
		      return empty.withMutations(function(list ) {
		        list.setSize(size);
		        iter.forEach(function(v, i)  {return list.set(i, v)});
		      });
		    }

		    List.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    List.prototype.toString = function() {
		      return this.__toString('List [', ']');
		    };

		    // @pragma Access

		    List.prototype.get = function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      if (index >= 0 && index < this.size) {
		        index += this._origin;
		        var node = listNodeFor(this, index);
		        return node && node.array[index & MASK];
		      }
		      return notSetValue;
		    };

		    // @pragma Modification

		    List.prototype.set = function(index, value) {
		      return updateList(this, index, value);
		    };

		    List.prototype.remove = function(index) {
		      return !this.has(index) ? this :
		        index === 0 ? this.shift() :
		        index === this.size - 1 ? this.pop() :
		        this.splice(index, 1);
		    };

		    List.prototype.insert = function(index, value) {
		      return this.splice(index, 0, value);
		    };

		    List.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = this._origin = this._capacity = 0;
		        this._level = SHIFT;
		        this._root = this._tail = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyList();
		    };

		    List.prototype.push = function(/*...values*/) {
		      var values = arguments;
		      var oldSize = this.size;
		      return this.withMutations(function(list ) {
		        setListBounds(list, 0, oldSize + values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(oldSize + ii, values[ii]);
		        }
		      });
		    };

		    List.prototype.pop = function() {
		      return setListBounds(this, 0, -1);
		    };

		    List.prototype.unshift = function(/*...values*/) {
		      var values = arguments;
		      return this.withMutations(function(list ) {
		        setListBounds(list, -values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(ii, values[ii]);
		        }
		      });
		    };

		    List.prototype.shift = function() {
		      return setListBounds(this, 1);
		    };

		    // @pragma Composition

		    List.prototype.merge = function(/*...iters*/) {
		      return mergeIntoListWith(this, undefined, arguments);
		    };

		    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, merger, iters);
		    };

		    List.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoListWith(this, deepMerger, arguments);
		    };

		    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, deepMergerWith(merger), iters);
		    };

		    List.prototype.setSize = function(size) {
		      return setListBounds(this, 0, size);
		    };

		    // @pragma Iteration

		    List.prototype.slice = function(begin, end) {
		      var size = this.size;
		      if (wholeSlice(begin, end, size)) {
		        return this;
		      }
		      return setListBounds(
		        this,
		        resolveBegin(begin, size),
		        resolveEnd(end, size)
		      );
		    };

		    List.prototype.__iterator = function(type, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      return new Iterator(function()  {
		        var value = values();
		        return value === DONE ?
		          iteratorDone() :
		          iteratorValue(type, index++, value);
		      });
		    };

		    List.prototype.__iterate = function(fn, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      var value;
		      while ((value = values()) !== DONE) {
		        if (fn(value, index++, this) === false) {
		          break;
		        }
		      }
		      return index;
		    };

		    List.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        return this;
		      }
		      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
		    };


		  function isList(maybeList) {
		    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
		  }

		  List.isList = isList;

		  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

		  var ListPrototype = List.prototype;
		  ListPrototype[IS_LIST_SENTINEL] = true;
		  ListPrototype[DELETE] = ListPrototype.remove;
		  ListPrototype.setIn = MapPrototype.setIn;
		  ListPrototype.deleteIn =
		  ListPrototype.removeIn = MapPrototype.removeIn;
		  ListPrototype.update = MapPrototype.update;
		  ListPrototype.updateIn = MapPrototype.updateIn;
		  ListPrototype.mergeIn = MapPrototype.mergeIn;
		  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  ListPrototype.withMutations = MapPrototype.withMutations;
		  ListPrototype.asMutable = MapPrototype.asMutable;
		  ListPrototype.asImmutable = MapPrototype.asImmutable;
		  ListPrototype.wasAltered = MapPrototype.wasAltered;



		    function VNode(array, ownerID) {
		      this.array = array;
		      this.ownerID = ownerID;
		    }

		    // TODO: seems like these methods are very similar

		    VNode.prototype.removeBefore = function(ownerID, level, index) {
		      if (index === level ? 1 << level : 0 || this.array.length === 0) {
		        return this;
		      }
		      var originIndex = (index >>> level) & MASK;
		      if (originIndex >= this.array.length) {
		        return new VNode([], ownerID);
		      }
		      var removingFirst = originIndex === 0;
		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[originIndex];
		        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && removingFirst) {
		          return this;
		        }
		      }
		      if (removingFirst && !newChild) {
		        return this;
		      }
		      var editable = editableVNode(this, ownerID);
		      if (!removingFirst) {
		        for (var ii = 0; ii < originIndex; ii++) {
		          editable.array[ii] = undefined;
		        }
		      }
		      if (newChild) {
		        editable.array[originIndex] = newChild;
		      }
		      return editable;
		    };

		    VNode.prototype.removeAfter = function(ownerID, level, index) {
		      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
		        return this;
		      }
		      var sizeIndex = ((index - 1) >>> level) & MASK;
		      if (sizeIndex >= this.array.length) {
		        return this;
		      }

		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[sizeIndex];
		        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
		          return this;
		        }
		      }

		      var editable = editableVNode(this, ownerID);
		      editable.array.splice(sizeIndex + 1);
		      if (newChild) {
		        editable.array[sizeIndex] = newChild;
		      }
		      return editable;
		    };



		  var DONE = {};

		  function iterateList(list, reverse) {
		    var left = list._origin;
		    var right = list._capacity;
		    var tailPos = getTailOffset(right);
		    var tail = list._tail;

		    return iterateNodeOrLeaf(list._root, list._level, 0);

		    function iterateNodeOrLeaf(node, level, offset) {
		      return level === 0 ?
		        iterateLeaf(node, offset) :
		        iterateNode(node, level, offset);
		    }

		    function iterateLeaf(node, offset) {
		      var array = offset === tailPos ? tail && tail.array : node && node.array;
		      var from = offset > left ? 0 : left - offset;
		      var to = right - offset;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        if (from === to) {
		          return DONE;
		        }
		        var idx = reverse ? --to : from++;
		        return array && array[idx];
		      };
		    }

		    function iterateNode(node, level, offset) {
		      var values;
		      var array = node && node.array;
		      var from = offset > left ? 0 : (left - offset) >> level;
		      var to = ((right - offset) >> level) + 1;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        do {
		          if (values) {
		            var value = values();
		            if (value !== DONE) {
		              return value;
		            }
		            values = null;
		          }
		          if (from === to) {
		            return DONE;
		          }
		          var idx = reverse ? --to : from++;
		          values = iterateNodeOrLeaf(
		            array && array[idx], level - SHIFT, offset + (idx << level)
		          );
		        } while (true);
		      };
		    }
		  }

		  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
		    var list = Object.create(ListPrototype);
		    list.size = capacity - origin;
		    list._origin = origin;
		    list._capacity = capacity;
		    list._level = level;
		    list._root = root;
		    list._tail = tail;
		    list.__ownerID = ownerID;
		    list.__hash = hash;
		    list.__altered = false;
		    return list;
		  }

		  var EMPTY_LIST;
		  function emptyList() {
		    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
		  }

		  function updateList(list, index, value) {
		    index = wrapIndex(list, index);

		    if (index !== index) {
		      return list;
		    }

		    if (index >= list.size || index < 0) {
		      return list.withMutations(function(list ) {
		        index < 0 ?
		          setListBounds(list, index).set(0, value) :
		          setListBounds(list, 0, index + 1).set(index, value)
		      });
		    }

		    index += list._origin;

		    var newTail = list._tail;
		    var newRoot = list._root;
		    var didAlter = MakeRef(DID_ALTER);
		    if (index >= getTailOffset(list._capacity)) {
		      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
		    } else {
		      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
		    }

		    if (!didAlter.value) {
		      return list;
		    }

		    if (list.__ownerID) {
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
		  }

		  function updateVNode(node, ownerID, level, index, value, didAlter) {
		    var idx = (index >>> level) & MASK;
		    var nodeHas = node && idx < node.array.length;
		    if (!nodeHas && value === undefined) {
		      return node;
		    }

		    var newNode;

		    if (level > 0) {
		      var lowerNode = node && node.array[idx];
		      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
		      if (newLowerNode === lowerNode) {
		        return node;
		      }
		      newNode = editableVNode(node, ownerID);
		      newNode.array[idx] = newLowerNode;
		      return newNode;
		    }

		    if (nodeHas && node.array[idx] === value) {
		      return node;
		    }

		    SetRef(didAlter);

		    newNode = editableVNode(node, ownerID);
		    if (value === undefined && idx === newNode.array.length - 1) {
		      newNode.array.pop();
		    } else {
		      newNode.array[idx] = value;
		    }
		    return newNode;
		  }

		  function editableVNode(node, ownerID) {
		    if (ownerID && node && ownerID === node.ownerID) {
		      return node;
		    }
		    return new VNode(node ? node.array.slice() : [], ownerID);
		  }

		  function listNodeFor(list, rawIndex) {
		    if (rawIndex >= getTailOffset(list._capacity)) {
		      return list._tail;
		    }
		    if (rawIndex < 1 << (list._level + SHIFT)) {
		      var node = list._root;
		      var level = list._level;
		      while (node && level > 0) {
		        node = node.array[(rawIndex >>> level) & MASK];
		        level -= SHIFT;
		      }
		      return node;
		    }
		  }

		  function setListBounds(list, begin, end) {
		    // Sanitize begin & end using this shorthand for ToInt32(argument)
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
		    if (begin !== undefined) {
		      begin = begin | 0;
		    }
		    if (end !== undefined) {
		      end = end | 0;
		    }
		    var owner = list.__ownerID || new OwnerID();
		    var oldOrigin = list._origin;
		    var oldCapacity = list._capacity;
		    var newOrigin = oldOrigin + begin;
		    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
		    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
		      return list;
		    }

		    // If it's going to end after it starts, it's empty.
		    if (newOrigin >= newCapacity) {
		      return list.clear();
		    }

		    var newLevel = list._level;
		    var newRoot = list._root;

		    // New origin might need creating a higher root.
		    var offsetShift = 0;
		    while (newOrigin + offsetShift < 0) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
		      newLevel += SHIFT;
		      offsetShift += 1 << newLevel;
		    }
		    if (offsetShift) {
		      newOrigin += offsetShift;
		      oldOrigin += offsetShift;
		      newCapacity += offsetShift;
		      oldCapacity += offsetShift;
		    }

		    var oldTailOffset = getTailOffset(oldCapacity);
		    var newTailOffset = getTailOffset(newCapacity);

		    // New size might need creating a higher root.
		    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
		      newLevel += SHIFT;
		    }

		    // Locate or create the new tail.
		    var oldTail = list._tail;
		    var newTail = newTailOffset < oldTailOffset ?
		      listNodeFor(list, newCapacity - 1) :
		      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

		    // Merge Tail into tree.
		    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
		      newRoot = editableVNode(newRoot, owner);
		      var node = newRoot;
		      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
		        var idx = (oldTailOffset >>> level) & MASK;
		        node = node.array[idx] = editableVNode(node.array[idx], owner);
		      }
		      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
		    }

		    // If the size has been reduced, there's a chance the tail needs to be trimmed.
		    if (newCapacity < oldCapacity) {
		      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
		    }

		    // If the new origin is within the tail, then we do not need a root.
		    if (newOrigin >= newTailOffset) {
		      newOrigin -= newTailOffset;
		      newCapacity -= newTailOffset;
		      newLevel = SHIFT;
		      newRoot = null;
		      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

		    // Otherwise, if the root has been trimmed, garbage collect.
		    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
		      offsetShift = 0;

		      // Identify the new top root node of the subtree of the old root.
		      while (newRoot) {
		        var beginIndex = (newOrigin >>> newLevel) & MASK;
		        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
		          break;
		        }
		        if (beginIndex) {
		          offsetShift += (1 << newLevel) * beginIndex;
		        }
		        newLevel -= SHIFT;
		        newRoot = newRoot.array[beginIndex];
		      }

		      // Trim the new sides of the new root.
		      if (newRoot && newOrigin > oldOrigin) {
		        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
		      }
		      if (newRoot && newTailOffset < oldTailOffset) {
		        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
		      }
		      if (offsetShift) {
		        newOrigin -= offsetShift;
		        newCapacity -= offsetShift;
		      }
		    }

		    if (list.__ownerID) {
		      list.size = newCapacity - newOrigin;
		      list._origin = newOrigin;
		      list._capacity = newCapacity;
		      list._level = newLevel;
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
		  }

		  function mergeIntoListWith(list, merger, iterables) {
		    var iters = [];
		    var maxSize = 0;
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = IndexedIterable(value);
		      if (iter.size > maxSize) {
		        maxSize = iter.size;
		      }
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    if (maxSize > list.size) {
		      list = list.setSize(maxSize);
		    }
		    return mergeIntoCollectionWith(list, merger, iters);
		  }

		  function getTailOffset(size) {
		    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
		  }

		  createClass(OrderedMap, Map);

		    // @pragma Construction

		    function OrderedMap(value) {
		      return value === null || value === undefined ? emptyOrderedMap() :
		        isOrderedMap(value) ? value :
		        emptyOrderedMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }

		    OrderedMap.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    OrderedMap.prototype.toString = function() {
		      return this.__toString('OrderedMap {', '}');
		    };

		    // @pragma Access

		    OrderedMap.prototype.get = function(k, notSetValue) {
		      var index = this._map.get(k);
		      return index !== undefined ? this._list.get(index)[1] : notSetValue;
		    };

		    // @pragma Modification

		    OrderedMap.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._map.clear();
		        this._list.clear();
		        return this;
		      }
		      return emptyOrderedMap();
		    };

		    OrderedMap.prototype.set = function(k, v) {
		      return updateOrderedMap(this, k, v);
		    };

		    OrderedMap.prototype.remove = function(k) {
		      return updateOrderedMap(this, k, NOT_SET);
		    };

		    OrderedMap.prototype.wasAltered = function() {
		      return this._map.wasAltered() || this._list.wasAltered();
		    };

		    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._list.__iterate(
		        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
		        reverse
		      );
		    };

		    OrderedMap.prototype.__iterator = function(type, reverse) {
		      return this._list.fromEntrySeq().__iterator(type, reverse);
		    };

		    OrderedMap.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      var newList = this._list.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        this._list = newList;
		        return this;
		      }
		      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
		    };


		  function isOrderedMap(maybeOrderedMap) {
		    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
		  }

		  OrderedMap.isOrderedMap = isOrderedMap;

		  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
		  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



		  function makeOrderedMap(map, list, ownerID, hash) {
		    var omap = Object.create(OrderedMap.prototype);
		    omap.size = map ? map.size : 0;
		    omap._map = map;
		    omap._list = list;
		    omap.__ownerID = ownerID;
		    omap.__hash = hash;
		    return omap;
		  }

		  var EMPTY_ORDERED_MAP;
		  function emptyOrderedMap() {
		    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
		  }

		  function updateOrderedMap(omap, k, v) {
		    var map = omap._map;
		    var list = omap._list;
		    var i = map.get(k);
		    var has = i !== undefined;
		    var newMap;
		    var newList;
		    if (v === NOT_SET) { // removed
		      if (!has) {
		        return omap;
		      }
		      if (list.size >= SIZE && list.size >= map.size * 2) {
		        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
		        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
		        if (omap.__ownerID) {
		          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
		        }
		      } else {
		        newMap = map.remove(k);
		        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
		      }
		    } else {
		      if (has) {
		        if (v === list.get(i)[1]) {
		          return omap;
		        }
		        newMap = map;
		        newList = list.set(i, [k, v]);
		      } else {
		        newMap = map.set(k, list.size);
		        newList = list.set(list.size, [k, v]);
		      }
		    }
		    if (omap.__ownerID) {
		      omap.size = newMap.size;
		      omap._map = newMap;
		      omap._list = newList;
		      omap.__hash = undefined;
		      return omap;
		    }
		    return makeOrderedMap(newMap, newList);
		  }

		  createClass(ToKeyedSequence, KeyedSeq);
		    function ToKeyedSequence(indexed, useKeys) {
		      this._iter = indexed;
		      this._useKeys = useKeys;
		      this.size = indexed.size;
		    }

		    ToKeyedSequence.prototype.get = function(key, notSetValue) {
		      return this._iter.get(key, notSetValue);
		    };

		    ToKeyedSequence.prototype.has = function(key) {
		      return this._iter.has(key);
		    };

		    ToKeyedSequence.prototype.valueSeq = function() {
		      return this._iter.valueSeq();
		    };

		    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
		      var reversedSequence = reverseFactory(this, true);
		      if (!this._useKeys) {
		        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
		      }
		      return reversedSequence;
		    };

		    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
		      var mappedSequence = mapFactory(this, mapper, context);
		      if (!this._useKeys) {
		        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
		      }
		      return mappedSequence;
		    };

		    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var ii;
		      return this._iter.__iterate(
		        this._useKeys ?
		          function(v, k)  {return fn(v, k, this$0)} :
		          ((ii = reverse ? resolveSize(this) : 0),
		            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
		        reverse
		      );
		    };

		    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
		      if (this._useKeys) {
		        return this._iter.__iterator(type, reverse);
		      }
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var ii = reverse ? resolveSize(this) : 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
		      });
		    };

		  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


		  createClass(ToIndexedSequence, IndexedSeq);
		    function ToIndexedSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }

		    ToIndexedSequence.prototype.includes = function(value) {
		      return this._iter.includes(value);
		    };

		    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
		    };

		    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, iterations++, step.value, step)
		      });
		    };



		  createClass(ToSetSequence, SetSeq);
		    function ToSetSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }

		    ToSetSequence.prototype.has = function(key) {
		      return this._iter.includes(key);
		    };

		    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
		    };

		    ToSetSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, step.value, step.value, step);
		      });
		    };



		  createClass(FromEntriesSequence, KeyedSeq);
		    function FromEntriesSequence(entries) {
		      this._iter = entries;
		      this.size = entries.size;
		    }

		    FromEntriesSequence.prototype.entrySeq = function() {
		      return this._iter.toSeq();
		    };

		    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(entry ) {
		        // Check if entry exists first so array access doesn't throw for holes
		        // in the parent iteration.
		        if (entry) {
		          validateEntry(entry);
		          var indexedIterable = isIterable(entry);
		          return fn(
		            indexedIterable ? entry.get(1) : entry[1],
		            indexedIterable ? entry.get(0) : entry[0],
		            this$0
		          );
		        }
		      }, reverse);
		    };

		    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          // Check if entry exists first so array access doesn't throw for holes
		          // in the parent iteration.
		          if (entry) {
		            validateEntry(entry);
		            var indexedIterable = isIterable(entry);
		            return iteratorValue(
		              type,
		              indexedIterable ? entry.get(0) : entry[0],
		              indexedIterable ? entry.get(1) : entry[1],
		              step
		            );
		          }
		        }
		      });
		    };


		  ToIndexedSequence.prototype.cacheResult =
		  ToKeyedSequence.prototype.cacheResult =
		  ToSetSequence.prototype.cacheResult =
		  FromEntriesSequence.prototype.cacheResult =
		    cacheResultThrough;


		  function flipFactory(iterable) {
		    var flipSequence = makeSequence(iterable);
		    flipSequence._iter = iterable;
		    flipSequence.size = iterable.size;
		    flipSequence.flip = function()  {return iterable};
		    flipSequence.reverse = function () {
		      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
		      reversedSequence.flip = function()  {return iterable.reverse()};
		      return reversedSequence;
		    };
		    flipSequence.has = function(key ) {return iterable.includes(key)};
		    flipSequence.includes = function(key ) {return iterable.has(key)};
		    flipSequence.cacheResult = cacheResultThrough;
		    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
		    }
		    flipSequence.__iteratorUncached = function(type, reverse) {
		      if (type === ITERATE_ENTRIES) {
		        var iterator = iterable.__iterator(type, reverse);
		        return new Iterator(function()  {
		          var step = iterator.next();
		          if (!step.done) {
		            var k = step.value[0];
		            step.value[0] = step.value[1];
		            step.value[1] = k;
		          }
		          return step;
		        });
		      }
		      return iterable.__iterator(
		        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
		        reverse
		      );
		    }
		    return flipSequence;
		  }


		  function mapFactory(iterable, mapper, context) {
		    var mappedSequence = makeSequence(iterable);
		    mappedSequence.size = iterable.size;
		    mappedSequence.has = function(key ) {return iterable.has(key)};
		    mappedSequence.get = function(key, notSetValue)  {
		      var v = iterable.get(key, NOT_SET);
		      return v === NOT_SET ?
		        notSetValue :
		        mapper.call(context, v, key, iterable);
		    };
		    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(
		        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
		        reverse
		      );
		    }
		    mappedSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      return new Iterator(function()  {
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var key = entry[0];
		        return iteratorValue(
		          type,
		          key,
		          mapper.call(context, entry[1], key, iterable),
		          step
		        );
		      });
		    }
		    return mappedSequence;
		  }


		  function reverseFactory(iterable, useKeys) {
		    var reversedSequence = makeSequence(iterable);
		    reversedSequence._iter = iterable;
		    reversedSequence.size = iterable.size;
		    reversedSequence.reverse = function()  {return iterable};
		    if (iterable.flip) {
		      reversedSequence.flip = function () {
		        var flipSequence = flipFactory(iterable);
		        flipSequence.reverse = function()  {return iterable.flip()};
		        return flipSequence;
		      };
		    }
		    reversedSequence.get = function(key, notSetValue) 
		      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
		    reversedSequence.has = function(key )
		      {return iterable.has(useKeys ? key : -1 - key)};
		    reversedSequence.includes = function(value ) {return iterable.includes(value)};
		    reversedSequence.cacheResult = cacheResultThrough;
		    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
		    };
		    reversedSequence.__iterator =
		      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
		    return reversedSequence;
		  }


		  function filterFactory(iterable, predicate, context, useKeys) {
		    var filterSequence = makeSequence(iterable);
		    if (useKeys) {
		      filterSequence.has = function(key ) {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
		      };
		      filterSequence.get = function(key, notSetValue)  {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
		          v : notSetValue;
		      };
		    }
		    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      }, reverse);
		      return iterations;
		    };
		    filterSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          var key = entry[0];
		          var value = entry[1];
		          if (predicate.call(context, value, key, iterable)) {
		            return iteratorValue(type, useKeys ? key : iterations++, value, step);
		          }
		        }
		      });
		    }
		    return filterSequence;
		  }


		  function countByFactory(iterable, grouper, context) {
		    var groups = Map().asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        0,
		        function(a ) {return a + 1}
		      );
		    });
		    return groups.asImmutable();
		  }


		  function groupByFactory(iterable, grouper, context) {
		    var isKeyedIter = isKeyed(iterable);
		    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
		      );
		    });
		    var coerce = iterableClass(iterable);
		    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
		  }


		  function sliceFactory(iterable, begin, end, useKeys) {
		    var originalSize = iterable.size;

		    // Sanitize begin & end using this shorthand for ToInt32(argument)
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
		    if (begin !== undefined) {
		      begin = begin | 0;
		    }
		    if (end !== undefined) {
		      if (end === Infinity) {
		        end = originalSize;
		      } else {
		        end = end | 0;
		      }
		    }

		    if (wholeSlice(begin, end, originalSize)) {
		      return iterable;
		    }

		    var resolvedBegin = resolveBegin(begin, originalSize);
		    var resolvedEnd = resolveEnd(end, originalSize);

		    // begin or end will be NaN if they were provided as negative numbers and
		    // this iterable's size is unknown. In that case, cache first so there is
		    // a known size and these do not resolve to NaN.
		    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
		      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
		    }

		    // Note: resolvedEnd is undefined when the original sequence's length is
		    // unknown and this slice did not supply an end and should contain all
		    // elements after resolvedBegin.
		    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
		    var resolvedSize = resolvedEnd - resolvedBegin;
		    var sliceSize;
		    if (resolvedSize === resolvedSize) {
		      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
		    }

		    var sliceSeq = makeSequence(iterable);

		    // If iterable.size is undefined, the size of the realized sliceSeq is
		    // unknown at this point unless the number of items to slice is 0
		    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

		    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
		      sliceSeq.get = function (index, notSetValue) {
		        index = wrapIndex(this, index);
		        return index >= 0 && index < sliceSize ?
		          iterable.get(index + resolvedBegin, notSetValue) :
		          notSetValue;
		      }
		    }

		    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (sliceSize === 0) {
		        return 0;
		      }
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var skipped = 0;
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k)  {
		        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
		                 iterations !== sliceSize;
		        }
		      });
		      return iterations;
		    };

		    sliceSeq.__iteratorUncached = function(type, reverse) {
		      if (sliceSize !== 0 && reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      // Don't bother instantiating parent iterator if taking 0.
		      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
		      var skipped = 0;
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (skipped++ < resolvedBegin) {
		          iterator.next();
		        }
		        if (++iterations > sliceSize) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (useKeys || type === ITERATE_VALUES) {
		          return step;
		        } else if (type === ITERATE_KEYS) {
		          return iteratorValue(type, iterations - 1, undefined, step);
		        } else {
		          return iteratorValue(type, iterations - 1, step.value[1], step);
		        }
		      });
		    }

		    return sliceSeq;
		  }


		  function takeWhileFactory(iterable, predicate, context) {
		    var takeSequence = makeSequence(iterable);
		    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c) 
		        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
		      );
		      return iterations;
		    };
		    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterating = true;
		      return new Iterator(function()  {
		        if (!iterating) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var k = entry[0];
		        var v = entry[1];
		        if (!predicate.call(context, v, k, this$0)) {
		          iterating = false;
		          return iteratorDone();
		        }
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return takeSequence;
		  }


		  function skipWhileFactory(iterable, predicate, context, useKeys) {
		    var skipSequence = makeSequence(iterable);
		    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      });
		      return iterations;
		    };
		    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var skipping = true;
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step, k, v;
		        do {
		          step = iterator.next();
		          if (step.done) {
		            if (useKeys || type === ITERATE_VALUES) {
		              return step;
		            } else if (type === ITERATE_KEYS) {
		              return iteratorValue(type, iterations++, undefined, step);
		            } else {
		              return iteratorValue(type, iterations++, step.value[1], step);
		            }
		          }
		          var entry = step.value;
		          k = entry[0];
		          v = entry[1];
		          skipping && (skipping = predicate.call(context, v, k, this$0));
		        } while (skipping);
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return skipSequence;
		  }


		  function concatFactory(iterable, values) {
		    var isKeyedIterable = isKeyed(iterable);
		    var iters = [iterable].concat(values).map(function(v ) {
		      if (!isIterable(v)) {
		        v = isKeyedIterable ?
		          keyedSeqFromValue(v) :
		          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
		      } else if (isKeyedIterable) {
		        v = KeyedIterable(v);
		      }
		      return v;
		    }).filter(function(v ) {return v.size !== 0});

		    if (iters.length === 0) {
		      return iterable;
		    }

		    if (iters.length === 1) {
		      var singleton = iters[0];
		      if (singleton === iterable ||
		          isKeyedIterable && isKeyed(singleton) ||
		          isIndexed(iterable) && isIndexed(singleton)) {
		        return singleton;
		      }
		    }

		    var concatSeq = new ArraySeq(iters);
		    if (isKeyedIterable) {
		      concatSeq = concatSeq.toKeyedSeq();
		    } else if (!isIndexed(iterable)) {
		      concatSeq = concatSeq.toSetSeq();
		    }
		    concatSeq = concatSeq.flatten(true);
		    concatSeq.size = iters.reduce(
		      function(sum, seq)  {
		        if (sum !== undefined) {
		          var size = seq.size;
		          if (size !== undefined) {
		            return sum + size;
		          }
		        }
		      },
		      0
		    );
		    return concatSeq;
		  }


		  function flattenFactory(iterable, depth, useKeys) {
		    var flatSequence = makeSequence(iterable);
		    flatSequence.__iterateUncached = function(fn, reverse) {
		      var iterations = 0;
		      var stopped = false;
		      function flatDeep(iter, currentDepth) {var this$0 = this;
		        iter.__iterate(function(v, k)  {
		          if ((!depth || currentDepth < depth) && isIterable(v)) {
		            flatDeep(v, currentDepth + 1);
		          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
		            stopped = true;
		          }
		          return !stopped;
		        }, reverse);
		      }
		      flatDeep(iterable, 0);
		      return iterations;
		    }
		    flatSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(type, reverse);
		      var stack = [];
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (iterator) {
		          var step = iterator.next();
		          if (step.done !== false) {
		            iterator = stack.pop();
		            continue;
		          }
		          var v = step.value;
		          if (type === ITERATE_ENTRIES) {
		            v = v[1];
		          }
		          if ((!depth || stack.length < depth) && isIterable(v)) {
		            stack.push(iterator);
		            iterator = v.__iterator(type, reverse);
		          } else {
		            return useKeys ? step : iteratorValue(type, iterations++, v, step);
		          }
		        }
		        return iteratorDone();
		      });
		    }
		    return flatSequence;
		  }


		  function flatMapFactory(iterable, mapper, context) {
		    var coerce = iterableClass(iterable);
		    return iterable.toSeq().map(
		      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
		    ).flatten(true);
		  }


		  function interposeFactory(iterable, separator) {
		    var interposedSequence = makeSequence(iterable);
		    interposedSequence.size = iterable.size && iterable.size * 2 -1;
		    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k) 
		        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
		        fn(v, iterations++, this$0) !== false},
		        reverse
		      );
		      return iterations;
		    };
		    interposedSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      var step;
		      return new Iterator(function()  {
		        if (!step || iterations % 2) {
		          step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		        }
		        return iterations % 2 ?
		          iteratorValue(type, iterations++, separator) :
		          iteratorValue(type, iterations++, step.value, step);
		      });
		    };
		    return interposedSequence;
		  }


		  function sortFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    var isKeyedIterable = isKeyed(iterable);
		    var index = 0;
		    var entries = iterable.toSeq().map(
		      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
		    ).toArray();
		    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
		      isKeyedIterable ?
		      function(v, i)  { entries[i].length = 2; } :
		      function(v, i)  { entries[i] = v[1]; }
		    );
		    return isKeyedIterable ? KeyedSeq(entries) :
		      isIndexed(iterable) ? IndexedSeq(entries) :
		      SetSeq(entries);
		  }


		  function maxFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    if (mapper) {
		      var entry = iterable.toSeq()
		        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
		        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
		      return entry && entry[0];
		    } else {
		      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
		    }
		  }

		  function maxCompare(comparator, a, b) {
		    var comp = comparator(b, a);
		    // b is considered the new max if the comparator declares them equal, but
		    // they are not equal and b is in fact a nullish value.
		    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
		  }


		  function zipWithFactory(keyIter, zipper, iters) {
		    var zipSequence = makeSequence(keyIter);
		    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
		    // Note: this a generic base implementation of __iterate in terms of
		    // __iterator which may be more generically useful in the future.
		    zipSequence.__iterate = function(fn, reverse) {
		      /* generic:
		      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        iterations++;
		        if (fn(step.value[1], step.value[0], this) === false) {
		          break;
		        }
		      }
		      return iterations;
		      */
		      // indexed:
		      var iterator = this.__iterator(ITERATE_VALUES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        if (fn(step.value, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };
		    zipSequence.__iteratorUncached = function(type, reverse) {
		      var iterators = iters.map(function(i )
		        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
		      );
		      var iterations = 0;
		      var isDone = false;
		      return new Iterator(function()  {
		        var steps;
		        if (!isDone) {
		          steps = iterators.map(function(i ) {return i.next()});
		          isDone = steps.some(function(s ) {return s.done});
		        }
		        if (isDone) {
		          return iteratorDone();
		        }
		        return iteratorValue(
		          type,
		          iterations++,
		          zipper.apply(null, steps.map(function(s ) {return s.value}))
		        );
		      });
		    };
		    return zipSequence
		  }


		  // #pragma Helper Functions

		  function reify(iter, seq) {
		    return isSeq(iter) ? seq : iter.constructor(seq);
		  }

		  function validateEntry(entry) {
		    if (entry !== Object(entry)) {
		      throw new TypeError('Expected [K, V] tuple: ' + entry);
		    }
		  }

		  function resolveSize(iter) {
		    assertNotInfinite(iter.size);
		    return ensureSize(iter);
		  }

		  function iterableClass(iterable) {
		    return isKeyed(iterable) ? KeyedIterable :
		      isIndexed(iterable) ? IndexedIterable :
		      SetIterable;
		  }

		  function makeSequence(iterable) {
		    return Object.create(
		      (
		        isKeyed(iterable) ? KeyedSeq :
		        isIndexed(iterable) ? IndexedSeq :
		        SetSeq
		      ).prototype
		    );
		  }

		  function cacheResultThrough() {
		    if (this._iter.cacheResult) {
		      this._iter.cacheResult();
		      this.size = this._iter.size;
		      return this;
		    } else {
		      return Seq.prototype.cacheResult.call(this);
		    }
		  }

		  function defaultComparator(a, b) {
		    return a > b ? 1 : a < b ? -1 : 0;
		  }

		  function forceIterator(keyPath) {
		    var iter = getIterator(keyPath);
		    if (!iter) {
		      // Array might not be iterable in this environment, so we need a fallback
		      // to our wrapped type.
		      if (!isArrayLike(keyPath)) {
		        throw new TypeError('Expected iterable or array-like: ' + keyPath);
		      }
		      iter = getIterator(Iterable(keyPath));
		    }
		    return iter;
		  }

		  createClass(Record, KeyedCollection);

		    function Record(defaultValues, name) {
		      var hasInitialized;

		      var RecordType = function Record(values) {
		        if (values instanceof RecordType) {
		          return values;
		        }
		        if (!(this instanceof RecordType)) {
		          return new RecordType(values);
		        }
		        if (!hasInitialized) {
		          hasInitialized = true;
		          var keys = Object.keys(defaultValues);
		          setProps(RecordTypePrototype, keys);
		          RecordTypePrototype.size = keys.length;
		          RecordTypePrototype._name = name;
		          RecordTypePrototype._keys = keys;
		          RecordTypePrototype._defaultValues = defaultValues;
		        }
		        this._map = Map(values);
		      };

		      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
		      RecordTypePrototype.constructor = RecordType;

		      return RecordType;
		    }

		    Record.prototype.toString = function() {
		      return this.__toString(recordName(this) + ' {', '}');
		    };

		    // @pragma Access

		    Record.prototype.has = function(k) {
		      return this._defaultValues.hasOwnProperty(k);
		    };

		    Record.prototype.get = function(k, notSetValue) {
		      if (!this.has(k)) {
		        return notSetValue;
		      }
		      var defaultVal = this._defaultValues[k];
		      return this._map ? this._map.get(k, defaultVal) : defaultVal;
		    };

		    // @pragma Modification

		    Record.prototype.clear = function() {
		      if (this.__ownerID) {
		        this._map && this._map.clear();
		        return this;
		      }
		      var RecordType = this.constructor;
		      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
		    };

		    Record.prototype.set = function(k, v) {
		      if (!this.has(k)) {
		        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
		      }
		      if (this._map && !this._map.has(k)) {
		        var defaultVal = this._defaultValues[k];
		        if (v === defaultVal) {
		          return this;
		        }
		      }
		      var newMap = this._map && this._map.set(k, v);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };

		    Record.prototype.remove = function(k) {
		      if (!this.has(k)) {
		        return this;
		      }
		      var newMap = this._map && this._map.remove(k);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };

		    Record.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };

		    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
		    };

		    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
		    };

		    Record.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map && this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return makeRecord(this, newMap, ownerID);
		    };


		  var RecordPrototype = Record.prototype;
		  RecordPrototype[DELETE] = RecordPrototype.remove;
		  RecordPrototype.deleteIn =
		  RecordPrototype.removeIn = MapPrototype.removeIn;
		  RecordPrototype.merge = MapPrototype.merge;
		  RecordPrototype.mergeWith = MapPrototype.mergeWith;
		  RecordPrototype.mergeIn = MapPrototype.mergeIn;
		  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
		  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
		  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  RecordPrototype.setIn = MapPrototype.setIn;
		  RecordPrototype.update = MapPrototype.update;
		  RecordPrototype.updateIn = MapPrototype.updateIn;
		  RecordPrototype.withMutations = MapPrototype.withMutations;
		  RecordPrototype.asMutable = MapPrototype.asMutable;
		  RecordPrototype.asImmutable = MapPrototype.asImmutable;


		  function makeRecord(likeRecord, map, ownerID) {
		    var record = Object.create(Object.getPrototypeOf(likeRecord));
		    record._map = map;
		    record.__ownerID = ownerID;
		    return record;
		  }

		  function recordName(record) {
		    return record._name || record.constructor.name || 'Record';
		  }

		  function setProps(prototype, names) {
		    try {
		      names.forEach(setProp.bind(undefined, prototype));
		    } catch (error) {
		      // Object.defineProperty failed. Probably IE8.
		    }
		  }

		  function setProp(prototype, name) {
		    Object.defineProperty(prototype, name, {
		      get: function() {
		        return this.get(name);
		      },
		      set: function(value) {
		        invariant(this.__ownerID, 'Cannot set on an immutable record.');
		        this.set(name, value);
		      }
		    });
		  }

		  createClass(Set, SetCollection);

		    // @pragma Construction

		    function Set(value) {
		      return value === null || value === undefined ? emptySet() :
		        isSet(value) && !isOrdered(value) ? value :
		        emptySet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }

		    Set.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    Set.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };

		    Set.prototype.toString = function() {
		      return this.__toString('Set {', '}');
		    };

		    // @pragma Access

		    Set.prototype.has = function(value) {
		      return this._map.has(value);
		    };

		    // @pragma Modification

		    Set.prototype.add = function(value) {
		      return updateSet(this, this._map.set(value, true));
		    };

		    Set.prototype.remove = function(value) {
		      return updateSet(this, this._map.remove(value));
		    };

		    Set.prototype.clear = function() {
		      return updateSet(this, this._map.clear());
		    };

		    // @pragma Composition

		    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
		      iters = iters.filter(function(x ) {return x.size !== 0});
		      if (iters.length === 0) {
		        return this;
		      }
		      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
		        return this.constructor(iters[0]);
		      }
		      return this.withMutations(function(set ) {
		        for (var ii = 0; ii < iters.length; ii++) {
		          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
		        }
		      });
		    };

		    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (!iters.every(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };

		    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (iters.some(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };

		    Set.prototype.merge = function() {
		      return this.union.apply(this, arguments);
		    };

		    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return this.union.apply(this, iters);
		    };

		    Set.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator));
		    };

		    Set.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator, mapper));
		    };

		    Set.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };

		    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
		    };

		    Set.prototype.__iterator = function(type, reverse) {
		      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
		    };

		    Set.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return this.__make(newMap, ownerID);
		    };


		  function isSet(maybeSet) {
		    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
		  }

		  Set.isSet = isSet;

		  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

		  var SetPrototype = Set.prototype;
		  SetPrototype[IS_SET_SENTINEL] = true;
		  SetPrototype[DELETE] = SetPrototype.remove;
		  SetPrototype.mergeDeep = SetPrototype.merge;
		  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
		  SetPrototype.withMutations = MapPrototype.withMutations;
		  SetPrototype.asMutable = MapPrototype.asMutable;
		  SetPrototype.asImmutable = MapPrototype.asImmutable;

		  SetPrototype.__empty = emptySet;
		  SetPrototype.__make = makeSet;

		  function updateSet(set, newMap) {
		    if (set.__ownerID) {
		      set.size = newMap.size;
		      set._map = newMap;
		      return set;
		    }
		    return newMap === set._map ? set :
		      newMap.size === 0 ? set.__empty() :
		      set.__make(newMap);
		  }

		  function makeSet(map, ownerID) {
		    var set = Object.create(SetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }

		  var EMPTY_SET;
		  function emptySet() {
		    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
		  }

		  createClass(OrderedSet, Set);

		    // @pragma Construction

		    function OrderedSet(value) {
		      return value === null || value === undefined ? emptyOrderedSet() :
		        isOrderedSet(value) ? value :
		        emptyOrderedSet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }

		    OrderedSet.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    OrderedSet.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };

		    OrderedSet.prototype.toString = function() {
		      return this.__toString('OrderedSet {', '}');
		    };


		  function isOrderedSet(maybeOrderedSet) {
		    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
		  }

		  OrderedSet.isOrderedSet = isOrderedSet;

		  var OrderedSetPrototype = OrderedSet.prototype;
		  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

		  OrderedSetPrototype.__empty = emptyOrderedSet;
		  OrderedSetPrototype.__make = makeOrderedSet;

		  function makeOrderedSet(map, ownerID) {
		    var set = Object.create(OrderedSetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }

		  var EMPTY_ORDERED_SET;
		  function emptyOrderedSet() {
		    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
		  }

		  createClass(Stack, IndexedCollection);

		    // @pragma Construction

		    function Stack(value) {
		      return value === null || value === undefined ? emptyStack() :
		        isStack(value) ? value :
		        emptyStack().unshiftAll(value);
		    }

		    Stack.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    Stack.prototype.toString = function() {
		      return this.__toString('Stack [', ']');
		    };

		    // @pragma Access

		    Stack.prototype.get = function(index, notSetValue) {
		      var head = this._head;
		      index = wrapIndex(this, index);
		      while (head && index--) {
		        head = head.next;
		      }
		      return head ? head.value : notSetValue;
		    };

		    Stack.prototype.peek = function() {
		      return this._head && this._head.value;
		    };

		    // @pragma Modification

		    Stack.prototype.push = function(/*...values*/) {
		      if (arguments.length === 0) {
		        return this;
		      }
		      var newSize = this.size + arguments.length;
		      var head = this._head;
		      for (var ii = arguments.length - 1; ii >= 0; ii--) {
		        head = {
		          value: arguments[ii],
		          next: head
		        };
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    Stack.prototype.pushAll = function(iter) {
		      iter = IndexedIterable(iter);
		      if (iter.size === 0) {
		        return this;
		      }
		      assertNotInfinite(iter.size);
		      var newSize = this.size;
		      var head = this._head;
		      iter.reverse().forEach(function(value ) {
		        newSize++;
		        head = {
		          value: value,
		          next: head
		        };
		      });
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    Stack.prototype.pop = function() {
		      return this.slice(1);
		    };

		    Stack.prototype.unshift = function(/*...values*/) {
		      return this.push.apply(this, arguments);
		    };

		    Stack.prototype.unshiftAll = function(iter) {
		      return this.pushAll(iter);
		    };

		    Stack.prototype.shift = function() {
		      return this.pop.apply(this, arguments);
		    };

		    Stack.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._head = undefined;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyStack();
		    };

		    Stack.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      var resolvedBegin = resolveBegin(begin, this.size);
		      var resolvedEnd = resolveEnd(end, this.size);
		      if (resolvedEnd !== this.size) {
		        // super.slice(begin, end);
		        return IndexedCollection.prototype.slice.call(this, begin, end);
		      }
		      var newSize = this.size - resolvedBegin;
		      var head = this._head;
		      while (resolvedBegin--) {
		        head = head.next;
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    // @pragma Mutability

		    Stack.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeStack(this.size, this._head, ownerID, this.__hash);
		    };

		    // @pragma Iteration

		    Stack.prototype.__iterate = function(fn, reverse) {
		      if (reverse) {
		        return this.reverse().__iterate(fn);
		      }
		      var iterations = 0;
		      var node = this._head;
		      while (node) {
		        if (fn(node.value, iterations++, this) === false) {
		          break;
		        }
		        node = node.next;
		      }
		      return iterations;
		    };

		    Stack.prototype.__iterator = function(type, reverse) {
		      if (reverse) {
		        return this.reverse().__iterator(type);
		      }
		      var iterations = 0;
		      var node = this._head;
		      return new Iterator(function()  {
		        if (node) {
		          var value = node.value;
		          node = node.next;
		          return iteratorValue(type, iterations++, value);
		        }
		        return iteratorDone();
		      });
		    };


		  function isStack(maybeStack) {
		    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
		  }

		  Stack.isStack = isStack;

		  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

		  var StackPrototype = Stack.prototype;
		  StackPrototype[IS_STACK_SENTINEL] = true;
		  StackPrototype.withMutations = MapPrototype.withMutations;
		  StackPrototype.asMutable = MapPrototype.asMutable;
		  StackPrototype.asImmutable = MapPrototype.asImmutable;
		  StackPrototype.wasAltered = MapPrototype.wasAltered;


		  function makeStack(size, head, ownerID, hash) {
		    var map = Object.create(StackPrototype);
		    map.size = size;
		    map._head = head;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }

		  var EMPTY_STACK;
		  function emptyStack() {
		    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
		  }

		  /**
		   * Contributes additional methods to a constructor
		   */
		  function mixin(ctor, methods) {
		    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
		    Object.keys(methods).forEach(keyCopier);
		    Object.getOwnPropertySymbols &&
		      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
		    return ctor;
		  }

		  Iterable.Iterator = Iterator;

		  mixin(Iterable, {

		    // ### Conversion to other types

		    toArray: function() {
		      assertNotInfinite(this.size);
		      var array = new Array(this.size || 0);
		      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
		      return array;
		    },

		    toIndexedSeq: function() {
		      return new ToIndexedSequence(this);
		    },

		    toJS: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
		      ).__toJS();
		    },

		    toJSON: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
		      ).__toJS();
		    },

		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, true);
		    },

		    toMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Map(this.toKeyedSeq());
		    },

		    toObject: function() {
		      assertNotInfinite(this.size);
		      var object = {};
		      this.__iterate(function(v, k)  { object[k] = v; });
		      return object;
		    },

		    toOrderedMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedMap(this.toKeyedSeq());
		    },

		    toOrderedSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Set(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toSetSeq: function() {
		      return new ToSetSequence(this);
		    },

		    toSeq: function() {
		      return isIndexed(this) ? this.toIndexedSeq() :
		        isKeyed(this) ? this.toKeyedSeq() :
		        this.toSetSeq();
		    },

		    toStack: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Stack(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toList: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return List(isKeyed(this) ? this.valueSeq() : this);
		    },


		    // ### Common JavaScript methods and properties

		    toString: function() {
		      return '[Iterable]';
		    },

		    __toString: function(head, tail) {
		      if (this.size === 0) {
		        return head + tail;
		      }
		      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
		    },


		    // ### ES6 Collection methods (ES6 Array and Map)

		    concat: function() {var values = SLICE$0.call(arguments, 0);
		      return reify(this, concatFactory(this, values));
		    },

		    includes: function(searchValue) {
		      return this.some(function(value ) {return is(value, searchValue)});
		    },

		    entries: function() {
		      return this.__iterator(ITERATE_ENTRIES);
		    },

		    every: function(predicate, context) {
		      assertNotInfinite(this.size);
		      var returnValue = true;
		      this.__iterate(function(v, k, c)  {
		        if (!predicate.call(context, v, k, c)) {
		          returnValue = false;
		          return false;
		        }
		      });
		      return returnValue;
		    },

		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, true));
		    },

		    find: function(predicate, context, notSetValue) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[1] : notSetValue;
		    },

		    forEach: function(sideEffect, context) {
		      assertNotInfinite(this.size);
		      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
		    },

		    join: function(separator) {
		      assertNotInfinite(this.size);
		      separator = separator !== undefined ? '' + separator : ',';
		      var joined = '';
		      var isFirst = true;
		      this.__iterate(function(v ) {
		        isFirst ? (isFirst = false) : (joined += separator);
		        joined += v !== null && v !== undefined ? v.toString() : '';
		      });
		      return joined;
		    },

		    keys: function() {
		      return this.__iterator(ITERATE_KEYS);
		    },

		    map: function(mapper, context) {
		      return reify(this, mapFactory(this, mapper, context));
		    },

		    reduce: function(reducer, initialReduction, context) {
		      assertNotInfinite(this.size);
		      var reduction;
		      var useFirst;
		      if (arguments.length < 2) {
		        useFirst = true;
		      } else {
		        reduction = initialReduction;
		      }
		      this.__iterate(function(v, k, c)  {
		        if (useFirst) {
		          useFirst = false;
		          reduction = v;
		        } else {
		          reduction = reducer.call(context, reduction, v, k, c);
		        }
		      });
		      return reduction;
		    },

		    reduceRight: function(reducer, initialReduction, context) {
		      var reversed = this.toKeyedSeq().reverse();
		      return reversed.reduce.apply(reversed, arguments);
		    },

		    reverse: function() {
		      return reify(this, reverseFactory(this, true));
		    },

		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, true));
		    },

		    some: function(predicate, context) {
		      return !this.every(not(predicate), context);
		    },

		    sort: function(comparator) {
		      return reify(this, sortFactory(this, comparator));
		    },

		    values: function() {
		      return this.__iterator(ITERATE_VALUES);
		    },


		    // ### More sequential methods

		    butLast: function() {
		      return this.slice(0, -1);
		    },

		    isEmpty: function() {
		      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
		    },

		    count: function(predicate, context) {
		      return ensureSize(
		        predicate ? this.toSeq().filter(predicate, context) : this
		      );
		    },

		    countBy: function(grouper, context) {
		      return countByFactory(this, grouper, context);
		    },

		    equals: function(other) {
		      return deepEqual(this, other);
		    },

		    entrySeq: function() {
		      var iterable = this;
		      if (iterable._cache) {
		        // We cache as an entries array, so we can just return the cache!
		        return new ArraySeq(iterable._cache);
		      }
		      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
		      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
		      return entriesSequence;
		    },

		    filterNot: function(predicate, context) {
		      return this.filter(not(predicate), context);
		    },

		    findEntry: function(predicate, context, notSetValue) {
		      var found = notSetValue;
		      this.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          found = [k, v];
		          return false;
		        }
		      });
		      return found;
		    },

		    findKey: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry && entry[0];
		    },

		    findLast: function(predicate, context, notSetValue) {
		      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
		    },

		    findLastEntry: function(predicate, context, notSetValue) {
		      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
		    },

		    findLastKey: function(predicate, context) {
		      return this.toKeyedSeq().reverse().findKey(predicate, context);
		    },

		    first: function() {
		      return this.find(returnTrue);
		    },

		    flatMap: function(mapper, context) {
		      return reify(this, flatMapFactory(this, mapper, context));
		    },

		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, true));
		    },

		    fromEntrySeq: function() {
		      return new FromEntriesSequence(this);
		    },

		    get: function(searchKey, notSetValue) {
		      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
		    },

		    getIn: function(searchKeyPath, notSetValue) {
		      var nested = this;
		      // Note: in an ES6 environment, we would prefer:
		      // for (var key of searchKeyPath) {
		      var iter = forceIterator(searchKeyPath);
		      var step;
		      while (!(step = iter.next()).done) {
		        var key = step.value;
		        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
		        if (nested === NOT_SET) {
		          return notSetValue;
		        }
		      }
		      return nested;
		    },

		    groupBy: function(grouper, context) {
		      return groupByFactory(this, grouper, context);
		    },

		    has: function(searchKey) {
		      return this.get(searchKey, NOT_SET) !== NOT_SET;
		    },

		    hasIn: function(searchKeyPath) {
		      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
		    },

		    isSubset: function(iter) {
		      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
		      return this.every(function(value ) {return iter.includes(value)});
		    },

		    isSuperset: function(iter) {
		      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
		      return iter.isSubset(this);
		    },

		    keyOf: function(searchValue) {
		      return this.findKey(function(value ) {return is(value, searchValue)});
		    },

		    keySeq: function() {
		      return this.toSeq().map(keyMapper).toIndexedSeq();
		    },

		    last: function() {
		      return this.toSeq().reverse().first();
		    },

		    lastKeyOf: function(searchValue) {
		      return this.toKeyedSeq().reverse().keyOf(searchValue);
		    },

		    max: function(comparator) {
		      return maxFactory(this, comparator);
		    },

		    maxBy: function(mapper, comparator) {
		      return maxFactory(this, comparator, mapper);
		    },

		    min: function(comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
		    },

		    minBy: function(mapper, comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
		    },

		    rest: function() {
		      return this.slice(1);
		    },

		    skip: function(amount) {
		      return this.slice(Math.max(0, amount));
		    },

		    skipLast: function(amount) {
		      return reify(this, this.toSeq().reverse().skip(amount).reverse());
		    },

		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, true));
		    },

		    skipUntil: function(predicate, context) {
		      return this.skipWhile(not(predicate), context);
		    },

		    sortBy: function(mapper, comparator) {
		      return reify(this, sortFactory(this, comparator, mapper));
		    },

		    take: function(amount) {
		      return this.slice(0, Math.max(0, amount));
		    },

		    takeLast: function(amount) {
		      return reify(this, this.toSeq().reverse().take(amount).reverse());
		    },

		    takeWhile: function(predicate, context) {
		      return reify(this, takeWhileFactory(this, predicate, context));
		    },

		    takeUntil: function(predicate, context) {
		      return this.takeWhile(not(predicate), context);
		    },

		    valueSeq: function() {
		      return this.toIndexedSeq();
		    },


		    // ### Hashable Object

		    hashCode: function() {
		      return this.__hash || (this.__hash = hashIterable(this));
		    }


		    // ### Internal

		    // abstract __iterate(fn, reverse)

		    // abstract __iterator(type, reverse)
		  });

		  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

		  var IterablePrototype = Iterable.prototype;
		  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
		  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
		  IterablePrototype.__toJS = IterablePrototype.toArray;
		  IterablePrototype.__toStringMapper = quoteString;
		  IterablePrototype.inspect =
		  IterablePrototype.toSource = function() { return this.toString(); };
		  IterablePrototype.chain = IterablePrototype.flatMap;
		  IterablePrototype.contains = IterablePrototype.includes;

		  mixin(KeyedIterable, {

		    // ### More sequential methods

		    flip: function() {
		      return reify(this, flipFactory(this));
		    },

		    mapEntries: function(mapper, context) {var this$0 = this;
		      var iterations = 0;
		      return reify(this,
		        this.toSeq().map(
		          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
		        ).fromEntrySeq()
		      );
		    },

		    mapKeys: function(mapper, context) {var this$0 = this;
		      return reify(this,
		        this.toSeq().flip().map(
		          function(k, v)  {return mapper.call(context, k, v, this$0)}
		        ).flip()
		      );
		    }

		  });

		  var KeyedIterablePrototype = KeyedIterable.prototype;
		  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
		  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
		  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
		  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



		  mixin(IndexedIterable, {

		    // ### Conversion to other types

		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, false);
		    },


		    // ### ES6 Collection methods (ES6 Array and Map)

		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, false));
		    },

		    findIndex: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[0] : -1;
		    },

		    indexOf: function(searchValue) {
		      var key = this.keyOf(searchValue);
		      return key === undefined ? -1 : key;
		    },

		    lastIndexOf: function(searchValue) {
		      var key = this.lastKeyOf(searchValue);
		      return key === undefined ? -1 : key;
		    },

		    reverse: function() {
		      return reify(this, reverseFactory(this, false));
		    },

		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, false));
		    },

		    splice: function(index, removeNum /*, ...values*/) {
		      var numArgs = arguments.length;
		      removeNum = Math.max(removeNum | 0, 0);
		      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
		        return this;
		      }
		      // If index is negative, it should resolve relative to the size of the
		      // collection. However size may be expensive to compute if not cached, so
		      // only call count() if the number is in fact negative.
		      index = resolveBegin(index, index < 0 ? this.count() : this.size);
		      var spliced = this.slice(0, index);
		      return reify(
		        this,
		        numArgs === 1 ?
		          spliced :
		          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
		      );
		    },


		    // ### More collection methods

		    findLastIndex: function(predicate, context) {
		      var entry = this.findLastEntry(predicate, context);
		      return entry ? entry[0] : -1;
		    },

		    first: function() {
		      return this.get(0);
		    },

		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, false));
		    },

		    get: function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      return (index < 0 || (this.size === Infinity ||
		          (this.size !== undefined && index > this.size))) ?
		        notSetValue :
		        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
		    },

		    has: function(index) {
		      index = wrapIndex(this, index);
		      return index >= 0 && (this.size !== undefined ?
		        this.size === Infinity || index < this.size :
		        this.indexOf(index) !== -1
		      );
		    },

		    interpose: function(separator) {
		      return reify(this, interposeFactory(this, separator));
		    },

		    interleave: function(/*...iterables*/) {
		      var iterables = [this].concat(arrCopy(arguments));
		      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
		      var interleaved = zipped.flatten(true);
		      if (zipped.size) {
		        interleaved.size = zipped.size * iterables.length;
		      }
		      return reify(this, interleaved);
		    },

		    keySeq: function() {
		      return Range(0, this.size);
		    },

		    last: function() {
		      return this.get(-1);
		    },

		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, false));
		    },

		    zip: function(/*, ...iterables */) {
		      var iterables = [this].concat(arrCopy(arguments));
		      return reify(this, zipWithFactory(this, defaultZipper, iterables));
		    },

		    zipWith: function(zipper/*, ...iterables */) {
		      var iterables = arrCopy(arguments);
		      iterables[0] = this;
		      return reify(this, zipWithFactory(this, zipper, iterables));
		    }

		  });

		  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
		  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



		  mixin(SetIterable, {

		    // ### ES6 Collection methods (ES6 Array and Map)

		    get: function(value, notSetValue) {
		      return this.has(value) ? value : notSetValue;
		    },

		    includes: function(value) {
		      return this.has(value);
		    },


		    // ### More sequential methods

		    keySeq: function() {
		      return this.valueSeq();
		    }

		  });

		  SetIterable.prototype.has = IterablePrototype.includes;
		  SetIterable.prototype.contains = SetIterable.prototype.includes;


		  // Mixin subclasses

		  mixin(KeyedSeq, KeyedIterable.prototype);
		  mixin(IndexedSeq, IndexedIterable.prototype);
		  mixin(SetSeq, SetIterable.prototype);

		  mixin(KeyedCollection, KeyedIterable.prototype);
		  mixin(IndexedCollection, IndexedIterable.prototype);
		  mixin(SetCollection, SetIterable.prototype);


		  // #pragma Helper functions

		  function keyMapper(v, k) {
		    return k;
		  }

		  function entryMapper(v, k) {
		    return [k, v];
		  }

		  function not(predicate) {
		    return function() {
		      return !predicate.apply(this, arguments);
		    }
		  }

		  function neg(predicate) {
		    return function() {
		      return -predicate.apply(this, arguments);
		    }
		  }

		  function quoteString(value) {
		    return typeof value === 'string' ? JSON.stringify(value) : String(value);
		  }

		  function defaultZipper() {
		    return arrCopy(arguments);
		  }

		  function defaultNegComparator(a, b) {
		    return a < b ? 1 : a > b ? -1 : 0;
		  }

		  function hashIterable(iterable) {
		    if (iterable.size === Infinity) {
		      return 0;
		    }
		    var ordered = isOrdered(iterable);
		    var keyed = isKeyed(iterable);
		    var h = ordered ? 1 : 0;
		    var size = iterable.__iterate(
		      keyed ?
		        ordered ?
		          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
		          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
		        ordered ?
		          function(v ) { h = 31 * h + hash(v) | 0; } :
		          function(v ) { h = h + hash(v) | 0; }
		    );
		    return murmurHashOfSize(size, h);
		  }

		  function murmurHashOfSize(size, h) {
		    h = imul(h, 0xCC9E2D51);
		    h = imul(h << 15 | h >>> -15, 0x1B873593);
		    h = imul(h << 13 | h >>> -13, 5);
		    h = (h + 0xE6546B64 | 0) ^ size;
		    h = imul(h ^ h >>> 16, 0x85EBCA6B);
		    h = imul(h ^ h >>> 13, 0xC2B2AE35);
		    h = smi(h ^ h >>> 16);
		    return h;
		  }

		  function hashMerge(a, b) {
		    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
		  }

		  var Immutable = {

		    Iterable: Iterable,

		    Seq: Seq,
		    Collection: Collection,
		    Map: Map,
		    OrderedMap: OrderedMap,
		    List: List,
		    Stack: Stack,
		    Set: Set,
		    OrderedSet: OrderedSet,

		    Record: Record,
		    Range: Range,
		    Repeat: Repeat,

		    is: is,
		    fromJS: fromJS

		  };

		  return Immutable;

		}));

	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.ALL_PHASES = exports.Types = undefined;

		var _immutable = __webpack_require__(9);

		var _errors = __webpack_require__(11);

		var _bindingMap = __webpack_require__(12);

		var _bindingMap2 = _interopRequireDefault(_bindingMap);

		var _ramdaFantasy = __webpack_require__(13);

		var _tokenizer = __webpack_require__(2);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const Just_779 = _ramdaFantasy.Maybe.Just;
		const Nothing_780 = _ramdaFantasy.Maybe.Nothing;
		function sizeDecending_781(a_784, b_785) {
		  if (a_784.scopes.size > b_785.scopes.size) {
		    return -1;
		  } else if (b_785.scopes.size > a_784.scopes.size) {
		    return 1;
		  } else {
		    return 0;
		  }
		}
		let Types_782 = { null: { match: token_786 => !Types_782.delimiter.match(token_786) && token_786.type === _tokenizer.TokenType.NULL, create: (value_787, stx_788) => new Syntax({ type: _tokenizer.TokenType.NULL, value: null }, stx_788) }, number: { match: token_789 => !Types_782.delimiter.match(token_789) && token_789.type.klass === _tokenizer.TokenClass.NumericLiteral, create: (value_790, stx_791) => new Syntax({ type: _tokenizer.TokenType.NUMBER, value: value_790 }, stx_791) }, string: { match: token_792 => !Types_782.delimiter.match(token_792) && token_792.type.klass === _tokenizer.TokenClass.StringLiteral, create: (value_793, stx_794) => new Syntax({ type: _tokenizer.TokenType.STRING, str: value_793 }, stx_794) }, punctuator: { match: token_795 => !Types_782.delimiter.match(token_795) && token_795.type.klass === _tokenizer.TokenClass.Punctuator, create: (value_796, stx_797) => new Syntax({ type: { klass: _tokenizer.TokenClass.Punctuator, name: value_796 }, value: value_796 }, stx_797) }, keyword: { match: token_798 => !Types_782.delimiter.match(token_798) && token_798.type.klass === _tokenizer.TokenClass.Keyword, create: (value_799, stx_800) => new Syntax({ type: { klass: _tokenizer.TokenClass.Keyword, name: value_799 }, value: value_799 }, stx_800) }, identifier: { match: token_801 => !Types_782.delimiter.match(token_801) && token_801.type.klass === _tokenizer.TokenClass.Ident, create: (value_802, stx_803) => new Syntax({ type: _tokenizer.TokenType.IDENTIFIER, value: value_802 }, stx_803) }, regularExpression: { match: token_804 => !Types_782.delimiter.match(token_804) && token_804.type.klass === _tokenizer.TokenClass.RegularExpression, create: (value_805, stx_806) => new Syntax({ type: _tokenizer.TokenType.REGEXP, value: value_805 }, stx_806) }, braces: { match: token_807 => Types_782.delimiter.match(token_807) && token_807.get(0).token.type === _tokenizer.TokenType.LBRACE, create: (inner_808, stx_809) => {
		      let left_810 = new Syntax({ type: _tokenizer.TokenType.LBRACE, value: "{" });
		      let right_811 = new Syntax({ type: _tokenizer.TokenType.RBRACE, value: "}" });
		      return new Syntax(_immutable.List.of(left_810).concat(inner_808).push(right_811), stx_809);
		    } }, brackets: { match: token_812 => Types_782.delimiter.match(token_812) && token_812.get(0).token.type === _tokenizer.TokenType.LBRACK, create: (inner_813, stx_814) => {
		      let left_815 = new Syntax({ type: _tokenizer.TokenType.LBRACK, value: "[" });
		      let right_816 = new Syntax({ type: _tokenizer.TokenType.RBRACK, value: "]" });
		      return new Syntax(_immutable.List.of(left_815).concat(inner_813).push(right_816), stx_814);
		    } }, parens: { match: token_817 => Types_782.delimiter.match(token_817) && token_817.get(0).token.type === _tokenizer.TokenType.LPAREN, create: (inner_818, stx_819) => {
		      let left_820 = new Syntax({ type: _tokenizer.TokenType.LPAREN, value: "(" });
		      let right_821 = new Syntax({ type: _tokenizer.TokenType.RPAREN, value: ")" });
		      return new Syntax(_immutable.List.of(left_820).concat(inner_818).push(right_821), stx_819);
		    } }, assign: { match: token_822 => {
		      if (Types_782.punctuator.match(token_822)) {
		        switch (token_822.value) {
		          case "=":
		          case "|=":
		          case "^=":
		          case "&=":
		          case "<<=":
		          case ">>=":
		          case ">>>=":
		          case "+=":
		          case "-=":
		          case "*=":
		          case "/=":
		          case "%=":
		            return true;
		          default:
		            return false;
		        }
		      }
		      return false;
		    } }, boolean: { match: token_823 => !Types_782.delimiter.match(token_823) && token_823.type === _tokenizer.TokenType.TRUE || token_823.type === _tokenizer.TokenType.FALSE }, template: { match: token_824 => !Types_782.delimiter.match(token_824) && token_824.type === _tokenizer.TokenType.TEMPLATE }, delimiter: { match: token_825 => _immutable.List.isList(token_825) }, syntaxTemplate: { match: token_826 => Types_782.delimiter.match(token_826) && token_826.get(0).val() === "#`" }, eof: { match: token_827 => !Types_782.delimiter.match(token_827) && token_827.type === _tokenizer.TokenType.EOS } };
		;
		const ALL_PHASES_783 = {};
		;
		class Syntax {
		  constructor(token_828) {
		    let oldstx_829 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    this.token = token_828;
		    this.bindings = oldstx_829.bindings != null ? oldstx_829.bindings : new _bindingMap2.default();
		    this.scopesets = oldstx_829.scopesets != null ? oldstx_829.scopesets : { all: (0, _immutable.List)(), phase: (0, _immutable.Map)() };
		    Object.freeze(this);
		  }
		  static of(token_830) {
		    let stx_831 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return new Syntax(token_830, stx_831);
		  }
		  static from(type_832, value_833) {
		    let stx_834 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

		    if (!Types_782[type_832]) {
		      throw new Error(type_832 + " is not a valid type");
		    } else if (!Types_782[type_832].create) {
		      throw new Error("Cannot create a syntax from type " + type_832);
		    }
		    return Types_782[type_832].create(value_833, stx_834);
		  }
		  static fromNull() {
		    let stx_835 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		    return Syntax.from("null", null, stx_835);
		  }
		  static fromNumber(value_836) {
		    let stx_837 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("number", value_836, stx_837);
		  }
		  static fromString(value_838) {
		    let stx_839 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("string", value_838, stx_839);
		  }
		  static fromPunctuator(value_840) {
		    let stx_841 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("punctuator", value_840, stx_841);
		  }
		  static fromKeyword(value_842) {
		    let stx_843 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("keyword", value_842, stx_843);
		  }
		  static fromIdentifier(value_844) {
		    let stx_845 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("identifier", value_844, stx_845);
		  }
		  static fromRegularExpression(value_846) {
		    let stx_847 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("regularExpression", value_846, stx_847);
		  }
		  static fromBraces(inner_848) {
		    let stx_849 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("braces", inner_848, stx_849);
		  }
		  static fromBrackets(inner_850) {
		    let stx_851 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("brackets", inner_850, stx_851);
		  }
		  static fromParens(inner_852) {
		    let stx_853 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    return Syntax.from("parens", inner_852, stx_853);
		  }
		  resolve(phase_854) {
		    (0, _errors.assert)(phase_854 != null, "must provide a phase to resolve");
		    let allScopes_855 = this.scopesets.all;
		    let stxScopes_856 = this.scopesets.phase.has(phase_854) ? this.scopesets.phase.get(phase_854) : (0, _immutable.List)();
		    stxScopes_856 = allScopes_855.concat(stxScopes_856);
		    if (stxScopes_856.size === 0 || !(this.match("identifier") || this.match("keyword"))) {
		      return this.token.value;
		    }
		    let scope_857 = stxScopes_856.last();
		    let bindings_858 = this.bindings;
		    if (scope_857) {
		      let scopesetBindingList = bindings_858.get(this);
		      if (scopesetBindingList) {
		        let biggestBindingPair = scopesetBindingList.filter(_ref => {
		          let scopes = _ref.scopes;
		          let binding = _ref.binding;

		          return scopes.isSubset(stxScopes_856);
		        }).sort(sizeDecending_781);
		        if (biggestBindingPair.size >= 2 && biggestBindingPair.get(0).scopes.size === biggestBindingPair.get(1).scopes.size) {
		          let debugBase = "{" + stxScopes_856.map(s_859 => s_859.toString()).join(", ") + "}";
		          let debugAmbigousScopesets = biggestBindingPair.map(_ref2 => {
		            let scopes = _ref2.scopes;

		            return "{" + scopes.map(s_860 => s_860.toString()).join(", ") + "}";
		          }).join(", ");
		          throw new Error("Scopeset " + debugBase + " has ambiguous subsets " + debugAmbigousScopesets);
		        } else if (biggestBindingPair.size !== 0) {
		          let bindingStr = biggestBindingPair.get(0).binding.toString();
		          if (_ramdaFantasy.Maybe.isJust(biggestBindingPair.get(0).alias)) {
		            return biggestBindingPair.get(0).alias.getOrElse(null).resolve(phase_854);
		          }
		          return bindingStr;
		        }
		      }
		    }
		    return this.token.value;
		  }
		  val() {
		    (0, _errors.assert)(!this.match("delimiter"), "cannot get the val of a delimiter");
		    if (this.match("string")) {
		      return this.token.str;
		    }
		    if (this.match("template")) {
		      return this.token.items.map(el_861 => {
		        if (el_861 instanceof Syntax && el_861.match("delimiter")) {
		          return "${...}";
		        }
		        return el_861.slice.text;
		      }).join("");
		    }
		    return this.token.value;
		  }
		  lineNumber() {
		    if (!this.match("delimiter")) {
		      return this.token.slice.startLocation.line;
		    } else {
		      return this.token.get(0).lineNumber();
		    }
		  }
		  setLineNumber(line_862) {
		    let newTok_863 = {};
		    if (this.isDelimiter()) {
		      newTok_863 = this.token.map(s_864 => s_864.setLineNumber(line_862));
		    } else {
		      for (let key of Object.keys(this.token)) {
		        newTok_863[key] = this.token[key];
		      }
		      (0, _errors.assert)(newTok_863.slice && newTok_863.slice.startLocation, "all tokens must have line info");
		      newTok_863.slice.startLocation.line = line_862;
		    }
		    return new Syntax(newTok_863, this);
		  }
		  inner() {
		    (0, _errors.assert)(this.match("delimiter"), "can only get the inner of a delimiter");
		    return this.token.slice(1, this.token.size - 1);
		  }
		  addScope(scope_865, bindings_866, phase_867) {
		    let options_868 = arguments.length <= 3 || arguments[3] === undefined ? { flip: false } : arguments[3];

		    let token_869 = this.match("delimiter") ? this.token.map(s_873 => s_873.addScope(scope_865, bindings_866, phase_867, options_868)) : this.token;
		    if (this.match("template")) {
		      token_869 = { type: this.token.type, items: token_869.items.map(it_874 => {
		          if (it_874 instanceof Syntax && it_874.match("delimiter")) {
		            return it_874.addScope(scope_865, bindings_866, phase_867, options_868);
		          }
		          return it_874;
		        }) };
		    }
		    let oldScopeset_870;
		    if (phase_867 === ALL_PHASES_783) {
		      oldScopeset_870 = this.scopesets.all;
		    } else {
		      oldScopeset_870 = this.scopesets.phase.has(phase_867) ? this.scopesets.phase.get(phase_867) : (0, _immutable.List)();
		    }
		    let newScopeset_871;
		    if (options_868.flip) {
		      let index = oldScopeset_870.indexOf(scope_865);
		      if (index !== -1) {
		        newScopeset_871 = oldScopeset_870.remove(index);
		      } else {
		        newScopeset_871 = oldScopeset_870.push(scope_865);
		      }
		    } else {
		      newScopeset_871 = oldScopeset_870.push(scope_865);
		    }
		    let newstx_872 = { bindings: bindings_866, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } };
		    if (phase_867 === ALL_PHASES_783) {
		      newstx_872.scopesets.all = newScopeset_871;
		    } else {
		      newstx_872.scopesets.phase = newstx_872.scopesets.phase.set(phase_867, newScopeset_871);
		    }
		    return new Syntax(token_869, newstx_872);
		  }
		  removeScope(scope_875, phase_876) {
		    let token_877 = this.match("delimiter") ? this.token.map(s_883 => s_883.removeScope(scope_875, phase_876)) : this.token;
		    let phaseScopeset_878 = this.scopesets.phase.has(phase_876) ? this.scopesets.phase.get(phase_876) : (0, _immutable.List)();
		    let allScopeset_879 = this.scopesets.all;
		    let newstx_880 = { bindings: this.bindings, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } };
		    let phaseIndex_881 = phaseScopeset_878.indexOf(scope_875);
		    let allIndex_882 = allScopeset_879.indexOf(scope_875);
		    if (phaseIndex_881 !== -1) {
		      newstx_880.scopesets.phase = this.scopesets.phase.set(phase_876, phaseScopeset_878.remove(phaseIndex_881));
		    } else if (allIndex_882 !== -1) {
		      newstx_880.scopesets.all = allScopeset_879.remove(allIndex_882);
		    }
		    return new Syntax(token_877, newstx_880);
		  }
		  match(type_884, value_885) {
		    if (!Types_782[type_884]) {
		      throw new Error(type_884 + " is an invalid type");
		    }
		    return Types_782[type_884].match(this.token) && (value_885 == null || (value_885 instanceof RegExp ? value_885.test(this.val()) : this.val() == value_885));
		  }
		  isIdentifier(value_886) {
		    return this.match("identifier", value_886);
		  }
		  isAssign(value_887) {
		    return this.match("assign", value_887);
		  }
		  isBooleanLiteral(value_888) {
		    return this.match("boolean", value_888);
		  }
		  isKeyword(value_889) {
		    return this.match("keyword", value_889);
		  }
		  isNullLiteral(value_890) {
		    return this.match("null", value_890);
		  }
		  isNumericLiteral(value_891) {
		    return this.match("number", value_891);
		  }
		  isPunctuator(value_892) {
		    return this.match("punctuator", value_892);
		  }
		  isStringLiteral(value_893) {
		    return this.match("string", value_893);
		  }
		  isRegularExpression(value_894) {
		    return this.match("regularExpression", value_894);
		  }
		  isTemplate(value_895) {
		    return this.match("template", value_895);
		  }
		  isDelimiter(value_896) {
		    return this.match("delimiter", value_896);
		  }
		  isParens(value_897) {
		    return this.match("parens", value_897);
		  }
		  isBraces(value_898) {
		    return this.match("braces", value_898);
		  }
		  isBrackets(value_899) {
		    return this.match("brackets", value_899);
		  }
		  isSyntaxTemplate(value_900) {
		    return this.match("syntaxTemplate", value_900);
		  }
		  isEOF(value_901) {
		    return this.match("eof", value_901);
		  }
		  toString() {
		    if (this.match("delimiter")) {
		      return this.token.map(s_902 => s_902.toString()).join(" ");
		    }
		    if (this.match("string")) {
		      return "'" + this.token.str;
		    }
		    if (this.match("template")) {
		      return this.val();
		    }
		    return this.token.value;
		  }
		}
		exports.default = Syntax;
		exports.Types = Types_782;
		exports.ALL_PHASES = ALL_PHASES_783;
		//# sourceMappingURL=data:application/json;base64,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IjpbImltcG9ydCB7TGlzdCwgTWFwfSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgQmluZGluZ01hcCBmcm9tIFwiLi9iaW5kaW5nLW1hcFwiO1xuaW1wb3J0IHtNYXliZX0gZnJvbSBcInJhbWRhLWZhbnRhc3lcIjtcbmltcG9ydCB7VG9rZW5UeXBlLCBUb2tlbkNsYXNzfSBmcm9tIFwic2hpZnQtcGFyc2VyL2Rpc3QvdG9rZW5pemVyXCI7XG5pbXBvcnQgICogYXMgXyBmcm9tIFwicmFtZGFcIjtcbmNvbnN0IEp1c3RfNzc5ID0gTWF5YmUuSnVzdDtcbmNvbnN0IE5vdGhpbmdfNzgwID0gTWF5YmUuTm90aGluZztcbmZ1bmN0aW9uIHNpemVEZWNlbmRpbmdfNzgxKGFfNzg0LCBiXzc4NSkge1xuICBpZiAoYV83ODQuc2NvcGVzLnNpemUgPiBiXzc4NS5zY29wZXMuc2l6ZSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiXzc4NS5zY29wZXMuc2l6ZSA+IGFfNzg0LnNjb3Blcy5zaXplKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbmxldCBUeXBlc183ODIgPSB7bnVsbDoge21hdGNoOiB0b2tlbl83ODYgPT4gIVR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fNzg2KSAmJiB0b2tlbl83ODYudHlwZSA9PT0gVG9rZW5UeXBlLk5VTEwsIGNyZWF0ZTogKHZhbHVlXzc4Nywgc3R4Xzc4OCkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLk5VTEwsIHZhbHVlOiBudWxsfSwgc3R4Xzc4OCl9LCBudW1iZXI6IHttYXRjaDogdG9rZW5fNzg5ID0+ICFUeXBlc183ODIuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzc4OSkgJiYgdG9rZW5fNzg5LnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuTnVtZXJpY0xpdGVyYWwsIGNyZWF0ZTogKHZhbHVlXzc5MCwgc3R4Xzc5MSkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLk5VTUJFUiwgdmFsdWU6IHZhbHVlXzc5MH0sIHN0eF83OTEpfSwgc3RyaW5nOiB7bWF0Y2g6IHRva2VuXzc5MiA9PiAhVHlwZXNfNzgyLmRlbGltaXRlci5tYXRjaCh0b2tlbl83OTIpICYmIHRva2VuXzc5Mi50eXBlLmtsYXNzID09PSBUb2tlbkNsYXNzLlN0cmluZ0xpdGVyYWwsIGNyZWF0ZTogKHZhbHVlXzc5Mywgc3R4Xzc5NCkgPT4gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLlNUUklORywgc3RyOiB2YWx1ZV83OTN9LCBzdHhfNzk0KX0sIHB1bmN0dWF0b3I6IHttYXRjaDogdG9rZW5fNzk1ID0+ICFUeXBlc183ODIuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzc5NSkgJiYgdG9rZW5fNzk1LnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuUHVuY3R1YXRvciwgY3JlYXRlOiAodmFsdWVfNzk2LCBzdHhfNzk3KSA9PiBuZXcgU3ludGF4KHt0eXBlOiB7a2xhc3M6IFRva2VuQ2xhc3MuUHVuY3R1YXRvciwgbmFtZTogdmFsdWVfNzk2fSwgdmFsdWU6IHZhbHVlXzc5Nn0sIHN0eF83OTcpfSwga2V5d29yZDoge21hdGNoOiB0b2tlbl83OTggPT4gIVR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fNzk4KSAmJiB0b2tlbl83OTgudHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5LZXl3b3JkLCBjcmVhdGU6ICh2YWx1ZV83OTksIHN0eF84MDApID0+IG5ldyBTeW50YXgoe3R5cGU6IHtrbGFzczogVG9rZW5DbGFzcy5LZXl3b3JkLCBuYW1lOiB2YWx1ZV83OTl9LCB2YWx1ZTogdmFsdWVfNzk5fSwgc3R4XzgwMCl9LCBpZGVudGlmaWVyOiB7bWF0Y2g6IHRva2VuXzgwMSA9PiAhVHlwZXNfNzgyLmRlbGltaXRlci5tYXRjaCh0b2tlbl84MDEpICYmIHRva2VuXzgwMS50eXBlLmtsYXNzID09PSBUb2tlbkNsYXNzLklkZW50LCBjcmVhdGU6ICh2YWx1ZV84MDIsIHN0eF84MDMpID0+IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5JREVOVElGSUVSLCB2YWx1ZTogdmFsdWVfODAyfSwgc3R4XzgwMyl9LCByZWd1bGFyRXhwcmVzc2lvbjoge21hdGNoOiB0b2tlbl84MDQgPT4gIVR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODA0KSAmJiB0b2tlbl84MDQudHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5SZWd1bGFyRXhwcmVzc2lvbiwgY3JlYXRlOiAodmFsdWVfODA1LCBzdHhfODA2KSA9PiBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuUkVHRVhQLCB2YWx1ZTogdmFsdWVfODA1fSwgc3R4XzgwNil9LCBicmFjZXM6IHttYXRjaDogdG9rZW5fODA3ID0+IFR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODA3KSAmJiB0b2tlbl84MDcuZ2V0KDApLnRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5MQlJBQ0UsIGNyZWF0ZTogKGlubmVyXzgwOCwgc3R4XzgwOSkgPT4ge1xuICBsZXQgbGVmdF84MTAgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuTEJSQUNFLCB2YWx1ZTogXCJ7XCJ9KTtcbiAgbGV0IHJpZ2h0XzgxMSA9IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5SQlJBQ0UsIHZhbHVlOiBcIn1cIn0pO1xuICByZXR1cm4gbmV3IFN5bnRheChMaXN0Lm9mKGxlZnRfODEwKS5jb25jYXQoaW5uZXJfODA4KS5wdXNoKHJpZ2h0XzgxMSksIHN0eF84MDkpO1xufX0sIGJyYWNrZXRzOiB7bWF0Y2g6IHRva2VuXzgxMiA9PiBUeXBlc183ODIuZGVsaW1pdGVyLm1hdGNoKHRva2VuXzgxMikgJiYgdG9rZW5fODEyLmdldCgwKS50b2tlbi50eXBlID09PSBUb2tlblR5cGUuTEJSQUNLLCBjcmVhdGU6IChpbm5lcl84MTMsIHN0eF84MTQpID0+IHtcbiAgbGV0IGxlZnRfODE1ID0gbmV3IFN5bnRheCh7dHlwZTogVG9rZW5UeXBlLkxCUkFDSywgdmFsdWU6IFwiW1wifSk7XG4gIGxldCByaWdodF84MTYgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuUkJSQUNLLCB2YWx1ZTogXCJdXCJ9KTtcbiAgcmV0dXJuIG5ldyBTeW50YXgoTGlzdC5vZihsZWZ0XzgxNSkuY29uY2F0KGlubmVyXzgxMykucHVzaChyaWdodF84MTYpLCBzdHhfODE0KTtcbn19LCBwYXJlbnM6IHttYXRjaDogdG9rZW5fODE3ID0+IFR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODE3KSAmJiB0b2tlbl84MTcuZ2V0KDApLnRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5MUEFSRU4sIGNyZWF0ZTogKGlubmVyXzgxOCwgc3R4XzgxOSkgPT4ge1xuICBsZXQgbGVmdF84MjAgPSBuZXcgU3ludGF4KHt0eXBlOiBUb2tlblR5cGUuTFBBUkVOLCB2YWx1ZTogXCIoXCJ9KTtcbiAgbGV0IHJpZ2h0XzgyMSA9IG5ldyBTeW50YXgoe3R5cGU6IFRva2VuVHlwZS5SUEFSRU4sIHZhbHVlOiBcIilcIn0pO1xuICByZXR1cm4gbmV3IFN5bnRheChMaXN0Lm9mKGxlZnRfODIwKS5jb25jYXQoaW5uZXJfODE4KS5wdXNoKHJpZ2h0XzgyMSksIHN0eF84MTkpO1xufX0sIGFzc2lnbjoge21hdGNoOiB0b2tlbl84MjIgPT4ge1xuICBpZiAoVHlwZXNfNzgyLnB1bmN0dWF0b3IubWF0Y2godG9rZW5fODIyKSkge1xuICAgIHN3aXRjaCAodG9rZW5fODIyLnZhbHVlKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgY2FzZSBcInw9XCI6XG4gICAgICBjYXNlIFwiXj1cIjpcbiAgICAgIGNhc2UgXCImPVwiOlxuICAgICAgY2FzZSBcIjw8PVwiOlxuICAgICAgY2FzZSBcIj4+PVwiOlxuICAgICAgY2FzZSBcIj4+Pj1cIjpcbiAgICAgIGNhc2UgXCIrPVwiOlxuICAgICAgY2FzZSBcIi09XCI6XG4gICAgICBjYXNlIFwiKj1cIjpcbiAgICAgIGNhc2UgXCIvPVwiOlxuICAgICAgY2FzZSBcIiU9XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59fSwgYm9vbGVhbjoge21hdGNoOiB0b2tlbl84MjMgPT4gIVR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODIzKSAmJiB0b2tlbl84MjMudHlwZSA9PT0gVG9rZW5UeXBlLlRSVUUgfHwgdG9rZW5fODIzLnR5cGUgPT09IFRva2VuVHlwZS5GQUxTRX0sIHRlbXBsYXRlOiB7bWF0Y2g6IHRva2VuXzgyNCA9PiAhVHlwZXNfNzgyLmRlbGltaXRlci5tYXRjaCh0b2tlbl84MjQpICYmIHRva2VuXzgyNC50eXBlID09PSBUb2tlblR5cGUuVEVNUExBVEV9LCBkZWxpbWl0ZXI6IHttYXRjaDogdG9rZW5fODI1ID0+IExpc3QuaXNMaXN0KHRva2VuXzgyNSl9LCBzeW50YXhUZW1wbGF0ZToge21hdGNoOiB0b2tlbl84MjYgPT4gVHlwZXNfNzgyLmRlbGltaXRlci5tYXRjaCh0b2tlbl84MjYpICYmIHRva2VuXzgyNi5nZXQoMCkudmFsKCkgPT09IFwiI2BcIn0sIGVvZjoge21hdGNoOiB0b2tlbl84MjcgPT4gIVR5cGVzXzc4Mi5kZWxpbWl0ZXIubWF0Y2godG9rZW5fODI3KSAmJiB0b2tlbl84MjcudHlwZSA9PT0gVG9rZW5UeXBlLkVPU319O1xuO1xuY29uc3QgQUxMX1BIQVNFU183ODMgPSB7fTtcbjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bnRheCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuXzgyOCwgb2xkc3R4XzgyOSA9IHt9KSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuXzgyODtcbiAgICB0aGlzLmJpbmRpbmdzID0gb2xkc3R4XzgyOS5iaW5kaW5ncyAhPSBudWxsID8gb2xkc3R4XzgyOS5iaW5kaW5ncyA6IG5ldyBCaW5kaW5nTWFwO1xuICAgIHRoaXMuc2NvcGVzZXRzID0gb2xkc3R4XzgyOS5zY29wZXNldHMgIT0gbnVsbCA/IG9sZHN0eF84Mjkuc2NvcGVzZXRzIDoge2FsbDogTGlzdCgpLCBwaGFzZTogTWFwKCl9O1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgc3RhdGljIG9mKHRva2VuXzgzMCwgc3R4XzgzMSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXgodG9rZW5fODMwLCBzdHhfODMxKTtcbiAgfVxuICBzdGF0aWMgZnJvbSh0eXBlXzgzMiwgdmFsdWVfODMzLCBzdHhfODM0ID0ge30pIHtcbiAgICBpZiAoIVR5cGVzXzc4Mlt0eXBlXzgzMl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlXzgzMiArIFwiIGlzIG5vdCBhIHZhbGlkIHR5cGVcIik7XG4gICAgfSBlbHNlIGlmICghVHlwZXNfNzgyW3R5cGVfODMyXS5jcmVhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBzeW50YXggZnJvbSB0eXBlIFwiICsgdHlwZV84MzIpO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZXNfNzgyW3R5cGVfODMyXS5jcmVhdGUodmFsdWVfODMzLCBzdHhfODM0KTtcbiAgfVxuICBzdGF0aWMgZnJvbU51bGwoc3R4XzgzNSA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwibnVsbFwiLCBudWxsLCBzdHhfODM1KTtcbiAgfVxuICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZV84MzYsIHN0eF84MzcgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcIm51bWJlclwiLCB2YWx1ZV84MzYsIHN0eF84MzcpO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlXzgzOCwgc3R4XzgzOSA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwic3RyaW5nXCIsIHZhbHVlXzgzOCwgc3R4XzgzOSk7XG4gIH1cbiAgc3RhdGljIGZyb21QdW5jdHVhdG9yKHZhbHVlXzg0MCwgc3R4Xzg0MSA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwicHVuY3R1YXRvclwiLCB2YWx1ZV84NDAsIHN0eF84NDEpO1xuICB9XG4gIHN0YXRpYyBmcm9tS2V5d29yZCh2YWx1ZV84NDIsIHN0eF84NDMgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcImtleXdvcmRcIiwgdmFsdWVfODQyLCBzdHhfODQzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUlkZW50aWZpZXIodmFsdWVfODQ0LCBzdHhfODQ1ID0ge30pIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oXCJpZGVudGlmaWVyXCIsIHZhbHVlXzg0NCwgc3R4Xzg0NSk7XG4gIH1cbiAgc3RhdGljIGZyb21SZWd1bGFyRXhwcmVzc2lvbih2YWx1ZV84NDYsIHN0eF84NDcgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcInJlZ3VsYXJFeHByZXNzaW9uXCIsIHZhbHVlXzg0Niwgc3R4Xzg0Nyk7XG4gIH1cbiAgc3RhdGljIGZyb21CcmFjZXMoaW5uZXJfODQ4LCBzdHhfODQ5ID0ge30pIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oXCJicmFjZXNcIiwgaW5uZXJfODQ4LCBzdHhfODQ5KTtcbiAgfVxuICBzdGF0aWMgZnJvbUJyYWNrZXRzKGlubmVyXzg1MCwgc3R4Xzg1MSA9IHt9KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKFwiYnJhY2tldHNcIiwgaW5uZXJfODUwLCBzdHhfODUxKTtcbiAgfVxuICBzdGF0aWMgZnJvbVBhcmVucyhpbm5lcl84NTIsIHN0eF84NTMgPSB7fSkge1xuICAgIHJldHVybiBTeW50YXguZnJvbShcInBhcmVuc1wiLCBpbm5lcl84NTIsIHN0eF84NTMpO1xuICB9XG4gIHJlc29sdmUocGhhc2VfODU0KSB7XG4gICAgYXNzZXJ0KHBoYXNlXzg1NCAhPSBudWxsLCBcIm11c3QgcHJvdmlkZSBhIHBoYXNlIHRvIHJlc29sdmVcIik7XG4gICAgbGV0IGFsbFNjb3Blc184NTUgPSB0aGlzLnNjb3Blc2V0cy5hbGw7XG4gICAgbGV0IHN0eFNjb3Blc184NTYgPSB0aGlzLnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfODU0KSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZV84NTQpIDogTGlzdCgpO1xuICAgIHN0eFNjb3Blc184NTYgPSBhbGxTY29wZXNfODU1LmNvbmNhdChzdHhTY29wZXNfODU2KTtcbiAgICBpZiAoc3R4U2NvcGVzXzg1Ni5zaXplID09PSAwIHx8ICEodGhpcy5tYXRjaChcImlkZW50aWZpZXJcIikgfHwgdGhpcy5tYXRjaChcImtleXdvcmRcIikpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi52YWx1ZTtcbiAgICB9XG4gICAgbGV0IHNjb3BlXzg1NyA9IHN0eFNjb3Blc184NTYubGFzdCgpO1xuICAgIGxldCBiaW5kaW5nc184NTggPSB0aGlzLmJpbmRpbmdzO1xuICAgIGlmIChzY29wZV84NTcpIHtcbiAgICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gYmluZGluZ3NfODU4LmdldCh0aGlzKTtcbiAgICAgIGlmIChzY29wZXNldEJpbmRpbmdMaXN0KSB7XG4gICAgICAgIGxldCBiaWdnZXN0QmluZGluZ1BhaXIgPSBzY29wZXNldEJpbmRpbmdMaXN0LmZpbHRlcigoe3Njb3BlcywgYmluZGluZ30pID0+IHtcbiAgICAgICAgICByZXR1cm4gc2NvcGVzLmlzU3Vic2V0KHN0eFNjb3Blc184NTYpO1xuICAgICAgICB9KS5zb3J0KHNpemVEZWNlbmRpbmdfNzgxKTtcbiAgICAgICAgaWYgKGJpZ2dlc3RCaW5kaW5nUGFpci5zaXplID49IDIgJiYgYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5zY29wZXMuc2l6ZSA9PT0gYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgxKS5zY29wZXMuc2l6ZSkge1xuICAgICAgICAgIGxldCBkZWJ1Z0Jhc2UgPSBcIntcIiArIHN0eFNjb3Blc184NTYubWFwKHNfODU5ID0+IHNfODU5LnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuICAgICAgICAgIGxldCBkZWJ1Z0FtYmlnb3VzU2NvcGVzZXRzID0gYmlnZ2VzdEJpbmRpbmdQYWlyLm1hcCgoe3Njb3Blc30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBcIntcIiArIHNjb3Blcy5tYXAoc184NjAgPT4gc184NjAudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3Blc2V0IFwiICsgZGVidWdCYXNlICsgXCIgaGFzIGFtYmlndW91cyBzdWJzZXRzIFwiICsgZGVidWdBbWJpZ291c1Njb3Blc2V0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmlnZ2VzdEJpbmRpbmdQYWlyLnNpemUgIT09IDApIHtcbiAgICAgICAgICBsZXQgYmluZGluZ1N0ciA9IGJpZ2dlc3RCaW5kaW5nUGFpci5nZXQoMCkuYmluZGluZy50b1N0cmluZygpO1xuICAgICAgICAgIGlmIChNYXliZS5pc0p1c3QoYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5hbGlhcykpIHtcbiAgICAgICAgICAgIHJldHVybiBiaWdnZXN0QmluZGluZ1BhaXIuZ2V0KDApLmFsaWFzLmdldE9yRWxzZShudWxsKS5yZXNvbHZlKHBoYXNlXzg1NCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiaW5kaW5nU3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG4gIHZhbCgpIHtcbiAgICBhc3NlcnQoIXRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIiksIFwiY2Fubm90IGdldCB0aGUgdmFsIG9mIGEgZGVsaW1pdGVyXCIpO1xuICAgIGlmICh0aGlzLm1hdGNoKFwic3RyaW5nXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5zdHI7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLml0ZW1zLm1hcChlbF84NjEgPT4ge1xuICAgICAgICBpZiAoZWxfODYxIGluc3RhbmNlb2YgU3ludGF4ICYmIGVsXzg2MS5tYXRjaChcImRlbGltaXRlclwiKSkge1xuICAgICAgICAgIHJldHVybiBcIiR7Li4ufVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbF84NjEuc2xpY2UudGV4dDtcbiAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG4gIGxpbmVOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5zbGljZS5zdGFydExvY2F0aW9uLmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLmdldCgwKS5saW5lTnVtYmVyKCk7XG4gICAgfVxuICB9XG4gIHNldExpbmVOdW1iZXIobGluZV84NjIpIHtcbiAgICBsZXQgbmV3VG9rXzg2MyA9IHt9O1xuICAgIGlmICh0aGlzLmlzRGVsaW1pdGVyKCkpIHtcbiAgICAgIG5ld1Rva184NjMgPSB0aGlzLnRva2VuLm1hcChzXzg2NCA9PiBzXzg2NC5zZXRMaW5lTnVtYmVyKGxpbmVfODYyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnRva2VuKSkge1xuICAgICAgICBuZXdUb2tfODYzW2tleV0gPSB0aGlzLnRva2VuW2tleV07XG4gICAgICB9XG4gICAgICBhc3NlcnQobmV3VG9rXzg2My5zbGljZSAmJiBuZXdUb2tfODYzLnNsaWNlLnN0YXJ0TG9jYXRpb24sIFwiYWxsIHRva2VucyBtdXN0IGhhdmUgbGluZSBpbmZvXCIpO1xuICAgICAgbmV3VG9rXzg2My5zbGljZS5zdGFydExvY2F0aW9uLmxpbmUgPSBsaW5lXzg2MjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTeW50YXgobmV3VG9rXzg2MywgdGhpcyk7XG4gIH1cbiAgaW5uZXIoKSB7XG4gICAgYXNzZXJ0KHRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIiksIFwiY2FuIG9ubHkgZ2V0IHRoZSBpbm5lciBvZiBhIGRlbGltaXRlclwiKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbi5zbGljZSgxLCB0aGlzLnRva2VuLnNpemUgLSAxKTtcbiAgfVxuICBhZGRTY29wZShzY29wZV84NjUsIGJpbmRpbmdzXzg2NiwgcGhhc2VfODY3LCBvcHRpb25zXzg2OCA9IHtmbGlwOiBmYWxzZX0pIHtcbiAgICBsZXQgdG9rZW5fODY5ID0gdGhpcy5tYXRjaChcImRlbGltaXRlclwiKSA/IHRoaXMudG9rZW4ubWFwKHNfODczID0+IHNfODczLmFkZFNjb3BlKHNjb3BlXzg2NSwgYmluZGluZ3NfODY2LCBwaGFzZV84NjcsIG9wdGlvbnNfODY4KSkgOiB0aGlzLnRva2VuO1xuICAgIGlmICh0aGlzLm1hdGNoKFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHRva2VuXzg2OSA9IHt0eXBlOiB0aGlzLnRva2VuLnR5cGUsIGl0ZW1zOiB0b2tlbl84NjkuaXRlbXMubWFwKGl0Xzg3NCA9PiB7XG4gICAgICAgIGlmIChpdF84NzQgaW5zdGFuY2VvZiBTeW50YXggJiYgaXRfODc0Lm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGl0Xzg3NC5hZGRTY29wZShzY29wZV84NjUsIGJpbmRpbmdzXzg2NiwgcGhhc2VfODY3LCBvcHRpb25zXzg2OCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0Xzg3NDtcbiAgICAgIH0pfTtcbiAgICB9XG4gICAgbGV0IG9sZFNjb3Blc2V0Xzg3MDtcbiAgICBpZiAocGhhc2VfODY3ID09PSBBTExfUEhBU0VTXzc4Mykge1xuICAgICAgb2xkU2NvcGVzZXRfODcwID0gdGhpcy5zY29wZXNldHMuYWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRTY29wZXNldF84NzAgPSB0aGlzLnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfODY3KSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZV84NjcpIDogTGlzdCgpO1xuICAgIH1cbiAgICBsZXQgbmV3U2NvcGVzZXRfODcxO1xuICAgIGlmIChvcHRpb25zXzg2OC5mbGlwKSB7XG4gICAgICBsZXQgaW5kZXggPSBvbGRTY29wZXNldF84NzAuaW5kZXhPZihzY29wZV84NjUpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBuZXdTY29wZXNldF84NzEgPSBvbGRTY29wZXNldF84NzAucmVtb3ZlKGluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Njb3Blc2V0Xzg3MSA9IG9sZFNjb3Blc2V0Xzg3MC5wdXNoKHNjb3BlXzg2NSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Njb3Blc2V0Xzg3MSA9IG9sZFNjb3Blc2V0Xzg3MC5wdXNoKHNjb3BlXzg2NSk7XG4gICAgfVxuICAgIGxldCBuZXdzdHhfODcyID0ge2JpbmRpbmdzOiBiaW5kaW5nc184NjYsIHNjb3Blc2V0czoge2FsbDogdGhpcy5zY29wZXNldHMuYWxsLCBwaGFzZTogdGhpcy5zY29wZXNldHMucGhhc2V9fTtcbiAgICBpZiAocGhhc2VfODY3ID09PSBBTExfUEhBU0VTXzc4Mykge1xuICAgICAgbmV3c3R4Xzg3Mi5zY29wZXNldHMuYWxsID0gbmV3U2NvcGVzZXRfODcxO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdzdHhfODcyLnNjb3Blc2V0cy5waGFzZSA9IG5ld3N0eF84NzIuc2NvcGVzZXRzLnBoYXNlLnNldChwaGFzZV84NjcsIG5ld1Njb3Blc2V0Xzg3MSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3ludGF4KHRva2VuXzg2OSwgbmV3c3R4Xzg3Mik7XG4gIH1cbiAgcmVtb3ZlU2NvcGUoc2NvcGVfODc1LCBwaGFzZV84NzYpIHtcbiAgICBsZXQgdG9rZW5fODc3ID0gdGhpcy5tYXRjaChcImRlbGltaXRlclwiKSA/IHRoaXMudG9rZW4ubWFwKHNfODgzID0+IHNfODgzLnJlbW92ZVNjb3BlKHNjb3BlXzg3NSwgcGhhc2VfODc2KSkgOiB0aGlzLnRva2VuO1xuICAgIGxldCBwaGFzZVNjb3Blc2V0Xzg3OCA9IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZV84NzYpID8gdGhpcy5zY29wZXNldHMucGhhc2UuZ2V0KHBoYXNlXzg3NikgOiBMaXN0KCk7XG4gICAgbGV0IGFsbFNjb3Blc2V0Xzg3OSA9IHRoaXMuc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgbmV3c3R4Xzg4MCA9IHtiaW5kaW5nczogdGhpcy5iaW5kaW5ncywgc2NvcGVzZXRzOiB7YWxsOiB0aGlzLnNjb3Blc2V0cy5hbGwsIHBoYXNlOiB0aGlzLnNjb3Blc2V0cy5waGFzZX19O1xuICAgIGxldCBwaGFzZUluZGV4Xzg4MSA9IHBoYXNlU2NvcGVzZXRfODc4LmluZGV4T2Yoc2NvcGVfODc1KTtcbiAgICBsZXQgYWxsSW5kZXhfODgyID0gYWxsU2NvcGVzZXRfODc5LmluZGV4T2Yoc2NvcGVfODc1KTtcbiAgICBpZiAocGhhc2VJbmRleF84ODEgIT09IC0xKSB7XG4gICAgICBuZXdzdHhfODgwLnNjb3Blc2V0cy5waGFzZSA9IHRoaXMuc2NvcGVzZXRzLnBoYXNlLnNldChwaGFzZV84NzYsIHBoYXNlU2NvcGVzZXRfODc4LnJlbW92ZShwaGFzZUluZGV4Xzg4MSkpO1xuICAgIH0gZWxzZSBpZiAoYWxsSW5kZXhfODgyICE9PSAtMSkge1xuICAgICAgbmV3c3R4Xzg4MC5zY29wZXNldHMuYWxsID0gYWxsU2NvcGVzZXRfODc5LnJlbW92ZShhbGxJbmRleF84ODIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN5bnRheCh0b2tlbl84NzcsIG5ld3N0eF84ODApO1xuICB9XG4gIG1hdGNoKHR5cGVfODg0LCB2YWx1ZV84ODUpIHtcbiAgICBpZiAoIVR5cGVzXzc4Mlt0eXBlXzg4NF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlXzg4NCArIFwiIGlzIGFuIGludmFsaWQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVzXzc4Mlt0eXBlXzg4NF0ubWF0Y2godGhpcy50b2tlbikgJiYgKHZhbHVlXzg4NSA9PSBudWxsIHx8ICh2YWx1ZV84ODUgaW5zdGFuY2VvZiBSZWdFeHAgPyB2YWx1ZV84ODUudGVzdCh0aGlzLnZhbCgpKSA6IHRoaXMudmFsKCkgPT0gdmFsdWVfODg1KSk7XG4gIH1cbiAgaXNJZGVudGlmaWVyKHZhbHVlXzg4Nikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiaWRlbnRpZmllclwiLCB2YWx1ZV84ODYpO1xuICB9XG4gIGlzQXNzaWduKHZhbHVlXzg4Nykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiYXNzaWduXCIsIHZhbHVlXzg4Nyk7XG4gIH1cbiAgaXNCb29sZWFuTGl0ZXJhbCh2YWx1ZV84ODgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJvb2xlYW5cIiwgdmFsdWVfODg4KTtcbiAgfVxuICBpc0tleXdvcmQodmFsdWVfODg5KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJrZXl3b3JkXCIsIHZhbHVlXzg4OSk7XG4gIH1cbiAgaXNOdWxsTGl0ZXJhbCh2YWx1ZV84OTApIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcIm51bGxcIiwgdmFsdWVfODkwKTtcbiAgfVxuICBpc051bWVyaWNMaXRlcmFsKHZhbHVlXzg5MSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwibnVtYmVyXCIsIHZhbHVlXzg5MSk7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHZhbHVlXzg5Mikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwicHVuY3R1YXRvclwiLCB2YWx1ZV84OTIpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh2YWx1ZV84OTMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcInN0cmluZ1wiLCB2YWx1ZV84OTMpO1xuICB9XG4gIGlzUmVndWxhckV4cHJlc3Npb24odmFsdWVfODk0KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJyZWd1bGFyRXhwcmVzc2lvblwiLCB2YWx1ZV84OTQpO1xuICB9XG4gIGlzVGVtcGxhdGUodmFsdWVfODk1KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJ0ZW1wbGF0ZVwiLCB2YWx1ZV84OTUpO1xuICB9XG4gIGlzRGVsaW1pdGVyKHZhbHVlXzg5Nikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIsIHZhbHVlXzg5Nik7XG4gIH1cbiAgaXNQYXJlbnModmFsdWVfODk3KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJwYXJlbnNcIiwgdmFsdWVfODk3KTtcbiAgfVxuICBpc0JyYWNlcyh2YWx1ZV84OTgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJyYWNlc1wiLCB2YWx1ZV84OTgpO1xuICB9XG4gIGlzQnJhY2tldHModmFsdWVfODk5KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJicmFja2V0c1wiLCB2YWx1ZV84OTkpO1xuICB9XG4gIGlzU3ludGF4VGVtcGxhdGUodmFsdWVfOTAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJzeW50YXhUZW1wbGF0ZVwiLCB2YWx1ZV85MDApO1xuICB9XG4gIGlzRU9GKHZhbHVlXzkwMSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZW9mXCIsIHZhbHVlXzkwMSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goXCJkZWxpbWl0ZXJcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLm1hcChzXzkwMiA9PiBzXzkwMi50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goXCJzdHJpbmdcIikpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHRoaXMudG9rZW4uc3RyO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaChcInRlbXBsYXRlXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9rZW4udmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7VHlwZXNfNzgyIGFzIFR5cGVzfTtcbmV4cG9ydCB7QUxMX1BIQVNFU183ODMgYXMgQUxMX1BIQVNFU30iXX0=

	/***/ },
	/* 11 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		function expect_316(cond_318, message_319, offendingSyntax_320, rest_321) {
		  if (!cond_318) {
		    let ctx = "";
		    if (rest_321) {
		      let ctx = rest_321.slice(0, 20).map(s_322 => {
		        if (s_322 === offendingSyntax_320) {
		          return "__" + s_322.val() + "__";
		        }
		        return s_322.val();
		      }).join(" ");
		    }
		    throw new Error("[error]: " + message_319 + "\n" + ctx);
		  }
		}
		function assert_317(cond_323, message_324) {
		  if (!cond_323) {
		    throw new Error("[assertion error]: " + message_324);
		  }
		}
		exports.expect = expect_316;
		exports.assert = assert_317;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2Vycm9ycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QixXQUE5QixFQUEyQyxtQkFBM0MsRUFBZ0UsUUFBaEUsRUFBMEU7QUFDeEUsTUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLFFBQUksTUFBTSxFQUFWO0FBQ0EsUUFBSSxRQUFKLEVBQWM7QUFDWixVQUFJLE1BQU0sU0FBUyxLQUFULENBQWUsQ0FBZixFQUFrQixFQUFsQixFQUFzQixHQUF0QixDQUEwQixTQUFTO0FBQzNDLFlBQUksVUFBVSxtQkFBZCxFQUFtQztBQUNqQyxpQkFBTyxPQUFPLE1BQU0sR0FBTixFQUFQLEdBQXFCLElBQTVCO0FBQ0Q7QUFDRCxlQUFPLE1BQU0sR0FBTixFQUFQO0FBQ0QsT0FMUyxFQUtQLElBTE8sQ0FLRixHQUxFLENBQVY7QUFNRDtBQUNELFVBQU0sSUFBSSxLQUFKLENBQVUsY0FBYyxXQUFkLEdBQTRCLElBQTVCLEdBQW1DLEdBQTdDLENBQU47QUFDRDtBQUNGO0FBQ0QsU0FBUyxVQUFULENBQW9CLFFBQXBCLEVBQThCLFdBQTlCLEVBQTJDO0FBQ3pDLE1BQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixVQUFNLElBQUksS0FBSixDQUFVLHdCQUF3QixXQUFsQyxDQUFOO0FBQ0Q7QUFDRjtRQUNxQixNLEdBQWQsVTtRQUNjLE0sR0FBZCxVIiwiZmlsZSI6ImVycm9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4cGVjdF8zMTYoY29uZF8zMTgsIG1lc3NhZ2VfMzE5LCBvZmZlbmRpbmdTeW50YXhfMzIwLCByZXN0XzMyMSkge1xuICBpZiAoIWNvbmRfMzE4KSB7XG4gICAgbGV0IGN0eCA9IFwiXCI7XG4gICAgaWYgKHJlc3RfMzIxKSB7XG4gICAgICBsZXQgY3R4ID0gcmVzdF8zMjEuc2xpY2UoMCwgMjApLm1hcChzXzMyMiA9PiB7XG4gICAgICAgIGlmIChzXzMyMiA9PT0gb2ZmZW5kaW5nU3ludGF4XzMyMCkge1xuICAgICAgICAgIHJldHVybiBcIl9fXCIgKyBzXzMyMi52YWwoKSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc18zMjIudmFsKCk7XG4gICAgICB9KS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW2Vycm9yXTogXCIgKyBtZXNzYWdlXzMxOSArIFwiXFxuXCIgKyBjdHgpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRfMzE3KGNvbmRfMzIzLCBtZXNzYWdlXzMyNCkge1xuICBpZiAoIWNvbmRfMzIzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW2Fzc2VydGlvbiBlcnJvcl06IFwiICsgbWVzc2FnZV8zMjQpO1xuICB9XG59XG5leHBvcnQge2V4cGVjdF8zMTYgYXMgZXhwZWN0fTtcbmV4cG9ydCB7YXNzZXJ0XzMxNyBhcyBhc3NlcnR9Il19

	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _immutable = __webpack_require__(9);

		var _errors = __webpack_require__(11);

		var _ramdaFantasy = __webpack_require__(13);

		var _syntax = __webpack_require__(10);

		class BindingMap {
		  constructor() {
		    this._map = new Map();
		  }
		  add(stx_20, _ref) {
		    let binding = _ref.binding;
		    let phase = _ref.phase;
		    var _ref$skipDup = _ref.skipDup;
		    let skipDup = _ref$skipDup === undefined ? false : _ref$skipDup;

		    let stxName_21 = stx_20.val();
		    let allScopeset_22 = stx_20.scopesets.all;
		    let scopeset_23 = stx_20.scopesets.phase.has(phase) ? stx_20.scopesets.phase.get(phase) : (0, _immutable.List)();
		    scopeset_23 = allScopeset_22.concat(scopeset_23);
		    (0, _errors.assert)(phase != null, "must provide a phase for binding add");
		    if (this._map.has(stxName_21)) {
		      let scopesetBindingList = this._map.get(stxName_21);
		      if (skipDup && scopesetBindingList.some(s_24 => s_24.scopes.equals(scopeset_23))) {
		        return;
		      }
		      this._map.set(stxName_21, scopesetBindingList.push({ scopes: scopeset_23, binding: binding, alias: _ramdaFantasy.Maybe.Nothing() }));
		    } else {
		      this._map.set(stxName_21, _immutable.List.of({ scopes: scopeset_23, binding: binding, alias: _ramdaFantasy.Maybe.Nothing() }));
		    }
		  }
		  addForward(stx_25, forwardStx_26, binding_27, phase_28) {
		    let stxName_29 = stx_25.token.value;
		    let allScopeset_30 = stx_25.scopesets.all;
		    let scopeset_31 = stx_25.scopesets.phase.has(phase_28) ? stx_25.scopesets.phase.get(phase_28) : (0, _immutable.List)();
		    scopeset_31 = allScopeset_30.concat(scopeset_31);
		    (0, _errors.assert)(phase_28 != null, "must provide a phase for binding add");
		    if (this._map.has(stxName_29)) {
		      let scopesetBindingList = this._map.get(stxName_29);
		      this._map.set(stxName_29, scopesetBindingList.push({ scopes: scopeset_31, binding: binding_27, alias: _ramdaFantasy.Maybe.of(forwardStx_26) }));
		    } else {
		      this._map.set(stxName_29, _immutable.List.of({ scopes: scopeset_31, binding: binding_27, alias: _ramdaFantasy.Maybe.of(forwardStx_26) }));
		    }
		  }
		  get(stx_32) {
		    return this._map.get(stx_32.token.value);
		  }
		}
		exports.default = BindingMap;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2JpbmRpbmctbWFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNlLE1BQU0sVUFBTixDQUFpQjtBQUM5QixnQkFBYztBQUNaLFNBQUssSUFBTCxHQUFZLElBQUksR0FBSixFQUFaO0FBQ0Q7QUFDRCxNQUFJLE1BQUosUUFBK0M7QUFBQSxRQUFsQyxPQUFrQyxRQUFsQyxPQUFrQztBQUFBLFFBQXpCLEtBQXlCLFFBQXpCLEtBQXlCO0FBQUEsNEJBQWxCLE9BQWtCO0FBQUEsUUFBbEIsT0FBa0IsZ0NBQVIsS0FBUTs7QUFDN0MsUUFBSSxhQUFhLE9BQU8sR0FBUCxFQUFqQjtBQUNBLFFBQUksaUJBQWlCLE9BQU8sU0FBUCxDQUFpQixHQUF0QztBQUNBLFFBQUksY0FBYyxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBMkIsS0FBM0IsSUFBb0MsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCLENBQTJCLEtBQTNCLENBQXBDLEdBQXdFLHNCQUExRjtBQUNBLGtCQUFjLGVBQWUsTUFBZixDQUFzQixXQUF0QixDQUFkO0FBQ0Esd0JBQU8sU0FBUyxJQUFoQixFQUFzQixzQ0FBdEI7QUFDQSxRQUFJLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxVQUFkLENBQUosRUFBK0I7QUFDN0IsVUFBSSxzQkFBc0IsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLFVBQWQsQ0FBMUI7QUFDQSxVQUFJLFdBQVcsb0JBQW9CLElBQXBCLENBQXlCLFFBQVEsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixXQUFuQixDQUFqQyxDQUFmLEVBQWtGO0FBQ2hGO0FBQ0Q7QUFDRCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixvQkFBb0IsSUFBcEIsQ0FBeUIsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxPQUEvQixFQUF3QyxPQUFPLG9CQUFNLE9BQU4sRUFBL0MsRUFBekIsQ0FBMUI7QUFDRCxLQU5ELE1BTU87QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixnQkFBSyxFQUFMLENBQVEsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxPQUEvQixFQUF3QyxPQUFPLG9CQUFNLE9BQU4sRUFBL0MsRUFBUixDQUExQjtBQUNEO0FBQ0Y7QUFDRCxhQUFXLE1BQVgsRUFBbUIsYUFBbkIsRUFBa0MsVUFBbEMsRUFBOEMsUUFBOUMsRUFBd0Q7QUFDdEQsUUFBSSxhQUFhLE9BQU8sS0FBUCxDQUFhLEtBQTlCO0FBQ0EsUUFBSSxpQkFBaUIsT0FBTyxTQUFQLENBQWlCLEdBQXRDO0FBQ0EsUUFBSSxjQUFjLE9BQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixHQUF2QixDQUEyQixRQUEzQixJQUF1QyxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBMkIsUUFBM0IsQ0FBdkMsR0FBOEUsc0JBQWhHO0FBQ0Esa0JBQWMsZUFBZSxNQUFmLENBQXNCLFdBQXRCLENBQWQ7QUFDQSx3QkFBTyxZQUFZLElBQW5CLEVBQXlCLHNDQUF6QjtBQUNBLFFBQUksS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLFVBQWQsQ0FBSixFQUErQjtBQUM3QixVQUFJLHNCQUFzQixLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxDQUExQjtBQUNBLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxVQUFkLEVBQTBCLG9CQUFvQixJQUFwQixDQUF5QixFQUFDLFFBQVEsV0FBVCxFQUFzQixTQUFTLFVBQS9CLEVBQTJDLE9BQU8sb0JBQU0sRUFBTixDQUFTLGFBQVQsQ0FBbEQsRUFBekIsQ0FBMUI7QUFDRCxLQUhELE1BR087QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsVUFBZCxFQUEwQixnQkFBSyxFQUFMLENBQVEsRUFBQyxRQUFRLFdBQVQsRUFBc0IsU0FBUyxVQUEvQixFQUEyQyxPQUFPLG9CQUFNLEVBQU4sQ0FBUyxhQUFULENBQWxELEVBQVIsQ0FBMUI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxNQUFKLEVBQVk7QUFDVixXQUFPLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxPQUFPLEtBQVAsQ0FBYSxLQUEzQixDQUFQO0FBQ0Q7QUFuQzZCO2tCQUFYLFUiLCJmaWxlIjoiYmluZGluZy1tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCB7ZXhwZWN0LCBhc3NlcnR9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHtNYXliZX0gZnJvbSBcInJhbWRhLWZhbnRhc3lcIjtcbmltcG9ydCB7QUxMX1BIQVNFU30gZnJvbSBcIi4vc3ludGF4XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5kaW5nTWFwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcDtcbiAgfVxuICBhZGQoc3R4XzIwLCB7YmluZGluZywgcGhhc2UsIHNraXBEdXAgPSBmYWxzZX0pIHtcbiAgICBsZXQgc3R4TmFtZV8yMSA9IHN0eF8yMC52YWwoKTtcbiAgICBsZXQgYWxsU2NvcGVzZXRfMjIgPSBzdHhfMjAuc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgc2NvcGVzZXRfMjMgPSBzdHhfMjAuc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZSkgPyBzdHhfMjAuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgc2NvcGVzZXRfMjMgPSBhbGxTY29wZXNldF8yMi5jb25jYXQoc2NvcGVzZXRfMjMpO1xuICAgIGFzc2VydChwaGFzZSAhPSBudWxsLCBcIm11c3QgcHJvdmlkZSBhIHBoYXNlIGZvciBiaW5kaW5nIGFkZFwiKTtcbiAgICBpZiAodGhpcy5fbWFwLmhhcyhzdHhOYW1lXzIxKSkge1xuICAgICAgbGV0IHNjb3Blc2V0QmluZGluZ0xpc3QgPSB0aGlzLl9tYXAuZ2V0KHN0eE5hbWVfMjEpO1xuICAgICAgaWYgKHNraXBEdXAgJiYgc2NvcGVzZXRCaW5kaW5nTGlzdC5zb21lKHNfMjQgPT4gc18yNC5zY29wZXMuZXF1YWxzKHNjb3Blc2V0XzIzKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChzdHhOYW1lXzIxLCBzY29wZXNldEJpbmRpbmdMaXN0LnB1c2goe3Njb3Blczogc2NvcGVzZXRfMjMsIGJpbmRpbmc6IGJpbmRpbmcsIGFsaWFzOiBNYXliZS5Ob3RoaW5nKCl9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yMSwgTGlzdC5vZih7c2NvcGVzOiBzY29wZXNldF8yMywgYmluZGluZzogYmluZGluZywgYWxpYXM6IE1heWJlLk5vdGhpbmcoKX0pKTtcbiAgICB9XG4gIH1cbiAgYWRkRm9yd2FyZChzdHhfMjUsIGZvcndhcmRTdHhfMjYsIGJpbmRpbmdfMjcsIHBoYXNlXzI4KSB7XG4gICAgbGV0IHN0eE5hbWVfMjkgPSBzdHhfMjUudG9rZW4udmFsdWU7XG4gICAgbGV0IGFsbFNjb3Blc2V0XzMwID0gc3R4XzI1LnNjb3Blc2V0cy5hbGw7XG4gICAgbGV0IHNjb3Blc2V0XzMxID0gc3R4XzI1LnNjb3Blc2V0cy5waGFzZS5oYXMocGhhc2VfMjgpID8gc3R4XzI1LnNjb3Blc2V0cy5waGFzZS5nZXQocGhhc2VfMjgpIDogTGlzdCgpO1xuICAgIHNjb3Blc2V0XzMxID0gYWxsU2NvcGVzZXRfMzAuY29uY2F0KHNjb3Blc2V0XzMxKTtcbiAgICBhc3NlcnQocGhhc2VfMjggIT0gbnVsbCwgXCJtdXN0IHByb3ZpZGUgYSBwaGFzZSBmb3IgYmluZGluZyBhZGRcIik7XG4gICAgaWYgKHRoaXMuX21hcC5oYXMoc3R4TmFtZV8yOSkpIHtcbiAgICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gdGhpcy5fbWFwLmdldChzdHhOYW1lXzI5KTtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yOSwgc2NvcGVzZXRCaW5kaW5nTGlzdC5wdXNoKHtzY29wZXM6IHNjb3Blc2V0XzMxLCBiaW5kaW5nOiBiaW5kaW5nXzI3LCBhbGlhczogTWF5YmUub2YoZm9yd2FyZFN0eF8yNil9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZV8yOSwgTGlzdC5vZih7c2NvcGVzOiBzY29wZXNldF8zMSwgYmluZGluZzogYmluZGluZ18yNywgYWxpYXM6IE1heWJlLm9mKGZvcndhcmRTdHhfMjYpfSkpO1xuICAgIH1cbiAgfVxuICBnZXQoc3R4XzMyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc3R4XzMyLnRva2VuLnZhbHVlKTtcbiAgfVxufVxuIl19

	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		module.exports = {
		    Either: __webpack_require__(14),
		    Future: __webpack_require__(17),
		    Identity: __webpack_require__(18),
		    IO: __webpack_require__(19),
		    lift2: __webpack_require__(20),
		    lift3: __webpack_require__(21),
		    Maybe: __webpack_require__(22),
		    Tuple: __webpack_require__(23),
		    Reader: __webpack_require__(24)
		};


	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		var util = __webpack_require__(16);


		function Either(left, right) {
		  switch (arguments.length) {
		    case 0:
		      throw new TypeError('no arguments to Either');
		    case 1:
		      return function(right) {
		        return right == null ? Either.Left(left) : Either.Right(right);
		      };
		    default:
		      return right == null ? Either.Left(left) : Either.Right(right);
		  }
		}

		Either.prototype.map = util.returnThis;

		Either.of = Either.prototype.of = function(value) {
		  return Either.Right(value);
		};

		Either.prototype.chain = util.returnThis; // throw?

		Either.equals = Either.prototype.equals = util.getEquals(Either);


		// Right
		function _Right(x) {
		  this.value = x;
		}
		util.extend(_Right, Either);

		_Right.prototype.map = function(fn) {
		  return new _Right(fn(this.value));
		};

		_Right.prototype.ap = function(that) {
		  return that.map(this.value);
		};

		_Right.prototype.chain = function(f) {
		  return f(this.value);
		};

		_Right.prototype.bimap = function(_, f) {
		  return new _Right(f(this.value));
		};

		_Right.prototype.extend = function(f) {
		  return new _Right(f(this));
		};

		_Right.prototype.toString = function() {
		  return 'Either.Right(' + R.toString(this.value) + ')';
		};

		Either.Right = function(value) {
		  return new _Right(value);
		};


		// Left
		function _Left(x) {
		  this.value = x;
		}
		util.extend(_Left, Either);

		_Left.prototype.ap = function(that) { return that; };

		_Left.prototype.bimap = function(f) {
		  return new _Left(f(this.value));
		};

		_Left.prototype.extend = util.returnThis;

		_Left.prototype.toString = function() {
		  return 'Either.Left(' + R.toString(this.value) + ')';
		};

		Either.Left = function(value) {
		  return new _Left(value);
		};


		module.exports = Either;


	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		//  Ramda v0.17.1
		//  https://github.com/ramda/ramda
		//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
		//  Ramda may be freely distributed under the MIT license.

		;(function() {

		  'use strict';

		  /**
		     * A special placeholder value used to specify "gaps" within curried functions,
		     * allowing partial application of any combination of arguments,
		     * regardless of their positions.
		     *
		     * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2, _)(1, 3)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @constant
		     * @memberOf R
		     * @category Function
		     * @example
		     *
		     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
		     *      greet('Alice'); //=> 'Hello, Alice!'
		     */
		    var __ = { '@@functional/placeholder': true };

		    // jshint unused:vars
		    var _arity = function _arity(n, fn) {
		        // jshint unused:vars
		        switch (n) {
		        case 0:
		            return function () {
		                return fn.apply(this, arguments);
		            };
		        case 1:
		            return function (a0) {
		                return fn.apply(this, arguments);
		            };
		        case 2:
		            return function (a0, a1) {
		                return fn.apply(this, arguments);
		            };
		        case 3:
		            return function (a0, a1, a2) {
		                return fn.apply(this, arguments);
		            };
		        case 4:
		            return function (a0, a1, a2, a3) {
		                return fn.apply(this, arguments);
		            };
		        case 5:
		            return function (a0, a1, a2, a3, a4) {
		                return fn.apply(this, arguments);
		            };
		        case 6:
		            return function (a0, a1, a2, a3, a4, a5) {
		                return fn.apply(this, arguments);
		            };
		        case 7:
		            return function (a0, a1, a2, a3, a4, a5, a6) {
		                return fn.apply(this, arguments);
		            };
		        case 8:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
		                return fn.apply(this, arguments);
		            };
		        case 9:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
		                return fn.apply(this, arguments);
		            };
		        case 10:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
		                return fn.apply(this, arguments);
		            };
		        default:
		            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
		        }
		    };

		    var _cloneRegExp = function _cloneRegExp(pattern) {
		        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
		    };

		    var _complement = function _complement(f) {
		        return function () {
		            return !f.apply(this, arguments);
		        };
		    };

		    /**
		     * Private `concat` function to merge two array-like objects.
		     *
		     * @private
		     * @param {Array|Arguments} [set1=[]] An array-like object.
		     * @param {Array|Arguments} [set2=[]] An array-like object.
		     * @return {Array} A new, merged array.
		     * @example
		     *
		     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
		     */
		    var _concat = function _concat(set1, set2) {
		        set1 = set1 || [];
		        set2 = set2 || [];
		        var idx;
		        var len1 = set1.length;
		        var len2 = set2.length;
		        var result = [];
		        idx = 0;
		        while (idx < len1) {
		            result[result.length] = set1[idx];
		            idx += 1;
		        }
		        idx = 0;
		        while (idx < len2) {
		            result[result.length] = set2[idx];
		            idx += 1;
		        }
		        return result;
		    };

		    var _containsWith = function _containsWith(pred, x, list) {
		        var idx = 0, len = list.length;
		        while (idx < len) {
		            if (pred(x, list[idx])) {
		                return true;
		            }
		            idx += 1;
		        }
		        return false;
		    };

		    /**
		     * Optimized internal two-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry1 = function _curry1(fn) {
		        return function f1(a) {
		            if (arguments.length === 0) {
		                return f1;
		            } else if (a != null && a['@@functional/placeholder'] === true) {
		                return f1;
		            } else {
		                return fn.apply(this, arguments);
		            }
		        };
		    };

		    /**
		     * Optimized internal two-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry2 = function _curry2(fn) {
		        return function f2(a, b) {
		            var n = arguments.length;
		            if (n === 0) {
		                return f2;
		            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
		                return f2;
		            } else if (n === 1) {
		                return _curry1(function (b) {
		                    return fn(a, b);
		                });
		            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
		                return f2;
		            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
		                return _curry1(function (a) {
		                    return fn(a, b);
		                });
		            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
		                return _curry1(function (b) {
		                    return fn(a, b);
		                });
		            } else {
		                return fn(a, b);
		            }
		        };
		    };

		    /**
		     * Optimized internal three-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry3 = function _curry3(fn) {
		        return function f3(a, b, c) {
		            var n = arguments.length;
		            if (n === 0) {
		                return f3;
		            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
		                return f3;
		            } else if (n === 1) {
		                return _curry2(function (b, c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
		                return f3;
		            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
		                return _curry2(function (a, c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
		                return _curry2(function (b, c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 2) {
		                return _curry1(function (c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
		                return f3;
		            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
		                return _curry2(function (a, b) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
		                return _curry2(function (a, c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
		                return _curry2(function (b, c) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
		                return _curry1(function (a) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
		                return _curry1(function (b) {
		                    return fn(a, b, c);
		                });
		            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
		                return _curry1(function (c) {
		                    return fn(a, b, c);
		                });
		            } else {
		                return fn(a, b, c);
		            }
		        };
		    };

		    /**
		     * Internal curryN function.
		     *
		     * @private
		     * @category Function
		     * @param {Number} length The arity of the curried function.
		     * @return {array} An array of arguments received thus far.
		     * @param {Function} fn The function to curry.
		     */
		    var _curryN = function _curryN(length, received, fn) {
		        return function () {
		            var combined = [];
		            var argsIdx = 0;
		            var left = length;
		            var combinedIdx = 0;
		            while (combinedIdx < received.length || argsIdx < arguments.length) {
		                var result;
		                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
		                    result = received[combinedIdx];
		                } else {
		                    result = arguments[argsIdx];
		                    argsIdx += 1;
		                }
		                combined[combinedIdx] = result;
		                if (result == null || result['@@functional/placeholder'] !== true) {
		                    left -= 1;
		                }
		                combinedIdx += 1;
		            }
		            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
		        };
		    };

		    var _filter = function _filter(fn, list) {
		        var idx = 0, len = list.length, result = [];
		        while (idx < len) {
		            if (fn(list[idx])) {
		                result[result.length] = list[idx];
		            }
		            idx += 1;
		        }
		        return result;
		    };

		    var _forceReduced = function _forceReduced(x) {
		        return {
		            '@@transducer/value': x,
		            '@@transducer/reduced': true
		        };
		    };

		    /**
		     * @private
		     * @param {Function} fn The strategy for extracting function names from an object
		     * @return {Function} A function that takes an object and returns an array of function names.
		     */
		    var _functionsWith = function _functionsWith(fn) {
		        return function (obj) {
		            return _filter(function (key) {
		                return typeof obj[key] === 'function';
		            }, fn(obj));
		        };
		    };

		    var _has = function _has(prop, obj) {
		        return Object.prototype.hasOwnProperty.call(obj, prop);
		    };

		    var _identity = function _identity(x) {
		        return x;
		    };

		    /**
		     * Tests whether or not an object is an array.
		     *
		     * @private
		     * @param {*} val The object to test.
		     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
		     * @example
		     *
		     *      _isArray([]); //=> true
		     *      _isArray(null); //=> false
		     *      _isArray({}); //=> false
		     */
		    var _isArray = Array.isArray || function _isArray(val) {
		        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
		    };

		    /**
		     * Determine if the passed argument is an integer.
		     *
		     * @private
		     * @param {*} n
		     * @category Type
		     * @return {Boolean}
		     */
		    var _isInteger = Number.isInteger || function _isInteger(n) {
		        return n << 0 === n;
		    };

		    var _isNumber = function _isNumber(x) {
		        return Object.prototype.toString.call(x) === '[object Number]';
		    };

		    var _isString = function _isString(x) {
		        return Object.prototype.toString.call(x) === '[object String]';
		    };

		    var _isTransformer = function _isTransformer(obj) {
		        return typeof obj['@@transducer/step'] === 'function';
		    };

		    var _map = function _map(fn, list) {
		        var idx = 0, len = list.length, result = Array(len);
		        while (idx < len) {
		            result[idx] = fn(list[idx]);
		            idx += 1;
		        }
		        return result;
		    };

		    var _pipe = function _pipe(f, g) {
		        return function () {
		            return g.call(this, f.apply(this, arguments));
		        };
		    };

		    var _pipeP = function _pipeP(f, g) {
		        return function () {
		            var ctx = this;
		            return f.apply(ctx, arguments).then(function (x) {
		                return g.call(ctx, x);
		            });
		        };
		    };

		    var _quote = function _quote(s) {
		        return '"' + s.replace(/"/g, '\\"') + '"';
		    };

		    var _reduced = function _reduced(x) {
		        return x && x['@@transducer/reduced'] ? x : {
		            '@@transducer/value': x,
		            '@@transducer/reduced': true
		        };
		    };

		    /**
		     * An optimized, private array `slice` implementation.
		     *
		     * @private
		     * @param {Arguments|Array} args The array or arguments object to consider.
		     * @param {Number} [from=0] The array index to slice from, inclusive.
		     * @param {Number} [to=args.length] The array index to slice to, exclusive.
		     * @return {Array} A new, sliced array.
		     * @example
		     *
		     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
		     *
		     *      var firstThreeArgs = function(a, b, c, d) {
		     *        return _slice(arguments, 0, 3);
		     *      };
		     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
		     */
		    var _slice = function _slice(args, from, to) {
		        switch (arguments.length) {
		        case 1:
		            return _slice(args, 0, args.length);
		        case 2:
		            return _slice(args, from, args.length);
		        default:
		            var list = [];
		            var idx = 0;
		            var len = Math.max(0, Math.min(args.length, to) - from);
		            while (idx < len) {
		                list[idx] = args[from + idx];
		                idx += 1;
		            }
		            return list;
		        }
		    };

		    /**
		     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
		     */
		    var _toISOString = function () {
		        var pad = function pad(n) {
		            return (n < 10 ? '0' : '') + n;
		        };
		        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
		            return d.toISOString();
		        } : function _toISOString(d) {
		            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
		        };
		    }();

		    var _xdropRepeatsWith = function () {
		        function XDropRepeatsWith(pred, xf) {
		            this.xf = xf;
		            this.pred = pred;
		            this.lastValue = undefined;
		            this.seenFirstValue = false;
		        }
		        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
		            return this.xf['@@transducer/init']();
		        };
		        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](result);
		        };
		        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
		            var sameAsLast = false;
		            if (!this.seenFirstValue) {
		                this.seenFirstValue = true;
		            } else if (this.pred(this.lastValue, input)) {
		                sameAsLast = true;
		            }
		            this.lastValue = input;
		            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdropRepeatsWith(pred, xf) {
		            return new XDropRepeatsWith(pred, xf);
		        });
		    }();

		    var _xfBase = {
		        init: function () {
		            return this.xf['@@transducer/init']();
		        },
		        result: function (result) {
		            return this.xf['@@transducer/result'](result);
		        }
		    };

		    var _xfilter = function () {
		        function XFilter(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XFilter.prototype['@@transducer/init'] = _xfBase.init;
		        XFilter.prototype['@@transducer/result'] = _xfBase.result;
		        XFilter.prototype['@@transducer/step'] = function (result, input) {
		            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
		        };
		        return _curry2(function _xfilter(f, xf) {
		            return new XFilter(f, xf);
		        });
		    }();

		    var _xfind = function () {
		        function XFind(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.found = false;
		        }
		        XFind.prototype['@@transducer/init'] = _xfBase.init;
		        XFind.prototype['@@transducer/result'] = function (result) {
		            if (!this.found) {
		                result = this.xf['@@transducer/step'](result, void 0);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XFind.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.found = true;
		                result = _reduced(this.xf['@@transducer/step'](result, input));
		            }
		            return result;
		        };
		        return _curry2(function _xfind(f, xf) {
		            return new XFind(f, xf);
		        });
		    }();

		    var _xfindIndex = function () {
		        function XFindIndex(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.idx = -1;
		            this.found = false;
		        }
		        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
		        XFindIndex.prototype['@@transducer/result'] = function (result) {
		            if (!this.found) {
		                result = this.xf['@@transducer/step'](result, -1);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
		            this.idx += 1;
		            if (this.f(input)) {
		                this.found = true;
		                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
		            }
		            return result;
		        };
		        return _curry2(function _xfindIndex(f, xf) {
		            return new XFindIndex(f, xf);
		        });
		    }();

		    var _xfindLast = function () {
		        function XFindLast(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
		        XFindLast.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
		        };
		        XFindLast.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.last = input;
		            }
		            return result;
		        };
		        return _curry2(function _xfindLast(f, xf) {
		            return new XFindLast(f, xf);
		        });
		    }();

		    var _xfindLastIndex = function () {
		        function XFindLastIndex(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.idx = -1;
		            this.lastIdx = -1;
		        }
		        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
		        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
		        };
		        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
		            this.idx += 1;
		            if (this.f(input)) {
		                this.lastIdx = this.idx;
		            }
		            return result;
		        };
		        return _curry2(function _xfindLastIndex(f, xf) {
		            return new XFindLastIndex(f, xf);
		        });
		    }();

		    var _xmap = function () {
		        function XMap(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XMap.prototype['@@transducer/init'] = _xfBase.init;
		        XMap.prototype['@@transducer/result'] = _xfBase.result;
		        XMap.prototype['@@transducer/step'] = function (result, input) {
		            return this.xf['@@transducer/step'](result, this.f(input));
		        };
		        return _curry2(function _xmap(f, xf) {
		            return new XMap(f, xf);
		        });
		    }();

		    var _xtake = function () {
		        function XTake(n, xf) {
		            this.xf = xf;
		            this.n = n;
		        }
		        XTake.prototype['@@transducer/init'] = _xfBase.init;
		        XTake.prototype['@@transducer/result'] = _xfBase.result;
		        XTake.prototype['@@transducer/step'] = function (result, input) {
		            if (this.n === 0) {
		                return _reduced(result);
		            } else {
		                this.n -= 1;
		                return this.xf['@@transducer/step'](result, input);
		            }
		        };
		        return _curry2(function _xtake(n, xf) {
		            return new XTake(n, xf);
		        });
		    }();

		    var _xtakeWhile = function () {
		        function XTakeWhile(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
		        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
		        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
		            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
		        };
		        return _curry2(function _xtakeWhile(f, xf) {
		            return new XTakeWhile(f, xf);
		        });
		    }();

		    var _xwrap = function () {
		        function XWrap(fn) {
		            this.f = fn;
		        }
		        XWrap.prototype['@@transducer/init'] = function () {
		            throw new Error('init not implemented on XWrap');
		        };
		        XWrap.prototype['@@transducer/result'] = function (acc) {
		            return acc;
		        };
		        XWrap.prototype['@@transducer/step'] = function (acc, x) {
		            return this.f(acc, x);
		        };
		        return function _xwrap(fn) {
		            return new XWrap(fn);
		        };
		    }();

		    /**
		     * Adds two numbers. Equivalent to `a + b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Number}
		     * @see R.subtract
		     * @example
		     *
		     *      R.add(2, 3);       //=>  5
		     *      R.add(7)(10);      //=> 17
		     */
		    var add = _curry2(function add(a, b) {
		        return a + b;
		    });

		    /**
		     * Applies a function to the value at the given index of an array,
		     * returning a new copy of the array with the element at the given
		     * index replaced with the result of the function application.
		     * @see R.update
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> a) -> Number -> [a] -> [a]
		     * @param {Function} fn The function to apply.
		     * @param {Number} idx The index.
		     * @param {Array|Arguments} list An array-like object whose value
		     *        at the supplied index will be replaced.
		     * @return {Array} A copy of the supplied array-like object with
		     *         the element at index `idx` replaced with the value
		     *         returned by applying `fn` to the existing element.
		     * @example
		     *
		     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
		     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
		     */
		    var adjust = _curry3(function adjust(fn, idx, list) {
		        if (idx >= list.length || idx < -list.length) {
		            return list;
		        }
		        var start = idx < 0 ? list.length : 0;
		        var _idx = start + idx;
		        var _list = _concat(list);
		        _list[_idx] = fn(list[_idx]);
		        return _list;
		    });

		    /**
		     * Returns a function that always returns the given value. Note that for
		     * non-primitives the value returned is a reference to the original value.
		     *
		     * This function is known as `const`, `constant`, or `K` (for K combinator)
		     * in other languages and libraries.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig a -> (* -> a)
		     * @param {*} val The value to wrap in a function
		     * @return {Function} A Function :: * -> val.
		     * @example
		     *
		     *      var t = R.always('Tee');
		     *      t(); //=> 'Tee'
		     */
		    var always = _curry1(function always(val) {
		        return function () {
		            return val;
		        };
		    });

		    /**
		     * Returns a new list, composed of n-tuples of consecutive elements
		     * If `n` is greater than the length of the list, an empty list is returned.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [[a]]
		     * @param {Number} n The size of the tuples to create
		     * @param {Array} list The list to split into `n`-tuples
		     * @return {Array} The new list.
		     * @example
		     *
		     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
		     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
		     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
		     */
		    var aperture = _curry2(function aperture(n, list) {
		        var idx = 0;
		        var limit = list.length - (n - 1);
		        var acc = new Array(limit >= 0 ? limit : 0);
		        while (idx < limit) {
		            acc[idx] = _slice(list, idx, idx + n);
		            idx += 1;
		        }
		        return acc;
		    });

		    /**
		     * Returns a new list containing the contents of the given list, followed by the given
		     * element.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} el The element to add to the end of the new list.
		     * @param {Array} list The list whose contents will be added to the beginning of the output
		     *        list.
		     * @return {Array} A new list containing the contents of the old list followed by `el`.
		     * @see R.prepend
		     * @example
		     *
		     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
		     *      R.append('tests', []); //=> ['tests']
		     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
		     */
		    var append = _curry2(function append(el, list) {
		        return _concat(list, [el]);
		    });

		    /**
		     * Applies function `fn` to the argument list `args`. This is useful for
		     * creating a fixed-arity function from a variadic function. `fn` should
		     * be a bound function if context is significant.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (*... -> a) -> [*] -> a
		     * @param {Function} fn
		     * @param {Array} args
		     * @return {*}
		     * @see R.call, R.unapply
		     * @example
		     *
		     *      var nums = [1, 2, 3, -99, 42, 6, 7];
		     *      R.apply(Math.max, nums); //=> 42
		     */
		    var apply = _curry2(function apply(fn, args) {
		        return fn.apply(this, args);
		    });

		    /**
		     * Makes a shallow clone of an object, setting or overriding the specified
		     * property with the given value.  Note that this copies and flattens
		     * prototype properties onto the new object as well.  All non-primitive
		     * properties are copied by reference.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig String -> a -> {k: v} -> {k: v}
		     * @param {String} prop the property name to set
		     * @param {*} val the new value
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original except for the specified property.
		     * @see R.dissoc
		     * @example
		     *
		     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
		     */
		    var assoc = _curry3(function assoc(prop, val, obj) {
		        var result = {};
		        for (var p in obj) {
		            result[p] = obj[p];
		        }
		        result[prop] = val;
		        return result;
		    });

		    /**
		     * Makes a shallow clone of an object, setting or overriding the nodes
		     * required to create the given path, and placing the specific value at the
		     * tail end of that path.  Note that this copies and flattens prototype
		     * properties onto the new object as well.  All non-primitive properties
		     * are copied by reference.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [String] -> a -> {k: v} -> {k: v}
		     * @param {Array} path the path to set
		     * @param {*} val the new value
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original except along the specified path.
		     * @see R.dissocPath
		     * @example
		     *
		     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
		     */
		    var assocPath = _curry3(function assocPath(path, val, obj) {
		        switch (path.length) {
		        case 0:
		            return obj;
		        case 1:
		            return assoc(path[0], val, obj);
		        default:
		            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
		        }
		    });

		    /**
		     * Creates a function that is bound to a context.
		     * Note: `R.bind` does not provide the additional argument-binding capabilities of
		     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @category Object
		     * @see R.partial
		     * @sig (* -> *) -> {*} -> (* -> *)
		     * @param {Function} fn The function to bind to context
		     * @param {Object} thisObj The context to bind `fn` to
		     * @return {Function} A function that will execute in the context of `thisObj`.
		     */
		    var bind = _curry2(function bind(fn, thisObj) {
		        return _arity(fn.length, function () {
		            return fn.apply(thisObj, arguments);
		        });
		    });

		    /**
		     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
		     * function if it is false-y and the result of the second function otherwise.  Note that this is
		     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y
		     * value.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
		     * @param {Function} f a predicate
		     * @param {Function} g another predicate
		     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
		     * @see R.and
		     * @example
		     *
		     *      var gt10 = function(x) { return x > 10; };
		     *      var even = function(x) { return x % 2 === 0 };
		     *      var f = R.both(gt10, even);
		     *      f(100); //=> true
		     *      f(101); //=> false
		     */
		    var both = _curry2(function both(f, g) {
		        return function _both() {
		            return f.apply(this, arguments) && g.apply(this, arguments);
		        };
		    });

		    /**
		     * Makes a comparator function out of a function that reports whether the first element is less than the second.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a, b -> Boolean) -> (a, b -> Number)
		     * @param {Function} pred A predicate function of arity two.
		     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
		     * @example
		     *
		     *      var cmp = R.comparator(function(a, b) {
		     *        return a.age < b.age;
		     *      });
		     *      var people = [
		     *        // ...
		     *      ];
		     *      R.sort(cmp, people);
		     */
		    var comparator = _curry1(function comparator(pred) {
		        return function (a, b) {
		            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
		        };
		    });

		    /**
		     * Takes a function `f` and returns a function `g` such that:
		     *
		     *   - applying `g` to zero or more arguments will give __true__ if applying
		     *     the same arguments to `f` gives a logical __false__ value; and
		     *
		     *   - applying `g` to zero or more arguments will give __false__ if applying
		     *     the same arguments to `f` gives a logical __true__ value.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig (*... -> *) -> (*... -> Boolean)
		     * @param {Function} f
		     * @return {Function}
		     * @see R.not
		     * @example
		     *
		     *      var isEven = function(n) { return n % 2 === 0; };
		     *      var isOdd = R.complement(isEven);
		     *      isOdd(21); //=> true
		     *      isOdd(42); //=> false
		     */
		    var complement = _curry1(_complement);

		    /**
		     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
		     * `R.cond` takes a list of [predicate, transform] pairs. All of the
		     * arguments to `fn` are applied to each of the predicates in turn
		     * until one returns a "truthy" value, at which point `fn` returns the
		     * result of applying its arguments to the corresponding transformer.
		     * If none of the predicates matches, `fn` returns undefined.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
		     * @param {Array} pairs
		     * @return {Function}
		     * @example
		     *
		     *      var fn = R.cond([
		     *        [R.equals(0),   R.always('water freezes at 0°C')],
		     *        [R.equals(100), R.always('water boils at 100°C')],
		     *        [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]
		     *      ]);
		     *      fn(0); //=> 'water freezes at 0°C'
		     *      fn(50); //=> 'nothing special happens at 50°C'
		     *      fn(100); //=> 'water boils at 100°C'
		     */
		    var cond = _curry1(function cond(pairs) {
		        return function () {
		            var idx = 0;
		            while (idx < pairs.length) {
		                if (pairs[idx][0].apply(this, arguments)) {
		                    return pairs[idx][1].apply(this, arguments);
		                }
		                idx += 1;
		            }
		        };
		    });

		    /**
		     * Returns `true` if the `x` is found in the `list`, using `pred` as an
		     * equality predicate for `x`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {*} x The item to find
		     * @param {Array} list The list to iterate over
		     * @return {Boolean} `true` if `x` is in `list`, else `false`.
		     * @example
		     *
		     *      var xs = [{x: 12}, {x: 11}, {x: 10}];
		     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true
		     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false
		     */
		    var containsWith = _curry3(_containsWith);

		    /**
		     * Counts the elements of a list according to how many match each value
		     * of a key generated by the supplied function. Returns an object
		     * mapping the keys produced by `fn` to the number of occurrences in
		     * the list. Note that all keys are coerced to strings because of how
		     * JavaScript objects work.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig (a -> String) -> [a] -> {*}
		     * @param {Function} fn The function used to map values to keys.
		     * @param {Array} list The list to count elements from.
		     * @return {Object} An object mapping keys to number of occurrences in the list.
		     * @example
		     *
		     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
		     *      var letters = R.split('', 'abcABCaaaBBc');
		     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
		     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
		     */
		    var countBy = _curry2(function countBy(fn, list) {
		        var counts = {};
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            var key = fn(list[idx]);
		            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
		            idx += 1;
		        }
		        return counts;
		    });

		    /**
		     * Creates an object containing a single key:value pair.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig String -> a -> {String:a}
		     * @param {String} key
		     * @param {*} val
		     * @return {Object}
		     * @example
		     *
		     *      var matchPhrases = R.compose(
		     *        R.createMapEntry('must'),
		     *        R.map(R.createMapEntry('match_phrase'))
		     *      );
		     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
		     */
		    var createMapEntry = _curry2(function createMapEntry(key, val) {
		        var obj = {};
		        obj[key] = val;
		        return obj;
		    });

		    /**
		     * Returns a curried equivalent of the provided function, with the
		     * specified arity. The curried function has two unusual capabilities.
		     * First, its arguments needn't be provided one at a time. If `g` is
		     * `R.curryN(3, f)`, the following are equivalent:
		     *
		     *   - `g(1)(2)(3)`
		     *   - `g(1)(2, 3)`
		     *   - `g(1, 2)(3)`
		     *   - `g(1, 2, 3)`
		     *
		     * Secondly, the special placeholder value `R.__` may be used to specify
		     * "gaps", allowing partial application of any combination of arguments,
		     * regardless of their positions. If `g` is as above and `_` is `R.__`,
		     * the following are equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> (* -> a) -> (* -> a)
		     * @param {Number} length The arity for the returned function.
		     * @param {Function} fn The function to curry.
		     * @return {Function} A new, curried function.
		     * @see R.curry
		     * @example
		     *
		     *      var addFourNumbers = function() {
		     *        return R.sum([].slice.call(arguments, 0, 4));
		     *      };
		     *
		     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);
		     *      var f = curriedAddFourNumbers(1, 2);
		     *      var g = f(3);
		     *      g(4); //=> 10
		     */
		    var curryN = _curry2(function curryN(length, fn) {
		        if (length === 1) {
		            return _curry1(fn);
		        }
		        return _arity(length, _curryN(length, [], fn));
		    });

		    /**
		     * Decrements its argument.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @see R.inc
		     * @example
		     *
		     *      R.dec(42); //=> 41
		     */
		    var dec = add(-1);

		    /**
		     * Returns the second argument if it is not null or undefined. If it is null
		     * or undefined, the first (default) argument is returned.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig a -> b -> a | b
		     * @param {a} val The default value.
		     * @param {b} val The value to return if it is not null or undefined
		     * @return {*} The the second value or the default value
		     * @example
		     *
		     *      var defaultTo42 = defaultTo(42);
		     *
		     *      defaultTo42(null);  //=> 42
		     *      defaultTo42(undefined);  //=> 42
		     *      defaultTo42('Ramda');  //=> 'Ramda'
		     */
		    var defaultTo = _curry2(function defaultTo(d, v) {
		        return v == null ? d : v;
		    });

		    /**
		     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
		     * Duplication is determined according to the value returned by applying the supplied predicate to two list
		     * elements.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @see R.difference
		     * @return {Array} The elements in `list1` that are not in `list2`.
		     * @example
		     *
		     *      function cmp(x, y) { return x.a === y.a; }
		     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
		     *      var l2 = [{a: 3}, {a: 4}];
		     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
		     */
		    var differenceWith = _curry3(function differenceWith(pred, first, second) {
		        var out = [];
		        var idx = 0;
		        var firstLen = first.length;
		        var containsPred = containsWith(pred);
		        while (idx < firstLen) {
		            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
		                out[out.length] = first[idx];
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new object that does not contain a `prop` property.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig String -> {k: v} -> {k: v}
		     * @param {String} prop the name of the property to dissociate
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original but without the specified property
		     * @see R.assoc
		     * @example
		     *
		     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
		     */
		    var dissoc = _curry2(function dissoc(prop, obj) {
		        var result = {};
		        for (var p in obj) {
		            if (p !== prop) {
		                result[p] = obj[p];
		            }
		        }
		        return result;
		    });

		    /**
		     * Makes a shallow clone of an object, omitting the property at the
		     * given path. Note that this copies and flattens prototype properties
		     * onto the new object as well.  All non-primitive properties are copied
		     * by reference.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [String] -> {k: v} -> {k: v}
		     * @param {Array} path the path to set
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object without the property at path
		     * @see R.assocPath
		     * @example
		     *
		     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
		     */
		    var dissocPath = _curry2(function dissocPath(path, obj) {
		        switch (path.length) {
		        case 0:
		            return obj;
		        case 1:
		            return dissoc(path[0], obj);
		        default:
		            var head = path[0];
		            var tail = _slice(path, 1);
		            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
		        }
		    });

		    /**
		     * Divides two numbers. Equivalent to `a / b`.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a / b`.
		     * @see R.multiply
		     * @example
		     *
		     *      R.divide(71, 100); //=> 0.71
		     *
		     *      var half = R.divide(R.__, 2);
		     *      half(42); //=> 21
		     *
		     *      var reciprocal = R.divide(1);
		     *      reciprocal(4);   //=> 0.25
		     */
		    var divide = _curry2(function divide(a, b) {
		        return a / b;
		    });

		    /**
		     * Returns a new list containing all but last the`n` elements of a given list,
		     * passing each value from the right to the supplied predicate function, skipping
		     * elements while the predicate function returns `true`. The predicate function
		     * is passed one argument: (value)*.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.takeLastWhile
		     * @example
		     *
		     *      var lteThree = function(x) {
		     *        return x <= 3;
		     *      };
		     *
		     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2]
		     */
		    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
		        var idx = list.length - 1;
		        while (idx >= 0 && pred(list[idx])) {
		            idx -= 1;
		        }
		        return _slice(list, 0, idx + 1);
		    });

		    /**
		     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
		     * function if it is truth-y and the result of the second function otherwise.  Note that this is
		     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
		     * value.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
		     * @param {Function} f a predicate
		     * @param {Function} g another predicate
		     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
		     * @see R.or
		     * @example
		     *
		     *      var gt10 = function(x) { return x > 10; };
		     *      var even = function(x) { return x % 2 === 0 };
		     *      var f = R.either(gt10, even);
		     *      f(101); //=> true
		     *      f(8); //=> true
		     */
		    var either = _curry2(function either(f, g) {
		        return function _either() {
		            return f.apply(this, arguments) || g.apply(this, arguments);
		        };
		    });

		    /**
		     * Returns the empty value of its argument's type. Ramda defines the empty
		     * value of Array (`[]`), Object (`{}`), and String (`''`). Other types are
		     * supported if they define `<Type>.empty` and/or `<Type>.prototype.empty`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig a -> a
		     * @param {*} x
		     * @return {*}
		     * @example
		     *
		     *      R.empty(Just(42));      //=> Nothing()
		     *      R.empty([1, 2, 3]);     //=> []
		     *      R.empty('unicorns');    //=> ''
		     *      R.empty({x: 1, y: 2});  //=> {}
		     */
		    var empty = _curry1(function empty(x) {
		        if (x != null && typeof x.empty === 'function') {
		            return x.empty();
		        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
		            return x.constructor.empty();
		        } else {
		            switch (Object.prototype.toString.call(x)) {
		            case '[object Array]':
		                return [];
		            case '[object Object]':
		                return {};
		            case '[object String]':
		                return '';
		            }
		        }
		    });

		    /**
		     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
		     * `transformation` functions. All non-primitive properties are copied by reference.
		     *
		     * A `tranformation` function will not be invoked if its corresponding key does not exist in
		     * the evolved object.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
		     * @param {Object} transformations The object specifying transformation functions to apply
		     *        to the object.
		     * @param {Object} object The object to be transformed.
		     * @return {Object} The transformed object.
		     * @example
		     *
		     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
		     *      var transformations = {
		     *        firstName: R.trim,
		     *        lastName: R.trim, // Will not get invoked.
		     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
		     *      };
		     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
		     */
		    var evolve = _curry2(function evolve(transformations, object) {
		        var transformation, key, type, result = {};
		        for (key in object) {
		            transformation = transformations[key];
		            type = typeof transformation;
		            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
		        }
		        return result;
		    });

		    /**
		     * Creates a new object out of a list key-value pairs.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [[k,v]] -> {k: v}
		     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
		     * @return {Object} The object made by pairing up `keys` and `values`.
		     * @see R.toPairs
		     * @example
		     *
		     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
		     */
		    var fromPairs = _curry1(function fromPairs(pairs) {
		        var idx = 0, len = pairs.length, out = {};
		        while (idx < len) {
		            if (_isArray(pairs[idx]) && pairs[idx].length) {
		                out[pairs[idx][0]] = pairs[idx][1];
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns `true` if the first argument is greater than the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @see R.lt
		     * @example
		     *
		     *      R.gt(2, 1); //=> true
		     *      R.gt(2, 2); //=> false
		     *      R.gt(2, 3); //=> false
		     *      R.gt('a', 'z'); //=> false
		     *      R.gt('z', 'a'); //=> true
		     */
		    var gt = _curry2(function gt(a, b) {
		        return a > b;
		    });

		    /**
		     * Returns `true` if the first argument is greater than or equal to the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Boolean}
		     * @see R.lte
		     * @example
		     *
		     *      R.gte(2, 1); //=> true
		     *      R.gte(2, 2); //=> true
		     *      R.gte(2, 3); //=> false
		     *      R.gte('a', 'z'); //=> false
		     *      R.gte('z', 'a'); //=> true
		     */
		    var gte = _curry2(function gte(a, b) {
		        return a >= b;
		    });

		    /**
		     * Returns whether or not an object has an own property with
		     * the specified name
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig s -> {s: x} -> Boolean
		     * @param {String} prop The name of the property to check for.
		     * @param {Object} obj The object to query.
		     * @return {Boolean} Whether the property exists.
		     * @example
		     *
		     *      var hasName = R.has('name');
		     *      hasName({name: 'alice'});   //=> true
		     *      hasName({name: 'bob'});     //=> true
		     *      hasName({});                //=> false
		     *
		     *      var point = {x: 0, y: 0};
		     *      var pointHas = R.has(R.__, point);
		     *      pointHas('x');  //=> true
		     *      pointHas('y');  //=> true
		     *      pointHas('z');  //=> false
		     */
		    var has = _curry2(_has);

		    /**
		     * Returns whether or not an object or its prototype chain has
		     * a property with the specified name
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig s -> {s: x} -> Boolean
		     * @param {String} prop The name of the property to check for.
		     * @param {Object} obj The object to query.
		     * @return {Boolean} Whether the property exists.
		     * @example
		     *
		     *      function Rectangle(width, height) {
		     *        this.width = width;
		     *        this.height = height;
		     *      }
		     *      Rectangle.prototype.area = function() {
		     *        return this.width * this.height;
		     *      };
		     *
		     *      var square = new Rectangle(2, 2);
		     *      R.hasIn('width', square);  //=> true
		     *      R.hasIn('area', square);  //=> true
		     */
		    var hasIn = _curry2(function hasIn(prop, obj) {
		        return prop in obj;
		    });

		    /**
		     * Returns true if its arguments are identical, false otherwise. Values are
		     * identical if they reference the same memory. `NaN` is identical to `NaN`;
		     * `0` and `-0` are not identical.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @example
		     *
		     *      var o = {};
		     *      R.identical(o, o); //=> true
		     *      R.identical(1, 1); //=> true
		     *      R.identical(1, '1'); //=> false
		     *      R.identical([], []); //=> false
		     *      R.identical(0, -0); //=> false
		     *      R.identical(NaN, NaN); //=> true
		     */
		    // SameValue algorithm
		    // Steps 1-5, 7-10
		    // Steps 6.b-6.e: +0 != -0
		    // Step 6.a: NaN == NaN
		    var identical = _curry2(function identical(a, b) {
		        // SameValue algorithm
		        if (a === b) {
		            // Steps 1-5, 7-10
		            // Steps 6.b-6.e: +0 != -0
		            return a !== 0 || 1 / a === 1 / b;
		        } else {
		            // Step 6.a: NaN == NaN
		            return a !== a && b !== b;
		        }
		    });

		    /**
		     * A function that does nothing but return the parameter supplied to it. Good as a default
		     * or placeholder function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig a -> a
		     * @param {*} x The value to return.
		     * @return {*} The input value, `x`.
		     * @example
		     *
		     *      R.identity(1); //=> 1
		     *
		     *      var obj = {};
		     *      R.identity(obj) === obj; //=> true
		     */
		    var identity = _curry1(_identity);

		    /**
		     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
		     * upon the result of the `condition` predicate.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
		     * @param {Function} condition A predicate function
		     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
		     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
		     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
		     *                    function depending upon the result of the `condition` predicate.
		     * @example
		     *
		     *      // Flatten all arrays in the list but leave other values alone.
		     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));
		     *
		     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]
		     *      flattenArrays([[[10], 123], [8, [10]], "hello"]); //=> [[10, 123], [8, 10], "hello"]
		     */
		    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
		        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
		            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
		        });
		    });

		    /**
		     * Increments its argument.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @see R.dec
		     * @example
		     *
		     *      R.inc(42); //=> 43
		     */
		    var inc = add(1);

		    /**
		     * Inserts the supplied element into the list, at index `index`.  _Note
		     * that this is not destructive_: it returns a copy of the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> a -> [a] -> [a]
		     * @param {Number} index The position to insert the element
		     * @param {*} elt The element to insert into the Array
		     * @param {Array} list The list to insert into
		     * @return {Array} A new Array with `elt` inserted at `index`.
		     * @example
		     *
		     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
		     */
		    var insert = _curry3(function insert(idx, elt, list) {
		        idx = idx < list.length && idx >= 0 ? idx : list.length;
		        var result = _slice(list);
		        result.splice(idx, 0, elt);
		        return result;
		    });

		    /**
		     * Inserts the sub-list into the list, at index `index`.  _Note  that this
		     * is not destructive_: it returns a copy of the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [a] -> [a]
		     * @param {Number} index The position to insert the sub-list
		     * @param {Array} elts The sub-list to insert into the Array
		     * @param {Array} list The list to insert the sub-list into
		     * @return {Array} A new Array with `elts` inserted starting at `index`.
		     * @example
		     *
		     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
		     */
		    var insertAll = _curry3(function insertAll(idx, elts, list) {
		        idx = idx < list.length && idx >= 0 ? idx : list.length;
		        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
		    });

		    /**
		     * See if an object (`val`) is an instance of the supplied constructor.
		     * This function will check up the inheritance chain, if any.
		     *
		     * @func
		     * @memberOf R
		     * @category Type
		     * @sig (* -> {*}) -> a -> Boolean
		     * @param {Object} ctor A constructor
		     * @param {*} val The value to test
		     * @return {Boolean}
		     * @example
		     *
		     *      R.is(Object, {}); //=> true
		     *      R.is(Number, 1); //=> true
		     *      R.is(Object, 1); //=> false
		     *      R.is(String, 's'); //=> true
		     *      R.is(String, new String('')); //=> true
		     *      R.is(Object, new String('')); //=> true
		     *      R.is(Object, 's'); //=> false
		     *      R.is(Number, {}); //=> false
		     */
		    var is = _curry2(function is(Ctor, val) {
		        return val != null && val.constructor === Ctor || val instanceof Ctor;
		    });

		    /**
		     * Tests whether or not an object is similar to an array.
		     *
		     * @func
		     * @memberOf R
		     * @category Type
		     * @category List
		     * @sig * -> Boolean
		     * @param {*} x The object to test.
		     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
		     * @example
		     *
		     *      R.isArrayLike([]); //=> true
		     *      R.isArrayLike(true); //=> false
		     *      R.isArrayLike({}); //=> false
		     *      R.isArrayLike({length: 10}); //=> false
		     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
		     */
		    var isArrayLike = _curry1(function isArrayLike(x) {
		        if (_isArray(x)) {
		            return true;
		        }
		        if (!x) {
		            return false;
		        }
		        if (typeof x !== 'object') {
		            return false;
		        }
		        if (x instanceof String) {
		            return false;
		        }
		        if (x.nodeType === 1) {
		            return !!x.length;
		        }
		        if (x.length === 0) {
		            return true;
		        }
		        if (x.length > 0) {
		            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
		        }
		        return false;
		    });

		    /**
		     * Reports whether the list has zero elements.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig [a] -> Boolean
		     * @param {Array} list
		     * @return {Boolean}
		     * @example
		     *
		     *      R.isEmpty([1, 2, 3]);   //=> false
		     *      R.isEmpty([]);          //=> true
		     *      R.isEmpty('');          //=> true
		     *      R.isEmpty(null);        //=> false
		     *      R.isEmpty(R.keys({}));  //=> true
		     *      R.isEmpty({});          //=> false ({} does not have a length property)
		     *      R.isEmpty({length: 0}); //=> true
		     */
		    var isEmpty = _curry1(function isEmpty(list) {
		        return Object(list).length === 0;
		    });

		    /**
		     * Checks if the input value is `null` or `undefined`.
		     *
		     * @func
		     * @memberOf R
		     * @category Type
		     * @sig * -> Boolean
		     * @param {*} x The value to test.
		     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
		     * @example
		     *
		     *      R.isNil(null); //=> true
		     *      R.isNil(undefined); //=> true
		     *      R.isNil(0); //=> false
		     *      R.isNil([]); //=> false
		     */
		    var isNil = _curry1(function isNil(x) {
		        return x == null;
		    });

		    /**
		     * Returns a list containing the names of all the enumerable own
		     * properties of the supplied object.
		     * Note that the order of the output array is not guaranteed to be
		     * consistent across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: v} -> [k]
		     * @param {Object} obj The object to extract properties from
		     * @return {Array} An array of the object's own properties.
		     * @example
		     *
		     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
		     */
		    // cover IE < 9 keys issues
		    var keys = function () {
		        // cover IE < 9 keys issues
		        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
		        var nonEnumerableProps = [
		            'constructor',
		            'valueOf',
		            'isPrototypeOf',
		            'toString',
		            'propertyIsEnumerable',
		            'hasOwnProperty',
		            'toLocaleString'
		        ];
		        var contains = function contains(list, item) {
		            var idx = 0;
		            while (idx < list.length) {
		                if (list[idx] === item) {
		                    return true;
		                }
		                idx += 1;
		            }
		            return false;
		        };
		        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
		            return Object(obj) !== obj ? [] : Object.keys(obj);
		        }) : _curry1(function keys(obj) {
		            if (Object(obj) !== obj) {
		                return [];
		            }
		            var prop, ks = [], nIdx;
		            for (prop in obj) {
		                if (_has(prop, obj)) {
		                    ks[ks.length] = prop;
		                }
		            }
		            if (hasEnumBug) {
		                nIdx = nonEnumerableProps.length - 1;
		                while (nIdx >= 0) {
		                    prop = nonEnumerableProps[nIdx];
		                    if (_has(prop, obj) && !contains(ks, prop)) {
		                        ks[ks.length] = prop;
		                    }
		                    nIdx -= 1;
		                }
		            }
		            return ks;
		        });
		    }();

		    /**
		     * Returns a list containing the names of all the
		     * properties of the supplied object, including prototype properties.
		     * Note that the order of the output array is not guaranteed to be
		     * consistent across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: v} -> [k]
		     * @param {Object} obj The object to extract properties from
		     * @return {Array} An array of the object's own and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.keysIn(f); //=> ['x', 'y']
		     */
		    var keysIn = _curry1(function keysIn(obj) {
		        var prop, ks = [];
		        for (prop in obj) {
		            ks[ks.length] = prop;
		        }
		        return ks;
		    });

		    /**
		     * Returns the number of elements in the array by returning `list.length`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> Number
		     * @param {Array} list The array to inspect.
		     * @return {Number} The length of the array.
		     * @example
		     *
		     *      R.length([]); //=> 0
		     *      R.length([1, 2, 3]); //=> 3
		     */
		    var length = _curry1(function length(list) {
		        return list != null && is(Number, list.length) ? list.length : NaN;
		    });

		    /**
		     * Returns `true` if the first argument is less than the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @see R.gt
		     * @example
		     *
		     *      R.lt(2, 1); //=> false
		     *      R.lt(2, 2); //=> false
		     *      R.lt(2, 3); //=> true
		     *      R.lt('a', 'z'); //=> true
		     *      R.lt('z', 'a'); //=> false
		     */
		    var lt = _curry2(function lt(a, b) {
		        return a < b;
		    });

		    /**
		     * Returns `true` if the first argument is less than or equal to the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Boolean}
		     * @see R.gte
		     * @example
		     *
		     *      R.lte(2, 1); //=> false
		     *      R.lte(2, 2); //=> true
		     *      R.lte(2, 3); //=> true
		     *      R.lte('a', 'z'); //=> true
		     *      R.lte('z', 'a'); //=> false
		     */
		    var lte = _curry2(function lte(a, b) {
		        return a <= b;
		    });

		    /**
		     * The mapAccum function behaves like a combination of map and reduce; it applies a
		     * function to each element of a list, passing an accumulating parameter from left to
		     * right, and returning a final value of this accumulator together with the new list.
		     *
		     * The iterator function receives two arguments, *acc* and *value*, and should return
		     * a tuple *[acc, value]*.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var digits = ['1', '2', '3', '4'];
		     *      var append = function(a, b) {
		     *        return [a + b, a + b];
		     *      }
		     *
		     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
		     */
		    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
		        var idx = 0, len = list.length, result = [], tuple = [acc];
		        while (idx < len) {
		            tuple = fn(tuple[0], list[idx]);
		            result[idx] = tuple[1];
		            idx += 1;
		        }
		        return [
		            tuple[0],
		            result
		        ];
		    });

		    /**
		     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
		     * function to each element of a list, passing an accumulating parameter from right
		     * to left, and returning a final value of this accumulator together with the new list.
		     *
		     * Similar to `mapAccum`, except moves through the input list from the right to the
		     * left.
		     *
		     * The iterator function receives two arguments, *acc* and *value*, and should return
		     * a tuple *[acc, value]*.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var digits = ['1', '2', '3', '4'];
		     *      var append = function(a, b) {
		     *        return [a + b, a + b];
		     *      }
		     *
		     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
		     */
		    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
		        var idx = list.length - 1, result = [], tuple = [acc];
		        while (idx >= 0) {
		            tuple = fn(tuple[0], list[idx]);
		            result[idx] = tuple[1];
		            idx -= 1;
		        }
		        return [
		            tuple[0],
		            result
		        ];
		    });

		    /**
		     * Tests a regular expression against a String. Note that this function
		     * will return an empty array when there are no matches. This differs
		     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
		     * which returns `null` when there are no matches.
		     *
		     * @func
		     * @memberOf R
		     * @see R.test
		     * @category String
		     * @sig RegExp -> String -> [String | Undefined]
		     * @param {RegExp} rx A regular expression.
		     * @param {String} str The string to match against
		     * @return {Array} The list of matches or empty array.
		     * @example
		     *
		     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
		     *      R.match(/a/, 'b'); //=> []
		     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
		     */
		    var match = _curry2(function match(rx, str) {
		        return str.match(rx) || [];
		    });

		    /**
		     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
		     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
		     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
		     * when the modulus is zero or negative.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} m The dividend.
		     * @param {Number} p the modulus.
		     * @return {Number} The result of `b mod a`.
		     * @example
		     *
		     *      R.mathMod(-17, 5);  //=> 3
		     *      R.mathMod(17, 5);   //=> 2
		     *      R.mathMod(17, -5);  //=> NaN
		     *      R.mathMod(17, 0);   //=> NaN
		     *      R.mathMod(17.2, 5); //=> NaN
		     *      R.mathMod(17, 5.3); //=> NaN
		     *
		     *      var clock = R.mathMod(R.__, 12);
		     *      clock(15); //=> 3
		     *      clock(24); //=> 0
		     *
		     *      var seventeenMod = R.mathMod(17);
		     *      seventeenMod(3);  //=> 2
		     *      seventeenMod(4);  //=> 1
		     *      seventeenMod(10); //=> 7
		     */
		    var mathMod = _curry2(function mathMod(m, p) {
		        if (!_isInteger(m)) {
		            return NaN;
		        }
		        if (!_isInteger(p) || p < 1) {
		            return NaN;
		        }
		        return (m % p + p) % p;
		    });

		    /**
		     * Returns the larger of its two arguments.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> a
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.maxBy, R.min
		     * @example
		     *
		     *      R.max(789, 123); //=> 789
		     *      R.max('a', 'b'); //=> 'b'
		     */
		    var max = _curry2(function max(a, b) {
		        return b > a ? b : a;
		    });

		    /**
		     * Takes a function and two values, and returns whichever value produces
		     * the larger result when passed to the provided function.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord b => (a -> b) -> a -> a -> a
		     * @param {Function} f
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.max, R.minBy
		     * @example
		     *
		     *      R.maxBy(function(n) { return n * n; }, -3, 2); //=> -3
		     */
		    var maxBy = _curry3(function maxBy(f, a, b) {
		        return f(b) > f(a) ? b : a;
		    });

		    /**
		     * Create a new object with the own properties of `a`
		     * merged with the own properties of object `b`.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: v} -> {k: v} -> {k: v}
		     * @param {Object} a
		     * @param {Object} b
		     * @return {Object}
		     * @example
		     *
		     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
		     *      //=> { 'name': 'fred', 'age': 40 }
		     *
		     *      var resetToDefault = R.merge(R.__, {x: 0});
		     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
		     */
		    var merge = _curry2(function merge(a, b) {
		        var result = {};
		        var ks = keys(a);
		        var idx = 0;
		        while (idx < ks.length) {
		            result[ks[idx]] = a[ks[idx]];
		            idx += 1;
		        }
		        ks = keys(b);
		        idx = 0;
		        while (idx < ks.length) {
		            result[ks[idx]] = b[ks[idx]];
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns the smaller of its two arguments.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord a => a -> a -> a
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.minBy, R.max
		     * @example
		     *
		     *      R.min(789, 123); //=> 123
		     *      R.min('a', 'b'); //=> 'a'
		     */
		    var min = _curry2(function min(a, b) {
		        return b < a ? b : a;
		    });

		    /**
		     * Takes a function and two values, and returns whichever value produces
		     * the smaller result when passed to the provided function.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord b => (a -> b) -> a -> a -> a
		     * @param {Function} f
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.min, R.maxBy
		     * @example
		     *
		     *      R.minBy(function(n) { return n * n; }, -3, 2); //=> 2
		     */
		    var minBy = _curry3(function minBy(f, a, b) {
		        return f(b) < f(a) ? b : a;
		    });

		    /**
		     * Divides the second parameter by the first and returns the remainder.
		     * Note that this functions preserves the JavaScript-style behavior for
		     * modulo. For mathematical modulo see `mathMod`
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The value to the divide.
		     * @param {Number} b The pseudo-modulus
		     * @return {Number} The result of `b % a`.
		     * @see R.mathMod
		     * @example
		     *
		     *      R.modulo(17, 3); //=> 2
		     *      // JS behavior:
		     *      R.modulo(-17, 3); //=> -2
		     *      R.modulo(17, -3); //=> 2
		     *
		     *      var isOdd = R.modulo(R.__, 2);
		     *      isOdd(42); //=> 0
		     *      isOdd(21); //=> 1
		     */
		    var modulo = _curry2(function modulo(a, b) {
		        return a % b;
		    });

		    /**
		     * Multiplies two numbers. Equivalent to `a * b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a * b`.
		     * @see R.divide
		     * @example
		     *
		     *      var double = R.multiply(2);
		     *      var triple = R.multiply(3);
		     *      double(3);       //=>  6
		     *      triple(4);       //=> 12
		     *      R.multiply(2, 5);  //=> 10
		     */
		    var multiply = _curry2(function multiply(a, b) {
		        return a * b;
		    });

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
		     * parameters. Any extraneous parameters will not be passed to the supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> (* -> a) -> (* -> a)
		     * @param {Number} n The desired arity of the new function.
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity `n`.
		     * @example
		     *
		     *      var takesTwoArgs = function(a, b) {
		     *        return [a, b];
		     *      };
		     *      takesTwoArgs.length; //=> 2
		     *      takesTwoArgs(1, 2); //=> [1, 2]
		     *
		     *      var takesOneArg = R.nAry(1, takesTwoArgs);
		     *      takesOneArg.length; //=> 1
		     *      // Only `n` arguments are passed to the wrapped function
		     *      takesOneArg(1, 2); //=> [1, undefined]
		     */
		    var nAry = _curry2(function nAry(n, fn) {
		        switch (n) {
		        case 0:
		            return function () {
		                return fn.call(this);
		            };
		        case 1:
		            return function (a0) {
		                return fn.call(this, a0);
		            };
		        case 2:
		            return function (a0, a1) {
		                return fn.call(this, a0, a1);
		            };
		        case 3:
		            return function (a0, a1, a2) {
		                return fn.call(this, a0, a1, a2);
		            };
		        case 4:
		            return function (a0, a1, a2, a3) {
		                return fn.call(this, a0, a1, a2, a3);
		            };
		        case 5:
		            return function (a0, a1, a2, a3, a4) {
		                return fn.call(this, a0, a1, a2, a3, a4);
		            };
		        case 6:
		            return function (a0, a1, a2, a3, a4, a5) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5);
		            };
		        case 7:
		            return function (a0, a1, a2, a3, a4, a5, a6) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
		            };
		        case 8:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
		            };
		        case 9:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
		            };
		        case 10:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
		            };
		        default:
		            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
		        }
		    });

		    /**
		     * Negates its argument.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @example
		     *
		     *      R.negate(42); //=> -42
		     */
		    var negate = _curry1(function negate(n) {
		        return -n;
		    });

		    /**
		     * A function that returns the `!` of its argument. It will return `true` when
		     * passed false-y value, and `false` when passed a truth-y one.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig * -> Boolean
		     * @param {*} a any value
		     * @return {Boolean} the logical inverse of passed argument.
		     * @see R.complement
		     * @example
		     *
		     *      R.not(true); //=> false
		     *      R.not(false); //=> true
		     *      R.not(0); => true
		     *      R.not(1); => false
		     */
		    var not = _curry1(function not(a) {
		        return !a;
		    });

		    /**
		     * Returns the nth element of the given list or string.
		     * If n is negative the element at index length + n is returned.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> a | Undefined
		     * @sig Number -> String -> String
		     * @param {Number} offset
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      var list = ['foo', 'bar', 'baz', 'quux'];
		     *      R.nth(1, list); //=> 'bar'
		     *      R.nth(-1, list); //=> 'quux'
		     *      R.nth(-99, list); //=> undefined
		     *
		     *      R.nth('abc', 2); //=> 'c'
		     *      R.nth('abc', 3); //=> ''
		     */
		    var nth = _curry2(function nth(offset, list) {
		        var idx = offset < 0 ? list.length + offset : offset;
		        return _isString(list) ? list.charAt(idx) : list[idx];
		    });

		    /**
		     * Returns a function which returns its nth argument.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> *... -> *
		     * @param {Number} n
		     * @return {Function}
		     * @example
		     *
		     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
		     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
		     */
		    var nthArg = _curry1(function nthArg(n) {
		        return function () {
		            return nth(n, arguments);
		        };
		    });

		    /**
		     * Returns the nth character of the given string.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig Number -> String -> String
		     * @param {Number} n
		     * @param {String} str
		     * @return {String}
		     * @deprecated since v0.16.0
		     * @example
		     *
		     *      R.nthChar(2, 'Ramda'); //=> 'm'
		     *      R.nthChar(-2, 'Ramda'); //=> 'd'
		     */
		    var nthChar = _curry2(function nthChar(n, str) {
		        return str.charAt(n < 0 ? str.length + n : n);
		    });

		    /**
		     * Returns the character code of the nth character of the given string.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig Number -> String -> Number
		     * @param {Number} n
		     * @param {String} str
		     * @return {Number}
		     * @deprecated since v0.16.0
		     * @example
		     *
		     *      R.nthCharCode(2, 'Ramda'); //=> 'm'.charCodeAt(0)
		     *      R.nthCharCode(-2, 'Ramda'); //=> 'd'.charCodeAt(0)
		     */
		    var nthCharCode = _curry2(function nthCharCode(n, str) {
		        return str.charCodeAt(n < 0 ? str.length + n : n);
		    });

		    /**
		     * Returns a singleton array containing the value provided.
		     *
		     * Note this `of` is different from the ES6 `of`; See
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig a -> [a]
		     * @param {*} x any value
		     * @return {Array} An array wrapping `x`.
		     * @example
		     *
		     *      R.of(null); //=> [null]
		     *      R.of([42]); //=> [[42]]
		     */
		    var of = _curry1(function of(x) {
		        return [x];
		    });

		    /**
		     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
		     * `fn` can only ever be called once, no matter how many times the returned function is
		     * invoked.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a... -> b) -> (a... -> b)
		     * @param {Function} fn The function to wrap in a call-only-once wrapper.
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      var addOneOnce = R.once(function(x){ return x + 1; });
		     *      addOneOnce(10); //=> 11
		     *      addOneOnce(addOneOnce(50)); //=> 11
		     */
		    var once = _curry1(function once(fn) {
		        var called = false, result;
		        return function () {
		            if (called) {
		                return result;
		            }
		            called = true;
		            result = fn.apply(this, arguments);
		            return result;
		        };
		    });

		    /**
		     * Returns the result of "setting" the portion of the given data structure
		     * focused by the given lens to the given value.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> (a -> a) -> s -> s
		     * @param {Lens} lens
		     * @param {*} v
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var headLens = R.lensIndex(0);
		     *
		     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
		     */
		    var over = function () {
		        var Identity = function (x) {
		            return {
		                value: x,
		                map: function (f) {
		                    return Identity(f(x));
		                }
		            };
		        };
		        return _curry3(function over(lens, f, x) {
		            return lens(function (y) {
		                return Identity(f(y));
		            })(x).value;
		        });
		    }();

		    /**
		     * Retrieve the value at a given path.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [String] -> {k: v} -> v | Undefined
		     * @param {Array} path The path to use.
		     * @return {*} The data at `path`.
		     * @example
		     *
		     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
		     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
		     */
		    var path = _curry2(function path(paths, obj) {
		        if (obj == null) {
		            return;
		        } else {
		            var val = obj;
		            for (var idx = 0, len = paths.length; idx < len && val != null; idx += 1) {
		                val = val[paths[idx]];
		            }
		            return val;
		        }
		    });

		    /**
		     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
		     * property is ignored.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [k] -> {k: v} -> {k: v}
		     * @param {Array} names an array of String property names to copy onto a new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties from `names` on it.
		     * @see R.omit
		     * @example
		     *
		     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
		     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
		     */
		    var pick = _curry2(function pick(names, obj) {
		        var result = {};
		        var idx = 0;
		        while (idx < names.length) {
		            if (names[idx] in obj) {
		                result[names[idx]] = obj[names[idx]];
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [k] -> {k: v} -> {k: v}
		     * @param {Array} names an array of String property names to copy onto a new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties from `names` on it.
		     * @see R.pick
		     * @example
		     *
		     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
		     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
		     */
		    var pickAll = _curry2(function pickAll(names, obj) {
		        var result = {};
		        var idx = 0;
		        var len = names.length;
		        while (idx < len) {
		            var name = names[idx];
		            result[name] = obj[name];
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a partial copy of an object containing only the keys that
		     * satisfy the supplied predicate.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
		     * @param {Function} pred A predicate to determine whether or not a key
		     *        should be included on the output object.
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties that satisfy `pred`
		     *         on it.
		     * @see R.pick
		     * @example
		     *
		     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }
		     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
		     */
		    var pickBy = _curry2(function pickBy(test, obj) {
		        var result = {};
		        for (var prop in obj) {
		            if (test(obj[prop], prop, obj)) {
		                result[prop] = obj[prop];
		            }
		        }
		        return result;
		    });

		    /**
		     * Returns a new list with the given element at the front, followed by the contents of the
		     * list.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} el The item to add to the head of the output list.
		     * @param {Array} list The array to add to the tail of the output list.
		     * @return {Array} A new array.
		     * @see R.append
		     * @example
		     *
		     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
		     */
		    var prepend = _curry2(function prepend(el, list) {
		        return _concat([el], list);
		    });

		    /**
		     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig s -> {s: a} -> a | Undefined
		     * @param {String} p The property name
		     * @param {Object} obj The object to query
		     * @return {*} The value at `obj.p`.
		     * @example
		     *
		     *      R.prop('x', {x: 100}); //=> 100
		     *      R.prop('x', {}); //=> undefined
		     */
		    var prop = _curry2(function prop(p, obj) {
		        return obj[p];
		    });

		    /**
		     * If the given, non-null object has an own property with the specified name,
		     * returns the value of that property.
		     * Otherwise returns the provided default value.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig a -> String -> Object -> a
		     * @param {*} val The default value.
		     * @param {String} p The name of the property to return.
		     * @param {Object} obj The object to query.
		     * @return {*} The value of given property of the supplied object or the default value.
		     * @example
		     *
		     *      var alice = {
		     *        name: 'ALICE',
		     *        age: 101
		     *      };
		     *      var favorite = R.prop('favoriteLibrary');
		     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
		     *
		     *      favorite(alice);  //=> undefined
		     *      favoriteWithDefault(alice);  //=> 'Ramda'
		     */
		    var propOr = _curry3(function propOr(val, p, obj) {
		        return obj != null && _has(p, obj) ? obj[p] : val;
		    });

		    /**
		     * Returns `true` if the specified object property satisfies the given
		     * predicate; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
		     * @param {Function} pred
		     * @param {String} name
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.propEq
		     * @see R.propIs
		     * @example
		     *
		     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
		     */
		    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
		        return pred(obj[name]);
		    });

		    /**
		     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [k] -> {k: v} -> [v]
		     * @param {Array} ps The property names to fetch
		     * @param {Object} obj The object to query
		     * @return {Array} The corresponding values or partially applied function.
		     * @example
		     *
		     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
		     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
		     *
		     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
		     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
		     */
		    var props = _curry2(function props(ps, obj) {
		        var len = ps.length;
		        var out = [];
		        var idx = 0;
		        while (idx < len) {
		            out[idx] = obj[ps[idx]];
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a list of numbers from `from` (inclusive) to `to`
		     * (exclusive).
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> Number -> [Number]
		     * @param {Number} from The first number in the list.
		     * @param {Number} to One more than the last number in the list.
		     * @return {Array} The list of numbers in tthe set `[a, b)`.
		     * @example
		     *
		     *      R.range(1, 5);    //=> [1, 2, 3, 4]
		     *      R.range(50, 53);  //=> [50, 51, 52]
		     */
		    var range = _curry2(function range(from, to) {
		        if (!(_isNumber(from) && _isNumber(to))) {
		            throw new TypeError('Both arguments to range must be numbers');
		        }
		        var result = [];
		        var n = from;
		        while (n < to) {
		            result.push(n);
		            n += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a single item by iterating through the list, successively calling the iterator
		     * function and passing it an accumulator value and the current value from the array, and
		     * then passing the result to the next call.
		     *
		     * Similar to `reduce`, except moves through the input list from the right to the left.
		     *
		     * The iterator function receives two values: *(acc, value)*
		     *
		     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
		     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a,b -> a) -> a -> [b] -> a
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
		     *      var flattenPairs = function(acc, pair) {
		     *        return acc.concat(pair);
		     *      };
		     *
		     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
		     */
		    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            acc = fn(acc, list[idx]);
		            idx -= 1;
		        }
		        return acc;
		    });

		    /**
		     * Returns a value wrapped to indicate that it is the final value of the
		     * reduce and transduce functions.  The returned value
		     * should be considered a black box: the internal structure is not
		     * guaranteed to be stable.
		     *
		     * Note: this optimization is unavailable to functions not explicitly listed
		     * above.  For instance, it is not currently supported by reduceIndexed,
		     * reduceRight, or reduceRightIndexed.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.reduce, R.transduce
		     * @sig a -> *
		     * @param {*} x The final value of the reduce.
		     * @return {*} The wrapped value.
		     * @example
		     *
		     *      R.reduce(
		     *        R.pipe(R.add, R.ifElse(R.lte(10), R.reduced, R.identity)),
		     *        0,
		     *        [1, 2, 3, 4, 5]) // 10
		     */
		    var reduced = _curry1(_reduced);

		    /**
		     * Removes the sub-list of `list` starting at index `start` and containing
		     * `count` elements.  _Note that this is not destructive_: it returns a
		     * copy of the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> Number -> [a] -> [a]
		     * @param {Number} start The position to start removing elements
		     * @param {Number} count The number of elements to remove
		     * @param {Array} list The list to remove from
		     * @return {Array} A new Array with `count` elements from `start` removed.
		     * @example
		     *
		     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
		     */
		    var remove = _curry3(function remove(start, count, list) {
		        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
		    });

		    /**
		     * Replace a substring or regex match in a string with a replacement.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig RegExp|String -> String -> String -> String
		     * @param {RegExp|String} pattern A regular expression or a substring to match.
		     * @param {String} replacement The string to replace the matches with.
		     * @param {String} str The String to do the search and replacement in.
		     * @return {String} The result.
		     * @example
		     *
		     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
		     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
		     *
		     *      // Use the "g" (global) flag to replace all occurrences:
		     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
		     */
		    var replace = _curry3(function replace(regex, replacement, str) {
		        return str.replace(regex, replacement);
		    });

		    /**
		     * Returns a new list with the same elements as the original list, just
		     * in the reverse order.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [a]
		     * @param {Array} list The list to reverse.
		     * @return {Array} A copy of the list in reverse order.
		     * @example
		     *
		     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
		     *      R.reverse([1, 2]);     //=> [2, 1]
		     *      R.reverse([1]);        //=> [1]
		     *      R.reverse([]);         //=> []
		     */
		    var reverse = _curry1(function reverse(list) {
		        return _slice(list).reverse();
		    });

		    /**
		     * Scan is similar to reduce, but returns a list of successively reduced values from the left
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a,b -> a) -> a -> [b] -> [a]
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {Array} A list of all intermediately reduced values.
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
		     */
		    var scan = _curry3(function scan(fn, acc, list) {
		        var idx = 0, len = list.length, result = [acc];
		        while (idx < len) {
		            acc = fn(acc, list[idx]);
		            result[idx + 1] = acc;
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns the result of "setting" the portion of the given data structure
		     * focused by the given lens to the given value.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> a -> s -> s
		     * @param {Lens} lens
		     * @param {*} v
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
		     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
		     */
		    var set = _curry3(function set(lens, v, x) {
		        return over(lens, always(v), x);
		    });

		    /**
		     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
		     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
		     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a,a -> Number) -> [a] -> [a]
		     * @param {Function} comparator A sorting function :: a -> b -> Int
		     * @param {Array} list The list to sort
		     * @return {Array} a new array with its elements sorted by the comparator function.
		     * @example
		     *
		     *      var diff = function(a, b) { return a - b; };
		     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
		     */
		    var sort = _curry2(function sort(comparator, list) {
		        return _slice(list).sort(comparator);
		    });

		    /**
		     * Sorts the list according to the supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig Ord b => (a -> b) -> [a] -> [a]
		     * @param {Function} fn
		     * @param {Array} list The list to sort.
		     * @return {Array} A new list sorted by the keys generated by `fn`.
		     * @example
		     *
		     *      var sortByFirstItem = R.sortBy(prop(0));
		     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
		     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
		     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
		     *      var alice = {
		     *        name: 'ALICE',
		     *        age: 101
		     *      };
		     *      var bob = {
		     *        name: 'Bob',
		     *        age: -10
		     *      };
		     *      var clara = {
		     *        name: 'clara',
		     *        age: 314.159
		     *      };
		     *      var people = [clara, bob, alice];
		     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
		     */
		    var sortBy = _curry2(function sortBy(fn, list) {
		        return _slice(list).sort(function (a, b) {
		            var aa = fn(a);
		            var bb = fn(b);
		            return aa < bb ? -1 : aa > bb ? 1 : 0;
		        });
		    });

		    /**
		     * Subtracts two numbers. Equivalent to `a - b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a - b`.
		     * @see R.add
		     * @example
		     *
		     *      R.subtract(10, 8); //=> 2
		     *
		     *      var minus5 = R.subtract(R.__, 5);
		     *      minus5(17); //=> 12
		     *
		     *      var complementaryAngle = R.subtract(90);
		     *      complementaryAngle(30); //=> 60
		     *      complementaryAngle(72); //=> 18
		     */
		    var subtract = _curry2(function subtract(a, b) {
		        return a - b;
		    });

		    /**
		     * Returns a new list containing the last `n` elements of a given list, passing each value
		     * to the supplied predicate function, and terminating when the predicate function returns
		     * `false`. Excludes the element that caused the predicate function to fail. The predicate
		     * function is passed one argument: *(value)*.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.dropLastWhile
		     * @example
		     *
		     *      var isNotOne = function(x) {
		     *        return !(x === 1);
		     *      };
		     *
		     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
		     */
		    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0 && fn(list[idx])) {
		            idx -= 1;
		        }
		        return _slice(list, idx + 1, Infinity);
		    });

		    /**
		     * Runs the given function with the supplied object, then returns the object.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a -> *) -> a -> a
		     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
		     * @param {*} x
		     * @return {*} `x`.
		     * @example
		     *
		     *      var sayX = function(x) { console.log('x is ' + x); };
		     *      R.tap(sayX, 100); //=> 100
		     *      //-> 'x is 100'
		     */
		    var tap = _curry2(function tap(fn, x) {
		        fn(x);
		        return x;
		    });

		    /**
		     * Determines whether a given string matches a given regular expression.
		     *
		     * @func
		     * @memberOf R
		     * @see R.match
		     * @category String
		     * @sig RegExp -> String -> Boolean
		     * @param {RegExp} pattern
		     * @param {String} str
		     * @return {Boolean}
		     * @example
		     *
		     *      R.test(/^x/, 'xyz'); //=> true
		     *      R.test(/^y/, 'xyz'); //=> false
		     */
		    var test = _curry2(function test(pattern, str) {
		        return _cloneRegExp(pattern).test(str);
		    });

		    /**
		     * Calls an input function `n` times, returning an array containing the results of those
		     * function calls.
		     *
		     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
		     * gradually incremented to `n - 1`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (i -> a) -> i -> [a]
		     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
		     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
		     * @return {Array} An array containing the return values of all calls to `fn`.
		     * @example
		     *
		     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
		     */
		    var times = _curry2(function times(fn, n) {
		        var len = Number(n);
		        var list = new Array(len);
		        var idx = 0;
		        while (idx < len) {
		            list[idx] = fn(idx);
		            idx += 1;
		        }
		        return list;
		    });

		    /**
		     * Converts an object into an array of key, value arrays.
		     * Only the object's own properties are used.
		     * Note that the order of the output array is not guaranteed to be
		     * consistent across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {String: *} -> [[String,*]]
		     * @param {Object} obj The object to extract from
		     * @return {Array} An array of key, value arrays from the object's own properties.
		     * @see R.fromPairs
		     * @example
		     *
		     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
		     */
		    var toPairs = _curry1(function toPairs(obj) {
		        var pairs = [];
		        for (var prop in obj) {
		            if (_has(prop, obj)) {
		                pairs[pairs.length] = [
		                    prop,
		                    obj[prop]
		                ];
		            }
		        }
		        return pairs;
		    });

		    /**
		     * Converts an object into an array of key, value arrays.
		     * The object's own properties and prototype properties are used.
		     * Note that the order of the output array is not guaranteed to be
		     * consistent across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {String: *} -> [[String,*]]
		     * @param {Object} obj The object to extract from
		     * @return {Array} An array of key, value arrays from the object's own
		     *         and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
		     */
		    var toPairsIn = _curry1(function toPairsIn(obj) {
		        var pairs = [];
		        for (var prop in obj) {
		            pairs[pairs.length] = [
		                prop,
		                obj[prop]
		            ];
		        }
		        return pairs;
		    });

		    /**
		     * Removes (strips) whitespace from both ends of the string.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to trim.
		     * @return {String} Trimmed version of `str`.
		     * @example
		     *
		     *      R.trim('   xyz  '); //=> 'xyz'
		     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
		     */
		    var trim = function () {
		        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
		        var zeroWidth = '\u200B';
		        var hasProtoTrim = typeof String.prototype.trim === 'function';
		        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
		            return _curry1(function trim(str) {
		                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
		                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
		                return str.replace(beginRx, '').replace(endRx, '');
		            });
		        } else {
		            return _curry1(function trim(str) {
		                return str.trim();
		            });
		        }
		    }();

		    /**
		     * Gives a single-word string description of the (native) type of a value, returning such
		     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
		     * Object types any further, reporting them all as 'Object'.
		     *
		     * @func
		     * @memberOf R
		     * @category Type
		     * @sig (* -> {*}) -> String
		     * @param {*} val The value to test
		     * @return {String}
		     * @example
		     *
		     *      R.type({}); //=> "Object"
		     *      R.type(1); //=> "Number"
		     *      R.type(false); //=> "Boolean"
		     *      R.type('s'); //=> "String"
		     *      R.type(null); //=> "Null"
		     *      R.type([]); //=> "Array"
		     *      R.type(/[A-z]/); //=> "RegExp"
		     */
		    var type = _curry1(function type(val) {
		        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
		    });

		    /**
		     * Takes a function `fn`, which takes a single array argument, and returns
		     * a function which:
		     *
		     *   - takes any number of positional arguments;
		     *   - passes these arguments to `fn` as an array; and
		     *   - returns the result.
		     *
		     * In other words, R.unapply derives a variadic function from a function
		     * which takes an array. R.unapply is the inverse of R.apply.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig ([*...] -> a) -> (*... -> a)
		     * @param {Function} fn
		     * @return {Function}
		     * @see R.apply
		     * @example
		     *
		     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
		     */
		    var unapply = _curry1(function unapply(fn) {
		        return function () {
		            return fn(_slice(arguments));
		        };
		    });

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
		     * parameter. Any extraneous parameters will not be passed to the supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (* -> b) -> (a -> b)
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity 1.
		     * @example
		     *
		     *      var takesTwoArgs = function(a, b) {
		     *        return [a, b];
		     *      };
		     *      takesTwoArgs.length; //=> 2
		     *      takesTwoArgs(1, 2); //=> [1, 2]
		     *
		     *      var takesOneArg = R.unary(takesTwoArgs);
		     *      takesOneArg.length; //=> 1
		     *      // Only 1 argument is passed to the wrapped function
		     *      takesOneArg(1, 2); //=> [1, undefined]
		     */
		    var unary = _curry1(function unary(fn) {
		        return nAry(1, fn);
		    });

		    /**
		     * Returns a function of arity `n` from a (manually) curried function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> (a -> b) -> (a -> c)
		     * @param {Number} length The arity for the returned function.
		     * @param {Function} fn The function to uncurry.
		     * @return {Function} A new function.
		     * @see R.curry
		     * @example
		     *
		     *      var addFour = function(a) {
		     *        return function(b) {
		     *          return function(c) {
		     *            return function(d) {
		     *              return a + b + c + d;
		     *            };
		     *          };
		     *        };
		     *      };
		     *
		     *      var uncurriedAddFour = R.uncurryN(4, addFour);
		     *      curriedAddFour(1, 2, 3, 4); //=> 10
		     */
		    var uncurryN = _curry2(function uncurryN(depth, fn) {
		        return curryN(depth, function () {
		            var currentDepth = 1;
		            var value = fn;
		            var idx = 0;
		            var endIdx;
		            while (currentDepth <= depth && typeof value === 'function') {
		                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
		                value = value.apply(this, _slice(arguments, idx, endIdx));
		                currentDepth += 1;
		                idx = endIdx;
		            }
		            return value;
		        });
		    });

		    /**
		     * Builds a list from a seed value. Accepts an iterator function, which returns either false
		     * to stop iteration or an array of length 2 containing the value to add to the resulting
		     * list and the seed to be used in the next call to the iterator function.
		     *
		     * The iterator function receives one argument: *(seed)*.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> [b]) -> * -> [b]
		     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
		     *        either false to quit iteration or an array of length two to proceed. The element
		     *        at index 0 of this array will be added to the resulting array, and the element
		     *        at index 1 will be passed to the next call to `fn`.
		     * @param {*} seed The seed value.
		     * @return {Array} The final list.
		     * @example
		     *
		     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };
		     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
		     */
		    var unfold = _curry2(function unfold(fn, seed) {
		        var pair = fn(seed);
		        var result = [];
		        while (pair && pair.length) {
		            result[result.length] = pair[0];
		            pair = fn(pair[1]);
		        }
		        return result;
		    });

		    /**
		     * Returns a new list containing only one copy of each element in the original list, based
		     * upon the value returned by applying the supplied predicate to two list elements. Prefers
		     * the first item if two items compare equal based on the predicate.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a, a -> Boolean) -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      var strEq = function(a, b) { return String(a) === String(b); };
		     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
		     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
		     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
		     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
		     */
		    var uniqWith = _curry2(function uniqWith(pred, list) {
		        var idx = 0, len = list.length;
		        var result = [], item;
		        while (idx < len) {
		            item = list[idx];
		            if (!_containsWith(pred, item, result)) {
		                result[result.length] = item;
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a new copy of the array with the element at the
		     * provided index replaced with the given value.
		     * @see R.adjust
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> a -> [a] -> [a]
		     * @param {Number} idx The index to update.
		     * @param {*} x The value to exist at the given index of the returned array.
		     * @param {Array|Arguments} list The source array-like object to be updated.
		     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
		     * @example
		     *
		     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
		     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
		     */
		    var update = _curry3(function update(idx, x, list) {
		        return adjust(always(x), idx, list);
		    });

		    /**
		     * Returns a list of all the enumerable own properties of the supplied object.
		     * Note that the order of the output array is not guaranteed across
		     * different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: v} -> [v]
		     * @param {Object} obj The object to extract values from
		     * @return {Array} An array of the values of the object's own properties.
		     * @example
		     *
		     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
		     */
		    var values = _curry1(function values(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var vals = [];
		        var idx = 0;
		        while (idx < len) {
		            vals[idx] = obj[props[idx]];
		            idx += 1;
		        }
		        return vals;
		    });

		    /**
		     * Returns a list of all the properties, including prototype properties,
		     * of the supplied object.
		     * Note that the order of the output array is not guaranteed to be
		     * consistent across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {k: v} -> [v]
		     * @param {Object} obj The object to extract values from
		     * @return {Array} An array of the values of the object's own and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.valuesIn(f); //=> ['X', 'Y']
		     */
		    var valuesIn = _curry1(function valuesIn(obj) {
		        var prop, vs = [];
		        for (prop in obj) {
		            vs[vs.length] = obj[prop];
		        }
		        return vs;
		    });

		    /**
		     * Returns a "view" of the given data structure, determined by the given lens.
		     * The lens's focus determines which portion of the data structure is visible.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> s -> a
		     * @param {Lens} lens
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.view(xLens, {x: 1, y: 2});  //=> 1
		     *      R.view(xLens, {x: 4, y: 2});  //=> 4
		     */
		    var view = function () {
		        var Const = function (x) {
		            return {
		                value: x,
		                map: function () {
		                    return this;
		                }
		            };
		        };
		        return _curry2(function view(lens, x) {
		            return lens(Const)(x).value;
		        });
		    }();

		    /**
		     * Takes a spec object and a test object; returns true if the test satisfies
		     * the spec. Each of the spec's own properties must be a predicate function.
		     * Each predicate is applied to the value of the corresponding property of
		     * the test object. `where` returns true if all the predicates return true,
		     * false otherwise.
		     *
		     * `where` is well suited to declaratively expressing constraints for other
		     * functions such as `filter` and `find`.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
		     * @param {Object} spec
		     * @param {Object} testObj
		     * @return {Boolean}
		     * @example
		     *
		     *      // pred :: Object -> Boolean
		     *      var pred = R.where({
		     *        a: R.equals('foo'),
		     *        b: R.complement(R.equals('bar')),
		     *        x: R.gt(_, 10),
		     *        y: R.lt(_, 20)
		     *      });
		     *
		     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
		     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
		     */
		    var where = _curry2(function where(spec, testObj) {
		        for (var prop in spec) {
		            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
		                return false;
		            }
		        }
		        return true;
		    });

		    /**
		     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
		     * other processing either before the internal function is called or with its results.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
		     * @param {Function} fn The function to wrap.
		     * @param {Function} wrapper The wrapper function.
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      var greet = function(name) {return 'Hello ' + name;};
		     *
		     *      var shoutedGreet = R.wrap(greet, function(gr, name) {
		     *        return gr(name).toUpperCase();
		     *      });
		     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
		     *
		     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
		     *        return gr(name.substring(0, 3));
		     *      });
		     *      shortenedGreet("Robert"); //=> "Hello Rob"
		     */
		    var wrap = _curry2(function wrap(fn, wrapper) {
		        return curryN(fn.length, function () {
		            return wrapper.apply(this, _concat([fn], arguments));
		        });
		    });

		    /**
		     * Creates a new list out of the two supplied by creating each possible
		     * pair from the lists.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [b] -> [[a,b]]
		     * @param {Array} as The first list.
		     * @param {Array} bs The second list.
		     * @return {Array} The list made by combining each possible pair from
		     *         `as` and `bs` into pairs (`[a, b]`).
		     * @example
		     *
		     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
		     */
		    // = xprodWith(prepend); (takes about 3 times as long...)
		    var xprod = _curry2(function xprod(a, b) {
		        // = xprodWith(prepend); (takes about 3 times as long...)
		        var idx = 0;
		        var ilen = a.length;
		        var j;
		        var jlen = b.length;
		        var result = [];
		        while (idx < ilen) {
		            j = 0;
		            while (j < jlen) {
		                result[result.length] = [
		                    a[idx],
		                    b[j]
		                ];
		                j += 1;
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Creates a new list out of the two supplied by pairing up
		     * equally-positioned items from both lists.  The returned list is
		     * truncated to the length of the shorter of the two input lists.
		     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [b] -> [[a,b]]
		     * @param {Array} list1 The first array to consider.
		     * @param {Array} list2 The second array to consider.
		     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
		     * @example
		     *
		     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
		     */
		    var zip = _curry2(function zip(a, b) {
		        var rv = [];
		        var idx = 0;
		        var len = Math.min(a.length, b.length);
		        while (idx < len) {
		            rv[idx] = [
		                a[idx],
		                b[idx]
		            ];
		            idx += 1;
		        }
		        return rv;
		    });

		    /**
		     * Creates a new object out of a list of keys and a list of values.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [String] -> [*] -> {String: *}
		     * @param {Array} keys The array that will be properties on the output object.
		     * @param {Array} values The list of values on the output object.
		     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
		     * @example
		     *
		     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
		     */
		    var zipObj = _curry2(function zipObj(keys, values) {
		        var idx = 0, len = keys.length, out = {};
		        while (idx < len) {
		            out[keys[idx]] = values[idx];
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Creates a new list out of the two supplied by applying the function to
		     * each equally-positioned pair in the lists. The returned list is
		     * truncated to the length of the shorter of the two input lists.
		     *
		     * @function
		     * @memberOf R
		     * @category List
		     * @sig (a,b -> c) -> [a] -> [b] -> [c]
		     * @param {Function} fn The function used to combine the two elements into one value.
		     * @param {Array} list1 The first array to consider.
		     * @param {Array} list2 The second array to consider.
		     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
		     *         using `fn`.
		     * @example
		     *
		     *      var f = function(x, y) {
		     *        // ...
		     *      };
		     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
		     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
		     */
		    var zipWith = _curry3(function zipWith(fn, a, b) {
		        var rv = [], idx = 0, len = Math.min(a.length, b.length);
		        while (idx < len) {
		            rv[idx] = fn(a[idx], b[idx]);
		            idx += 1;
		        }
		        return rv;
		    });

		    /**
		     * A function that always returns `false`. Any passed in parameters are ignored.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig * -> false
		     * @return {Boolean} false
		     * @see R.always, R.T
		     * @example
		     *
		     *      R.F(); //=> false
		     */
		    var F = always(false);

		    /**
		     * A function that always returns `true`. Any passed in parameters are ignored.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig * -> true
		     * @return {Boolean} `true`.
		     * @see R.always, R.F
		     * @example
		     *
		     *      R.T(); //=> true
		     */
		    var T = always(true);

		    /**
		     * Similar to hasMethod, this checks whether a function has a [methodname]
		     * function. If it isn't an array it will execute that function otherwise it will
		     * default to the ramda implementation.
		     *
		     * @private
		     * @param {Function} fn ramda implemtation
		     * @param {String} methodname property to check for a custom implementation
		     * @return {Object} Whatever the return value of the method is.
		     */
		    var _checkForMethod = function _checkForMethod(methodname, fn) {
		        return function () {
		            var length = arguments.length;
		            if (length === 0) {
		                return fn();
		            }
		            var obj = arguments[length - 1];
		            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
		        };
		    };

		    /**
		     * Copies an object.
		     *
		     * @private
		     * @param {*} value The value to be copied
		     * @param {Array} refFrom Array containing the source references
		     * @param {Array} refTo Array containing the copied source references
		     * @return {*} The copied value.
		     */
		    var _clone = function _clone(value, refFrom, refTo) {
		        var copy = function copy(copiedValue) {
		            var len = refFrom.length;
		            var idx = 0;
		            while (idx < len) {
		                if (value === refFrom[idx]) {
		                    return refTo[idx];
		                }
		                idx += 1;
		            }
		            refFrom[idx + 1] = value;
		            refTo[idx + 1] = copiedValue;
		            for (var key in value) {
		                copiedValue[key] = _clone(value[key], refFrom, refTo);
		            }
		            return copiedValue;
		        };
		        switch (type(value)) {
		        case 'Object':
		            return copy({});
		        case 'Array':
		            return copy([]);
		        case 'Date':
		            return new Date(value);
		        case 'RegExp':
		            return _cloneRegExp(value);
		        default:
		            return value;
		        }
		    };

		    var _createPartialApplicator = function _createPartialApplicator(concat) {
		        return function (fn) {
		            var args = _slice(arguments, 1);
		            return _arity(Math.max(0, fn.length - args.length), function () {
		                return fn.apply(this, concat(args, arguments));
		            });
		        };
		    };

		    /**
		     * Returns a function that dispatches with different strategies based on the
		     * object in list position (last argument). If it is an array, executes [fn].
		     * Otherwise, if it has a  function with [methodname], it will execute that
		     * function (functor case). Otherwise, if it is a transformer, uses transducer
		     * [xf] to return a new transformer (transducer case). Otherwise, it will
		     * default to executing [fn].
		     *
		     * @private
		     * @param {String} methodname property to check for a custom implementation
		     * @param {Function} xf transducer to initialize if object is transformer
		     * @param {Function} fn default ramda implementation
		     * @return {Function} A function that dispatches on object in list position
		     */
		    var _dispatchable = function _dispatchable(methodname, xf, fn) {
		        return function () {
		            var length = arguments.length;
		            if (length === 0) {
		                return fn();
		            }
		            var obj = arguments[length - 1];
		            if (!_isArray(obj)) {
		                var args = _slice(arguments, 0, length - 1);
		                if (typeof obj[methodname] === 'function') {
		                    return obj[methodname].apply(obj, args);
		                }
		                if (_isTransformer(obj)) {
		                    var transducer = xf.apply(null, args);
		                    return transducer(obj);
		                }
		            }
		            return fn.apply(this, arguments);
		        };
		    };

		    // The algorithm used to handle cyclic structures is
		    // inspired by underscore's isEqual
		    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
		    var _equals = function _equals(a, b, stackA, stackB) {
		        var typeA = type(a);
		        if (typeA !== type(b)) {
		            return false;
		        }
		        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
		            return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
		        }
		        if (identical(a, b)) {
		            return true;
		        }
		        if (typeA === 'RegExp') {
		            // RegExp equality algorithm: http://stackoverflow.com/a/10776635
		            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
		        }
		        if (Object(a) === a) {
		            if (typeA === 'Date' && a.getTime() !== b.getTime()) {
		                return false;
		            }
		            var keysA = keys(a);
		            if (keysA.length !== keys(b).length) {
		                return false;
		            }
		            var idx = stackA.length - 1;
		            while (idx >= 0) {
		                if (stackA[idx] === a) {
		                    return stackB[idx] === b;
		                }
		                idx -= 1;
		            }
		            stackA[stackA.length] = a;
		            stackB[stackB.length] = b;
		            idx = keysA.length - 1;
		            while (idx >= 0) {
		                var key = keysA[idx];
		                if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
		                    return false;
		                }
		                idx -= 1;
		            }
		            stackA.pop();
		            stackB.pop();
		            return true;
		        }
		        return false;
		    };

		    /**
		     * Private function that determines whether or not a provided object has a given method.
		     * Does not ignore methods stored on the object's prototype chain. Used for dynamically
		     * dispatching Ramda methods to non-Array objects.
		     *
		     * @private
		     * @param {String} methodName The name of the method to check for.
		     * @param {Object} obj The object to test.
		     * @return {Boolean} `true` has a given method, `false` otherwise.
		     * @example
		     *
		     *      var person = { name: 'John' };
		     *      person.shout = function() { alert(this.name); };
		     *
		     *      _hasMethod('shout', person); //=> true
		     *      _hasMethod('foo', person); //=> false
		     */
		    var _hasMethod = function _hasMethod(methodName, obj) {
		        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
		    };

		    /**
		     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
		     * based on the flag passed in.
		     *
		     * @private
		     */
		    var _makeFlat = function _makeFlat(recursive) {
		        return function flatt(list) {
		            var value, result = [], idx = 0, j, ilen = list.length, jlen;
		            while (idx < ilen) {
		                if (isArrayLike(list[idx])) {
		                    value = recursive ? flatt(list[idx]) : list[idx];
		                    j = 0;
		                    jlen = value.length;
		                    while (j < jlen) {
		                        result[result.length] = value[j];
		                        j += 1;
		                    }
		                } else {
		                    result[result.length] = list[idx];
		                }
		                idx += 1;
		            }
		            return result;
		        };
		    };

		    var _reduce = function () {
		        function _arrayReduce(xf, acc, list) {
		            var idx = 0, len = list.length;
		            while (idx < len) {
		                acc = xf['@@transducer/step'](acc, list[idx]);
		                if (acc && acc['@@transducer/reduced']) {
		                    acc = acc['@@transducer/value'];
		                    break;
		                }
		                idx += 1;
		            }
		            return xf['@@transducer/result'](acc);
		        }
		        function _iterableReduce(xf, acc, iter) {
		            var step = iter.next();
		            while (!step.done) {
		                acc = xf['@@transducer/step'](acc, step.value);
		                if (acc && acc['@@transducer/reduced']) {
		                    acc = acc['@@transducer/value'];
		                    break;
		                }
		                step = iter.next();
		            }
		            return xf['@@transducer/result'](acc);
		        }
		        function _methodReduce(xf, acc, obj) {
		            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
		        }
		        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
		        return function _reduce(fn, acc, list) {
		            if (typeof fn === 'function') {
		                fn = _xwrap(fn);
		            }
		            if (isArrayLike(list)) {
		                return _arrayReduce(fn, acc, list);
		            }
		            if (typeof list.reduce === 'function') {
		                return _methodReduce(fn, acc, list);
		            }
		            if (list[symIterator] != null) {
		                return _iterableReduce(fn, acc, list[symIterator]());
		            }
		            if (typeof list.next === 'function') {
		                return _iterableReduce(fn, acc, list);
		            }
		            throw new TypeError('reduce: list must be array or iterable');
		        };
		    }();

		    var _stepCat = function () {
		        var _stepCatArray = {
		            '@@transducer/init': Array,
		            '@@transducer/step': function (xs, x) {
		                return _concat(xs, [x]);
		            },
		            '@@transducer/result': _identity
		        };
		        var _stepCatString = {
		            '@@transducer/init': String,
		            '@@transducer/step': function (a, b) {
		                return a + b;
		            },
		            '@@transducer/result': _identity
		        };
		        var _stepCatObject = {
		            '@@transducer/init': Object,
		            '@@transducer/step': function (result, input) {
		                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
		            },
		            '@@transducer/result': _identity
		        };
		        return function _stepCat(obj) {
		            if (_isTransformer(obj)) {
		                return obj;
		            }
		            if (isArrayLike(obj)) {
		                return _stepCatArray;
		            }
		            if (typeof obj === 'string') {
		                return _stepCatString;
		            }
		            if (typeof obj === 'object') {
		                return _stepCatObject;
		            }
		            throw new Error('Cannot create transformer for ' + obj);
		        };
		    }();

		    var _xall = function () {
		        function XAll(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.all = true;
		        }
		        XAll.prototype['@@transducer/init'] = _xfBase.init;
		        XAll.prototype['@@transducer/result'] = function (result) {
		            if (this.all) {
		                result = this.xf['@@transducer/step'](result, true);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XAll.prototype['@@transducer/step'] = function (result, input) {
		            if (!this.f(input)) {
		                this.all = false;
		                result = _reduced(this.xf['@@transducer/step'](result, false));
		            }
		            return result;
		        };
		        return _curry2(function _xall(f, xf) {
		            return new XAll(f, xf);
		        });
		    }();

		    var _xany = function () {
		        function XAny(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.any = false;
		        }
		        XAny.prototype['@@transducer/init'] = _xfBase.init;
		        XAny.prototype['@@transducer/result'] = function (result) {
		            if (!this.any) {
		                result = this.xf['@@transducer/step'](result, false);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XAny.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.any = true;
		                result = _reduced(this.xf['@@transducer/step'](result, true));
		            }
		            return result;
		        };
		        return _curry2(function _xany(f, xf) {
		            return new XAny(f, xf);
		        });
		    }();

		    var _xdrop = function () {
		        function XDrop(n, xf) {
		            this.xf = xf;
		            this.n = n;
		        }
		        XDrop.prototype['@@transducer/init'] = _xfBase.init;
		        XDrop.prototype['@@transducer/result'] = _xfBase.result;
		        XDrop.prototype['@@transducer/step'] = function (result, input) {
		            if (this.n > 0) {
		                this.n -= 1;
		                return result;
		            }
		            return this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdrop(n, xf) {
		            return new XDrop(n, xf);
		        });
		    }();

		    var _xdropWhile = function () {
		        function XDropWhile(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
		        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
		        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f) {
		                if (this.f(input)) {
		                    return result;
		                }
		                this.f = null;
		            }
		            return this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdropWhile(f, xf) {
		            return new XDropWhile(f, xf);
		        });
		    }();

		    var _xgroupBy = function () {
		        function XGroupBy(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.inputs = {};
		        }
		        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
		        XGroupBy.prototype['@@transducer/result'] = function (result) {
		            var key;
		            for (key in this.inputs) {
		                if (_has(key, this.inputs)) {
		                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
		                    if (result['@@transducer/reduced']) {
		                        result = result['@@transducer/value'];
		                        break;
		                    }
		                }
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
		            var key = this.f(input);
		            this.inputs[key] = this.inputs[key] || [
		                key,
		                []
		            ];
		            this.inputs[key][1] = append(input, this.inputs[key][1]);
		            return result;
		        };
		        return _curry2(function _xgroupBy(f, xf) {
		            return new XGroupBy(f, xf);
		        });
		    }();

		    /**
		     * Creates a new list iteration function from an existing one by adding two new parameters
		     * to its callback function: the current index, and the entire list.
		     *
		     * This would turn, for instance, Ramda's simple `map` function into one that more closely
		     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
		     * the iteration callback function is the first parameter, and where the list is the last
		     * parameter.  (This latter might be unimportant if the list parameter is not used.)
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @category List
		     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
		     * @param {Function} fn A list iteration function that does not pass index or list to its callback
		     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
		     * @example
		     *
		     *      var mapIndexed = R.addIndex(R.map);
		     *      mapIndexed(function(val, idx) {return idx + '-' + val;}, ['f', 'o', 'o', 'b', 'a', 'r']);
		     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
		     */
		    var addIndex = _curry1(function addIndex(fn) {
		        return curryN(fn.length, function () {
		            var idx = 0;
		            var origFn = arguments[0];
		            var list = arguments[arguments.length - 1];
		            var args = _slice(arguments);
		            args[0] = function () {
		                var result = origFn.apply(this, _concat(arguments, [
		                    idx,
		                    list
		                ]));
		                idx += 1;
		                return result;
		            };
		            return fn.apply(this, args);
		        });
		    });

		    /**
		     * Returns `true` if all elements of the list match the predicate, `false` if there are any
		     * that don't.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
		     *         otherwise.
		     * @see R.any, R.none
		     * @example
		     *
		     *      var lessThan2 = R.flip(R.lt)(2);
		     *      var lessThan3 = R.flip(R.lt)(3);
		     *      R.all(lessThan2)([1, 2]); //=> false
		     *      R.all(lessThan3)([1, 2]); //=> true
		     */
		    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
		        var idx = 0;
		        while (idx < list.length) {
		            if (!fn(list[idx])) {
		                return false;
		            }
		            idx += 1;
		        }
		        return true;
		    }));

		    /**
		     * A function that returns the first argument if it's falsy otherwise the second
		     * argument. Note that this is NOT short-circuited, meaning that if expressions
		     * are passed they are both evaluated.
		     *
		     * Dispatches to the `and` method of the first argument if applicable.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig * -> * -> *
		     * @param {*} a any value
		     * @param {*} b any other value
		     * @return {*} the first argument if falsy otherwise the second argument.
		     * @see R.both
		     * @example
		     *
		     *      R.and(false, true); //=> false
		     *      R.and(0, []); //=> 0
		     *      R.and(null, ''); => null
		     */
		    var and = _curry2(function and(a, b) {
		        return _hasMethod('and', a) ? a.and(b) : a && b;
		    });

		    /**
		     * Returns `true` if at least one of elements of the list match the predicate, `false`
		     * otherwise.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
		     *         otherwise.
		     * @see R.all, R.none
		     * @example
		     *
		     *      var lessThan0 = R.flip(R.lt)(0);
		     *      var lessThan2 = R.flip(R.lt)(2);
		     *      R.any(lessThan0)([1, 2]); //=> false
		     *      R.any(lessThan2)([1, 2]); //=> true
		     */
		    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
		        var idx = 0;
		        while (idx < list.length) {
		            if (fn(list[idx])) {
		                return true;
		            }
		            idx += 1;
		        }
		        return false;
		    }));

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
		     * parameters. Any extraneous parameters will not be passed to the supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (* -> c) -> (a, b -> c)
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity 2.
		     * @example
		     *
		     *      var takesThreeArgs = function(a, b, c) {
		     *        return [a, b, c];
		     *      };
		     *      takesThreeArgs.length; //=> 3
		     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
		     *
		     *      var takesTwoArgs = R.binary(takesThreeArgs);
		     *      takesTwoArgs.length; //=> 2
		     *      // Only 2 arguments are passed to the wrapped function
		     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
		     */
		    var binary = _curry1(function binary(fn) {
		        return nAry(2, fn);
		    });

		    /**
		     * Creates a deep copy of the value which may contain (nested) `Array`s and
		     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
		     * not copied, but assigned by their reference.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {*} -> {*}
		     * @param {*} value The object or array to clone
		     * @return {*} A new object or array.
		     * @example
		     *
		     *      var objects = [{}, {}, {}];
		     *      var objectsClone = R.clone(objects);
		     *      objects[0] === objectsClone[0]; //=> false
		     */
		    var clone = _curry1(function clone(value) {
		        return _clone(value, [], []);
		    });

		    /**
		     * Returns a new list consisting of the elements of the first list followed by the elements
		     * of the second.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [a] -> [a]
		     * @param {Array} list1 The first list to merge.
		     * @param {Array} list2 The second set to merge.
		     * @return {Array} A new array consisting of the contents of `list1` followed by the
		     *         contents of `list2`. If, instead of an Array for `list1`, you pass an
		     *         object with a `concat` method on it, `concat` will call `list1.concat`
		     *         and pass it the value of `list2`.
		     *
		     * @example
		     *
		     *      R.concat([], []); //=> []
		     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
		     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
		     */
		    var concat = _curry2(function concat(set1, set2) {
		        if (_isArray(set2)) {
		            return _concat(set1, set2);
		        } else if (_hasMethod('concat', set1)) {
		            return set1.concat(set2);
		        } else {
		            throw new TypeError('can\'t concat ' + typeof set1);
		        }
		    });

		    /**
		     * Returns a curried equivalent of the provided function. The curried
		     * function has two unusual capabilities. First, its arguments needn't
		     * be provided one at a time. If `f` is a ternary function and `g` is
		     * `R.curry(f)`, the following are equivalent:
		     *
		     *   - `g(1)(2)(3)`
		     *   - `g(1)(2, 3)`
		     *   - `g(1, 2)(3)`
		     *   - `g(1, 2, 3)`
		     *
		     * Secondly, the special placeholder value `R.__` may be used to specify
		     * "gaps", allowing partial application of any combination of arguments,
		     * regardless of their positions. If `g` is as above and `_` is `R.__`,
		     * the following are equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (* -> a) -> (* -> a)
		     * @param {Function} fn The function to curry.
		     * @return {Function} A new, curried function.
		     * @see R.curryN
		     * @example
		     *
		     *      var addFourNumbers = function(a, b, c, d) {
		     *        return a + b + c + d;
		     *      };
		     *
		     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
		     *      var f = curriedAddFourNumbers(1, 2);
		     *      var g = f(3);
		     *      g(4); //=> 10
		     */
		    var curry = _curry1(function curry(fn) {
		        return curryN(fn.length, fn);
		    });

		    /**
		     * Returns a new list containing the last `n` elements of a given list, passing each value
		     * to the supplied predicate function, skipping elements while the predicate function returns
		     * `true`. The predicate function is passed one argument: *(value)*.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.takeWhile
		     * @example
		     *
		     *      var lteTwo = function(x) {
		     *        return x <= 2;
		     *      };
		     *
		     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
		     */
		    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
		        var idx = 0, len = list.length;
		        while (idx < len && pred(list[idx])) {
		            idx += 1;
		        }
		        return _slice(list, idx);
		    }));

		    /**
		     * Returns `true` if its arguments are equivalent, `false` otherwise.
		     * Dispatches to an `equals` method if present. Handles cyclical data
		     * structures.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig a -> b -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @example
		     *
		     *      R.equals(1, 1); //=> true
		     *      R.equals(1, '1'); //=> false
		     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
		     *
		     *      var a = {}; a.v = a;
		     *      var b = {}; b.v = b;
		     *      R.equals(a, b); //=> true
		     */
		    var equals = _curry2(function equals(a, b) {
		        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
		    });

		    /**
		     * Returns a new list containing only those items that match a given predicate function.
		     * The predicate function is passed one argument: *(value)*.
		     *
		     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
		     * `Array.prototype.filter` method. For more details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} The new filtered array.
		     * @see R.reject
		     * @example
		     *
		     *      var isEven = function(n) {
		     *        return n % 2 === 0;
		     *      };
		     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
		     */
		    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

		    /**
		     * Returns the first element of the list which matches the predicate, or `undefined` if no
		     * element matches.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> a | undefined
		     * @param {Function} fn The predicate function used to determine if the element is the
		     *        desired one.
		     * @param {Array} list The array to consider.
		     * @return {Object} The element found, or `undefined`.
		     * @example
		     *
		     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
		     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
		     *      R.find(R.propEq('a', 4))(xs); //=> undefined
		     */
		    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len) {
		            if (fn(list[idx])) {
		                return list[idx];
		            }
		            idx += 1;
		        }
		    }));

		    /**
		     * Returns the index of the first element of the list which matches the predicate, or `-1`
		     * if no element matches.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Number
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Number} The index of the element found, or `-1`.
		     * @example
		     *
		     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
		     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
		     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
		     */
		    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len) {
		            if (fn(list[idx])) {
		                return idx;
		            }
		            idx += 1;
		        }
		        return -1;
		    }));

		    /**
		     * Returns the last element of the list which matches the predicate, or `undefined` if no
		     * element matches.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> a | undefined
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Object} The element found, or `undefined`.
		     * @example
		     *
		     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
		     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
		     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
		     */
		    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            if (fn(list[idx])) {
		                return list[idx];
		            }
		            idx -= 1;
		        }
		    }));

		    /**
		     * Returns the index of the last element of the list which matches the predicate, or
		     * `-1` if no element matches.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Number
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Number} The index of the element found, or `-1`.
		     * @example
		     *
		     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
		     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
		     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
		     */
		    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            if (fn(list[idx])) {
		                return idx;
		            }
		            idx -= 1;
		        }
		        return -1;
		    }));

		    /**
		     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
		     * them in a new array, depth-first.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [b]
		     * @param {Array} list The array to consider.
		     * @return {Array} The flattened list.
		     * @see R.unnest
		     * @example
		     *
		     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
		     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
		     */
		    var flatten = _curry1(_makeFlat(true));

		    /**
		     * Returns a new function much like the supplied one, except that the first two arguments'
		     * order is reversed.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
		     * @param {Function} fn The function to invoke with its first two parameters reversed.
		     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
		     * @example
		     *
		     *      var mergeThree = function(a, b, c) {
		     *        return ([]).concat(a, b, c);
		     *      };
		     *
		     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
		     *
		     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
		     */
		    var flip = _curry1(function flip(fn) {
		        return curry(function (a, b) {
		            var args = _slice(arguments);
		            args[0] = b;
		            args[1] = a;
		            return fn.apply(this, args);
		        });
		    });

		    /**
		     * Iterate over an input `list`, calling a provided function `fn` for each element in the
		     * list.
		     *
		     * `fn` receives one argument: *(value)*.
		     *
		     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
		     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
		     *
		     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
		     * array. In some libraries this function is named `each`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> *) -> [a] -> [a]
		     * @param {Function} fn The function to invoke. Receives one argument, `value`.
		     * @param {Array} list The list to iterate over.
		     * @return {Array} The original list.
		     * @example
		     *
		     *      var printXPlusFive = function(x) { console.log(x + 5); };
		     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
		     *      //-> 6
		     *      //-> 7
		     *      //-> 8
		     */
		    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            fn(list[idx]);
		            idx += 1;
		        }
		        return list;
		    }));

		    /**
		     * Returns a list of function names of object's own functions
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {*} -> [String]
		     * @param {Object} obj The objects with functions in it
		     * @return {Array} A list of the object's own properties that map to functions.
		     * @example
		     *
		     *      R.functions(R); // returns list of ramda's own function names
		     *
		     *      var F = function() { this.x = function(){}; this.y = 1; }
		     *      F.prototype.z = function() {};
		     *      F.prototype.a = 100;
		     *      R.functions(new F()); //=> ["x"]
		     */
		    var functions = _curry1(_functionsWith(keys));

		    /**
		     * Returns a list of function names of object's own and prototype functions
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {*} -> [String]
		     * @param {Object} obj The objects with functions in it
		     * @return {Array} A list of the object's own properties and prototype
		     *         properties that map to functions.
		     * @example
		     *
		     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
		     *
		     *      var F = function() { this.x = function(){}; this.y = 1; }
		     *      F.prototype.z = function() {};
		     *      F.prototype.a = 100;
		     *      R.functionsIn(new F()); //=> ["x", "z"]
		     */
		    var functionsIn = _curry1(_functionsWith(keysIn));

		    /**
		     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
		     * on each element, and grouping the results according to values returned.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> String) -> [a] -> {String: [a]}
		     * @param {Function} fn Function :: a -> String
		     * @param {Array} list The array to group
		     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
		     *         that produced that key when passed to `fn`.
		     * @example
		     *
		     *      var byGrade = R.groupBy(function(student) {
		     *        var score = student.score;
		     *        return score < 65 ? 'F' :
		     *               score < 70 ? 'D' :
		     *               score < 80 ? 'C' :
		     *               score < 90 ? 'B' : 'A';
		     *      });
		     *      var students = [{name: 'Abby', score: 84},
		     *                      {name: 'Eddy', score: 58},
		     *                      // ...
		     *                      {name: 'Jack', score: 69}];
		     *      byGrade(students);
		     *      // {
		     *      //   'A': [{name: 'Dianne', score: 99}],
		     *      //   'B': [{name: 'Abby', score: 84}]
		     *      //   // ...,
		     *      //   'F': [{name: 'Eddy', score: 58}]
		     *      // }
		     */
		    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
		        return _reduce(function (acc, elt) {
		            var key = fn(elt);
		            acc[key] = append(elt, acc[key] || (acc[key] = []));
		            return acc;
		        }, {}, list);
		    }));

		    /**
		     * Returns the first element of the given list or string. In some libraries
		     * this function is named `first`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.tail, R.init, R.last
		     * @sig [a] -> a | Undefined
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
		     *      R.head([]); //=> undefined
		     *
		     *      R.head('abc'); //=> 'a'
		     *      R.head(''); //=> ''
		     */
		    var head = nth(0);

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of those
		     * elements common to both lists.  Duplication is determined according
		     * to the value returned by applying the supplied predicate to two list
		     * elements.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
		     * @param {Function} pred A predicate function that determines whether
		     *        the two supplied elements are equal.
		     * @param {Array} list1 One list of items to compare
		     * @param {Array} list2 A second list of items to compare
		     * @see R.intersection
		     * @return {Array} A new list containing those elements common to both lists.
		     * @example
		     *
		     *      var buffaloSpringfield = [
		     *        {id: 824, name: 'Richie Furay'},
		     *        {id: 956, name: 'Dewey Martin'},
		     *        {id: 313, name: 'Bruce Palmer'},
		     *        {id: 456, name: 'Stephen Stills'},
		     *        {id: 177, name: 'Neil Young'}
		     *      ];
		     *      var csny = [
		     *        {id: 204, name: 'David Crosby'},
		     *        {id: 456, name: 'Stephen Stills'},
		     *        {id: 539, name: 'Graham Nash'},
		     *        {id: 177, name: 'Neil Young'}
		     *      ];
		     *
		     *      var sameId = function(o1, o2) {return o1.id === o2.id;};
		     *
		     *      R.intersectionWith(sameId, buffaloSpringfield, csny);
		     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
		     */
		    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
		        var results = [], idx = 0;
		        while (idx < list1.length) {
		            if (_containsWith(pred, list1[idx], list2)) {
		                results[results.length] = list1[idx];
		            }
		            idx += 1;
		        }
		        return uniqWith(pred, results);
		    });

		    /**
		     * Creates a new list with the separator interposed between elements.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} separator The element to add to the list.
		     * @param {Array} list The list to be interposed.
		     * @return {Array} The new list.
		     * @example
		     *
		     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
		     */
		    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
		        var out = [];
		        var idx = 0;
		        var length = list.length;
		        while (idx < length) {
		            if (idx === length - 1) {
		                out.push(list[idx]);
		            } else {
		                out.push(list[idx], separator);
		            }
		            idx += 1;
		        }
		        return out;
		    }));

		    /**
		     * Transforms the items of the list with the transducer and appends the transformed items to
		     * the accumulator using an appropriate iterator function based on the accumulator type.
		     *
		     * The accumulator can be an array, string, object or a transformer. Iterated items will
		     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
		     * arrays will be merged as key, value pairs.
		     *
		     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
		     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
		     * result. The step function is used as the iterator function in reduce. The result function is
		     * used to convert the final accumulator into the return type and in most cases is R.identity.
		     * The init function is used to provide the initial accumulator.
		     *
		     * The iteration is performed with R.reduce after initializing the transducer.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> (b -> b) -> [c] -> a
		     * @param {*} acc The initial accumulator value.
		     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
		     *
		     *      R.into([], transducer, numbers); //=> [2, 3]
		     *
		     *      var intoArray = R.into([]);
		     *      intoArray(transducer, numbers); //=> [2, 3]
		     */
		    var into = _curry3(function into(acc, xf, list) {
		        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
		    });

		    /**
		     * Same as R.invertObj, however this accounts for objects
		     * with duplicate values by putting the values into an
		     * array.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {s: x} -> {x: [ s, ... ]}
		     * @param {Object} obj The object or array to invert
		     * @return {Object} out A new object with keys
		     * in an array.
		     * @example
		     *
		     *      var raceResultsByFirstName = {
		     *        first: 'alice',
		     *        second: 'jake',
		     *        third: 'alice',
		     *      };
		     *      R.invert(raceResultsByFirstName);
		     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
		     */
		    var invert = _curry1(function invert(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var idx = 0;
		        var out = {};
		        while (idx < len) {
		            var key = props[idx];
		            var val = obj[key];
		            var list = _has(val, out) ? out[val] : out[val] = [];
		            list[list.length] = key;
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new object with the keys of the given object
		     * as values, and the values of the given object as keys.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {s: x} -> {x: s}
		     * @param {Object} obj The object or array to invert
		     * @return {Object} out A new object
		     * @example
		     *
		     *      var raceResults = {
		     *        first: 'alice',
		     *        second: 'jake'
		     *      };
		     *      R.invertObj(raceResults);
		     *      //=> { 'alice': 'first', 'jake':'second' }
		     *
		     *      // Alternatively:
		     *      var raceResults = ['alice', 'jake'];
		     *      R.invertObj(raceResults);
		     *      //=> { 'alice': '0', 'jake':'1' }
		     */
		    var invertObj = _curry1(function invertObj(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var idx = 0;
		        var out = {};
		        while (idx < len) {
		            var key = props[idx];
		            out[obj[key]] = key;
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns the last element of the given list or string.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.init, R.head, R.tail
		     * @sig [a] -> a | Undefined
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
		     *      R.last([]); //=> undefined
		     *
		     *      R.last('abc'); //=> 'c'
		     *      R.last(''); //=> ''
		     */
		    var last = nth(-1);

		    /**
		     * Returns the position of the last occurrence of an item in
		     * an array, or -1 if the item is not included in the array.
		     * `R.equals` is used to determine equality.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> Number
		     * @param {*} target The item to find.
		     * @param {Array} xs The array to search in.
		     * @return {Number} the index of the target, or -1 if the target is not found.
		     * @see R.indexOf
		     * @example
		     *
		     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
		     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
		     */
		    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
		        if (_hasMethod('lastIndexOf', xs)) {
		            return xs.lastIndexOf(target);
		        } else {
		            var idx = xs.length - 1;
		            while (idx >= 0) {
		                if (equals(xs[idx], target)) {
		                    return idx;
		                }
		                idx -= 1;
		            }
		            return -1;
		        }
		    });

		    /**
		     * Returns a new list, constructed by applying the supplied function to every element of the
		     * supplied list.
		     *
		     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
		     * native `Array.prototype.map` method. For more details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> b) -> [a] -> [b]
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {Array} list The list to be iterated over.
		     * @return {Array} The new list.
		     * @example
		     *
		     *      var double = function(x) {
		     *        return x * 2;
		     *      };
		     *
		     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
		     */
		    var map = _curry2(_dispatchable('map', _xmap, _map));

		    /**
		     * Map, but for objects. Creates an object with the same keys as `obj` and values
		     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
		     * *(value)*.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig (v -> v) -> {k: v} -> {k: v}
		     * @param {Function} fn A function called for each property in `obj`. Its return value will
		     * become a new property on the return object.
		     * @param {Object} obj The object to iterate over.
		     * @return {Object} A new object with the same keys as `obj` and values that are the result
		     *         of running each property through `fn`.
		     * @example
		     *
		     *      var values = { x: 1, y: 2, z: 3 };
		     *      var double = function(num) {
		     *        return num * 2;
		     *      };
		     *
		     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
		     */
		    var mapObj = _curry2(function mapObj(fn, obj) {
		        return _reduce(function (acc, key) {
		            acc[key] = fn(obj[key]);
		            return acc;
		        }, {}, keys(obj));
		    });

		    /**
		     * Like `mapObj`, but but passes additional arguments to the predicate function. The
		     * predicate function is passed three arguments: *(value, key, obj)*.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
		     * @param {Function} fn A function called for each property in `obj`. Its return value will
		     *        become a new property on the return object.
		     * @param {Object} obj The object to iterate over.
		     * @return {Object} A new object with the same keys as `obj` and values that are the result
		     *         of running each property through `fn`.
		     * @example
		     *
		     *      var values = { x: 1, y: 2, z: 3 };
		     *      var prependKeyAndDouble = function(num, key, obj) {
		     *        return key + (num * 2);
		     *      };
		     *
		     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
		     */
		    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
		        return _reduce(function (acc, key) {
		            acc[key] = fn(obj[key], key, obj);
		            return acc;
		        }, {}, keys(obj));
		    });

		    /**
		     * Returns `true` if no elements of the list match the predicate,
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
		     * @see R.all, R.any
		     * @example
		     *
		     *      R.none(R.isNaN, [1, 2, 3]); //=> true
		     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
		     */
		    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

		    /**
		     * A function that returns the first truthy of two arguments otherwise the
		     * last argument. Note that this is NOT short-circuited, meaning that if
		     * expressions are passed they are both evaluated.
		     *
		     * Dispatches to the `or` method of the first argument if applicable.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig * -> * -> *
		     * @param {*} a any value
		     * @param {*} b any other value
		     * @return {*} the first truthy argument, otherwise the last argument.
		     * @see R.either
		     * @example
		     *
		     *      R.or(false, true); //=> true
		     *      R.or(0, []); //=> []
		     *      R.or(null, ''); => ''
		     */
		    var or = _curry2(function or(a, b) {
		        return _hasMethod('or', a) ? a.or(b) : a || b;
		    });

		    /**
		     * Accepts as its arguments a function and any number of values and returns a function that,
		     * when invoked, calls the original function with all of the values prepended to the
		     * original function's arguments list. In some libraries this function is named `applyLeft`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)
		     * @param {Function} fn The function to invoke.
		     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
		     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
		     *         with `args` prepended to `fn`'s arguments list.
		     * @example
		     *
		     *      var multiply = function(a, b) { return a * b; };
		     *      var double = R.partial(multiply, 2);
		     *      double(2); //=> 4
		     *
		     *      var greet = function(salutation, title, firstName, lastName) {
		     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
		     *      };
		     *      var sayHello = R.partial(greet, 'Hello');
		     *      var sayHelloToMs = R.partial(sayHello, 'Ms.');
		     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
		     */
		    var partial = curry(_createPartialApplicator(_concat));

		    /**
		     * Accepts as its arguments a function and any number of values and returns a function that,
		     * when invoked, calls the original function with all of the values appended to the original
		     * function's arguments list.
		     *
		     * Note that `partialRight` is the opposite of `partial`: `partialRight` fills `fn`'s arguments
		     * from the right to the left.  In some libraries this function is named `applyRight`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)
		     * @param {Function} fn The function to invoke.
		     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
		     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
		     *         `args` appended to `fn`'s arguments list.
		     * @example
		     *
		     *      var greet = function(salutation, title, firstName, lastName) {
		     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
		     *      };
		     *      var greetMsJaneJones = R.partialRight(greet, 'Ms.', 'Jane', 'Jones');
		     *
		     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
		     */
		    var partialRight = curry(_createPartialApplicator(flip(_concat)));

		    /**
		     * Takes a predicate and a list and returns the pair of lists of
		     * elements which do and do not satisfy the predicate, respectively.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
		     * @param {Function} pred A predicate to determine which array the element belongs to.
		     * @param {Array} list The array to partition.
		     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
		     *         and second an array of elements that did not satisfy.
		     * @example
		     *
		     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
		     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
		     */
		    var partition = _curry2(function partition(pred, list) {
		        return _reduce(function (acc, elt) {
		            var xs = acc[pred(elt) ? 0 : 1];
		            xs[xs.length] = elt;
		            return acc;
		        }, [
		            [],
		            []
		        ], list);
		    });

		    /**
		     * Determines whether a nested path on an object has a specific value,
		     * in `R.equals` terms. Most likely used to filter a list.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig [String] -> * -> {String: *} -> Boolean
		     * @param {Array} path The path of the nested property to use
		     * @param {*} val The value to compare the nested property with
		     * @param {Object} obj The object to check the nested property in
		     * @return {Boolean} `true` if the value equals the nested object property,
		     *         `false` otherwise.
		     * @example
		     *
		     *      var user1 = { address: { zipCode: 90210 } };
		     *      var user2 = { address: { zipCode: 55555 } };
		     *      var user3 = { name: 'Bob' };
		     *      var users = [ user1, user2, user3 ];
		     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
		     *      R.filter(isFamous, users); //=> [ user1 ]
		     */
		    var pathEq = _curry3(function pathEq(_path, val, obj) {
		        return equals(path(_path, obj), val);
		    });

		    /**
		     * Returns a new list by plucking the same named property off all objects in the list supplied.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig k -> [{k: v}] -> [v]
		     * @param {Number|String} key The key name to pluck off of each object.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of values for the given key.
		     * @example
		     *
		     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
		     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
		     */
		    var pluck = _curry2(function pluck(p, list) {
		        return map(prop(p), list);
		    });

		    /**
		     * Returns `true` if the specified object property is equal, in `R.equals`
		     * terms, to the given value; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig String -> a -> Object -> Boolean
		     * @param {String} name
		     * @param {*} val
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.equals, R.propSatisfies
		     * @example
		     *
		     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
		     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
		     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
		     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
		     *      var kids = [abby, fred, rusty, alois];
		     *      var hasBrownHair = R.propEq('hair', 'brown');
		     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
		     */
		    var propEq = _curry3(function propEq(name, val, obj) {
		        return propSatisfies(equals(val), name, obj);
		    });

		    /**
		     * Returns `true` if the specified object property is of the given type;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category Type
		     * @sig Type -> String -> Object -> Boolean
		     * @param {Function} type
		     * @param {String} name
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.is
		     * @see R.propSatisfies
		     * @example
		     *
		     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
		     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
		     *      R.propIs(Number, 'x', {});            //=> false
		     */
		    var propIs = _curry3(function propIs(type, name, obj) {
		        return propSatisfies(is(type), name, obj);
		    });

		    /**
		     * Returns a single item by iterating through the list, successively calling the iterator
		     * function and passing it an accumulator value and the current value from the array, and
		     * then passing the result to the next call.
		     *
		     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
		     * shortcut the iteration.
		     *
		     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
		     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
		     * @see R.reduced
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a,b -> a) -> a -> [b] -> a
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var numbers = [1, 2, 3];
		     *      var add = function(a, b) {
		     *        return a + b;
		     *      };
		     *
		     *      R.reduce(add, 10, numbers); //=> 16
		     */
		    var reduce = _curry3(_reduce);

		    /**
		     * Similar to `filter`, except that it keeps only values for which the given predicate
		     * function returns falsy. The predicate function is passed one argument: *(value)*.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} The new filtered array.
		     * @see R.filter
		     * @example
		     *
		     *      var isOdd = function(n) {
		     *        return n % 2 === 1;
		     *      };
		     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
		     */
		    var reject = _curry2(function reject(fn, list) {
		        return filter(_complement(fn), list);
		    });

		    /**
		     * Returns a fixed list of size `n` containing a specified identical value.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> n -> [a]
		     * @param {*} value The value to repeat.
		     * @param {Number} n The desired size of the output list.
		     * @return {Array} A new array containing `n` `value`s.
		     * @example
		     *
		     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
		     *
		     *      var obj = {};
		     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
		     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
		     */
		    var repeat = _curry2(function repeat(value, n) {
		        return times(always(value), n);
		    });

		    /**
		     * Returns the elements of the given list or string (or object with a `slice`
		     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> Number -> [a] -> [a]
		     * @sig Number -> Number -> String -> String
		     * @param {Number} fromIndex The start index (inclusive).
		     * @param {Number} toIndex The end index (exclusive).
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
		     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
		     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
		     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
		     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
		     */
		    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
		        return Array.prototype.slice.call(list, fromIndex, toIndex);
		    }));

		    /**
		     * Splits a collection into slices of the specified length.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [[a]]
		     * @sig Number -> String -> [String]
		     * @param {Number} n
		     * @param {Array} list
		     * @return {Array}
		     * @example
		     *
		     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
		     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
		     */
		    var splitEvery = _curry2(function splitEvery(n, list) {
		        if (n <= 0) {
		            throw new Error('First argument to splitEvery must be a positive integer');
		        }
		        var result = [];
		        var idx = 0;
		        while (idx < list.length) {
		            result.push(slice(idx, idx += n, list));
		        }
		        return result;
		    });

		    /**
		     * Adds together all the elements of a list.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list An array of numbers
		     * @return {Number} The sum of all the numbers in the list.
		     * @see R.reduce
		     * @example
		     *
		     *      R.sum([2,4,6,8,100,1]); //=> 121
		     */
		    var sum = reduce(add, 0);

		    /**
		     * Returns all but the first element of the given list or string (or object
		     * with a `tail` method).
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.head, R.init, R.last
		     * @sig [a] -> [a]
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.tail([1, 2, 3]);  //=> [2, 3]
		     *      R.tail([1, 2]);     //=> [2]
		     *      R.tail([1]);        //=> []
		     *      R.tail([]);         //=> []
		     *
		     *      R.tail('abc');  //=> 'bc'
		     *      R.tail('ab');   //=> 'b'
		     *      R.tail('a');    //=> ''
		     *      R.tail('');     //=> ''
		     */
		    var tail = _checkForMethod('tail', slice(1, Infinity));

		    /**
		     * Returns the first `n` elements of the given list, string, or
		     * transducer/transformer (or object with a `take` method).
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n
		     * @param {*} list
		     * @return {*}
		     * @see R.drop
		     * @example
		     *
		     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
		     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
		     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.take(3, 'ramda');               //=> 'ram'
		     *
		     *      var personnel = [
		     *        'Dave Brubeck',
		     *        'Paul Desmond',
		     *        'Eugene Wright',
		     *        'Joe Morello',
		     *        'Gerry Mulligan',
		     *        'Bob Bates',
		     *        'Joe Dodge',
		     *        'Ron Crotty'
		     *      ];
		     *
		     *      var takeFive = R.take(5);
		     *      takeFive(personnel);
		     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
		     */
		    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
		        return slice(0, n < 0 ? Infinity : n, xs);
		    }));

		    /**
		     * Returns a new list containing the first `n` elements of a given list, passing each value
		     * to the supplied predicate function, and terminating when the predicate function returns
		     * `false`. Excludes the element that caused the predicate function to fail. The predicate
		     * function is passed one argument: *(value)*.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.dropWhile
		     * @example
		     *
		     *      var isNotFour = function(x) {
		     *        return !(x === 4);
		     *      };
		     *
		     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
		     */
		    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
		        var idx = 0, len = list.length;
		        while (idx < len && fn(list[idx])) {
		            idx += 1;
		        }
		        return _slice(list, 0, idx);
		    }));

		    /**
		     * Initializes a transducer using supplied iterator function. Returns a single item by
		     * iterating through the list, successively calling the transformed iterator function and
		     * passing it an accumulator value and the current value from the array, and then passing
		     * the result to the next call.
		     *
		     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
		     * transformer to initialize the transducer. A transformer can be passed directly in place
		     * of an iterator function.  In both cases, iteration may be stopped early with the
		     * `R.reduced` function.
		     *
		     * A transducer is a function that accepts a transformer and returns a transformer and can
		     * be composed directly.
		     *
		     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
		     * 0-arity initial value function, init, and 1-arity result extraction function, result.
		     * The step function is used as the iterator function in reduce. The result function is used
		     * to convert the final accumulator into the return type and in most cases is R.identity.
		     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
		     *
		     * The iteration is performed with R.reduce after initializing the transducer.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.reduce, R.reduced, R.into
		     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
		     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array. Wrapped as transformer, if necessary, and used to
		     *        initialize the transducer
		     * @param {*} acc The initial accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
		     *
		     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
		     */
		    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
		        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
		    });

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
		     * determined according to the value returned by applying the supplied predicate to two list elements.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The first and second lists concatenated, with
		     *         duplicates removed.
		     * @see R.union
		     * @example
		     *
		     *      function cmp(x, y) { return x.a === y.a; }
		     *      var l1 = [{a: 1}, {a: 2}];
		     *      var l2 = [{a: 1}, {a: 4}];
		     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
		     */
		    var unionWith = _curry3(function unionWith(pred, list1, list2) {
		        return uniqWith(pred, _concat(list1, list2));
		    });

		    /**
		     * Returns a new list containing only one copy of each element in the original list.
		     * `R.equals` is used to determine equality.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [a]
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
		     *      R.uniq([1, '1']);     //=> [1, '1']
		     *      R.uniq([[42], [42]]); //=> [[42]]
		     */
		    var uniq = uniqWith(equals);

		    /**
		     * Returns a new list by pulling every item at the first level of nesting out, and putting
		     * them in a new array.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [b]
		     * @param {Array} list The array to consider.
		     * @return {Array} The flattened list.
		     * @see R.flatten
		     * @example
		     *
		     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
		     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
		     */
		    var unnest = _curry1(_makeFlat(false));

		    /**
		     * Accepts a function `fn` and any number of transformer functions and returns a new
		     * function. When the new function is invoked, it calls the function `fn` with parameters
		     * consisting of the result of calling each supplied handler on successive arguments to the
		     * new function.
		     *
		     * If more arguments are passed to the returned function than transformer functions, those
		     * arguments are passed directly to `fn` as additional parameters. If you expect additional
		     * arguments that don't need to be transformed, although you can ignore them, it's best to
		     * pass an identity function so that the new function reports the correct arity.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (x1 -> x2 -> ... -> z) -> ((a -> x1), (b -> x2), ...) -> (a -> b -> ... -> z)
		     * @param {Function} fn The function to wrap.
		     * @param {...Function} transformers A variable number of transformer functions
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      var double = function(y) { return y * 2; };
		     *      var square = function(x) { return x * x; };
		     *      var add = function(a, b) { return a + b; };
		     *      // Adds any number of arguments together
		     *      var addAll = function() {
		     *        return R.reduce(add, 0, arguments);
		     *      };
		     *
		     *      // Basic example
		     *      var addDoubleAndSquare = R.useWith(addAll, double, square);
		     *
		     *      //≅ addAll(double(10), square(5));
		     *      addDoubleAndSquare(10, 5); //=> 45
		     *
		     *      // Example of passing more arguments than transformers
		     *      //≅ addAll(double(10), square(5), 100);
		     *      addDoubleAndSquare(10, 5, 100); //=> 145
		     *
		     *      // If there are extra _expected_ arguments that don't need to be transformed, although
		     *      // you can ignore them, it might be best to pass in the identity function so that the new
		     *      // function correctly reports arity.
		     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);
		     *      // addDoubleAndSquareWithExtraParams.length //=> 3
		     *      //≅ addAll(double(10), square(5), R.identity(100));
		     *      addDoubleAndSquare(10, 5, 100); //=> 145
		     */
		    /*, transformers */
		    var useWith = curry(function useWith(fn) {
		        var transformers = _slice(arguments, 1);
		        var tlen = transformers.length;
		        return curry(_arity(tlen, function () {
		            var args = [], idx = 0;
		            while (idx < tlen) {
		                args[idx] = transformers[idx](arguments[idx]);
		                idx += 1;
		            }
		            return fn.apply(this, args.concat(_slice(arguments, tlen)));
		        }));
		    });

		    /**
		     * Takes a spec object and a test object; returns true if the test satisfies
		     * the spec, false otherwise. An object satisfies the spec if, for each of the
		     * spec's own properties, accessing that property of the object gives the same
		     * value (in `R.equals` terms) as accessing that property of the spec.
		     *
		     * `whereEq` is a specialization of [`where`](#where).
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig {String: *} -> {String: *} -> Boolean
		     * @param {Object} spec
		     * @param {Object} testObj
		     * @return {Boolean}
		     * @see R.where
		     * @example
		     *
		     *      // pred :: Object -> Boolean
		     *      var pred = R.whereEq({a: 1, b: 2});
		     *
		     *      pred({a: 1});              //=> false
		     *      pred({a: 1, b: 2});        //=> true
		     *      pred({a: 1, b: 2, c: 3});  //=> true
		     *      pred({a: 1, b: 1});        //=> false
		     */
		    var whereEq = _curry2(function whereEq(spec, testObj) {
		        return where(mapObj(equals, spec), testObj);
		    });

		    var _flatCat = function () {
		        var preservingReduced = function (xf) {
		            return {
		                '@@transducer/init': _xfBase.init,
		                '@@transducer/result': function (result) {
		                    return xf['@@transducer/result'](result);
		                },
		                '@@transducer/step': function (result, input) {
		                    var ret = xf['@@transducer/step'](result, input);
		                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
		                }
		            };
		        };
		        return function _xcat(xf) {
		            var rxf = preservingReduced(xf);
		            return {
		                '@@transducer/init': _xfBase.init,
		                '@@transducer/result': function (result) {
		                    return rxf['@@transducer/result'](result);
		                },
		                '@@transducer/step': function (result, input) {
		                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
		                }
		            };
		        };
		    }();

		    var _indexOf = function _indexOf(list, item, from) {
		        var idx = from;
		        while (idx < list.length) {
		            if (equals(list[idx], item)) {
		                return idx;
		            }
		            idx += 1;
		        }
		        return -1;
		    };

		    /**
		     * Create a predicate wrapper which will call a pick function (all/any) for each predicate
		     *
		     * @private
		     * @see R.all
		     * @see R.any
		     */
		    // Call function immediately if given arguments
		    // Return a function which will call the predicates with the provided arguments
		    var _predicateWrap = function _predicateWrap(predPicker) {
		        return function (preds) {
		            var predIterator = function () {
		                var args = arguments;
		                return predPicker(function (predicate) {
		                    return predicate.apply(null, args);
		                }, preds);
		            };
		            return arguments.length > 1 ? // Call function immediately if given arguments
		            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments
		            _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
		        };
		    };

		    var _xchain = _curry2(function _xchain(f, xf) {
		        return map(f, _flatCat(xf));
		    });

		    /**
		     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
		     * @param {Array} list An array of predicate functions
		     * @param {*} optional Any arguments to pass into the predicates
		     * @return {Function} a function that applies its arguments to each of
		     *         the predicates, returning `true` if all are satisfied.
		     * @see R.anyPass
		     * @example
		     *
		     *      var gt10 = function(x) { return x > 10; };
		     *      var even = function(x) { return x % 2 === 0};
		     *      var f = R.allPass([gt10, even]);
		     *      f(11); //=> false
		     *      f(12); //=> true
		     */
		    var allPass = _curry1(_predicateWrap(all));

		    /**
		     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
		     *
		     * @func
		     * @memberOf R
		     * @category Logic
		     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
		     * @param {Array} list An array of predicate functions
		     * @param {*} optional Any arguments to pass into the predicates
		     * @return {Function} A function that applies its arguments to each of the predicates, returning
		     *         `true` if all are satisfied.
		     * @see R.allPass
		     * @example
		     *
		     *      var gt10 = function(x) { return x > 10; };
		     *      var even = function(x) { return x % 2 === 0};
		     *      var f = R.anyPass([gt10, even]);
		     *      f(11); //=> true
		     *      f(8); //=> true
		     *      f(9); //=> false
		     */
		    var anyPass = _curry1(_predicateWrap(any));

		    /**
		     * ap applies a list of functions to a list of values.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig [f] -> [a] -> [f a]
		     * @param {Array} fns An array of functions
		     * @param {Array} vs An array of values
		     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
		     * @example
		     *
		     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
		     */
		    var ap = _curry2(function ap(fns, vs) {
		        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function (acc, fn) {
		            return _concat(acc, map(fn, vs));
		        }, [], fns);
		    });

		    /**
		     * Returns the result of calling its first argument with the remaining
		     * arguments. This is occasionally useful as a converging function for
		     * `R.converge`: the left branch can produce a function while the right
		     * branch produces a value to be passed to that function as an argument.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (*... -> a),*... -> a
		     * @param {Function} fn The function to apply to the remaining arguments.
		     * @param {...*} args Any number of positional arguments.
		     * @return {*}
		     * @see R.apply
		     * @example
		     *
		     *      var indentN = R.pipe(R.times(R.always(' ')),
		     *                           R.join(''),
		     *                           R.replace(/^(?!$)/gm));
		     *
		     *      var format = R.converge(R.call,
		     *                              R.pipe(R.prop('indent'), indentN),
		     *                              R.prop('value'));
		     *
		     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
		     */
		    var call = curry(function call(fn) {
		        return fn.apply(this, _slice(arguments, 1));
		    });

		    /**
		     * `chain` maps a function over a list and concatenates the results.
		     * This implementation is compatible with the
		     * Fantasy-land Chain spec, and will work with types that implement that spec.
		     * `chain` is also known as `flatMap` in some libraries
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> [b]) -> [a] -> [b]
		     * @param {Function} fn
		     * @param {Array} list
		     * @return {Array}
		     * @example
		     *
		     *      var duplicate = function(n) {
		     *        return [n, n];
		     *      };
		     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
		     */
		    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
		        return unnest(map(fn, list));
		    }));

		    /**
		     * Turns a list of Functors into a Functor of a list, applying
		     * a mapping function to the elements of the list along the way.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.commute
		     * @sig Functor f => (f a -> f b) -> (x -> f x) -> [f a] -> f [b]
		     * @param {Function} fn The transformation function
		     * @param {Function} of A function that returns the data type to return
		     * @param {Array} list An array of functors of the same type
		     * @return {*}
		     * @example
		     *
		     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
		     *      R.commuteMap(R.map(R.add(10)), R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
		     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
		     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
		     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     */
		    var commuteMap = _curry3(function commuteMap(fn, of, list) {
		        function consF(acc, ftor) {
		            return ap(map(append, fn(ftor)), acc);
		        }
		        return _reduce(consF, of([]), list);
		    });

		    /**
		     * Wraps a constructor function inside a curried function that can be called with the same
		     * arguments and returns the same type. The arity of the function returned is specified
		     * to allow using variadic constructor functions.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> (* -> {*}) -> (* -> {*})
		     * @param {Number} n The arity of the constructor function.
		     * @param {Function} Fn The constructor function to wrap.
		     * @return {Function} A wrapped, curried constructor function.
		     * @example
		     *
		     *      // Variadic constructor function
		     *      var Widget = function() {
		     *        this.children = Array.prototype.slice.call(arguments);
		     *        // ...
		     *      };
		     *      Widget.prototype = {
		     *        // ...
		     *      };
		     *      var allConfigs = [
		     *        // ...
		     *      ];
		     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
		     */
		    var constructN = _curry2(function constructN(n, Fn) {
		        if (n > 10) {
		            throw new Error('Constructor with greater than ten arguments');
		        }
		        if (n === 0) {
		            return function () {
		                return new Fn();
		            };
		        }
		        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
		            switch (arguments.length) {
		            case 1:
		                return new Fn($0);
		            case 2:
		                return new Fn($0, $1);
		            case 3:
		                return new Fn($0, $1, $2);
		            case 4:
		                return new Fn($0, $1, $2, $3);
		            case 5:
		                return new Fn($0, $1, $2, $3, $4);
		            case 6:
		                return new Fn($0, $1, $2, $3, $4, $5);
		            case 7:
		                return new Fn($0, $1, $2, $3, $4, $5, $6);
		            case 8:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
		            case 9:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
		            case 10:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
		            }
		        }));
		    });

		    /**
		     * Accepts at least three functions and returns a new function. When invoked, this new
		     * function will invoke the first function, `after`, passing as its arguments the
		     * results of invoking the subsequent functions with whatever arguments are passed to
		     * the new function.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (x1 -> x2 -> ... -> z) -> ((a -> b -> ... -> x1), (a -> b -> ... -> x2), ...) -> (a -> b -> ... -> z)
		     * @param {Function} after A function. `after` will be invoked with the return values of
		     *        `fn1` and `fn2` as its arguments.
		     * @param {...Function} functions A variable number of functions.
		     * @return {Function} A new function.
		     * @example
		     *
		     *      var add = function(a, b) { return a + b; };
		     *      var multiply = function(a, b) { return a * b; };
		     *      var subtract = function(a, b) { return a - b; };
		     *
		     *      //≅ multiply( add(1, 2), subtract(1, 2) );
		     *      R.converge(multiply, add, subtract)(1, 2); //=> -3
		     *
		     *      var add3 = function(a, b, c) { return a + b + c; };
		     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4
		     */
		    var converge = curryN(3, function converge(after) {
		        var fns = _slice(arguments, 1);
		        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
		            var args = arguments;
		            var context = this;
		            return after.apply(context, _map(function (fn) {
		                return fn.apply(context, args);
		            }, fns));
		        });
		    });

		    /**
		     * Returns all but the first `n` elements of the given list, string, or
		     * transducer/transformer (or object with a `drop` method).
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.transduce
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n
		     * @param {*} list
		     * @return {*}
		     * @see R.take
		     * @example
		     *
		     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
		     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
		     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
		     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
		     *      R.drop(3, 'ramda');               //=> 'da'
		     */
		    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
		        return slice(Math.max(0, n), Infinity, xs);
		    }));

		    /**
		     * Returns a list containing all but the last `n` elements of the given `list`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n The number of elements of `xs` to skip.
		     * @param {Array} xs The collection to consider.
		     * @return {Array}
		     * @see R.takeLast
		     * @example
		     *
		     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
		     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
		     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
		     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
		     *      R.dropLast(3, 'ramda');               //=> 'ra'
		     */
		    var dropLast = _curry2(function dropLast(n, xs) {
		        return take(n < xs.length ? xs.length - n : 0, xs);
		    });

		    /**
		     * Returns a new list without any consecutively repeating elements. Equality is
		     * determined by applying the supplied predicate two consecutive elements.
		     * The first element in a series of equal element is the one being preserved.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a, a -> Boolean) -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list The array to consider.
		     * @return {Array} `list` without repeating elements.
		     * @example
		     *
		     *      function lengthEq(x, y) { return Math.abs(x) === Math.abs(y); };
		     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
		     *      R.dropRepeatsWith(lengthEq, l); //=> [1, 3, 4, -5, 3]
		     */
		    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
		        var result = [];
		        var idx = 1;
		        var len = list.length;
		        if (len !== 0) {
		            result[0] = list[0];
		            while (idx < len) {
		                if (!pred(last(result), list[idx])) {
		                    result[result.length] = list[idx];
		                }
		                idx += 1;
		            }
		        }
		        return result;
		    }));

		    /**
		     * Reports whether two objects have the same value, in `R.equals` terms,
		     * for the specified property. Useful as a curried predicate.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig k -> {k: v} -> {k: v} -> Boolean
		     * @param {String} prop The name of the property to compare
		     * @param {Object} obj1
		     * @param {Object} obj2
		     * @return {Boolean}
		     *
		     * @example
		     *
		     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
		     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
		     *      R.eqProps('a', o1, o2); //=> false
		     *      R.eqProps('c', o1, o2); //=> true
		     */
		    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
		        return equals(obj1[prop], obj2[prop]);
		    });

		    /**
		     * Returns the position of the first occurrence of an item in an array,
		     * or -1 if the item is not included in the array. `R.equals` is used to
		     * determine equality.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> Number
		     * @param {*} target The item to find.
		     * @param {Array} xs The array to search in.
		     * @return {Number} the index of the target, or -1 if the target is not found.
		     * @see R.lastIndexOf
		     * @example
		     *
		     *      R.indexOf(3, [1,2,3,4]); //=> 2
		     *      R.indexOf(10, [1,2,3,4]); //=> -1
		     */
		    var indexOf = _curry2(function indexOf(target, xs) {
		        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
		    });

		    /**
		     * Returns all but the last element of the given list or string.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.last, R.head, R.tail
		     * @sig [a] -> [a]
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.init([1, 2, 3]);  //=> [1, 2]
		     *      R.init([1, 2]);     //=> [1]
		     *      R.init([1]);        //=> []
		     *      R.init([]);         //=> []
		     *
		     *      R.init('abc');  //=> 'ab'
		     *      R.init('ab');   //=> 'a'
		     *      R.init('a');    //=> ''
		     *      R.init('');     //=> ''
		     */
		    var init = slice(0, -1);

		    /**
		     * Returns `true` if all elements are unique, in `R.equals` terms,
		     * otherwise `false`.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> Boolean
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if all elements are unique, else `false`.
		     * @example
		     *
		     *      R.isSet(['1', 1]); //=> true
		     *      R.isSet([1, 1]);   //=> false
		     *      R.isSet([[42], [42]]); //=> false
		     */
		    var isSet = _curry1(function isSet(list) {
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            if (_indexOf(list, list[idx], idx + 1) >= 0) {
		                return false;
		            }
		            idx += 1;
		        }
		        return true;
		    });

		    /**
		     * Returns a lens for the given getter and setter functions. The getter "gets"
		     * the value of the focus; the setter "sets" the value of the focus. The setter
		     * should not mutate the data structure.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
		     * @param {Function} getter
		     * @param {Function} setter
		     * @return {Lens}
		     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
		     *
		     *      R.view(xLens, {x: 1, y: 2});            //=> 1
		     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
		     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
		     */
		    var lens = _curry2(function lens(getter, setter) {
		        return function (f) {
		            return function (s) {
		                return map(function (v) {
		                    return setter(v, s);
		                }, f(getter(s)));
		            };
		        };
		    });

		    /**
		     * Returns a lens whose focus is the specified index.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Number -> Lens s a
		     * @param {Number} n
		     * @return {Lens}
		     * @see R.view, R.set, R.over
		     * @example
		     *
		     *      var headLens = R.lensIndex(0);
		     *
		     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
		     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
		     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
		     */
		    var lensIndex = _curry1(function lensIndex(n) {
		        return lens(nth(n), update(n));
		    });

		    /**
		     * Returns a lens whose focus is the specified property.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig String -> Lens s a
		     * @param {String} k
		     * @return {Lens}
		     * @see R.view, R.set, R.over
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.view(xLens, {x: 1, y: 2});            //=> 1
		     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
		     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
		     */
		    var lensProp = _curry1(function lensProp(k) {
		        return lens(prop(k), assoc(k));
		    });

		    /**
		     * "lifts" a function to be the specified arity, so that it may "map over" that many
		     * lists (or other Functors).
		     *
		     * @func
		     * @memberOf R
		     * @see R.lift
		     * @category Function
		     * @sig Number -> (*... -> *) -> ([*]... -> [*])
		     * @param {Function} fn The function to lift into higher context
		     * @return {Function} The function `fn` applicable to mappable objects.
		     * @example
		     *
		     *      var madd3 = R.liftN(3, R.curryN(3, function() {
		     *        return R.reduce(R.add, 0, arguments);
		     *      }));
		     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
		     */
		    var liftN = _curry2(function liftN(arity, fn) {
		        var lifted = curryN(arity, fn);
		        return curryN(arity, function () {
		            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
		        });
		    });

		    /**
		     * Returns the mean of the given list of numbers.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list
		     * @return {Number}
		     * @example
		     *
		     *      R.mean([2, 7, 9]); //=> 6
		     *      R.mean([]); //=> NaN
		     */
		    var mean = _curry1(function mean(list) {
		        return sum(list) / list.length;
		    });

		    /**
		     * Returns the median of the given list of numbers.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list
		     * @return {Number}
		     * @example
		     *
		     *      R.median([2, 9, 7]); //=> 7
		     *      R.median([7, 2, 10, 9]); //=> 8
		     *      R.median([]); //=> NaN
		     */
		    var median = _curry1(function median(list) {
		        var len = list.length;
		        if (len === 0) {
		            return NaN;
		        }
		        var width = 2 - len % 2;
		        var idx = (len - width) / 2;
		        return mean(_slice(list).sort(function (a, b) {
		            return a < b ? -1 : a > b ? 1 : 0;
		        }).slice(idx, idx + width));
		    });

		    /**
		     * Merges a list of objects together into one object.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [{k: v}] -> {k: v}
		     * @param {Array} list An array of objects
		     * @return {Object} A merged object.
		     * @see R.reduce
		     * @example
		     *
		     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
		     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
		     */
		    var mergeAll = _curry1(function mergeAll(list) {
		        return reduce(merge, {}, list);
		    });

		    /**
		     * Performs left-to-right function composition. The leftmost function may have
		     * any arity; the remaining functions must be unary.
		     *
		     * In some libraries this function is named `sequence`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.compose
		     * @example
		     *
		     *      var f = R.pipe(Math.pow, R.negate, R.inc);
		     *
		     *      f(3, 4); // -(3^4) + 1
		     */
		    var pipe = function pipe() {
		        if (arguments.length === 0) {
		            throw new Error('pipe requires at least one argument');
		        }
		        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
		    };

		    /**
		     * Performs left-to-right composition of one or more Promise-returning
		     * functions. The leftmost function may have any arity; the remaining
		     * functions must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.composeP
		     * @example
		     *
		     *      //  followersForUser :: String -> Promise [User]
		     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
		     */
		    var pipeP = function pipeP() {
		        if (arguments.length === 0) {
		            throw new Error('pipeP requires at least one argument');
		        }
		        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
		    };

		    /**
		     * Multiplies together all the elements of a list.
		     *
		     * @func
		     * @memberOf R
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list An array of numbers
		     * @return {Number} The product of all the numbers in the list.
		     * @see R.reduce
		     * @example
		     *
		     *      R.product([2,4,6,8,100,1]); //=> 38400
		     */
		    var product = reduce(multiply, 1);

		    /**
		     * Reasonable analog to SQL `select` statement.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @category Relation
		     * @sig [k] -> [{k: v}] -> [{k: v}]
		     * @param {Array} props The property names to project
		     * @param {Array} objs The objects to query
		     * @return {Array} An array of objects with just the `props` properties.
		     * @example
		     *
		     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
		     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
		     *      var kids = [abby, fred];
		     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
		     */
		    // passing `identity` gives correct arity
		    var project = useWith(_map, pickAll, identity);

		    /**
		     * Returns a new list containing the last `n` elements of the given list.
		     * If `n > list.length`, returns a list of `list.length` elements.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n The number of elements to return.
		     * @param {Array} xs The collection to consider.
		     * @return {Array}
		     * @see R.dropLast
		     * @example
		     *
		     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
		     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['for', 'baz']
		     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.takeLast(3, 'ramda');               //=> 'mda'
		     */
		    var takeLast = _curry2(function takeLast(n, xs) {
		        return drop(n >= 0 ? xs.length - n : 0, xs);
		    });

		    var _contains = function _contains(a, list) {
		        return _indexOf(list, a, 0) >= 0;
		    };

		    //  mapPairs :: (Object, [String]) -> [String]
		    // Function, RegExp, user-defined types
		    var _toString = function _toString(x, seen) {
		        var recur = function recur(y) {
		            var xs = seen.concat([x]);
		            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
		        };
		        //  mapPairs :: (Object, [String]) -> [String]
		        var mapPairs = function (obj, keys) {
		            return _map(function (k) {
		                return _quote(k) + ': ' + recur(obj[k]);
		            }, keys.slice().sort());
		        };
		        switch (Object.prototype.toString.call(x)) {
		        case '[object Arguments]':
		            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
		        case '[object Array]':
		            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
		        case '[object Boolean]':
		            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
		        case '[object Date]':
		            return 'new Date(' + _quote(_toISOString(x)) + ')';
		        case '[object Null]':
		            return 'null';
		        case '[object Number]':
		            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
		        case '[object String]':
		            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
		        case '[object Undefined]':
		            return 'undefined';
		        default:
		            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
		            '{' + mapPairs(x, keys(x)).join(', ') + '}';
		        }
		    };

		    /**
		     * Turns a list of Functors into a Functor of a list.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @see R.commuteMap
		     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
		     * @param {Function} of A function that returns the data type to return
		     * @param {Array} list An array of functors of the same type
		     * @return {*}
		     * @example
		     *
		     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
		     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
		     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
		     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
		     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     */
		    var commute = commuteMap(identity);

		    /**
		     * Performs right-to-left function composition. The rightmost function may have
		     * any arity; the remaining functions must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.pipe
		     * @example
		     *
		     *      var f = R.compose(R.inc, R.negate, Math.pow);
		     *
		     *      f(3, 4); // -(3^4) + 1
		     */
		    var compose = function compose() {
		        if (arguments.length === 0) {
		            throw new Error('compose requires at least one argument');
		        }
		        return pipe.apply(this, reverse(arguments));
		    };

		    /**
		     * Returns the right-to-left Kleisli composition of the provided functions,
		     * each of which must return a value of a type supported by [`chain`](#chain).
		     *
		     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @see R.pipeK
		     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
		     * @param {...Function}
		     * @return {Function}
		     * @example
		     *
		     *      //  parseJson :: String -> Maybe *
		     *      //  get :: String -> Object -> Maybe *
		     *
		     *      //  getStateCode :: Maybe String -> Maybe String
		     *      var getStateCode = R.composeK(
		     *        R.compose(Maybe.of, R.toUpper),
		     *        get('state'),
		     *        get('address'),
		     *        get('user'),
		     *        parseJson
		     *      );
		     *
		     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
		     *      //=> Just('NY')
		     *      getStateCode(Maybe.of('[Invalid JSON]'));
		     *      //=> Nothing()
		     */
		    var composeK = function composeK() {
		        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
		    };

		    /**
		     * Performs right-to-left composition of one or more Promise-returning
		     * functions. The rightmost function may have any arity; the remaining
		     * functions must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.pipeP
		     * @example
		     *
		     *      //  followersForUser :: String -> Promise [User]
		     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
		     */
		    var composeP = function composeP() {
		        if (arguments.length === 0) {
		            throw new Error('composeP requires at least one argument');
		        }
		        return pipeP.apply(this, reverse(arguments));
		    };

		    /**
		     * Wraps a constructor function inside a curried function that can be called with the same
		     * arguments and returns the same type.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (* -> {*}) -> (* -> {*})
		     * @param {Function} Fn The constructor function to wrap.
		     * @return {Function} A wrapped, curried constructor function.
		     * @example
		     *
		     *      // Constructor function
		     *      var Widget = function(config) {
		     *        // ...
		     *      };
		     *      Widget.prototype = {
		     *        // ...
		     *      };
		     *      var allConfigs = [
		     *        // ...
		     *      ];
		     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
		     */
		    var construct = _curry1(function construct(Fn) {
		        return constructN(Fn.length, Fn);
		    });

		    /**
		     * Returns `true` if the specified value is equal, in `R.equals` terms,
		     * to at least one element of the given list; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig a -> [a] -> Boolean
		     * @param {Object} a The item to compare against.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
		     *
		     * @example
		     *
		     *      R.contains(3, [1, 2, 3]); //=> true
		     *      R.contains(4, [1, 2, 3]); //=> false
		     *      R.contains([42], [[42]]); //=> true
		     */
		    var contains = _curry2(_contains);

		    /**
		     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig [a] -> [a] -> [a]
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The elements in `list1` that are not in `list2`.
		     * @see R.differenceWith
		     * @example
		     *
		     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
		     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
		     */
		    var difference = _curry2(function difference(first, second) {
		        var out = [];
		        var idx = 0;
		        var firstLen = first.length;
		        while (idx < firstLen) {
		            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
		                out[out.length] = first[idx];
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new list without any consecutively repeating elements.
		     * `R.equals` is used to determine equality.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     * @see R.transduce
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig [a] -> [a]
		     * @param {Array} list The array to consider.
		     * @return {Array} `list` without repeating elements.
		     * @example
		     *
		     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
		     */
		    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig [a] -> [a] -> [a]
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @see R.intersectionWith
		     * @return {Array} The list of elements found in both `list1` and `list2`.
		     * @example
		     *
		     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
		     */
		    var intersection = _curry2(function intersection(list1, list2) {
		        return uniq(_filter(flip(_contains)(list1), list2));
		    });

		    /**
		     * "lifts" a function of arity > 1 so that it may "map over" an Array or
		     * other Functor.
		     *
		     * @func
		     * @memberOf R
		     * @see R.liftN
		     * @category Function
		     * @sig (*... -> *) -> ([*]... -> [*])
		     * @param {Function} fn The function to lift into higher context
		     * @return {Function} The function `fn` applicable to mappable objects.
		     * @example
		     *
		     *      var madd3 = R.lift(R.curry(function(a, b, c) {
		     *        return a + b + c;
		     *      }));
		     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
		     *
		     *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {
		     *        return a + b + c + d + e;
		     *      }));
		     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
		     */
		    var lift = _curry1(function lift(fn) {
		        return liftN(fn.length, fn);
		    });

		    /**
		     * Returns a partial copy of an object omitting the keys specified.
		     *
		     * @func
		     * @memberOf R
		     * @category Object
		     * @sig [String] -> {String: *} -> {String: *}
		     * @param {Array} names an array of String property names to omit from the new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with properties from `names` not on it.
		     * @see R.pick
		     * @example
		     *
		     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
		     */
		    var omit = _curry2(function omit(names, obj) {
		        var result = {};
		        for (var prop in obj) {
		            if (!_contains(prop, names)) {
		                result[prop] = obj[prop];
		            }
		        }
		        return result;
		    });

		    /**
		     * Returns the left-to-right Kleisli composition of the provided functions,
		     * each of which must return a value of a type supported by [`chain`](#chain).
		     *
		     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @see R.composeK
		     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
		     * @param {...Function}
		     * @return {Function}
		     * @example
		     *
		     *      //  parseJson :: String -> Maybe *
		     *      //  get :: String -> Object -> Maybe *
		     *
		     *      //  getStateCode :: Maybe String -> Maybe String
		     *      var getStateCode = R.pipeK(
		     *        parseJson,
		     *        get('user'),
		     *        get('address'),
		     *        get('state'),
		     *        R.compose(Maybe.of, R.toUpper)
		     *      );
		     *
		     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
		     *      //=> Just('NY')
		     *      getStateCode(Maybe.of('[Invalid JSON]'));
		     *      //=> Nothing()
		     */
		    var pipeK = function pipeK() {
		        return composeK.apply(this, reverse(arguments));
		    };

		    /**
		     * Returns the string representation of the given value. `eval`'ing the output
		     * should result in a value equivalent to the input value. Many of the built-in
		     * `toString` methods do not satisfy this requirement.
		     *
		     * If the given value is an `[object Object]` with a `toString` method other
		     * than `Object.prototype.toString`, this method is invoked with no arguments
		     * to produce the return value. This means user-defined constructor functions
		     * can provide a suitable `toString` method. For example:
		     *
		     *     function Point(x, y) {
		     *       this.x = x;
		     *       this.y = y;
		     *     }
		     *
		     *     Point.prototype.toString = function() {
		     *       return 'new Point(' + this.x + ', ' + this.y + ')';
		     *     };
		     *
		     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig * -> String
		     * @param {*} val
		     * @return {String}
		     * @example
		     *
		     *      R.toString(42); //=> '42'
		     *      R.toString('abc'); //=> '"abc"'
		     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
		     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
		     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
		     */
		    var toString = _curry1(function toString(val) {
		        return _toString(val, []);
		    });

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of the
		     * elements of each list.
		     *
		     * @func
		     * @memberOf R
		     * @category Relation
		     * @sig [a] -> [a] -> [a]
		     * @param {Array} as The first list.
		     * @param {Array} bs The second list.
		     * @return {Array} The first and second lists concatenated, with
		     *         duplicates removed.
		     * @example
		     *
		     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
		     */
		    var union = _curry2(compose(uniq, _concat));

		    /**
		     * Returns a new list containing only one copy of each element in the
		     * original list, based upon the value returned by applying the supplied
		     * function to each list element. Prefers the first item if the supplied
		     * function produces the same value on two items. `R.equals` is used for
		     * comparison.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig (a -> b) -> [a] -> [a]
		     * @param {Function} fn A function used to produce a value to use during comparisons.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
		     */
		    var uniqBy = _curry2(function uniqBy(fn, list) {
		        var idx = 0, applied = [], result = [], appliedItem, item;
		        while (idx < list.length) {
		            item = list[idx];
		            appliedItem = fn(item);
		            if (!_contains(appliedItem, applied)) {
		                result.push(item);
		                applied.push(appliedItem);
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Turns a named method with a specified arity into a function
		     * that can be called directly supplied with arguments and a target object.
		     *
		     * The returned function is curried and accepts `arity + 1` parameters where
		     * the final parameter is the target object.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
		     * @param {Number} arity Number of arguments the returned function should take
		     *        before the target object.
		     * @param {Function} method Name of the method to call.
		     * @return {Function} A new curried function.
		     * @example
		     *
		     *      var sliceFrom = R.invoker(1, 'slice');
		     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
		     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
		     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
		     */
		    var invoker = _curry2(function invoker(arity, method) {
		        return curryN(arity + 1, function () {
		            var target = arguments[arity];
		            if (target != null && is(Function, target[method])) {
		                return target[method].apply(target, _slice(arguments, 0, arity));
		            }
		            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
		        });
		    });

		    /**
		     * Returns a string made by inserting the `separator` between each
		     * element and concatenating all the elements into a single string.
		     *
		     * @func
		     * @memberOf R
		     * @category List
		     * @sig String -> [a] -> String
		     * @param {Number|String} separator The string used to separate the elements.
		     * @param {Array} xs The elements to join into a string.
		     * @return {String} str The string made by concatenating `xs` with `separator`.
		     * @see R.split
		     * @example
		     *
		     *      var spacer = R.join(' ');
		     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
		     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
		     */
		    var join = invoker(1, 'join');

		    /**
		     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
		     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
		     * argument set will not result in an additional call to `fn`; instead, the cached result
		     * for that set of arguments will be returned.
		     *
		     * @func
		     * @memberOf R
		     * @category Function
		     * @sig (*... -> a) -> (*... -> a)
		     * @param {Function} fn The function to memoize.
		     * @return {Function} Memoized version of `fn`.
		     * @example
		     *
		     *      var count = 0;
		     *      var factorial = R.memoize(function(n) {
		     *        count += 1;
		     *        return R.product(R.range(1, n + 1));
		     *      });
		     *      factorial(5); //=> 120
		     *      factorial(5); //=> 120
		     *      factorial(5); //=> 120
		     *      count; //=> 1
		     */
		    var memoize = _curry1(function memoize(fn) {
		        var cache = {};
		        return function () {
		            var key = toString(arguments);
		            if (!_has(key, cache)) {
		                cache[key] = fn.apply(this, arguments);
		            }
		            return cache[key];
		        };
		    });

		    /**
		     * Splits a string into an array of strings based on the given
		     * separator.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig String -> String -> [String]
		     * @param {String} sep The separator string.
		     * @param {String} str The string to separate into an array.
		     * @return {Array} The array of strings from `str` separated by `str`.
		     * @see R.join
		     * @example
		     *
		     *      var pathComponents = R.split('/');
		     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
		     *
		     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
		     */
		    var split = invoker(1, 'split');

		    /**
		     * The lower case version of a string.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to lower case.
		     * @return {String} The lower case version of `str`.
		     * @see R.toUpper
		     * @example
		     *
		     *      R.toLower('XYZ'); //=> 'xyz'
		     */
		    var toLower = invoker(0, 'toLowerCase');

		    /**
		     * The upper case version of a string.
		     *
		     * @func
		     * @memberOf R
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to upper case.
		     * @return {String} The upper case version of `str`.
		     * @see R.toLower
		     * @example
		     *
		     *      R.toUpper('abc'); //=> 'ABC'
		     */
		    var toUpper = invoker(0, 'toUpperCase');

		    var R = {
		        F: F,
		        T: T,
		        __: __,
		        add: add,
		        addIndex: addIndex,
		        adjust: adjust,
		        all: all,
		        allPass: allPass,
		        always: always,
		        and: and,
		        any: any,
		        anyPass: anyPass,
		        ap: ap,
		        aperture: aperture,
		        append: append,
		        apply: apply,
		        assoc: assoc,
		        assocPath: assocPath,
		        binary: binary,
		        bind: bind,
		        both: both,
		        call: call,
		        chain: chain,
		        clone: clone,
		        commute: commute,
		        commuteMap: commuteMap,
		        comparator: comparator,
		        complement: complement,
		        compose: compose,
		        composeK: composeK,
		        composeP: composeP,
		        concat: concat,
		        cond: cond,
		        construct: construct,
		        constructN: constructN,
		        contains: contains,
		        containsWith: containsWith,
		        converge: converge,
		        countBy: countBy,
		        createMapEntry: createMapEntry,
		        curry: curry,
		        curryN: curryN,
		        dec: dec,
		        defaultTo: defaultTo,
		        difference: difference,
		        differenceWith: differenceWith,
		        dissoc: dissoc,
		        dissocPath: dissocPath,
		        divide: divide,
		        drop: drop,
		        dropLast: dropLast,
		        dropLastWhile: dropLastWhile,
		        dropRepeats: dropRepeats,
		        dropRepeatsWith: dropRepeatsWith,
		        dropWhile: dropWhile,
		        either: either,
		        empty: empty,
		        eqProps: eqProps,
		        equals: equals,
		        evolve: evolve,
		        filter: filter,
		        find: find,
		        findIndex: findIndex,
		        findLast: findLast,
		        findLastIndex: findLastIndex,
		        flatten: flatten,
		        flip: flip,
		        forEach: forEach,
		        fromPairs: fromPairs,
		        functions: functions,
		        functionsIn: functionsIn,
		        groupBy: groupBy,
		        gt: gt,
		        gte: gte,
		        has: has,
		        hasIn: hasIn,
		        head: head,
		        identical: identical,
		        identity: identity,
		        ifElse: ifElse,
		        inc: inc,
		        indexOf: indexOf,
		        init: init,
		        insert: insert,
		        insertAll: insertAll,
		        intersection: intersection,
		        intersectionWith: intersectionWith,
		        intersperse: intersperse,
		        into: into,
		        invert: invert,
		        invertObj: invertObj,
		        invoker: invoker,
		        is: is,
		        isArrayLike: isArrayLike,
		        isEmpty: isEmpty,
		        isNil: isNil,
		        isSet: isSet,
		        join: join,
		        keys: keys,
		        keysIn: keysIn,
		        last: last,
		        lastIndexOf: lastIndexOf,
		        length: length,
		        lens: lens,
		        lensIndex: lensIndex,
		        lensProp: lensProp,
		        lift: lift,
		        liftN: liftN,
		        lt: lt,
		        lte: lte,
		        map: map,
		        mapAccum: mapAccum,
		        mapAccumRight: mapAccumRight,
		        mapObj: mapObj,
		        mapObjIndexed: mapObjIndexed,
		        match: match,
		        mathMod: mathMod,
		        max: max,
		        maxBy: maxBy,
		        mean: mean,
		        median: median,
		        memoize: memoize,
		        merge: merge,
		        mergeAll: mergeAll,
		        min: min,
		        minBy: minBy,
		        modulo: modulo,
		        multiply: multiply,
		        nAry: nAry,
		        negate: negate,
		        none: none,
		        not: not,
		        nth: nth,
		        nthArg: nthArg,
		        nthChar: nthChar,
		        nthCharCode: nthCharCode,
		        of: of,
		        omit: omit,
		        once: once,
		        or: or,
		        over: over,
		        partial: partial,
		        partialRight: partialRight,
		        partition: partition,
		        path: path,
		        pathEq: pathEq,
		        pick: pick,
		        pickAll: pickAll,
		        pickBy: pickBy,
		        pipe: pipe,
		        pipeK: pipeK,
		        pipeP: pipeP,
		        pluck: pluck,
		        prepend: prepend,
		        product: product,
		        project: project,
		        prop: prop,
		        propEq: propEq,
		        propIs: propIs,
		        propOr: propOr,
		        propSatisfies: propSatisfies,
		        props: props,
		        range: range,
		        reduce: reduce,
		        reduceRight: reduceRight,
		        reduced: reduced,
		        reject: reject,
		        remove: remove,
		        repeat: repeat,
		        replace: replace,
		        reverse: reverse,
		        scan: scan,
		        set: set,
		        slice: slice,
		        sort: sort,
		        sortBy: sortBy,
		        split: split,
		        splitEvery: splitEvery,
		        subtract: subtract,
		        sum: sum,
		        tail: tail,
		        take: take,
		        takeLast: takeLast,
		        takeLastWhile: takeLastWhile,
		        takeWhile: takeWhile,
		        tap: tap,
		        test: test,
		        times: times,
		        toLower: toLower,
		        toPairs: toPairs,
		        toPairsIn: toPairsIn,
		        toString: toString,
		        toUpper: toUpper,
		        transduce: transduce,
		        trim: trim,
		        type: type,
		        unapply: unapply,
		        unary: unary,
		        uncurryN: uncurryN,
		        unfold: unfold,
		        union: union,
		        unionWith: unionWith,
		        uniq: uniq,
		        uniqBy: uniqBy,
		        uniqWith: uniqWith,
		        unnest: unnest,
		        update: update,
		        useWith: useWith,
		        values: values,
		        valuesIn: valuesIn,
		        view: view,
		        where: where,
		        whereEq: whereEq,
		        wrap: wrap,
		        xprod: xprod,
		        zip: zip,
		        zipObj: zipObj,
		        zipWith: zipWith
		    };

		  /* TEST_ENTRY_POINT */

		  if (true) {
		    module.exports = R;
		  } else if (typeof define === 'function' && define.amd) {
		    define(function() { return R; });
		  } else {
		    this.R = R;
		  }

		}.call(this));


	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		var _equals = __webpack_require__(15).equals;


		module.exports = {

		  baseMap: function(f) {
		    return f(this.value);
		  },

		  getEquals: function(constructor) {
		    return function equals(that) {
		      return that instanceof constructor && _equals(this.value, that.value);
		    };
		  },

		  extend: function(Child, Parent) {
		    function Ctor() {
		      this.constructor = Child;
		    }
		    Ctor.prototype = Parent.prototype;
		    Child.prototype = new Ctor();
		    Child.super_ = Parent.prototype;
		  },

		  identity: function(x) { return x; },

		  notImplemented: function(str) {
		    return function() {
		      throw new Error(str + ' is not implemented');
		    };
		  },

		  notCallable: function(fn) {
		    return function() {
		      throw new Error(fn + ' cannot be called directly');
		    };
		  },

		  returnThis: function() { return this; }

		};


	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		// `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)
		function Future(f) {
		  if (!(this instanceof Future)) {
		    return new Future(f);
		  }
		  this._fork = f;
		}

		Future.prototype.fork = function(reject, resolve) {
		  try {
		    this._fork(reject, resolve);
		  } catch(e) {
		    reject(e);
		  }
		};

		// functor
		Future.prototype.map = function(f) {
		  return this.chain(function(a) { return Future.of(f(a)); });
		};

		// apply
		Future.prototype.ap = function(m) {
		  var self = this;

		  return new Future(function(rej, res) {
		    var applyFn, val;
		    var doReject = R.once(rej);

		    function resolveIfDone() {
		      if (applyFn != null && val != null) {
		        return res(applyFn(val));
		      }
		    }

		    self.fork(doReject, function(fn) {
		      applyFn = fn;
		      resolveIfDone();
		    });

		    m.fork(doReject, function(v) {
		      val = v;
		      resolveIfDone();
		    });

		  });

		};

		// applicative
		Future.of = function(x) {
		  // should include a default rejection?
		  return new Future(function(_, resolve) { return resolve(x); });
		};

		Future.prototype.of = Future.of;

		// chain
		//  f must be a function which returns a value
		//  f must return a value of the same Chain
		//  chain must return a value of the same Chain
		//:: Future a, b => (b -> Future c) -> Future c
		Future.prototype.chain = function(f) {  // Sorella's:
		  return new Future(function(reject, resolve) {
		    return this.fork(function(a) { return reject(a); },
		                     function(b) { return f(b).fork(reject, resolve); });
		  }.bind(this));
		};

		// chainReject
		// Like chain but operates on the reject instead of the resolve case.
		//:: Future a, b => (a -> Future c) -> Future c
		Future.prototype.chainReject = function(f) {
		  return new Future(function(reject, resolve) {
		    return this.fork(function(a) { return f(a).fork(reject, resolve); },
		                     function(b) { return resolve(b);
		    });
		  }.bind(this));
		};

		// monad
		// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
		// see above.

		Future.prototype.bimap = function(errFn, successFn) {
		  var self = this;
		  return new Future(function(reject, resolve) {
		    self.fork(function(err) {
		      reject(errFn(err));
		    }, function(val) {
		      resolve(successFn(val));
		    });
		  });
		};

		Future.reject = function(val) {
		  return new Future(function(reject) {
		    reject(val);
		  });
		};

		Future.prototype.toString = function() {
		  return 'Future(' + R.toString(this._fork) + ')';
		};

		Future.cache = function(f) {
		  var status = 'IDLE';
		  var listeners = [];
		  var cachedValue;

		  var handleCompletion = R.curry(function(newStatus, cb, val) {
		    status = newStatus;
		    cachedValue = val;
		    cb(val);
		    R.forEach(function(listener) {
		      listener[status](cachedValue);
		    }, listeners);
		  });

		  function addListeners(reject, resolve) {
		    listeners.push({ REJECTED: reject, RESOLVED: resolve } );
		  }

		  function doResolve(reject, resolve) {
		    status = 'PENDING';
		    return f.fork(
		      handleCompletion('REJECTED', reject),
		      handleCompletion('RESOLVED', resolve)
		    );
		  }

		  return new Future(function(reject, resolve) {

		    switch(status) {
		      case 'IDLE': doResolve(reject, resolve); break;
		      case 'PENDING': addListeners(reject, resolve); break;
		      case 'REJECTED': reject(cachedValue); break;
		      case 'RESOLVED': resolve(cachedValue); break;
		    }

		  });
		};

		module.exports = Future;


	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		var util = __webpack_require__(16);


		/**
		 * A data type that holds a value and exposes a monadic api.
		 */

		/**
		 * Constructs a new `Identity[a]` data type that holds a single
		 * value `a`.
		 * @param {*} a Value of any type
		 * @sig a -> Identity[a]
		 */
		function Identity(x) {
		  if (!(this instanceof Identity)) {
		    return new Identity(x);
		  }
		  this.value = x;
		}

		/**
		 * Applicative specification. Creates a new `Identity[a]` holding the value `a`.
		 * @param {*} a Value of any type
		 * @returns Identity[a]
		 * @sig a -> Identity[a]
		 */
		Identity.of = function(x) {
		  return new Identity(x);
		};
		Identity.prototype.of = Identity.of;

		/**
		 * Functor specification. Creates a new `Identity[a]` mapping function `f` onto
		 * `a` returning any value b.
		 * @param {Function} f Maps `a` to any value `b`
		 * @returns Identity[b]
		 * @sig @Identity[a] => (a -> b) -> Identity[b]
		 */
		Identity.prototype.map = function(f) {
		  return new Identity(f(this.value));
		};

		/**
		 * Apply specification. Applies the function inside the `Identity[a]`
		 * type to another applicative type.
		 * @param {Applicative[a]} app Applicative that will apply its function
		 * @returns Applicative[b]
		 * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]
		 */
		Identity.prototype.ap = function(app) {
		  return app.map(this.value);
		};

		/**
		 * Chain specification. Transforms the value of the `Identity[a]`
		 * type using an unary function to monads. The `Identity[a]` type
		 * should contain a function, otherwise an error is thrown.
		 *
		 * @param {Function} fn Transforms `a` into a `Monad[b]`
		 * @returns Monad[b]
		 * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]
		 */
		Identity.prototype.chain = function(fn) {
		  return fn(this.value);
		};

		/**
		 * Returns the value of `Identity[a]`
		 *
		 * @returns a
		 * @sig (Identity[a]) => a
		 */
		Identity.prototype.get = function() {
		  return this.value;
		};

		// equality method to enable testing
		Identity.prototype.equals = util.getEquals(Identity);

		Identity.prototype.toString = function() {
		  return 'Identity(' + R.toString(this.value) + ')';
		};

		module.exports = Identity;


	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		module.exports = IO;

		var compose = R.compose;

		function IO(fn) {
		  if (!(this instanceof IO)) {
		    return new IO(fn);
		  }
		  this.fn = fn;
		}

		// `f` must return an IO
		IO.prototype.chain = function(f) {
		  var io = this;
		  return new IO(function() {
		    var next = f(io.fn.apply(io, arguments));
		    return next.fn.apply(next, arguments);
		  });
		};

		IO.prototype.map = function(f) {
		  var io = this;
		  return new IO(compose(f, io.fn));
		};

		// `this` IO must wrap a function `f` that takes an IO (`thatIo`) as input
		// `f` must return an IO
		IO.prototype.ap = function(thatIo) {
		  return this.chain(function(f) {
		    return thatIo.map(f);
		  });
		};

		IO.runIO = function(io) {
		  return io.runIO.apply(io, [].slice.call(arguments, 1));
		};

		IO.prototype.runIO = function() {
		  return this.fn.apply(this, arguments);
		};

		IO.prototype.of = function(x) {
		  return new IO(function() { return x; });
		};

		IO.of = IO.prototype.of;

		IO.prototype.toString = function() {
		  return 'IO(' + R.toString(this.fn) + ')';
		};


	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		module.exports = R.curryN(3, function lift2(f, a1, a2) {
		  return a1.map(f).ap(a2);
		});


	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		module.exports = R.curryN(4, function lift3(f, a1, a2, a3) {
		  return a1.map(f).ap(a2).ap(a3);
		});


	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);

		var util = __webpack_require__(16);

		function Maybe(x) {
		  return x == null ? _nothing : Maybe.Just(x);
		}

		function _Just(x) {
		  this.value = x;
		}
		util.extend(_Just, Maybe);

		function _Nothing() {}
		util.extend(_Nothing, Maybe);

		var _nothing = new _Nothing();

		Maybe.Nothing = function() {
		  return _nothing;
		};

		Maybe.Just = function(x) {
		  return new _Just(x);
		};

		Maybe.of = Maybe.Just;

		Maybe.prototype.of = Maybe.Just;

		Maybe.isJust = function(x) {
		  return x instanceof _Just;
		};

		Maybe.isNothing = function(x) {
		  return x === _nothing;
		};

		Maybe.maybe = R.curry(function(nothingVal, justFn, m) {
		  return m.reduce(function(_, x) {
		    return justFn(x);
		  }, nothingVal);
		});

		// functor
		_Just.prototype.map = function(f) {
		  return this.of(f(this.value));
		};

		_Nothing.prototype.map = util.returnThis;

		// apply
		// takes a Maybe that wraps a function (`app`) and applies its `map`
		// method to this Maybe's value, which must be a function.
		_Just.prototype.ap = function(m) {
		  return m.map(this.value);
		};

		_Nothing.prototype.ap = util.returnThis;

		// applicative
		// `of` inherited from `Maybe`


		// chain
		//  f must be a function which returns a value
		//  f must return a value of the same Chain
		//  chain must return a value of the same Chain
		_Just.prototype.chain = util.baseMap;

		_Nothing.prototype.chain = util.returnThis;


		//
		_Just.prototype.datatype = _Just;

		_Nothing.prototype.datatype = _Nothing;

		// monad
		// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
		// see above.

		// equality method to enable testing
		_Just.prototype.equals = util.getEquals(_Just);

		_Nothing.prototype.equals = function(that) {
		  return that === _nothing;
		};

		Maybe.prototype.isNothing = function() {
		  return this === _nothing;
		};

		Maybe.prototype.isJust = function() {
		  return this instanceof _Just;
		};

		_Just.prototype.getOrElse = function() {
		  return this.value;
		};

		_Nothing.prototype.getOrElse = function(a) {
		  return a;
		};

		_Just.prototype.reduce = function(f, x) {
		  return f(x, this.value);
		};

		_Nothing.prototype.reduce = function(f, x) {
		  return x;
		};

		_Just.prototype.toString = function() {
		  return 'Maybe.Just(' + R.toString(this.value) + ')';
		};

		_Nothing.prototype.toString = function() {
		  return 'Maybe.Nothing()';
		};

		module.exports = Maybe;


	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);


		function Tuple(x, y) {
		  switch (arguments.length) {
		    case 0:
		      throw new TypeError('no arguments to Tuple');
		    case 1:
		      return function(y) {
		        return new _Tuple(x, y);
		      };
		    default:
		      return new _Tuple(x, y);
		  }
		}

		function _Tuple(x, y) {
		  this[0] = x;
		  this[1] = y;
		  this.length = 2;
		}

		function ensureConcat(xs) {
		  xs.forEach(function(x) {
		    if (typeof x.concat != 'function') {
		      throw new TypeError(R.toString(x) + ' must be a semigroup to perform this operation');
		    }
		  });
		}

		Tuple.fst = function(x) {
		  return x[0];
		};

		Tuple.snd = function(x) {
		  return x[1];
		};

		// semigroup
		_Tuple.prototype.concat = function(x) {
		  ensureConcat([this[0], this[1]]);
		  return Tuple(this[0].concat(x[0]), this[1].concat(x[1]));
		};

		// functor
		_Tuple.prototype.map = function(f) {
		  return Tuple(this[0], f(this[1]));
		};

		// apply
		_Tuple.prototype.ap = function(m) {
		  ensureConcat([this[0]]);
		  return Tuple(this[0].concat(m[0]), this[1](m[1]));
		};

		// setoid
		_Tuple.prototype.equals = function(that) {
		  return that instanceof _Tuple && R.equals(this[0], that[0]) && R.equals(this[1], that[1]);
		};

		_Tuple.prototype.toString = function() {
		  return 'Tuple(' + R.toString(this[0]) + ', ' + R.toString(this[1]) + ')';
		};

		module.exports = Tuple;


	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {

		var R = __webpack_require__(15);


		function Reader(run) {
		  if (!(this instanceof Reader)) {
		    return new Reader(run);
		  }
		  this.run = run;
		}

		Reader.run = function(reader) {
		  return reader.run.apply(reader, [].slice.call(arguments, 1));
		};

		Reader.prototype.chain = function(f) {
		  var reader = this;
		  return new Reader(function(r) {
		    return f(reader.run(r)).run(r);
		  });
		};

		Reader.prototype.ap = function(a) {
		  return this.chain(function(f) {
		    return a.map(f);
		  });
		};

		Reader.prototype.map = function(f) {
		  return this.chain(function(a) {
		    return Reader.of(f(a));
		  });
		};

		Reader.prototype.of = function(a) {
		  return new Reader(function() {
		    return a;
		  });
		};
		Reader.of = Reader.prototype.of;

		Reader.ask = Reader(R.identity);

		Reader.prototype.toString = function() {
		  return 'Reader(' + R.toString(this.run) + ')';
		};

		Reader.T = function(M) {
		  var ReaderT = function ReaderT(run) {
		    if (!(this instanceof ReaderT)) {
		      return new ReaderT(run);
		    }
		    this.run = run;
		  };

		  ReaderT.lift = R.compose(ReaderT, R.always);

		  ReaderT.ask = ReaderT(M.of);

		  ReaderT.prototype.of = ReaderT.of = function(a) {
		    return ReaderT(function() {
		      return M.of(a);
		    });
		  };

		  ReaderT.prototype.chain = function(f) {
		    var readerT = this;
		    return ReaderT(function(e) {
		      var m = readerT.run(e);
		      return m.chain(function(a) {
		        return f(a).run(e);
		      });
		    });
		  };

		  ReaderT.prototype.map = function(f) {
		    return this.chain(function(a) {
		      return ReaderT.of(f(a));
		    });
		  };

		  ReaderT.prototype.ap = function(a) {
		    var readerT = this;
		    return ReaderT(function(e) {
		      return readerT.run(e).ap(a.run(e));
		    });
		  };

		  ReaderT.prototype.equals = function(that) {
		    return this === that ||
		      this.run === that.run ||
		      R.equals(this.run().get(), that.run().get());
		  };

		  ReaderT.prototype.toString = function() {
		    return 'ReaderT[' + M.name + '](' + R.toString(this.run) + ')';
		  };

		  return ReaderT;
		};

		module.exports = Reader;


	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {

		//  Ramda v0.19.1
		//  https://github.com/ramda/ramda
		//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
		//  Ramda may be freely distributed under the MIT license.

		;(function() {

		  'use strict';

		  /**
		     * A special placeholder value used to specify "gaps" within curried functions,
		     * allowing partial application of any combination of arguments, regardless of
		     * their positions.
		     *
		     * If `g` is a curried ternary function and `_` is `R.__`, the following are
		     * equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2, _)(1, 3)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @constant
		     * @memberOf R
		     * @since v0.6.0
		     * @category Function
		     * @example
		     *
		     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
		     *      greet('Alice'); //=> 'Hello, Alice!'
		     */
		    var __ = { '@@functional/placeholder': true };

		    /* eslint-disable no-unused-vars */
		    var _arity = function _arity(n, fn) {
		        /* eslint-disable no-unused-vars */
		        switch (n) {
		        case 0:
		            return function () {
		                return fn.apply(this, arguments);
		            };
		        case 1:
		            return function (a0) {
		                return fn.apply(this, arguments);
		            };
		        case 2:
		            return function (a0, a1) {
		                return fn.apply(this, arguments);
		            };
		        case 3:
		            return function (a0, a1, a2) {
		                return fn.apply(this, arguments);
		            };
		        case 4:
		            return function (a0, a1, a2, a3) {
		                return fn.apply(this, arguments);
		            };
		        case 5:
		            return function (a0, a1, a2, a3, a4) {
		                return fn.apply(this, arguments);
		            };
		        case 6:
		            return function (a0, a1, a2, a3, a4, a5) {
		                return fn.apply(this, arguments);
		            };
		        case 7:
		            return function (a0, a1, a2, a3, a4, a5, a6) {
		                return fn.apply(this, arguments);
		            };
		        case 8:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
		                return fn.apply(this, arguments);
		            };
		        case 9:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
		                return fn.apply(this, arguments);
		            };
		        case 10:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
		                return fn.apply(this, arguments);
		            };
		        default:
		            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
		        }
		    };

		    var _arrayFromIterator = function _arrayFromIterator(iter) {
		        var list = [];
		        var next;
		        while (!(next = iter.next()).done) {
		            list.push(next.value);
		        }
		        return list;
		    };

		    var _cloneRegExp = function _cloneRegExp(pattern) {
		        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
		    };

		    var _complement = function _complement(f) {
		        return function () {
		            return !f.apply(this, arguments);
		        };
		    };

		    /**
		     * Private `concat` function to merge two array-like objects.
		     *
		     * @private
		     * @param {Array|Arguments} [set1=[]] An array-like object.
		     * @param {Array|Arguments} [set2=[]] An array-like object.
		     * @return {Array} A new, merged array.
		     * @example
		     *
		     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
		     */
		    var _concat = function _concat(set1, set2) {
		        set1 = set1 || [];
		        set2 = set2 || [];
		        var idx;
		        var len1 = set1.length;
		        var len2 = set2.length;
		        var result = [];
		        idx = 0;
		        while (idx < len1) {
		            result[result.length] = set1[idx];
		            idx += 1;
		        }
		        idx = 0;
		        while (idx < len2) {
		            result[result.length] = set2[idx];
		            idx += 1;
		        }
		        return result;
		    };

		    var _containsWith = function _containsWith(pred, x, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len) {
		            if (pred(x, list[idx])) {
		                return true;
		            }
		            idx += 1;
		        }
		        return false;
		    };

		    var _filter = function _filter(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        var result = [];
		        while (idx < len) {
		            if (fn(list[idx])) {
		                result[result.length] = list[idx];
		            }
		            idx += 1;
		        }
		        return result;
		    };

		    var _forceReduced = function _forceReduced(x) {
		        return {
		            '@@transducer/value': x,
		            '@@transducer/reduced': true
		        };
		    };

		    var _has = function _has(prop, obj) {
		        return Object.prototype.hasOwnProperty.call(obj, prop);
		    };

		    var _identity = function _identity(x) {
		        return x;
		    };

		    var _isArguments = function () {
		        var toString = Object.prototype.toString;
		        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
		            return toString.call(x) === '[object Arguments]';
		        } : function _isArguments(x) {
		            return _has('callee', x);
		        };
		    }();

		    /**
		     * Tests whether or not an object is an array.
		     *
		     * @private
		     * @param {*} val The object to test.
		     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
		     * @example
		     *
		     *      _isArray([]); //=> true
		     *      _isArray(null); //=> false
		     *      _isArray({}); //=> false
		     */
		    var _isArray = Array.isArray || function _isArray(val) {
		        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
		    };

		    /**
		     * Determine if the passed argument is an integer.
		     *
		     * @private
		     * @param {*} n
		     * @category Type
		     * @return {Boolean}
		     */
		    var _isInteger = Number.isInteger || function _isInteger(n) {
		        return n << 0 === n;
		    };

		    var _isNumber = function _isNumber(x) {
		        return Object.prototype.toString.call(x) === '[object Number]';
		    };

		    var _isObject = function _isObject(x) {
		        return Object.prototype.toString.call(x) === '[object Object]';
		    };

		    var _isPlaceholder = function _isPlaceholder(a) {
		        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
		    };

		    var _isRegExp = function _isRegExp(x) {
		        return Object.prototype.toString.call(x) === '[object RegExp]';
		    };

		    var _isString = function _isString(x) {
		        return Object.prototype.toString.call(x) === '[object String]';
		    };

		    var _isTransformer = function _isTransformer(obj) {
		        return typeof obj['@@transducer/step'] === 'function';
		    };

		    var _map = function _map(fn, functor) {
		        var idx = 0;
		        var len = functor.length;
		        var result = Array(len);
		        while (idx < len) {
		            result[idx] = fn(functor[idx]);
		            idx += 1;
		        }
		        return result;
		    };

		    var _of = function _of(x) {
		        return [x];
		    };

		    var _pipe = function _pipe(f, g) {
		        return function () {
		            return g.call(this, f.apply(this, arguments));
		        };
		    };

		    var _pipeP = function _pipeP(f, g) {
		        return function () {
		            var ctx = this;
		            return f.apply(ctx, arguments).then(function (x) {
		                return g.call(ctx, x);
		            });
		        };
		    };

		    // \b matches word boundary; [\b] matches backspace
		    var _quote = function _quote(s) {
		        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
		    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
		        return '"' + escaped.replace(/"/g, '\\"') + '"';
		    };

		    var _reduced = function _reduced(x) {
		        return x && x['@@transducer/reduced'] ? x : {
		            '@@transducer/value': x,
		            '@@transducer/reduced': true
		        };
		    };

		    /**
		     * An optimized, private array `slice` implementation.
		     *
		     * @private
		     * @param {Arguments|Array} args The array or arguments object to consider.
		     * @param {Number} [from=0] The array index to slice from, inclusive.
		     * @param {Number} [to=args.length] The array index to slice to, exclusive.
		     * @return {Array} A new, sliced array.
		     * @example
		     *
		     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
		     *
		     *      var firstThreeArgs = function(a, b, c, d) {
		     *        return _slice(arguments, 0, 3);
		     *      };
		     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
		     */
		    var _slice = function _slice(args, from, to) {
		        switch (arguments.length) {
		        case 1:
		            return _slice(args, 0, args.length);
		        case 2:
		            return _slice(args, from, args.length);
		        default:
		            var list = [];
		            var idx = 0;
		            var len = Math.max(0, Math.min(args.length, to) - from);
		            while (idx < len) {
		                list[idx] = args[from + idx];
		                idx += 1;
		            }
		            return list;
		        }
		    };

		    /**
		     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
		     */
		    var _toISOString = function () {
		        var pad = function pad(n) {
		            return (n < 10 ? '0' : '') + n;
		        };
		        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
		            return d.toISOString();
		        } : function _toISOString(d) {
		            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
		        };
		    }();

		    var _xfBase = {
		        init: function () {
		            return this.xf['@@transducer/init']();
		        },
		        result: function (result) {
		            return this.xf['@@transducer/result'](result);
		        }
		    };

		    var _xwrap = function () {
		        function XWrap(fn) {
		            this.f = fn;
		        }
		        XWrap.prototype['@@transducer/init'] = function () {
		            throw new Error('init not implemented on XWrap');
		        };
		        XWrap.prototype['@@transducer/result'] = function (acc) {
		            return acc;
		        };
		        XWrap.prototype['@@transducer/step'] = function (acc, x) {
		            return this.f(acc, x);
		        };
		        return function _xwrap(fn) {
		            return new XWrap(fn);
		        };
		    }();

		    var _aperture = function _aperture(n, list) {
		        var idx = 0;
		        var limit = list.length - (n - 1);
		        var acc = new Array(limit >= 0 ? limit : 0);
		        while (idx < limit) {
		            acc[idx] = _slice(list, idx, idx + n);
		            idx += 1;
		        }
		        return acc;
		    };

		    /**
		     * Similar to hasMethod, this checks whether a function has a [methodname]
		     * function. If it isn't an array it will execute that function otherwise it
		     * will default to the ramda implementation.
		     *
		     * @private
		     * @param {Function} fn ramda implemtation
		     * @param {String} methodname property to check for a custom implementation
		     * @return {Object} Whatever the return value of the method is.
		     */
		    var _checkForMethod = function _checkForMethod(methodname, fn) {
		        return function () {
		            var length = arguments.length;
		            if (length === 0) {
		                return fn();
		            }
		            var obj = arguments[length - 1];
		            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
		        };
		    };

		    /**
		     * Optimized internal one-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry1 = function _curry1(fn) {
		        return function f1(a) {
		            if (arguments.length === 0 || _isPlaceholder(a)) {
		                return f1;
		            } else {
		                return fn.apply(this, arguments);
		            }
		        };
		    };

		    /**
		     * Optimized internal two-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry2 = function _curry2(fn) {
		        return function f2(a, b) {
		            switch (arguments.length) {
		            case 0:
		                return f2;
		            case 1:
		                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
		                    return fn(a, _b);
		                });
		            default:
		                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
		                    return fn(_a, b);
		                }) : _isPlaceholder(b) ? _curry1(function (_b) {
		                    return fn(a, _b);
		                }) : fn(a, b);
		            }
		        };
		    };

		    /**
		     * Optimized internal three-arity curry function.
		     *
		     * @private
		     * @category Function
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curry3 = function _curry3(fn) {
		        return function f3(a, b, c) {
		            switch (arguments.length) {
		            case 0:
		                return f3;
		            case 1:
		                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
		                    return fn(a, _b, _c);
		                });
		            case 2:
		                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
		                    return fn(_a, b, _c);
		                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
		                    return fn(a, _b, _c);
		                }) : _curry1(function (_c) {
		                    return fn(a, b, _c);
		                });
		            default:
		                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
		                    return fn(_a, _b, c);
		                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
		                    return fn(_a, b, _c);
		                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
		                    return fn(a, _b, _c);
		                }) : _isPlaceholder(a) ? _curry1(function (_a) {
		                    return fn(_a, b, c);
		                }) : _isPlaceholder(b) ? _curry1(function (_b) {
		                    return fn(a, _b, c);
		                }) : _isPlaceholder(c) ? _curry1(function (_c) {
		                    return fn(a, b, _c);
		                }) : fn(a, b, c);
		            }
		        };
		    };

		    /**
		     * Internal curryN function.
		     *
		     * @private
		     * @category Function
		     * @param {Number} length The arity of the curried function.
		     * @param {Array} received An array of arguments received thus far.
		     * @param {Function} fn The function to curry.
		     * @return {Function} The curried function.
		     */
		    var _curryN = function _curryN(length, received, fn) {
		        return function () {
		            var combined = [];
		            var argsIdx = 0;
		            var left = length;
		            var combinedIdx = 0;
		            while (combinedIdx < received.length || argsIdx < arguments.length) {
		                var result;
		                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
		                    result = received[combinedIdx];
		                } else {
		                    result = arguments[argsIdx];
		                    argsIdx += 1;
		                }
		                combined[combinedIdx] = result;
		                if (!_isPlaceholder(result)) {
		                    left -= 1;
		                }
		                combinedIdx += 1;
		            }
		            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
		        };
		    };

		    /**
		     * Returns a function that dispatches with different strategies based on the
		     * object in list position (last argument). If it is an array, executes [fn].
		     * Otherwise, if it has a function with [methodname], it will execute that
		     * function (functor case). Otherwise, if it is a transformer, uses transducer
		     * [xf] to return a new transformer (transducer case). Otherwise, it will
		     * default to executing [fn].
		     *
		     * @private
		     * @param {String} methodname property to check for a custom implementation
		     * @param {Function} xf transducer to initialize if object is transformer
		     * @param {Function} fn default ramda implementation
		     * @return {Function} A function that dispatches on object in list position
		     */
		    var _dispatchable = function _dispatchable(methodname, xf, fn) {
		        return function () {
		            var length = arguments.length;
		            if (length === 0) {
		                return fn();
		            }
		            var obj = arguments[length - 1];
		            if (!_isArray(obj)) {
		                var args = _slice(arguments, 0, length - 1);
		                if (typeof obj[methodname] === 'function') {
		                    return obj[methodname].apply(obj, args);
		                }
		                if (_isTransformer(obj)) {
		                    var transducer = xf.apply(null, args);
		                    return transducer(obj);
		                }
		            }
		            return fn.apply(this, arguments);
		        };
		    };

		    var _dropLastWhile = function dropLastWhile(pred, list) {
		        var idx = list.length - 1;
		        while (idx >= 0 && pred(list[idx])) {
		            idx -= 1;
		        }
		        return _slice(list, 0, idx + 1);
		    };

		    var _xall = function () {
		        function XAll(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.all = true;
		        }
		        XAll.prototype['@@transducer/init'] = _xfBase.init;
		        XAll.prototype['@@transducer/result'] = function (result) {
		            if (this.all) {
		                result = this.xf['@@transducer/step'](result, true);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XAll.prototype['@@transducer/step'] = function (result, input) {
		            if (!this.f(input)) {
		                this.all = false;
		                result = _reduced(this.xf['@@transducer/step'](result, false));
		            }
		            return result;
		        };
		        return _curry2(function _xall(f, xf) {
		            return new XAll(f, xf);
		        });
		    }();

		    var _xany = function () {
		        function XAny(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.any = false;
		        }
		        XAny.prototype['@@transducer/init'] = _xfBase.init;
		        XAny.prototype['@@transducer/result'] = function (result) {
		            if (!this.any) {
		                result = this.xf['@@transducer/step'](result, false);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XAny.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.any = true;
		                result = _reduced(this.xf['@@transducer/step'](result, true));
		            }
		            return result;
		        };
		        return _curry2(function _xany(f, xf) {
		            return new XAny(f, xf);
		        });
		    }();

		    var _xaperture = function () {
		        function XAperture(n, xf) {
		            this.xf = xf;
		            this.pos = 0;
		            this.full = false;
		            this.acc = new Array(n);
		        }
		        XAperture.prototype['@@transducer/init'] = _xfBase.init;
		        XAperture.prototype['@@transducer/result'] = function (result) {
		            this.acc = null;
		            return this.xf['@@transducer/result'](result);
		        };
		        XAperture.prototype['@@transducer/step'] = function (result, input) {
		            this.store(input);
		            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
		        };
		        XAperture.prototype.store = function (input) {
		            this.acc[this.pos] = input;
		            this.pos += 1;
		            if (this.pos === this.acc.length) {
		                this.pos = 0;
		                this.full = true;
		            }
		        };
		        XAperture.prototype.getCopy = function () {
		            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
		        };
		        return _curry2(function _xaperture(n, xf) {
		            return new XAperture(n, xf);
		        });
		    }();

		    var _xdrop = function () {
		        function XDrop(n, xf) {
		            this.xf = xf;
		            this.n = n;
		        }
		        XDrop.prototype['@@transducer/init'] = _xfBase.init;
		        XDrop.prototype['@@transducer/result'] = _xfBase.result;
		        XDrop.prototype['@@transducer/step'] = function (result, input) {
		            if (this.n > 0) {
		                this.n -= 1;
		                return result;
		            }
		            return this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdrop(n, xf) {
		            return new XDrop(n, xf);
		        });
		    }();

		    var _xdropLast = function () {
		        function XDropLast(n, xf) {
		            this.xf = xf;
		            this.pos = 0;
		            this.full = false;
		            this.acc = new Array(n);
		        }
		        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
		        XDropLast.prototype['@@transducer/result'] = function (result) {
		            this.acc = null;
		            return this.xf['@@transducer/result'](result);
		        };
		        XDropLast.prototype['@@transducer/step'] = function (result, input) {
		            if (this.full) {
		                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
		            }
		            this.store(input);
		            return result;
		        };
		        XDropLast.prototype.store = function (input) {
		            this.acc[this.pos] = input;
		            this.pos += 1;
		            if (this.pos === this.acc.length) {
		                this.pos = 0;
		                this.full = true;
		            }
		        };
		        return _curry2(function _xdropLast(n, xf) {
		            return new XDropLast(n, xf);
		        });
		    }();

		    var _xdropRepeatsWith = function () {
		        function XDropRepeatsWith(pred, xf) {
		            this.xf = xf;
		            this.pred = pred;
		            this.lastValue = undefined;
		            this.seenFirstValue = false;
		        }
		        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
		            return this.xf['@@transducer/init']();
		        };
		        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](result);
		        };
		        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
		            var sameAsLast = false;
		            if (!this.seenFirstValue) {
		                this.seenFirstValue = true;
		            } else if (this.pred(this.lastValue, input)) {
		                sameAsLast = true;
		            }
		            this.lastValue = input;
		            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdropRepeatsWith(pred, xf) {
		            return new XDropRepeatsWith(pred, xf);
		        });
		    }();

		    var _xdropWhile = function () {
		        function XDropWhile(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
		        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
		        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f) {
		                if (this.f(input)) {
		                    return result;
		                }
		                this.f = null;
		            }
		            return this.xf['@@transducer/step'](result, input);
		        };
		        return _curry2(function _xdropWhile(f, xf) {
		            return new XDropWhile(f, xf);
		        });
		    }();

		    var _xfilter = function () {
		        function XFilter(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XFilter.prototype['@@transducer/init'] = _xfBase.init;
		        XFilter.prototype['@@transducer/result'] = _xfBase.result;
		        XFilter.prototype['@@transducer/step'] = function (result, input) {
		            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
		        };
		        return _curry2(function _xfilter(f, xf) {
		            return new XFilter(f, xf);
		        });
		    }();

		    var _xfind = function () {
		        function XFind(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.found = false;
		        }
		        XFind.prototype['@@transducer/init'] = _xfBase.init;
		        XFind.prototype['@@transducer/result'] = function (result) {
		            if (!this.found) {
		                result = this.xf['@@transducer/step'](result, void 0);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XFind.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.found = true;
		                result = _reduced(this.xf['@@transducer/step'](result, input));
		            }
		            return result;
		        };
		        return _curry2(function _xfind(f, xf) {
		            return new XFind(f, xf);
		        });
		    }();

		    var _xfindIndex = function () {
		        function XFindIndex(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.idx = -1;
		            this.found = false;
		        }
		        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
		        XFindIndex.prototype['@@transducer/result'] = function (result) {
		            if (!this.found) {
		                result = this.xf['@@transducer/step'](result, -1);
		            }
		            return this.xf['@@transducer/result'](result);
		        };
		        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
		            this.idx += 1;
		            if (this.f(input)) {
		                this.found = true;
		                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
		            }
		            return result;
		        };
		        return _curry2(function _xfindIndex(f, xf) {
		            return new XFindIndex(f, xf);
		        });
		    }();

		    var _xfindLast = function () {
		        function XFindLast(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
		        XFindLast.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
		        };
		        XFindLast.prototype['@@transducer/step'] = function (result, input) {
		            if (this.f(input)) {
		                this.last = input;
		            }
		            return result;
		        };
		        return _curry2(function _xfindLast(f, xf) {
		            return new XFindLast(f, xf);
		        });
		    }();

		    var _xfindLastIndex = function () {
		        function XFindLastIndex(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.idx = -1;
		            this.lastIdx = -1;
		        }
		        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
		        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
		            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
		        };
		        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
		            this.idx += 1;
		            if (this.f(input)) {
		                this.lastIdx = this.idx;
		            }
		            return result;
		        };
		        return _curry2(function _xfindLastIndex(f, xf) {
		            return new XFindLastIndex(f, xf);
		        });
		    }();

		    var _xmap = function () {
		        function XMap(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XMap.prototype['@@transducer/init'] = _xfBase.init;
		        XMap.prototype['@@transducer/result'] = _xfBase.result;
		        XMap.prototype['@@transducer/step'] = function (result, input) {
		            return this.xf['@@transducer/step'](result, this.f(input));
		        };
		        return _curry2(function _xmap(f, xf) {
		            return new XMap(f, xf);
		        });
		    }();

		    var _xtake = function () {
		        function XTake(n, xf) {
		            this.xf = xf;
		            this.n = n;
		        }
		        XTake.prototype['@@transducer/init'] = _xfBase.init;
		        XTake.prototype['@@transducer/result'] = _xfBase.result;
		        XTake.prototype['@@transducer/step'] = function (result, input) {
		            if (this.n === 0) {
		                return _reduced(result);
		            } else {
		                this.n -= 1;
		                return this.xf['@@transducer/step'](result, input);
		            }
		        };
		        return _curry2(function _xtake(n, xf) {
		            return new XTake(n, xf);
		        });
		    }();

		    var _xtakeWhile = function () {
		        function XTakeWhile(f, xf) {
		            this.xf = xf;
		            this.f = f;
		        }
		        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
		        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
		        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
		            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
		        };
		        return _curry2(function _xtakeWhile(f, xf) {
		            return new XTakeWhile(f, xf);
		        });
		    }();

		    /**
		     * Adds two numbers. Equivalent to `a + b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Number}
		     * @see R.subtract
		     * @example
		     *
		     *      R.add(2, 3);       //=>  5
		     *      R.add(7)(10);      //=> 17
		     */
		    var add = _curry2(function add(a, b) {
		        return a + b;
		    });

		    /**
		     * Applies a function to the value at the given index of an array, returning a
		     * new copy of the array with the element at the given index replaced with the
		     * result of the function application.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category List
		     * @sig (a -> a) -> Number -> [a] -> [a]
		     * @param {Function} fn The function to apply.
		     * @param {Number} idx The index.
		     * @param {Array|Arguments} list An array-like object whose value
		     *        at the supplied index will be replaced.
		     * @return {Array} A copy of the supplied array-like object with
		     *         the element at index `idx` replaced with the value
		     *         returned by applying `fn` to the existing element.
		     * @see R.update
		     * @example
		     *
		     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
		     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
		     */
		    var adjust = _curry3(function adjust(fn, idx, list) {
		        if (idx >= list.length || idx < -list.length) {
		            return list;
		        }
		        var start = idx < 0 ? list.length : 0;
		        var _idx = start + idx;
		        var _list = _concat(list);
		        _list[_idx] = fn(list[_idx]);
		        return _list;
		    });

		    /**
		     * Returns `true` if all elements of the list match the predicate, `false` if
		     * there are any that don't.
		     *
		     * Dispatches to the `all` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
		     *         otherwise.
		     * @see R.any, R.none, R.transduce
		     * @example
		     *
		     *      var lessThan2 = R.flip(R.lt)(2);
		     *      var lessThan3 = R.flip(R.lt)(3);
		     *      R.all(lessThan2)([1, 2]); //=> false
		     *      R.all(lessThan3)([1, 2]); //=> true
		     */
		    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
		        var idx = 0;
		        while (idx < list.length) {
		            if (!fn(list[idx])) {
		                return false;
		            }
		            idx += 1;
		        }
		        return true;
		    }));

		    /**
		     * Returns a function that always returns the given value. Note that for
		     * non-primitives the value returned is a reference to the original value.
		     *
		     * This function is known as `const`, `constant`, or `K` (for K combinator) in
		     * other languages and libraries.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig a -> (* -> a)
		     * @param {*} val The value to wrap in a function
		     * @return {Function} A Function :: * -> val.
		     * @example
		     *
		     *      var t = R.always('Tee');
		     *      t(); //=> 'Tee'
		     */
		    var always = _curry1(function always(val) {
		        return function () {
		            return val;
		        };
		    });

		    /**
		     * Returns `true` if both arguments are `true`; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Logic
		     * @sig * -> * -> *
		     * @param {Boolean} a A boolean value
		     * @param {Boolean} b A boolean value
		     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
		     * @see R.both
		     * @example
		     *
		     *      R.and(true, true); //=> true
		     *      R.and(true, false); //=> false
		     *      R.and(false, true); //=> false
		     *      R.and(false, false); //=> false
		     */
		    var and = _curry2(function and(a, b) {
		        return a && b;
		    });

		    /**
		     * Returns `true` if at least one of elements of the list match the predicate,
		     * `false` otherwise.
		     *
		     * Dispatches to the `any` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
		     *         otherwise.
		     * @see R.all, R.none, R.transduce
		     * @example
		     *
		     *      var lessThan0 = R.flip(R.lt)(0);
		     *      var lessThan2 = R.flip(R.lt)(2);
		     *      R.any(lessThan0)([1, 2]); //=> false
		     *      R.any(lessThan2)([1, 2]); //=> true
		     */
		    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
		        var idx = 0;
		        while (idx < list.length) {
		            if (fn(list[idx])) {
		                return true;
		            }
		            idx += 1;
		        }
		        return false;
		    }));

		    /**
		     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
		     * greater than the length of the list, an empty list is returned.
		     *
		     * Dispatches to the `aperture` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category List
		     * @sig Number -> [a] -> [[a]]
		     * @param {Number} n The size of the tuples to create
		     * @param {Array} list The list to split into `n`-tuples
		     * @return {Array} The new list.
		     * @see R.transduce
		     * @example
		     *
		     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
		     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
		     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
		     */
		    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

		    /**
		     * Returns a new list containing the contents of the given list, followed by
		     * the given element.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} el The element to add to the end of the new list.
		     * @param {Array} list The list whose contents will be added to the beginning of the output
		     *        list.
		     * @return {Array} A new list containing the contents of the old list followed by `el`.
		     * @see R.prepend
		     * @example
		     *
		     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
		     *      R.append('tests', []); //=> ['tests']
		     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
		     */
		    var append = _curry2(function append(el, list) {
		        return _concat(list, [el]);
		    });

		    /**
		     * Applies function `fn` to the argument list `args`. This is useful for
		     * creating a fixed-arity function from a variadic function. `fn` should be a
		     * bound function if context is significant.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Function
		     * @sig (*... -> a) -> [*] -> a
		     * @param {Function} fn
		     * @param {Array} args
		     * @return {*}
		     * @see R.call, R.unapply
		     * @example
		     *
		     *      var nums = [1, 2, 3, -99, 42, 6, 7];
		     *      R.apply(Math.max, nums); //=> 42
		     */
		    var apply = _curry2(function apply(fn, args) {
		        return fn.apply(this, args);
		    });

		    /**
		     * Makes a shallow clone of an object, setting or overriding the specified
		     * property with the given value. Note that this copies and flattens prototype
		     * properties onto the new object as well. All non-primitive properties are
		     * copied by reference.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Object
		     * @sig String -> a -> {k: v} -> {k: v}
		     * @param {String} prop the property name to set
		     * @param {*} val the new value
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original except for the specified property.
		     * @see R.dissoc
		     * @example
		     *
		     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
		     */
		    var assoc = _curry3(function assoc(prop, val, obj) {
		        var result = {};
		        for (var p in obj) {
		            result[p] = obj[p];
		        }
		        result[prop] = val;
		        return result;
		    });

		    /**
		     * Makes a shallow clone of an object, setting or overriding the nodes required
		     * to create the given path, and placing the specific value at the tail end of
		     * that path. Note that this copies and flattens prototype properties onto the
		     * new object as well. All non-primitive properties are copied by reference.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Object
		     * @sig [String] -> a -> {k: v} -> {k: v}
		     * @param {Array} path the path to set
		     * @param {*} val the new value
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original except along the specified path.
		     * @see R.dissocPath
		     * @example
		     *
		     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
		     */
		    var assocPath = _curry3(function assocPath(path, val, obj) {
		        switch (path.length) {
		        case 0:
		            return val;
		        case 1:
		            return assoc(path[0], val, obj);
		        default:
		            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
		        }
		    });

		    /**
		     * Creates a function that is bound to a context.
		     * Note: `R.bind` does not provide the additional argument-binding capabilities of
		     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.6.0
		     * @category Function
		     * @category Object
		     * @sig (* -> *) -> {*} -> (* -> *)
		     * @param {Function} fn The function to bind to context
		     * @param {Object} thisObj The context to bind `fn` to
		     * @return {Function} A function that will execute in the context of `thisObj`.
		     * @see R.partial
		     */
		    var bind = _curry2(function bind(fn, thisObj) {
		        return _arity(fn.length, function () {
		            return fn.apply(thisObj, arguments);
		        });
		    });

		    /**
		     * A function wrapping calls to the two functions in an `&&` operation,
		     * returning the result of the first function if it is false-y and the result
		     * of the second function otherwise. Note that this is short-circuited,
		     * meaning that the second function will not be invoked if the first returns a
		     * false-y value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
		     * @param {Function} f a predicate
		     * @param {Function} g another predicate
		     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
		     * @see R.and
		     * @example
		     *
		     *      var gt10 = x => x > 10;
		     *      var even = x => x % 2 === 0;
		     *      var f = R.both(gt10, even);
		     *      f(100); //=> true
		     *      f(101); //=> false
		     */
		    var both = _curry2(function both(f, g) {
		        return function _both() {
		            return f.apply(this, arguments) && g.apply(this, arguments);
		        };
		    });

		    /**
		     * Makes a comparator function out of a function that reports whether the first
		     * element is less than the second.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (a, b -> Boolean) -> (a, b -> Number)
		     * @param {Function} pred A predicate function of arity two.
		     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
		     * @example
		     *
		     *      var cmp = R.comparator((a, b) => a.age < b.age);
		     *      var people = [
		     *        // ...
		     *      ];
		     *      R.sort(cmp, people);
		     */
		    var comparator = _curry1(function comparator(pred) {
		        return function (a, b) {
		            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
		        };
		    });

		    /**
		     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
		     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
		     * to `fn` are applied to each of the predicates in turn until one returns a
		     * "truthy" value, at which point `fn` returns the result of applying its
		     * arguments to the corresponding transformer. If none of the predicates
		     * matches, `fn` returns undefined.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.6.0
		     * @category Logic
		     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
		     * @param {Array} pairs
		     * @return {Function}
		     * @example
		     *
		     *      var fn = R.cond([
		     *        [R.equals(0),   R.always('water freezes at 0°C')],
		     *        [R.equals(100), R.always('water boils at 100°C')],
		     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
		     *      ]);
		     *      fn(0); //=> 'water freezes at 0°C'
		     *      fn(50); //=> 'nothing special happens at 50°C'
		     *      fn(100); //=> 'water boils at 100°C'
		     */
		    var cond = _curry1(function cond(pairs) {
		        return function () {
		            var idx = 0;
		            while (idx < pairs.length) {
		                if (pairs[idx][0].apply(this, arguments)) {
		                    return pairs[idx][1].apply(this, arguments);
		                }
		                idx += 1;
		            }
		        };
		    });

		    /**
		     * Counts the elements of a list according to how many match each value of a
		     * key generated by the supplied function. Returns an object mapping the keys
		     * produced by `fn` to the number of occurrences in the list. Note that all
		     * keys are coerced to strings because of how JavaScript objects work.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig (a -> String) -> [a] -> {*}
		     * @param {Function} fn The function used to map values to keys.
		     * @param {Array} list The list to count elements from.
		     * @return {Object} An object mapping keys to number of occurrences in the list.
		     * @example
		     *
		     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
		     *      var letters = R.split('', 'abcABCaaaBBc');
		     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
		     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
		     */
		    var countBy = _curry2(function countBy(fn, list) {
		        var counts = {};
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            var key = fn(list[idx]);
		            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
		            idx += 1;
		        }
		        return counts;
		    });

		    /**
		     * Returns a curried equivalent of the provided function, with the specified
		     * arity. The curried function has two unusual capabilities. First, its
		     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
		     * following are equivalent:
		     *
		     *   - `g(1)(2)(3)`
		     *   - `g(1)(2, 3)`
		     *   - `g(1, 2)(3)`
		     *   - `g(1, 2, 3)`
		     *
		     * Secondly, the special placeholder value `R.__` may be used to specify
		     * "gaps", allowing partial application of any combination of arguments,
		     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
		     * following are equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @func
		     * @memberOf R
		     * @since v0.5.0
		     * @category Function
		     * @sig Number -> (* -> a) -> (* -> a)
		     * @param {Number} length The arity for the returned function.
		     * @param {Function} fn The function to curry.
		     * @return {Function} A new, curried function.
		     * @see R.curry
		     * @example
		     *
		     *      var sumArgs = (...args) => R.sum(args);
		     *
		     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
		     *      var f = curriedAddFourNumbers(1, 2);
		     *      var g = f(3);
		     *      g(4); //=> 10
		     */
		    var curryN = _curry2(function curryN(length, fn) {
		        if (length === 1) {
		            return _curry1(fn);
		        }
		        return _arity(length, _curryN(length, [], fn));
		    });

		    /**
		     * Decrements its argument.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @see R.inc
		     * @example
		     *
		     *      R.dec(42); //=> 41
		     */
		    var dec = add(-1);

		    /**
		     * Returns the second argument if it is not `null`, `undefined` or `NaN`
		     * otherwise the first argument is returned.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Logic
		     * @sig a -> b -> a | b
		     * @param {a} val The default value.
		     * @param {b} val The value to return if it is not null or undefined
		     * @return {*} The the second value or the default value
		     * @example
		     *
		     *      var defaultTo42 = R.defaultTo(42);
		     *
		     *      defaultTo42(null);  //=> 42
		     *      defaultTo42(undefined);  //=> 42
		     *      defaultTo42('Ramda');  //=> 'Ramda'
		     *      defaultTo42(parseInt('string')); //=> 42
		     */
		    var defaultTo = _curry2(function defaultTo(d, v) {
		        return v == null || v !== v ? d : v;
		    });

		    /**
		     * Finds the set (i.e. no duplicates) of all elements in the first list not
		     * contained in the second list. Duplication is determined according to the
		     * value returned by applying the supplied predicate to two list elements.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The elements in `list1` that are not in `list2`.
		     * @see R.difference
		     * @example
		     *
		     *      function cmp(x, y) => x.a === y.a;
		     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
		     *      var l2 = [{a: 3}, {a: 4}];
		     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
		     */
		    var differenceWith = _curry3(function differenceWith(pred, first, second) {
		        var out = [];
		        var idx = 0;
		        var firstLen = first.length;
		        while (idx < firstLen) {
		            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
		                out.push(first[idx]);
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new object that does not contain a `prop` property.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Object
		     * @sig String -> {k: v} -> {k: v}
		     * @param {String} prop the name of the property to dissociate
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object similar to the original but without the specified property
		     * @see R.assoc
		     * @example
		     *
		     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
		     */
		    var dissoc = _curry2(function dissoc(prop, obj) {
		        var result = {};
		        for (var p in obj) {
		            if (p !== prop) {
		                result[p] = obj[p];
		            }
		        }
		        return result;
		    });

		    /**
		     * Makes a shallow clone of an object, omitting the property at the given path.
		     * Note that this copies and flattens prototype properties onto the new object
		     * as well. All non-primitive properties are copied by reference.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.11.0
		     * @category Object
		     * @sig [String] -> {k: v} -> {k: v}
		     * @param {Array} path the path to set
		     * @param {Object} obj the object to clone
		     * @return {Object} a new object without the property at path
		     * @see R.assocPath
		     * @example
		     *
		     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
		     */
		    var dissocPath = _curry2(function dissocPath(path, obj) {
		        switch (path.length) {
		        case 0:
		            return obj;
		        case 1:
		            return dissoc(path[0], obj);
		        default:
		            var head = path[0];
		            var tail = _slice(path, 1);
		            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
		        }
		    });

		    /**
		     * Divides two numbers. Equivalent to `a / b`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a / b`.
		     * @see R.multiply
		     * @example
		     *
		     *      R.divide(71, 100); //=> 0.71
		     *
		     *      var half = R.divide(R.__, 2);
		     *      half(42); //=> 21
		     *
		     *      var reciprocal = R.divide(1);
		     *      reciprocal(4);   //=> 0.25
		     */
		    var divide = _curry2(function divide(a, b) {
		        return a / b;
		    });

		    /**
		     * Returns a new list containing the last `n` elements of a given list, passing
		     * each value to the supplied predicate function, skipping elements while the
		     * predicate function returns `true`. The predicate function is passed one
		     * argument: *(value)*.
		     *
		     * Dispatches to the `dropWhile` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.takeWhile, R.transduce, R.addIndex
		     * @example
		     *
		     *      var lteTwo = x => x <= 2;
		     *
		     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
		     */
		    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len && pred(list[idx])) {
		            idx += 1;
		        }
		        return _slice(list, idx);
		    }));

		    /**
		     * A function wrapping calls to the two functions in an `||` operation,
		     * returning the result of the first function if it is truth-y and the result
		     * of the second function otherwise. Note that this is short-circuited,
		     * meaning that the second function will not be invoked if the first returns a
		     * truth-y value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
		     * @param {Function} f a predicate
		     * @param {Function} g another predicate
		     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
		     * @see R.or
		     * @example
		     *
		     *      var gt10 = x => x > 10;
		     *      var even = x => x % 2 === 0;
		     *      var f = R.either(gt10, even);
		     *      f(101); //=> true
		     *      f(8); //=> true
		     */
		    var either = _curry2(function either(f, g) {
		        return function _either() {
		            return f.apply(this, arguments) || g.apply(this, arguments);
		        };
		    });

		    /**
		     * Returns the empty value of its argument's type. Ramda defines the empty
		     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
		     * types are supported if they define `<Type>.empty` and/or
		     * `<Type>.prototype.empty`.
		     *
		     * Dispatches to the `empty` method of the first argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category Function
		     * @sig a -> a
		     * @param {*} x
		     * @return {*}
		     * @example
		     *
		     *      R.empty(Just(42));      //=> Nothing()
		     *      R.empty([1, 2, 3]);     //=> []
		     *      R.empty('unicorns');    //=> ''
		     *      R.empty({x: 1, y: 2});  //=> {}
		     */
		    // else
		    var empty = _curry1(function empty(x) {
		        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
		            return arguments;
		        }() : // else
		        void 0;
		    });

		    /**
		     * Creates a new object by recursively evolving a shallow copy of `object`,
		     * according to the `transformation` functions. All non-primitive properties
		     * are copied by reference.
		     *
		     * A `transformation` function will not be invoked if its corresponding key
		     * does not exist in the evolved object.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Object
		     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
		     * @param {Object} transformations The object specifying transformation functions to apply
		     *        to the object.
		     * @param {Object} object The object to be transformed.
		     * @return {Object} The transformed object.
		     * @example
		     *
		     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
		     *      var transformations = {
		     *        firstName: R.trim,
		     *        lastName: R.trim, // Will not get invoked.
		     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
		     *      };
		     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
		     */
		    var evolve = _curry2(function evolve(transformations, object) {
		        var result = {};
		        var transformation, key, type;
		        for (key in object) {
		            transformation = transformations[key];
		            type = typeof transformation;
		            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
		        }
		        return result;
		    });

		    /**
		     * Returns the first element of the list which matches the predicate, or
		     * `undefined` if no element matches.
		     *
		     * Dispatches to the `find` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> a | undefined
		     * @param {Function} fn The predicate function used to determine if the element is the
		     *        desired one.
		     * @param {Array} list The array to consider.
		     * @return {Object} The element found, or `undefined`.
		     * @see R.transduce
		     * @example
		     *
		     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
		     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
		     *      R.find(R.propEq('a', 4))(xs); //=> undefined
		     */
		    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len) {
		            if (fn(list[idx])) {
		                return list[idx];
		            }
		            idx += 1;
		        }
		    }));

		    /**
		     * Returns the index of the first element of the list which matches the
		     * predicate, or `-1` if no element matches.
		     *
		     * Dispatches to the `findIndex` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Number
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Number} The index of the element found, or `-1`.
		     * @see R.transduce
		     * @example
		     *
		     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
		     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
		     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
		     */
		    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len) {
		            if (fn(list[idx])) {
		                return idx;
		            }
		            idx += 1;
		        }
		        return -1;
		    }));

		    /**
		     * Returns the last element of the list which matches the predicate, or
		     * `undefined` if no element matches.
		     *
		     * Dispatches to the `findLast` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> a | undefined
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Object} The element found, or `undefined`.
		     * @see R.transduce
		     * @example
		     *
		     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
		     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
		     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
		     */
		    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            if (fn(list[idx])) {
		                return list[idx];
		            }
		            idx -= 1;
		        }
		    }));

		    /**
		     * Returns the index of the last element of the list which matches the
		     * predicate, or `-1` if no element matches.
		     *
		     * Dispatches to the `findLastIndex` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Number
		     * @param {Function} fn The predicate function used to determine if the element is the
		     * desired one.
		     * @param {Array} list The array to consider.
		     * @return {Number} The index of the element found, or `-1`.
		     * @see R.transduce
		     * @example
		     *
		     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
		     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
		     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
		     */
		    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            if (fn(list[idx])) {
		                return idx;
		            }
		            idx -= 1;
		        }
		        return -1;
		    }));

		    /**
		     * Iterate over an input `list`, calling a provided function `fn` for each
		     * element in the list.
		     *
		     * `fn` receives one argument: *(value)*.
		     *
		     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
		     * arrays), unlike the native `Array.prototype.forEach` method. For more
		     * details on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
		     *
		     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
		     * the original array. In some libraries this function is named `each`.
		     *
		     * Dispatches to the `forEach` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category List
		     * @sig (a -> *) -> [a] -> [a]
		     * @param {Function} fn The function to invoke. Receives one argument, `value`.
		     * @param {Array} list The list to iterate over.
		     * @return {Array} The original list.
		     * @see R.addIndex
		     * @example
		     *
		     *      var printXPlusFive = x => console.log(x + 5);
		     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
		     *      //-> 6
		     *      //-> 7
		     *      //-> 8
		     */
		    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            fn(list[idx]);
		            idx += 1;
		        }
		        return list;
		    }));

		    /**
		     * Creates a new object out of a list key-value pairs.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category List
		     * @sig [[k,v]] -> {k: v}
		     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
		     * @return {Object} The object made by pairing up `keys` and `values`.
		     * @see R.toPairs, R.pair
		     * @example
		     *
		     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
		     */
		    var fromPairs = _curry1(function fromPairs(pairs) {
		        var idx = 0;
		        var len = pairs.length;
		        var out = {};
		        while (idx < len) {
		            if (_isArray(pairs[idx]) && pairs[idx].length) {
		                out[pairs[idx][0]] = pairs[idx][1];
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns `true` if the first argument is greater than the second; `false`
		     * otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @see R.lt
		     * @example
		     *
		     *      R.gt(2, 1); //=> true
		     *      R.gt(2, 2); //=> false
		     *      R.gt(2, 3); //=> false
		     *      R.gt('a', 'z'); //=> false
		     *      R.gt('z', 'a'); //=> true
		     */
		    var gt = _curry2(function gt(a, b) {
		        return a > b;
		    });

		    /**
		     * Returns `true` if the first argument is greater than or equal to the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Boolean}
		     * @see R.lte
		     * @example
		     *
		     *      R.gte(2, 1); //=> true
		     *      R.gte(2, 2); //=> true
		     *      R.gte(2, 3); //=> false
		     *      R.gte('a', 'z'); //=> false
		     *      R.gte('z', 'a'); //=> true
		     */
		    var gte = _curry2(function gte(a, b) {
		        return a >= b;
		    });

		    /**
		     * Returns whether or not an object has an own property with the specified name
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Object
		     * @sig s -> {s: x} -> Boolean
		     * @param {String} prop The name of the property to check for.
		     * @param {Object} obj The object to query.
		     * @return {Boolean} Whether the property exists.
		     * @example
		     *
		     *      var hasName = R.has('name');
		     *      hasName({name: 'alice'});   //=> true
		     *      hasName({name: 'bob'});     //=> true
		     *      hasName({});                //=> false
		     *
		     *      var point = {x: 0, y: 0};
		     *      var pointHas = R.has(R.__, point);
		     *      pointHas('x');  //=> true
		     *      pointHas('y');  //=> true
		     *      pointHas('z');  //=> false
		     */
		    var has = _curry2(_has);

		    /**
		     * Returns whether or not an object or its prototype chain has a property with
		     * the specified name
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Object
		     * @sig s -> {s: x} -> Boolean
		     * @param {String} prop The name of the property to check for.
		     * @param {Object} obj The object to query.
		     * @return {Boolean} Whether the property exists.
		     * @example
		     *
		     *      function Rectangle(width, height) {
		     *        this.width = width;
		     *        this.height = height;
		     *      }
		     *      Rectangle.prototype.area = function() {
		     *        return this.width * this.height;
		     *      };
		     *
		     *      var square = new Rectangle(2, 2);
		     *      R.hasIn('width', square);  //=> true
		     *      R.hasIn('area', square);  //=> true
		     */
		    var hasIn = _curry2(function hasIn(prop, obj) {
		        return prop in obj;
		    });

		    /**
		     * Returns true if its arguments are identical, false otherwise. Values are
		     * identical if they reference the same memory. `NaN` is identical to `NaN`;
		     * `0` and `-0` are not identical.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.15.0
		     * @category Relation
		     * @sig a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @example
		     *
		     *      var o = {};
		     *      R.identical(o, o); //=> true
		     *      R.identical(1, 1); //=> true
		     *      R.identical(1, '1'); //=> false
		     *      R.identical([], []); //=> false
		     *      R.identical(0, -0); //=> false
		     *      R.identical(NaN, NaN); //=> true
		     */
		    // SameValue algorithm
		    // Steps 1-5, 7-10
		    // Steps 6.b-6.e: +0 != -0
		    // Step 6.a: NaN == NaN
		    var identical = _curry2(function identical(a, b) {
		        // SameValue algorithm
		        if (a === b) {
		            // Steps 1-5, 7-10
		            // Steps 6.b-6.e: +0 != -0
		            return a !== 0 || 1 / a === 1 / b;
		        } else {
		            // Step 6.a: NaN == NaN
		            return a !== a && b !== b;
		        }
		    });

		    /**
		     * A function that does nothing but return the parameter supplied to it. Good
		     * as a default or placeholder function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig a -> a
		     * @param {*} x The value to return.
		     * @return {*} The input value, `x`.
		     * @example
		     *
		     *      R.identity(1); //=> 1
		     *
		     *      var obj = {};
		     *      R.identity(obj) === obj; //=> true
		     */
		    var identity = _curry1(_identity);

		    /**
		     * Creates a function that will process either the `onTrue` or the `onFalse`
		     * function depending upon the result of the `condition` predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Logic
		     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
		     * @param {Function} condition A predicate function
		     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
		     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
		     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
		     *                    function depending upon the result of the `condition` predicate.
		     * @see R.unless, R.when
		     * @example
		     *
		     *      var incCount = R.ifElse(
		     *        R.has('count'),
		     *        R.over(R.lensProp('count'), R.inc),
		     *        R.assoc('count', 1)
		     *      );
		     *      incCount({});           //=> { count: 1 }
		     *      incCount({ count: 1 }); //=> { count: 2 }
		     */
		    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
		        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
		            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
		        });
		    });

		    /**
		     * Increments its argument.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @see R.dec
		     * @example
		     *
		     *      R.inc(42); //=> 43
		     */
		    var inc = add(1);

		    /**
		     * Inserts the supplied element into the list, at index `index`. _Note that
		     * this is not destructive_: it returns a copy of the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.2
		     * @category List
		     * @sig Number -> a -> [a] -> [a]
		     * @param {Number} index The position to insert the element
		     * @param {*} elt The element to insert into the Array
		     * @param {Array} list The list to insert into
		     * @return {Array} A new Array with `elt` inserted at `index`.
		     * @example
		     *
		     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
		     */
		    var insert = _curry3(function insert(idx, elt, list) {
		        idx = idx < list.length && idx >= 0 ? idx : list.length;
		        var result = _slice(list);
		        result.splice(idx, 0, elt);
		        return result;
		    });

		    /**
		     * Inserts the sub-list into the list, at index `index`. _Note that this is not
		     * destructive_: it returns a copy of the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category List
		     * @sig Number -> [a] -> [a] -> [a]
		     * @param {Number} index The position to insert the sub-list
		     * @param {Array} elts The sub-list to insert into the Array
		     * @param {Array} list The list to insert the sub-list into
		     * @return {Array} A new Array with `elts` inserted starting at `index`.
		     * @example
		     *
		     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
		     */
		    var insertAll = _curry3(function insertAll(idx, elts, list) {
		        idx = idx < list.length && idx >= 0 ? idx : list.length;
		        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
		    });

		    /**
		     * Creates a new list with the separator interposed between elements.
		     *
		     * Dispatches to the `intersperse` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} separator The element to add to the list.
		     * @param {Array} list The list to be interposed.
		     * @return {Array} The new list.
		     * @example
		     *
		     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
		     */
		    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
		        var out = [];
		        var idx = 0;
		        var length = list.length;
		        while (idx < length) {
		            if (idx === length - 1) {
		                out.push(list[idx]);
		            } else {
		                out.push(list[idx], separator);
		            }
		            idx += 1;
		        }
		        return out;
		    }));

		    /**
		     * See if an object (`val`) is an instance of the supplied constructor. This
		     * function will check up the inheritance chain, if any.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category Type
		     * @sig (* -> {*}) -> a -> Boolean
		     * @param {Object} ctor A constructor
		     * @param {*} val The value to test
		     * @return {Boolean}
		     * @example
		     *
		     *      R.is(Object, {}); //=> true
		     *      R.is(Number, 1); //=> true
		     *      R.is(Object, 1); //=> false
		     *      R.is(String, 's'); //=> true
		     *      R.is(String, new String('')); //=> true
		     *      R.is(Object, new String('')); //=> true
		     *      R.is(Object, 's'); //=> false
		     *      R.is(Number, {}); //=> false
		     */
		    var is = _curry2(function is(Ctor, val) {
		        return val != null && val.constructor === Ctor || val instanceof Ctor;
		    });

		    /**
		     * Tests whether or not an object is similar to an array.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.5.0
		     * @category Type
		     * @category List
		     * @sig * -> Boolean
		     * @param {*} x The object to test.
		     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
		     * @example
		     *
		     *      R.isArrayLike([]); //=> true
		     *      R.isArrayLike(true); //=> false
		     *      R.isArrayLike({}); //=> false
		     *      R.isArrayLike({length: 10}); //=> false
		     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
		     */
		    var isArrayLike = _curry1(function isArrayLike(x) {
		        if (_isArray(x)) {
		            return true;
		        }
		        if (!x) {
		            return false;
		        }
		        if (typeof x !== 'object') {
		            return false;
		        }
		        if (x instanceof String) {
		            return false;
		        }
		        if (x.nodeType === 1) {
		            return !!x.length;
		        }
		        if (x.length === 0) {
		            return true;
		        }
		        if (x.length > 0) {
		            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
		        }
		        return false;
		    });

		    /**
		     * Checks if the input value is `null` or `undefined`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Type
		     * @sig * -> Boolean
		     * @param {*} x The value to test.
		     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
		     * @example
		     *
		     *      R.isNil(null); //=> true
		     *      R.isNil(undefined); //=> true
		     *      R.isNil(0); //=> false
		     *      R.isNil([]); //=> false
		     */
		    var isNil = _curry1(function isNil(x) {
		        return x == null;
		    });

		    /**
		     * Returns a list containing the names of all the enumerable own properties of
		     * the supplied object.
		     * Note that the order of the output array is not guaranteed to be consistent
		     * across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig {k: v} -> [k]
		     * @param {Object} obj The object to extract properties from
		     * @return {Array} An array of the object's own properties.
		     * @example
		     *
		     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
		     */
		    // cover IE < 9 keys issues
		    // Safari bug
		    var keys = function () {
		        // cover IE < 9 keys issues
		        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
		        var nonEnumerableProps = [
		            'constructor',
		            'valueOf',
		            'isPrototypeOf',
		            'toString',
		            'propertyIsEnumerable',
		            'hasOwnProperty',
		            'toLocaleString'
		        ];
		        // Safari bug
		        var hasArgsEnumBug = function () {
		            'use strict';
		            return arguments.propertyIsEnumerable('length');
		        }();
		        var contains = function contains(list, item) {
		            var idx = 0;
		            while (idx < list.length) {
		                if (list[idx] === item) {
		                    return true;
		                }
		                idx += 1;
		            }
		            return false;
		        };
		        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
		            return Object(obj) !== obj ? [] : Object.keys(obj);
		        }) : _curry1(function keys(obj) {
		            if (Object(obj) !== obj) {
		                return [];
		            }
		            var prop, nIdx;
		            var ks = [];
		            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
		            for (prop in obj) {
		                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
		                    ks[ks.length] = prop;
		                }
		            }
		            if (hasEnumBug) {
		                nIdx = nonEnumerableProps.length - 1;
		                while (nIdx >= 0) {
		                    prop = nonEnumerableProps[nIdx];
		                    if (_has(prop, obj) && !contains(ks, prop)) {
		                        ks[ks.length] = prop;
		                    }
		                    nIdx -= 1;
		                }
		            }
		            return ks;
		        });
		    }();

		    /**
		     * Returns a list containing the names of all the properties of the supplied
		     * object, including prototype properties.
		     * Note that the order of the output array is not guaranteed to be consistent
		     * across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category Object
		     * @sig {k: v} -> [k]
		     * @param {Object} obj The object to extract properties from
		     * @return {Array} An array of the object's own and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.keysIn(f); //=> ['x', 'y']
		     */
		    var keysIn = _curry1(function keysIn(obj) {
		        var prop;
		        var ks = [];
		        for (prop in obj) {
		            ks[ks.length] = prop;
		        }
		        return ks;
		    });

		    /**
		     * Returns the number of elements in the array by returning `list.length`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category List
		     * @sig [a] -> Number
		     * @param {Array} list The array to inspect.
		     * @return {Number} The length of the array.
		     * @example
		     *
		     *      R.length([]); //=> 0
		     *      R.length([1, 2, 3]); //=> 3
		     */
		    var length = _curry1(function length(list) {
		        return list != null && is(Number, list.length) ? list.length : NaN;
		    });

		    /**
		     * Returns `true` if the first argument is less than the second; `false`
		     * otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @see R.gt
		     * @example
		     *
		     *      R.lt(2, 1); //=> false
		     *      R.lt(2, 2); //=> false
		     *      R.lt(2, 3); //=> true
		     *      R.lt('a', 'z'); //=> true
		     *      R.lt('z', 'a'); //=> false
		     */
		    var lt = _curry2(function lt(a, b) {
		        return a < b;
		    });

		    /**
		     * Returns `true` if the first argument is less than or equal to the second;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> Boolean
		     * @param {Number} a
		     * @param {Number} b
		     * @return {Boolean}
		     * @see R.gte
		     * @example
		     *
		     *      R.lte(2, 1); //=> false
		     *      R.lte(2, 2); //=> true
		     *      R.lte(2, 3); //=> true
		     *      R.lte('a', 'z'); //=> true
		     *      R.lte('z', 'a'); //=> false
		     */
		    var lte = _curry2(function lte(a, b) {
		        return a <= b;
		    });

		    /**
		     * The mapAccum function behaves like a combination of map and reduce; it
		     * applies a function to each element of a list, passing an accumulating
		     * parameter from left to right, and returning a final value of this
		     * accumulator together with the new list.
		     *
		     * The iterator function receives two arguments, *acc* and *value*, and should
		     * return a tuple *[acc, value]*.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category List
		     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @see R.addIndex
		     * @example
		     *
		     *      var digits = ['1', '2', '3', '4'];
		     *      var append = (a, b) => [a + b, a + b];
		     *
		     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
		     */
		    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
		        var idx = 0;
		        var len = list.length;
		        var result = [];
		        var tuple = [acc];
		        while (idx < len) {
		            tuple = fn(tuple[0], list[idx]);
		            result[idx] = tuple[1];
		            idx += 1;
		        }
		        return [
		            tuple[0],
		            result
		        ];
		    });

		    /**
		     * The mapAccumRight function behaves like a combination of map and reduce; it
		     * applies a function to each element of a list, passing an accumulating
		     * parameter from right to left, and returning a final value of this
		     * accumulator together with the new list.
		     *
		     * Similar to `mapAccum`, except moves through the input list from the right to
		     * the left.
		     *
		     * The iterator function receives two arguments, *acc* and *value*, and should
		     * return a tuple *[acc, value]*.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category List
		     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @see R.addIndex
		     * @example
		     *
		     *      var digits = ['1', '2', '3', '4'];
		     *      var append = (a, b) => [a + b, a + b];
		     *
		     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
		     */
		    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
		        var idx = list.length - 1;
		        var result = [];
		        var tuple = [acc];
		        while (idx >= 0) {
		            tuple = fn(tuple[0], list[idx]);
		            result[idx] = tuple[1];
		            idx -= 1;
		        }
		        return [
		            tuple[0],
		            result
		        ];
		    });

		    /**
		     * Tests a regular expression against a String. Note that this function will
		     * return an empty array when there are no matches. This differs from
		     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
		     * which returns `null` when there are no matches.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category String
		     * @sig RegExp -> String -> [String | Undefined]
		     * @param {RegExp} rx A regular expression.
		     * @param {String} str The string to match against
		     * @return {Array} The list of matches or empty array.
		     * @see R.test
		     * @example
		     *
		     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
		     *      R.match(/a/, 'b'); //=> []
		     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
		     */
		    var match = _curry2(function match(rx, str) {
		        return str.match(rx) || [];
		    });

		    /**
		     * mathMod behaves like the modulo operator should mathematically, unlike the
		     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
		     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
		     * when the modulus is zero or negative.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} m The dividend.
		     * @param {Number} p the modulus.
		     * @return {Number} The result of `b mod a`.
		     * @example
		     *
		     *      R.mathMod(-17, 5);  //=> 3
		     *      R.mathMod(17, 5);   //=> 2
		     *      R.mathMod(17, -5);  //=> NaN
		     *      R.mathMod(17, 0);   //=> NaN
		     *      R.mathMod(17.2, 5); //=> NaN
		     *      R.mathMod(17, 5.3); //=> NaN
		     *
		     *      var clock = R.mathMod(R.__, 12);
		     *      clock(15); //=> 3
		     *      clock(24); //=> 0
		     *
		     *      var seventeenMod = R.mathMod(17);
		     *      seventeenMod(3);  //=> 2
		     *      seventeenMod(4);  //=> 1
		     *      seventeenMod(10); //=> 7
		     */
		    var mathMod = _curry2(function mathMod(m, p) {
		        if (!_isInteger(m)) {
		            return NaN;
		        }
		        if (!_isInteger(p) || p < 1) {
		            return NaN;
		        }
		        return (m % p + p) % p;
		    });

		    /**
		     * Returns the larger of its two arguments.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> a
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.maxBy, R.min
		     * @example
		     *
		     *      R.max(789, 123); //=> 789
		     *      R.max('a', 'b'); //=> 'b'
		     */
		    var max = _curry2(function max(a, b) {
		        return b > a ? b : a;
		    });

		    /**
		     * Takes a function and two values, and returns whichever value produces the
		     * larger result when passed to the provided function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Relation
		     * @sig Ord b => (a -> b) -> a -> a -> a
		     * @param {Function} f
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.max, R.minBy
		     * @example
		     *
		     *      //  square :: Number -> Number
		     *      var square = n => n * n;
		     *
		     *      R.maxBy(square, -3, 2); //=> -3
		     *
		     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
		     *      R.reduce(R.maxBy(square), 0, []); //=> 0
		     */
		    var maxBy = _curry3(function maxBy(f, a, b) {
		        return f(b) > f(a) ? b : a;
		    });

		    /**
		     * Creates a new object with the own properties of the two provided objects. If
		     * a key exists in both objects, the provided function is applied to the key
		     * and the values associated with the key in each object, with the result being
		     * used as the value associated with the key in the returned object. The key
		     * will be excluded from the returned object if the resulting value is
		     * `undefined`.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Object
		     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
		     * @param {Function} fn
		     * @param {Object} l
		     * @param {Object} r
		     * @return {Object}
		     * @see R.merge, R.mergeWith
		     * @example
		     *
		     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
		     *      R.mergeWithKey(concatValues,
		     *                     { a: true, thing: 'foo', values: [10, 20] },
		     *                     { b: true, thing: 'bar', values: [15, 35] });
		     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
		     */
		    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
		        var result = {};
		        var k;
		        for (k in l) {
		            if (_has(k, l)) {
		                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
		            }
		        }
		        for (k in r) {
		            if (_has(k, r) && !_has(k, result)) {
		                result[k] = r[k];
		            }
		        }
		        return result;
		    });

		    /**
		     * Returns the smaller of its two arguments.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord a => a -> a -> a
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.minBy, R.max
		     * @example
		     *
		     *      R.min(789, 123); //=> 123
		     *      R.min('a', 'b'); //=> 'a'
		     */
		    var min = _curry2(function min(a, b) {
		        return b < a ? b : a;
		    });

		    /**
		     * Takes a function and two values, and returns whichever value produces the
		     * smaller result when passed to the provided function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Relation
		     * @sig Ord b => (a -> b) -> a -> a -> a
		     * @param {Function} f
		     * @param {*} a
		     * @param {*} b
		     * @return {*}
		     * @see R.min, R.maxBy
		     * @example
		     *
		     *      //  square :: Number -> Number
		     *      var square = n => n * n;
		     *
		     *      R.minBy(square, -3, 2); //=> 2
		     *
		     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
		     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
		     */
		    var minBy = _curry3(function minBy(f, a, b) {
		        return f(b) < f(a) ? b : a;
		    });

		    /**
		     * Divides the second parameter by the first and returns the remainder. Note
		     * that this function preserves the JavaScript-style behavior for modulo. For
		     * mathematical modulo see `mathMod`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The value to the divide.
		     * @param {Number} b The pseudo-modulus
		     * @return {Number} The result of `b % a`.
		     * @see R.mathMod
		     * @example
		     *
		     *      R.modulo(17, 3); //=> 2
		     *      // JS behavior:
		     *      R.modulo(-17, 3); //=> -2
		     *      R.modulo(17, -3); //=> 2
		     *
		     *      var isOdd = R.modulo(R.__, 2);
		     *      isOdd(42); //=> 0
		     *      isOdd(21); //=> 1
		     */
		    var modulo = _curry2(function modulo(a, b) {
		        return a % b;
		    });

		    /**
		     * Multiplies two numbers. Equivalent to `a * b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a * b`.
		     * @see R.divide
		     * @example
		     *
		     *      var double = R.multiply(2);
		     *      var triple = R.multiply(3);
		     *      double(3);       //=>  6
		     *      triple(4);       //=> 12
		     *      R.multiply(2, 5);  //=> 10
		     */
		    var multiply = _curry2(function multiply(a, b) {
		        return a * b;
		    });

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts
		     * exactly `n` parameters. Any extraneous parameters will not be passed to the
		     * supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig Number -> (* -> a) -> (* -> a)
		     * @param {Number} n The desired arity of the new function.
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity `n`.
		     * @example
		     *
		     *      var takesTwoArgs = (a, b) => [a, b];
		     *
		     *      takesTwoArgs.length; //=> 2
		     *      takesTwoArgs(1, 2); //=> [1, 2]
		     *
		     *      var takesOneArg = R.nAry(1, takesTwoArgs);
		     *      takesOneArg.length; //=> 1
		     *      // Only `n` arguments are passed to the wrapped function
		     *      takesOneArg(1, 2); //=> [1, undefined]
		     */
		    var nAry = _curry2(function nAry(n, fn) {
		        switch (n) {
		        case 0:
		            return function () {
		                return fn.call(this);
		            };
		        case 1:
		            return function (a0) {
		                return fn.call(this, a0);
		            };
		        case 2:
		            return function (a0, a1) {
		                return fn.call(this, a0, a1);
		            };
		        case 3:
		            return function (a0, a1, a2) {
		                return fn.call(this, a0, a1, a2);
		            };
		        case 4:
		            return function (a0, a1, a2, a3) {
		                return fn.call(this, a0, a1, a2, a3);
		            };
		        case 5:
		            return function (a0, a1, a2, a3, a4) {
		                return fn.call(this, a0, a1, a2, a3, a4);
		            };
		        case 6:
		            return function (a0, a1, a2, a3, a4, a5) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5);
		            };
		        case 7:
		            return function (a0, a1, a2, a3, a4, a5, a6) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
		            };
		        case 8:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
		            };
		        case 9:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
		            };
		        case 10:
		            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
		                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
		            };
		        default:
		            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
		        }
		    });

		    /**
		     * Negates its argument.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Math
		     * @sig Number -> Number
		     * @param {Number} n
		     * @return {Number}
		     * @example
		     *
		     *      R.negate(42); //=> -42
		     */
		    var negate = _curry1(function negate(n) {
		        return -n;
		    });

		    /**
		     * Returns `true` if no elements of the list match the predicate, `false`
		     * otherwise.
		     *
		     * Dispatches to the `any` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> Boolean
		     * @param {Function} fn The predicate function.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
		     * @see R.all, R.any
		     * @example
		     *
		     *      var isEven = n => n % 2 === 0;
		     *
		     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
		     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
		     */
		    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

		    /**
		     * A function that returns the `!` of its argument. It will return `true` when
		     * passed false-y value, and `false` when passed a truth-y one.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Logic
		     * @sig * -> Boolean
		     * @param {*} a any value
		     * @return {Boolean} the logical inverse of passed argument.
		     * @see R.complement
		     * @example
		     *
		     *      R.not(true); //=> false
		     *      R.not(false); //=> true
		     *      R.not(0); => true
		     *      R.not(1); => false
		     */
		    var not = _curry1(function not(a) {
		        return !a;
		    });

		    /**
		     * Returns the nth element of the given list or string. If n is negative the
		     * element at index length + n is returned.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Number -> [a] -> a | Undefined
		     * @sig Number -> String -> String
		     * @param {Number} offset
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      var list = ['foo', 'bar', 'baz', 'quux'];
		     *      R.nth(1, list); //=> 'bar'
		     *      R.nth(-1, list); //=> 'quux'
		     *      R.nth(-99, list); //=> undefined
		     *
		     *      R.nth('abc', 2); //=> 'c'
		     *      R.nth('abc', 3); //=> ''
		     */
		    var nth = _curry2(function nth(offset, list) {
		        var idx = offset < 0 ? list.length + offset : offset;
		        return _isString(list) ? list.charAt(idx) : list[idx];
		    });

		    /**
		     * Returns a function which returns its nth argument.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Function
		     * @sig Number -> *... -> *
		     * @param {Number} n
		     * @return {Function}
		     * @example
		     *
		     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
		     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
		     */
		    var nthArg = _curry1(function nthArg(n) {
		        return function () {
		            return nth(n, arguments);
		        };
		    });

		    /**
		     * Creates an object containing a single key:value pair.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category Object
		     * @sig String -> a -> {String:a}
		     * @param {String} key
		     * @param {*} val
		     * @return {Object}
		     * @see R.pair
		     * @example
		     *
		     *      var matchPhrases = R.compose(
		     *        R.objOf('must'),
		     *        R.map(R.objOf('match_phrase'))
		     *      );
		     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
		     */
		    var objOf = _curry2(function objOf(key, val) {
		        var obj = {};
		        obj[key] = val;
		        return obj;
		    });

		    /**
		     * Returns a singleton array containing the value provided.
		     *
		     * Note this `of` is different from the ES6 `of`; See
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category Function
		     * @sig a -> [a]
		     * @param {*} x any value
		     * @return {Array} An array wrapping `x`.
		     * @example
		     *
		     *      R.of(null); //=> [null]
		     *      R.of([42]); //=> [[42]]
		     */
		    var of = _curry1(_of);

		    /**
		     * Accepts a function `fn` and returns a function that guards invocation of
		     * `fn` such that `fn` can only ever be called once, no matter how many times
		     * the returned function is invoked. The first value calculated is returned in
		     * subsequent invocations.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (a... -> b) -> (a... -> b)
		     * @param {Function} fn The function to wrap in a call-only-once wrapper.
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      var addOneOnce = R.once(x => x + 1);
		     *      addOneOnce(10); //=> 11
		     *      addOneOnce(addOneOnce(50)); //=> 11
		     */
		    var once = _curry1(function once(fn) {
		        var called = false;
		        var result;
		        return _arity(fn.length, function () {
		            if (called) {
		                return result;
		            }
		            called = true;
		            result = fn.apply(this, arguments);
		            return result;
		        });
		    });

		    /**
		     * Returns `true` if one or both of its arguments are `true`. Returns `false`
		     * if both arguments are `false`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Logic
		     * @sig * -> * -> *
		     * @param {Boolean} a A boolean value
		     * @param {Boolean} b A boolean value
		     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
		     * @see R.either
		     * @example
		     *
		     *      R.or(true, true); //=> true
		     *      R.or(true, false); //=> true
		     *      R.or(false, true); //=> true
		     *      R.or(false, false); //=> false
		     */
		    var or = _curry2(function or(a, b) {
		        return a || b;
		    });

		    /**
		     * Returns the result of "setting" the portion of the given data structure
		     * focused by the given lens to the result of applying the given function to
		     * the focused value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> (a -> a) -> s -> s
		     * @param {Lens} lens
		     * @param {*} v
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var headLens = R.lensIndex(0);
		     *
		     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
		     */
		    var over = function () {
		        var Identity = function (x) {
		            return {
		                value: x,
		                map: function (f) {
		                    return Identity(f(x));
		                }
		            };
		        };
		        return _curry3(function over(lens, f, x) {
		            return lens(function (y) {
		                return Identity(f(y));
		            })(x).value;
		        });
		    }();

		    /**
		     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category List
		     * @sig a -> b -> (a,b)
		     * @param {*} fst
		     * @param {*} snd
		     * @return {Array}
		     * @see R.createMapEntry, R.of
		     * @example
		     *
		     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
		     */
		    var pair = _curry2(function pair(fst, snd) {
		        return [
		            fst,
		            snd
		        ];
		    });

		    /**
		     * Retrieve the value at a given path.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category Object
		     * @sig [String] -> {k: v} -> v | Undefined
		     * @param {Array} path The path to use.
		     * @param {Object} obj The object to retrieve the nested property from.
		     * @return {*} The data at `path`.
		     * @example
		     *
		     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
		     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
		     */
		    var path = _curry2(function path(paths, obj) {
		        var val = obj;
		        var idx = 0;
		        while (idx < paths.length) {
		            if (val == null) {
		                return;
		            }
		            val = val[paths[idx]];
		            idx += 1;
		        }
		        return val;
		    });

		    /**
		     * If the given, non-null object has a value at the given path, returns the
		     * value at that path. Otherwise returns the provided default value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category Object
		     * @sig a -> [String] -> Object -> a
		     * @param {*} d The default value.
		     * @param {Array} p The path to use.
		     * @param {Object} obj The object to retrieve the nested property from.
		     * @return {*} The data at `path` of the supplied object or the default value.
		     * @example
		     *
		     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
		     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
		     */
		    var pathOr = _curry3(function pathOr(d, p, obj) {
		        return defaultTo(d, path(p, obj));
		    });

		    /**
		     * Returns `true` if the specified object property at given path satisfies the
		     * given predicate; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Logic
		     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
		     * @param {Function} pred
		     * @param {Array} propPath
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.propSatisfies, R.path
		     * @example
		     *
		     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
		     */
		    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
		        return propPath.length > 0 && pred(path(propPath, obj));
		    });

		    /**
		     * Returns a partial copy of an object containing only the keys specified. If
		     * the key does not exist, the property is ignored.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig [k] -> {k: v} -> {k: v}
		     * @param {Array} names an array of String property names to copy onto a new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties from `names` on it.
		     * @see R.omit, R.props
		     * @example
		     *
		     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
		     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
		     */
		    var pick = _curry2(function pick(names, obj) {
		        var result = {};
		        var idx = 0;
		        while (idx < names.length) {
		            if (names[idx] in obj) {
		                result[names[idx]] = obj[names[idx]];
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Similar to `pick` except that this one includes a `key: undefined` pair for
		     * properties that don't exist.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig [k] -> {k: v} -> {k: v}
		     * @param {Array} names an array of String property names to copy onto a new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties from `names` on it.
		     * @see R.pick
		     * @example
		     *
		     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
		     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
		     */
		    var pickAll = _curry2(function pickAll(names, obj) {
		        var result = {};
		        var idx = 0;
		        var len = names.length;
		        while (idx < len) {
		            var name = names[idx];
		            result[name] = obj[name];
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a partial copy of an object containing only the keys that satisfy
		     * the supplied predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Object
		     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
		     * @param {Function} pred A predicate to determine whether or not a key
		     *        should be included on the output object.
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with only properties that satisfy `pred`
		     *         on it.
		     * @see R.pick, R.filter
		     * @example
		     *
		     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
		     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
		     */
		    var pickBy = _curry2(function pickBy(test, obj) {
		        var result = {};
		        for (var prop in obj) {
		            if (test(obj[prop], prop, obj)) {
		                result[prop] = obj[prop];
		            }
		        }
		        return result;
		    });

		    /**
		     * Returns a new list with the given element at the front, followed by the
		     * contents of the list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig a -> [a] -> [a]
		     * @param {*} el The item to add to the head of the output list.
		     * @param {Array} list The array to add to the tail of the output list.
		     * @return {Array} A new array.
		     * @see R.append
		     * @example
		     *
		     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
		     */
		    var prepend = _curry2(function prepend(el, list) {
		        return _concat([el], list);
		    });

		    /**
		     * Returns a function that when supplied an object returns the indicated
		     * property of that object, if it exists.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig s -> {s: a} -> a | Undefined
		     * @param {String} p The property name
		     * @param {Object} obj The object to query
		     * @return {*} The value at `obj.p`.
		     * @example
		     *
		     *      R.prop('x', {x: 100}); //=> 100
		     *      R.prop('x', {}); //=> undefined
		     */
		    var prop = _curry2(function prop(p, obj) {
		        return obj[p];
		    });

		    /**
		     * If the given, non-null object has an own property with the specified name,
		     * returns the value of that property. Otherwise returns the provided default
		     * value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.6.0
		     * @category Object
		     * @sig a -> String -> Object -> a
		     * @param {*} val The default value.
		     * @param {String} p The name of the property to return.
		     * @param {Object} obj The object to query.
		     * @return {*} The value of given property of the supplied object or the default value.
		     * @example
		     *
		     *      var alice = {
		     *        name: 'ALICE',
		     *        age: 101
		     *      };
		     *      var favorite = R.prop('favoriteLibrary');
		     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
		     *
		     *      favorite(alice);  //=> undefined
		     *      favoriteWithDefault(alice);  //=> 'Ramda'
		     */
		    var propOr = _curry3(function propOr(val, p, obj) {
		        return obj != null && _has(p, obj) ? obj[p] : val;
		    });

		    /**
		     * Returns `true` if the specified object property satisfies the given
		     * predicate; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Logic
		     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
		     * @param {Function} pred
		     * @param {String} name
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.propEq, R.propIs
		     * @example
		     *
		     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
		     */
		    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
		        return pred(obj[name]);
		    });

		    /**
		     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
		     * order.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig [k] -> {k: v} -> [v]
		     * @param {Array} ps The property names to fetch
		     * @param {Object} obj The object to query
		     * @return {Array} The corresponding values or partially applied function.
		     * @example
		     *
		     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
		     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
		     *
		     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
		     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
		     */
		    var props = _curry2(function props(ps, obj) {
		        var len = ps.length;
		        var out = [];
		        var idx = 0;
		        while (idx < len) {
		            out[idx] = obj[ps[idx]];
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Number -> Number -> [Number]
		     * @param {Number} from The first number in the list.
		     * @param {Number} to One more than the last number in the list.
		     * @return {Array} The list of numbers in tthe set `[a, b)`.
		     * @example
		     *
		     *      R.range(1, 5);    //=> [1, 2, 3, 4]
		     *      R.range(50, 53);  //=> [50, 51, 52]
		     */
		    var range = _curry2(function range(from, to) {
		        if (!(_isNumber(from) && _isNumber(to))) {
		            throw new TypeError('Both arguments to range must be numbers');
		        }
		        var result = [];
		        var n = from;
		        while (n < to) {
		            result.push(n);
		            n += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a single item by iterating through the list, successively calling
		     * the iterator function and passing it an accumulator value and the current
		     * value from the array, and then passing the result to the next call.
		     *
		     * Similar to `reduce`, except moves through the input list from the right to
		     * the left.
		     *
		     * The iterator function receives two values: *(acc, value)*
		     *
		     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
		     * arrays), unlike the native `Array.prototype.reduce` method. For more details
		     * on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a,b -> a) -> a -> [b] -> a
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @see R.addIndex
		     * @example
		     *
		     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
		     *      var flattenPairs = (acc, pair) => acc.concat(pair);
		     *
		     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
		     */
		    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
		        var idx = list.length - 1;
		        while (idx >= 0) {
		            acc = fn(acc, list[idx]);
		            idx -= 1;
		        }
		        return acc;
		    });

		    /**
		     * Returns a value wrapped to indicate that it is the final value of the reduce
		     * and transduce functions. The returned value should be considered a black
		     * box: the internal structure is not guaranteed to be stable.
		     *
		     * Note: this optimization is unavailable to functions not explicitly listed
		     * above. For instance, it is not currently supported by reduceRight.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.15.0
		     * @category List
		     * @sig a -> *
		     * @param {*} x The final value of the reduce.
		     * @return {*} The wrapped value.
		     * @see R.reduce, R.transduce
		     * @example
		     *
		     *      R.reduce(
		     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
		     *        0,
		     *        [1, 2, 3, 4, 5]) // 10
		     */
		    var reduced = _curry1(_reduced);

		    /**
		     * Removes the sub-list of `list` starting at index `start` and containing
		     * `count` elements. _Note that this is not destructive_: it returns a copy of
		     * the list with the changes.
		     * <small>No lists have been harmed in the application of this function.</small>
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.2
		     * @category List
		     * @sig Number -> Number -> [a] -> [a]
		     * @param {Number} start The position to start removing elements
		     * @param {Number} count The number of elements to remove
		     * @param {Array} list The list to remove from
		     * @return {Array} A new Array with `count` elements from `start` removed.
		     * @example
		     *
		     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
		     */
		    var remove = _curry3(function remove(start, count, list) {
		        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
		    });

		    /**
		     * Replace a substring or regex match in a string with a replacement.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category String
		     * @sig RegExp|String -> String -> String -> String
		     * @param {RegExp|String} pattern A regular expression or a substring to match.
		     * @param {String} replacement The string to replace the matches with.
		     * @param {String} str The String to do the search and replacement in.
		     * @return {String} The result.
		     * @example
		     *
		     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
		     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
		     *
		     *      // Use the "g" (global) flag to replace all occurrences:
		     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
		     */
		    var replace = _curry3(function replace(regex, replacement, str) {
		        return str.replace(regex, replacement);
		    });

		    /**
		     * Returns a new list or string with the elements or characters in reverse
		     * order.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [a]
		     * @sig String -> String
		     * @param {Array|String} list
		     * @return {Array|String}
		     * @example
		     *
		     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
		     *      R.reverse([1, 2]);     //=> [2, 1]
		     *      R.reverse([1]);        //=> [1]
		     *      R.reverse([]);         //=> []
		     *
		     *      R.reverse('abc');      //=> 'cba'
		     *      R.reverse('ab');       //=> 'ba'
		     *      R.reverse('a');        //=> 'a'
		     *      R.reverse('');         //=> ''
		     */
		    var reverse = _curry1(function reverse(list) {
		        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
		    });

		    /**
		     * Scan is similar to reduce, but returns a list of successively reduced values
		     * from the left
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category List
		     * @sig (a,b -> a) -> a -> [b] -> [a]
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {Array} A list of all intermediately reduced values.
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
		     */
		    var scan = _curry3(function scan(fn, acc, list) {
		        var idx = 0;
		        var len = list.length;
		        var result = [acc];
		        while (idx < len) {
		            acc = fn(acc, list[idx]);
		            result[idx + 1] = acc;
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns the result of "setting" the portion of the given data structure
		     * focused by the given lens to the given value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> a -> s -> s
		     * @param {Lens} lens
		     * @param {*} v
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
		     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
		     */
		    var set = _curry3(function set(lens, v, x) {
		        return over(lens, always(v), x);
		    });

		    /**
		     * Returns the elements of the given list or string (or object with a `slice`
		     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
		     *
		     * Dispatches to the `slice` method of the third argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.4
		     * @category List
		     * @sig Number -> Number -> [a] -> [a]
		     * @sig Number -> Number -> String -> String
		     * @param {Number} fromIndex The start index (inclusive).
		     * @param {Number} toIndex The end index (exclusive).
		     * @param {*} list
		     * @return {*}
		     * @example
		     *
		     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
		     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
		     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
		     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
		     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
		     */
		    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
		        return Array.prototype.slice.call(list, fromIndex, toIndex);
		    }));

		    /**
		     * Returns a copy of the list, sorted according to the comparator function,
		     * which should accept two values at a time and return a negative number if the
		     * first value is smaller, a positive number if it's larger, and zero if they
		     * are equal. Please note that this is a **copy** of the list. It does not
		     * modify the original.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a,a -> Number) -> [a] -> [a]
		     * @param {Function} comparator A sorting function :: a -> b -> Int
		     * @param {Array} list The list to sort
		     * @return {Array} a new array with its elements sorted by the comparator function.
		     * @example
		     *
		     *      var diff = function(a, b) { return a - b; };
		     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
		     */
		    var sort = _curry2(function sort(comparator, list) {
		        return _slice(list).sort(comparator);
		    });

		    /**
		     * Sorts the list according to the supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig Ord b => (a -> b) -> [a] -> [a]
		     * @param {Function} fn
		     * @param {Array} list The list to sort.
		     * @return {Array} A new list sorted by the keys generated by `fn`.
		     * @example
		     *
		     *      var sortByFirstItem = R.sortBy(R.prop(0));
		     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
		     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
		     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
		     *      var alice = {
		     *        name: 'ALICE',
		     *        age: 101
		     *      };
		     *      var bob = {
		     *        name: 'Bob',
		     *        age: -10
		     *      };
		     *      var clara = {
		     *        name: 'clara',
		     *        age: 314.159
		     *      };
		     *      var people = [clara, bob, alice];
		     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
		     */
		    var sortBy = _curry2(function sortBy(fn, list) {
		        return _slice(list).sort(function (a, b) {
		            var aa = fn(a);
		            var bb = fn(b);
		            return aa < bb ? -1 : aa > bb ? 1 : 0;
		        });
		    });

		    /**
		     * Splits a given list or string at a given index.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig Number -> [a] -> [[a], [a]]
		     * @sig Number -> String -> [String, String]
		     * @param {Number} index The index where the array/string is split.
		     * @param {Array|String} array The array/string to be split.
		     * @return {Array}
		     * @example
		     *
		     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
		     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
		     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
		     */
		    var splitAt = _curry2(function splitAt(index, array) {
		        return [
		            slice(0, index, array),
		            slice(index, length(array), array)
		        ];
		    });

		    /**
		     * Splits a collection into slices of the specified length.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig Number -> [a] -> [[a]]
		     * @sig Number -> String -> [String]
		     * @param {Number} n
		     * @param {Array} list
		     * @return {Array}
		     * @example
		     *
		     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
		     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
		     */
		    var splitEvery = _curry2(function splitEvery(n, list) {
		        if (n <= 0) {
		            throw new Error('First argument to splitEvery must be a positive integer');
		        }
		        var result = [];
		        var idx = 0;
		        while (idx < list.length) {
		            result.push(slice(idx, idx += n, list));
		        }
		        return result;
		    });

		    /**
		     * Takes a list and a predicate and returns a pair of lists with the following properties:
		     *
		     *  - the result of concatenating the two output lists is equivalent to the input list;
		     *  - none of the elements of the first output list satisfies the predicate; and
		     *  - if the second output list is non-empty, its first element satisfies the predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
		     * @param {Function} pred The predicate that determines where the array is split.
		     * @param {Array} list The array to be split.
		     * @return {Array}
		     * @example
		     *
		     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
		     */
		    var splitWhen = _curry2(function splitWhen(pred, list) {
		        var idx = 0;
		        var len = list.length;
		        var prefix = [];
		        while (idx < len && !pred(list[idx])) {
		            prefix.push(list[idx]);
		            idx += 1;
		        }
		        return [
		            prefix,
		            _slice(list, idx)
		        ];
		    });

		    /**
		     * Subtracts two numbers. Equivalent to `a - b` but curried.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig Number -> Number -> Number
		     * @param {Number} a The first value.
		     * @param {Number} b The second value.
		     * @return {Number} The result of `a - b`.
		     * @see R.add
		     * @example
		     *
		     *      R.subtract(10, 8); //=> 2
		     *
		     *      var minus5 = R.subtract(R.__, 5);
		     *      minus5(17); //=> 12
		     *
		     *      var complementaryAngle = R.subtract(90);
		     *      complementaryAngle(30); //=> 60
		     *      complementaryAngle(72); //=> 18
		     */
		    var subtract = _curry2(function subtract(a, b) {
		        return a - b;
		    });

		    /**
		     * Returns all but the first element of the given list or string (or object
		     * with a `tail` method).
		     *
		     * Dispatches to the `slice` method of the first argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [a]
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @see R.head, R.init, R.last
		     * @example
		     *
		     *      R.tail([1, 2, 3]);  //=> [2, 3]
		     *      R.tail([1, 2]);     //=> [2]
		     *      R.tail([1]);        //=> []
		     *      R.tail([]);         //=> []
		     *
		     *      R.tail('abc');  //=> 'bc'
		     *      R.tail('ab');   //=> 'b'
		     *      R.tail('a');    //=> ''
		     *      R.tail('');     //=> ''
		     */
		    var tail = _checkForMethod('tail', slice(1, Infinity));

		    /**
		     * Returns the first `n` elements of the given list, string, or
		     * transducer/transformer (or object with a `take` method).
		     *
		     * Dispatches to the `take` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n
		     * @param {*} list
		     * @return {*}
		     * @see R.drop
		     * @example
		     *
		     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
		     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
		     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.take(3, 'ramda');               //=> 'ram'
		     *
		     *      var personnel = [
		     *        'Dave Brubeck',
		     *        'Paul Desmond',
		     *        'Eugene Wright',
		     *        'Joe Morello',
		     *        'Gerry Mulligan',
		     *        'Bob Bates',
		     *        'Joe Dodge',
		     *        'Ron Crotty'
		     *      ];
		     *
		     *      var takeFive = R.take(5);
		     *      takeFive(personnel);
		     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
		     */
		    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
		        return slice(0, n < 0 ? Infinity : n, xs);
		    }));

		    /**
		     * Returns a new list containing the last `n` elements of a given list, passing
		     * each value to the supplied predicate function, and terminating when the
		     * predicate function returns `false`. Excludes the element that caused the
		     * predicate function to fail. The predicate function is passed one argument:
		     * *(value)*.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.dropLastWhile, R.addIndex
		     * @example
		     *
		     *      var isNotOne = x => x !== 1;
		     *
		     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
		     */
		    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
		        var idx = list.length - 1;
		        while (idx >= 0 && fn(list[idx])) {
		            idx -= 1;
		        }
		        return _slice(list, idx + 1, Infinity);
		    });

		    /**
		     * Returns a new list containing the first `n` elements of a given list,
		     * passing each value to the supplied predicate function, and terminating when
		     * the predicate function returns `false`. Excludes the element that caused the
		     * predicate function to fail. The predicate function is passed one argument:
		     * *(value)*.
		     *
		     * Dispatches to the `takeWhile` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.dropWhile, R.transduce, R.addIndex
		     * @example
		     *
		     *      var isNotFour = x => x !== 4;
		     *
		     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
		     */
		    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
		        var idx = 0;
		        var len = list.length;
		        while (idx < len && fn(list[idx])) {
		            idx += 1;
		        }
		        return _slice(list, 0, idx);
		    }));

		    /**
		     * Runs the given function with the supplied object, then returns the object.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (a -> *) -> a -> a
		     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
		     * @param {*} x
		     * @return {*} `x`.
		     * @example
		     *
		     *      var sayX = x => console.log('x is ' + x);
		     *      R.tap(sayX, 100); //=> 100
		     *      //-> 'x is 100'
		     */
		    var tap = _curry2(function tap(fn, x) {
		        fn(x);
		        return x;
		    });

		    /**
		     * Calls an input function `n` times, returning an array containing the results
		     * of those function calls.
		     *
		     * `fn` is passed one argument: The current value of `n`, which begins at `0`
		     * and is gradually incremented to `n - 1`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.3
		     * @category List
		     * @sig (Number -> a) -> Number -> [a]
		     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
		     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
		     * @return {Array} An array containing the return values of all calls to `fn`.
		     * @example
		     *
		     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
		     */
		    var times = _curry2(function times(fn, n) {
		        var len = Number(n);
		        var idx = 0;
		        var list;
		        if (len < 0 || isNaN(len)) {
		            throw new RangeError('n must be a non-negative number');
		        }
		        list = new Array(len);
		        while (idx < len) {
		            list[idx] = fn(idx);
		            idx += 1;
		        }
		        return list;
		    });

		    /**
		     * Converts an object into an array of key, value arrays. Only the object's
		     * own properties are used.
		     * Note that the order of the output array is not guaranteed to be consistent
		     * across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.4.0
		     * @category Object
		     * @sig {String: *} -> [[String,*]]
		     * @param {Object} obj The object to extract from
		     * @return {Array} An array of key, value arrays from the object's own properties.
		     * @see R.fromPairs
		     * @example
		     *
		     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
		     */
		    var toPairs = _curry1(function toPairs(obj) {
		        var pairs = [];
		        for (var prop in obj) {
		            if (_has(prop, obj)) {
		                pairs[pairs.length] = [
		                    prop,
		                    obj[prop]
		                ];
		            }
		        }
		        return pairs;
		    });

		    /**
		     * Converts an object into an array of key, value arrays. The object's own
		     * properties and prototype properties are used. Note that the order of the
		     * output array is not guaranteed to be consistent across different JS
		     * platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.4.0
		     * @category Object
		     * @sig {String: *} -> [[String,*]]
		     * @param {Object} obj The object to extract from
		     * @return {Array} An array of key, value arrays from the object's own
		     *         and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
		     */
		    var toPairsIn = _curry1(function toPairsIn(obj) {
		        var pairs = [];
		        for (var prop in obj) {
		            pairs[pairs.length] = [
		                prop,
		                obj[prop]
		            ];
		        }
		        return pairs;
		    });

		    /**
		     * Transposes the rows and columns of a 2D list.
		     * When passed a list of `n` lists of length `x`,
		     * returns a list of `x` lists of length `n`.
		     *
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig [[a]] -> [[a]]
		     * @param {Array} list A 2D list
		     * @return {Array} A 2D list
		     * @example
		     *
		     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
		     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
		     *
		     * If some of the rows are shorter than the following rows, their elements are skipped:
		     *
		     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
		     */
		    var transpose = _curry1(function transpose(outerlist) {
		        var i = 0;
		        var result = [];
		        while (i < outerlist.length) {
		            var innerlist = outerlist[i];
		            var j = 0;
		            while (j < innerlist.length) {
		                if (typeof result[j] === 'undefined') {
		                    result[j] = [];
		                }
		                result[j].push(innerlist[j]);
		                j += 1;
		            }
		            i += 1;
		        }
		        return result;
		    });

		    /**
		     * Removes (strips) whitespace from both ends of the string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.6.0
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to trim.
		     * @return {String} Trimmed version of `str`.
		     * @example
		     *
		     *      R.trim('   xyz  '); //=> 'xyz'
		     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
		     */
		    var trim = function () {
		        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
		        var zeroWidth = '\u200B';
		        var hasProtoTrim = typeof String.prototype.trim === 'function';
		        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
		            return _curry1(function trim(str) {
		                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
		                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
		                return str.replace(beginRx, '').replace(endRx, '');
		            });
		        } else {
		            return _curry1(function trim(str) {
		                return str.trim();
		            });
		        }
		    }();

		    /**
		     * Gives a single-word string description of the (native) type of a value,
		     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
		     * attempt to distinguish user Object types any further, reporting them all as
		     * 'Object'.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Type
		     * @sig (* -> {*}) -> String
		     * @param {*} val The value to test
		     * @return {String}
		     * @example
		     *
		     *      R.type({}); //=> "Object"
		     *      R.type(1); //=> "Number"
		     *      R.type(false); //=> "Boolean"
		     *      R.type('s'); //=> "String"
		     *      R.type(null); //=> "Null"
		     *      R.type([]); //=> "Array"
		     *      R.type(/[A-z]/); //=> "RegExp"
		     */
		    var type = _curry1(function type(val) {
		        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
		    });

		    /**
		     * Takes a function `fn`, which takes a single array argument, and returns a
		     * function which:
		     *
		     *   - takes any number of positional arguments;
		     *   - passes these arguments to `fn` as an array; and
		     *   - returns the result.
		     *
		     * In other words, R.unapply derives a variadic function from a function which
		     * takes an array. R.unapply is the inverse of R.apply.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Function
		     * @sig ([*...] -> a) -> (*... -> a)
		     * @param {Function} fn
		     * @return {Function}
		     * @see R.apply
		     * @example
		     *
		     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
		     */
		    var unapply = _curry1(function unapply(fn) {
		        return function () {
		            return fn(_slice(arguments));
		        };
		    });

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts
		     * exactly 1 parameter. Any extraneous parameters will not be passed to the
		     * supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category Function
		     * @sig (* -> b) -> (a -> b)
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity 1.
		     * @example
		     *
		     *      var takesTwoArgs = function(a, b) {
		     *        return [a, b];
		     *      };
		     *      takesTwoArgs.length; //=> 2
		     *      takesTwoArgs(1, 2); //=> [1, 2]
		     *
		     *      var takesOneArg = R.unary(takesTwoArgs);
		     *      takesOneArg.length; //=> 1
		     *      // Only 1 argument is passed to the wrapped function
		     *      takesOneArg(1, 2); //=> [1, undefined]
		     */
		    var unary = _curry1(function unary(fn) {
		        return nAry(1, fn);
		    });

		    /**
		     * Returns a function of arity `n` from a (manually) curried function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Function
		     * @sig Number -> (a -> b) -> (a -> c)
		     * @param {Number} length The arity for the returned function.
		     * @param {Function} fn The function to uncurry.
		     * @return {Function} A new function.
		     * @see R.curry
		     * @example
		     *
		     *      var addFour = a => b => c => d => a + b + c + d;
		     *
		     *      var uncurriedAddFour = R.uncurryN(4, addFour);
		     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
		     */
		    var uncurryN = _curry2(function uncurryN(depth, fn) {
		        return curryN(depth, function () {
		            var currentDepth = 1;
		            var value = fn;
		            var idx = 0;
		            var endIdx;
		            while (currentDepth <= depth && typeof value === 'function') {
		                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
		                value = value.apply(this, _slice(arguments, idx, endIdx));
		                currentDepth += 1;
		                idx = endIdx;
		            }
		            return value;
		        });
		    });

		    /**
		     * Builds a list from a seed value. Accepts an iterator function, which returns
		     * either false to stop iteration or an array of length 2 containing the value
		     * to add to the resulting list and the seed to be used in the next call to the
		     * iterator function.
		     *
		     * The iterator function receives one argument: *(seed)*.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category List
		     * @sig (a -> [b]) -> * -> [b]
		     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
		     *        either false to quit iteration or an array of length two to proceed. The element
		     *        at index 0 of this array will be added to the resulting array, and the element
		     *        at index 1 will be passed to the next call to `fn`.
		     * @param {*} seed The seed value.
		     * @return {Array} The final list.
		     * @example
		     *
		     *      var f = n => n > 50 ? false : [-n, n + 10];
		     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
		     */
		    var unfold = _curry2(function unfold(fn, seed) {
		        var pair = fn(seed);
		        var result = [];
		        while (pair && pair.length) {
		            result[result.length] = pair[0];
		            pair = fn(pair[1]);
		        }
		        return result;
		    });

		    /**
		     * Returns a new list containing only one copy of each element in the original
		     * list, based upon the value returned by applying the supplied predicate to
		     * two list elements. Prefers the first item if two items compare equal based
		     * on the predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category List
		     * @sig (a, a -> Boolean) -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      var strEq = R.eqBy(String);
		     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
		     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
		     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
		     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
		     */
		    var uniqWith = _curry2(function uniqWith(pred, list) {
		        var idx = 0;
		        var len = list.length;
		        var result = [];
		        var item;
		        while (idx < len) {
		            item = list[idx];
		            if (!_containsWith(pred, item, result)) {
		                result[result.length] = item;
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Tests the final argument by passing it to the given predicate function. If
		     * the predicate is not satisfied, the function will return the result of
		     * calling the `whenFalseFn` function with the same argument. If the predicate
		     * is satisfied, the argument is returned as is.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category Logic
		     * @sig (a -> Boolean) -> (a -> a) -> a -> a
		     * @param {Function} pred        A predicate function
		     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
		     *                               to a falsy value.
		     * @param {*}        x           An object to test with the `pred` function and
		     *                               pass to `whenFalseFn` if necessary.
		     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
		     * @see R.ifElse, R.when
		     * @example
		     *
		     *      // coerceArray :: (a|[a]) -> [a]
		     *      var coerceArray = R.unless(R.isArrayLike, R.of);
		     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
		     *      coerceArray(1);         //=> [1]
		     */
		    var unless = _curry3(function unless(pred, whenFalseFn, x) {
		        return pred(x) ? x : whenFalseFn(x);
		    });

		    /**
		     * Returns a new copy of the array with the element at the provided index
		     * replaced with the given value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category List
		     * @sig Number -> a -> [a] -> [a]
		     * @param {Number} idx The index to update.
		     * @param {*} x The value to exist at the given index of the returned array.
		     * @param {Array|Arguments} list The source array-like object to be updated.
		     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
		     * @see R.adjust
		     * @example
		     *
		     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
		     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
		     */
		    var update = _curry3(function update(idx, x, list) {
		        return adjust(always(x), idx, list);
		    });

		    /**
		     * Accepts a function `fn` and a list of transformer functions and returns a
		     * new curried function. When the new function is invoked, it calls the
		     * function `fn` with parameters consisting of the result of calling each
		     * supplied handler on successive arguments to the new function.
		     *
		     * If more arguments are passed to the returned function than transformer
		     * functions, those arguments are passed directly to `fn` as additional
		     * parameters. If you expect additional arguments that don't need to be
		     * transformed, although you can ignore them, it's best to pass an identity
		     * function so that the new function reports the correct arity.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
		     * @param {Function} fn The function to wrap.
		     * @param {Array} transformers A list of transformer functions
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
		     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
		     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
		     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
		     */
		    var useWith = _curry2(function useWith(fn, transformers) {
		        return curryN(transformers.length, function () {
		            var args = [];
		            var idx = 0;
		            while (idx < transformers.length) {
		                args.push(transformers[idx].call(this, arguments[idx]));
		                idx += 1;
		            }
		            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
		        });
		    });

		    /**
		     * Returns a list of all the enumerable own properties of the supplied object.
		     * Note that the order of the output array is not guaranteed across different
		     * JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig {k: v} -> [v]
		     * @param {Object} obj The object to extract values from
		     * @return {Array} An array of the values of the object's own properties.
		     * @example
		     *
		     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
		     */
		    var values = _curry1(function values(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var vals = [];
		        var idx = 0;
		        while (idx < len) {
		            vals[idx] = obj[props[idx]];
		            idx += 1;
		        }
		        return vals;
		    });

		    /**
		     * Returns a list of all the properties, including prototype properties, of the
		     * supplied object.
		     * Note that the order of the output array is not guaranteed to be consistent
		     * across different JS platforms.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category Object
		     * @sig {k: v} -> [v]
		     * @param {Object} obj The object to extract values from
		     * @return {Array} An array of the values of the object's own and prototype properties.
		     * @example
		     *
		     *      var F = function() { this.x = 'X'; };
		     *      F.prototype.y = 'Y';
		     *      var f = new F();
		     *      R.valuesIn(f); //=> ['X', 'Y']
		     */
		    var valuesIn = _curry1(function valuesIn(obj) {
		        var prop;
		        var vs = [];
		        for (prop in obj) {
		            vs[vs.length] = obj[prop];
		        }
		        return vs;
		    });

		    /**
		     * Returns a "view" of the given data structure, determined by the given lens.
		     * The lens's focus determines which portion of the data structure is visible.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Lens s a -> s -> a
		     * @param {Lens} lens
		     * @param {*} x
		     * @return {*}
		     * @see R.prop, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.view(xLens, {x: 1, y: 2});  //=> 1
		     *      R.view(xLens, {x: 4, y: 2});  //=> 4
		     */
		    var view = function () {
		        var Const = function (x) {
		            return {
		                value: x,
		                map: function () {
		                    return this;
		                }
		            };
		        };
		        return _curry2(function view(lens, x) {
		            return lens(Const)(x).value;
		        });
		    }();

		    /**
		     * Tests the final argument by passing it to the given predicate function. If
		     * the predicate is satisfied, the function will return the result of calling
		     * the `whenTrueFn` function with the same argument. If the predicate is not
		     * satisfied, the argument is returned as is.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category Logic
		     * @sig (a -> Boolean) -> (a -> a) -> a -> a
		     * @param {Function} pred       A predicate function
		     * @param {Function} whenTrueFn A function to invoke when the `condition`
		     *                              evaluates to a truthy value.
		     * @param {*}        x          An object to test with the `pred` function and
		     *                              pass to `whenTrueFn` if necessary.
		     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
		     * @see R.ifElse, R.unless
		     * @example
		     *
		     *      // truncate :: String -> String
		     *      var truncate = R.when(
		     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
		     *        R.pipe(R.take(10), R.append('…'), R.join(''))
		     *      );
		     *      truncate('12345');         //=> '12345'
		     *      truncate('0123456789ABC'); //=> '0123456789…'
		     */
		    var when = _curry3(function when(pred, whenTrueFn, x) {
		        return pred(x) ? whenTrueFn(x) : x;
		    });

		    /**
		     * Takes a spec object and a test object; returns true if the test satisfies
		     * the spec. Each of the spec's own properties must be a predicate function.
		     * Each predicate is applied to the value of the corresponding property of the
		     * test object. `where` returns true if all the predicates return true, false
		     * otherwise.
		     *
		     * `where` is well suited to declaratively expressing constraints for other
		     * functions such as `filter` and `find`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category Object
		     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
		     * @param {Object} spec
		     * @param {Object} testObj
		     * @return {Boolean}
		     * @example
		     *
		     *      // pred :: Object -> Boolean
		     *      var pred = R.where({
		     *        a: R.equals('foo'),
		     *        b: R.complement(R.equals('bar')),
		     *        x: R.gt(_, 10),
		     *        y: R.lt(_, 20)
		     *      });
		     *
		     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
		     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
		     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
		     */
		    var where = _curry2(function where(spec, testObj) {
		        for (var prop in spec) {
		            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
		                return false;
		            }
		        }
		        return true;
		    });

		    /**
		     * Wrap a function inside another to allow you to make adjustments to the
		     * parameters, or do other processing either before the internal function is
		     * called or with its results.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
		     * @param {Function} fn The function to wrap.
		     * @param {Function} wrapper The wrapper function.
		     * @return {Function} The wrapped function.
		     * @example
		     *
		     *      var greet = name => 'Hello ' + name;
		     *
		     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
		     *
		     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
		     *
		     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
		     *        return gr(name.substring(0, 3));
		     *      });
		     *      shortenedGreet("Robert"); //=> "Hello Rob"
		     */
		    var wrap = _curry2(function wrap(fn, wrapper) {
		        return curryN(fn.length, function () {
		            return wrapper.apply(this, _concat([fn], arguments));
		        });
		    });

		    /**
		     * Creates a new list out of the two supplied by creating each possible pair
		     * from the lists.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [b] -> [[a,b]]
		     * @param {Array} as The first list.
		     * @param {Array} bs The second list.
		     * @return {Array} The list made by combining each possible pair from
		     *         `as` and `bs` into pairs (`[a, b]`).
		     * @example
		     *
		     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
		     */
		    // = xprodWith(prepend); (takes about 3 times as long...)
		    var xprod = _curry2(function xprod(a, b) {
		        // = xprodWith(prepend); (takes about 3 times as long...)
		        var idx = 0;
		        var ilen = a.length;
		        var j;
		        var jlen = b.length;
		        var result = [];
		        while (idx < ilen) {
		            j = 0;
		            while (j < jlen) {
		                result[result.length] = [
		                    a[idx],
		                    b[j]
		                ];
		                j += 1;
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Creates a new list out of the two supplied by pairing up equally-positioned
		     * items from both lists. The returned list is truncated to the length of the
		     * shorter of the two input lists.
		     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [b] -> [[a,b]]
		     * @param {Array} list1 The first array to consider.
		     * @param {Array} list2 The second array to consider.
		     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
		     * @example
		     *
		     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
		     */
		    var zip = _curry2(function zip(a, b) {
		        var rv = [];
		        var idx = 0;
		        var len = Math.min(a.length, b.length);
		        while (idx < len) {
		            rv[idx] = [
		                a[idx],
		                b[idx]
		            ];
		            idx += 1;
		        }
		        return rv;
		    });

		    /**
		     * Creates a new object out of a list of keys and a list of values.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category List
		     * @sig [String] -> [*] -> {String: *}
		     * @param {Array} keys The array that will be properties on the output object.
		     * @param {Array} values The list of values on the output object.
		     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
		     * @example
		     *
		     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
		     */
		    var zipObj = _curry2(function zipObj(keys, values) {
		        var idx = 0;
		        var len = keys.length;
		        var out = {};
		        while (idx < len) {
		            out[keys[idx]] = values[idx];
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Creates a new list out of the two supplied by applying the function to each
		     * equally-positioned pair in the lists. The returned list is truncated to the
		     * length of the shorter of the two input lists.
		     *
		     * @function
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a,b -> c) -> [a] -> [b] -> [c]
		     * @param {Function} fn The function used to combine the two elements into one value.
		     * @param {Array} list1 The first array to consider.
		     * @param {Array} list2 The second array to consider.
		     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
		     *         using `fn`.
		     * @example
		     *
		     *      var f = (x, y) => {
		     *        // ...
		     *      };
		     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
		     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
		     */
		    var zipWith = _curry3(function zipWith(fn, a, b) {
		        var rv = [];
		        var idx = 0;
		        var len = Math.min(a.length, b.length);
		        while (idx < len) {
		            rv[idx] = fn(a[idx], b[idx]);
		            idx += 1;
		        }
		        return rv;
		    });

		    /**
		     * A function that always returns `false`. Any passed in parameters are ignored.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Function
		     * @sig * -> Boolean
		     * @param {*}
		     * @return {Boolean}
		     * @see R.always, R.T
		     * @example
		     *
		     *      R.F(); //=> false
		     */
		    var F = always(false);

		    /**
		     * A function that always returns `true`. Any passed in parameters are ignored.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Function
		     * @sig * -> Boolean
		     * @param {*}
		     * @return {Boolean}
		     * @see R.always, R.F
		     * @example
		     *
		     *      R.T(); //=> true
		     */
		    var T = always(true);

		    /**
		     * Copies an object.
		     *
		     * @private
		     * @param {*} value The value to be copied
		     * @param {Array} refFrom Array containing the source references
		     * @param {Array} refTo Array containing the copied source references
		     * @return {*} The copied value.
		     */
		    var _clone = function _clone(value, refFrom, refTo) {
		        var copy = function copy(copiedValue) {
		            var len = refFrom.length;
		            var idx = 0;
		            while (idx < len) {
		                if (value === refFrom[idx]) {
		                    return refTo[idx];
		                }
		                idx += 1;
		            }
		            refFrom[idx + 1] = value;
		            refTo[idx + 1] = copiedValue;
		            for (var key in value) {
		                copiedValue[key] = _clone(value[key], refFrom, refTo);
		            }
		            return copiedValue;
		        };
		        switch (type(value)) {
		        case 'Object':
		            return copy({});
		        case 'Array':
		            return copy([]);
		        case 'Date':
		            return new Date(value.valueOf());
		        case 'RegExp':
		            return _cloneRegExp(value);
		        default:
		            return value;
		        }
		    };

		    var _createPartialApplicator = function _createPartialApplicator(concat) {
		        return _curry2(function (fn, args) {
		            return _arity(Math.max(0, fn.length - args.length), function () {
		                return fn.apply(this, concat(args, arguments));
		            });
		        });
		    };

		    var _dropLast = function dropLast(n, xs) {
		        return take(n < xs.length ? xs.length - n : 0, xs);
		    };

		    // Values of other types are only equal if identical.
		    var _equals = function _equals(a, b, stackA, stackB) {
		        if (identical(a, b)) {
		            return true;
		        }
		        if (type(a) !== type(b)) {
		            return false;
		        }
		        if (a == null || b == null) {
		            return false;
		        }
		        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
		            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
		        }
		        switch (type(a)) {
		        case 'Arguments':
		        case 'Array':
		        case 'Object':
		            break;
		        case 'Boolean':
		        case 'Number':
		        case 'String':
		            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
		                return false;
		            }
		            break;
		        case 'Date':
		            if (!identical(a.valueOf(), b.valueOf())) {
		                return false;
		            }
		            break;
		        case 'Error':
		            return a.name === b.name && a.message === b.message;
		        case 'RegExp':
		            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
		                return false;
		            }
		            break;
		        case 'Map':
		        case 'Set':
		            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
		                return false;
		            }
		            break;
		        case 'Int8Array':
		        case 'Uint8Array':
		        case 'Uint8ClampedArray':
		        case 'Int16Array':
		        case 'Uint16Array':
		        case 'Int32Array':
		        case 'Uint32Array':
		        case 'Float32Array':
		        case 'Float64Array':
		            break;
		        case 'ArrayBuffer':
		            break;
		        default:
		            // Values of other types are only equal if identical.
		            return false;
		        }
		        var keysA = keys(a);
		        if (keysA.length !== keys(b).length) {
		            return false;
		        }
		        var idx = stackA.length - 1;
		        while (idx >= 0) {
		            if (stackA[idx] === a) {
		                return stackB[idx] === b;
		            }
		            idx -= 1;
		        }
		        stackA.push(a);
		        stackB.push(b);
		        idx = keysA.length - 1;
		        while (idx >= 0) {
		            var key = keysA[idx];
		            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
		                return false;
		            }
		            idx -= 1;
		        }
		        stackA.pop();
		        stackB.pop();
		        return true;
		    };

		    /**
		     * `_makeFlat` is a helper function that returns a one-level or fully recursive
		     * function based on the flag passed in.
		     *
		     * @private
		     */
		    var _makeFlat = function _makeFlat(recursive) {
		        return function flatt(list) {
		            var value, jlen, j;
		            var result = [];
		            var idx = 0;
		            var ilen = list.length;
		            while (idx < ilen) {
		                if (isArrayLike(list[idx])) {
		                    value = recursive ? flatt(list[idx]) : list[idx];
		                    j = 0;
		                    jlen = value.length;
		                    while (j < jlen) {
		                        result[result.length] = value[j];
		                        j += 1;
		                    }
		                } else {
		                    result[result.length] = list[idx];
		                }
		                idx += 1;
		            }
		            return result;
		        };
		    };

		    var _reduce = function () {
		        function _arrayReduce(xf, acc, list) {
		            var idx = 0;
		            var len = list.length;
		            while (idx < len) {
		                acc = xf['@@transducer/step'](acc, list[idx]);
		                if (acc && acc['@@transducer/reduced']) {
		                    acc = acc['@@transducer/value'];
		                    break;
		                }
		                idx += 1;
		            }
		            return xf['@@transducer/result'](acc);
		        }
		        function _iterableReduce(xf, acc, iter) {
		            var step = iter.next();
		            while (!step.done) {
		                acc = xf['@@transducer/step'](acc, step.value);
		                if (acc && acc['@@transducer/reduced']) {
		                    acc = acc['@@transducer/value'];
		                    break;
		                }
		                step = iter.next();
		            }
		            return xf['@@transducer/result'](acc);
		        }
		        function _methodReduce(xf, acc, obj) {
		            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
		        }
		        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
		        return function _reduce(fn, acc, list) {
		            if (typeof fn === 'function') {
		                fn = _xwrap(fn);
		            }
		            if (isArrayLike(list)) {
		                return _arrayReduce(fn, acc, list);
		            }
		            if (typeof list.reduce === 'function') {
		                return _methodReduce(fn, acc, list);
		            }
		            if (list[symIterator] != null) {
		                return _iterableReduce(fn, acc, list[symIterator]());
		            }
		            if (typeof list.next === 'function') {
		                return _iterableReduce(fn, acc, list);
		            }
		            throw new TypeError('reduce: list must be array or iterable');
		        };
		    }();

		    var _xdropLastWhile = function () {
		        function XDropLastWhile(fn, xf) {
		            this.f = fn;
		            this.retained = [];
		            this.xf = xf;
		        }
		        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
		        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
		            this.retained = null;
		            return this.xf['@@transducer/result'](result);
		        };
		        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
		            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
		        };
		        XDropLastWhile.prototype.flush = function (result, input) {
		            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
		            this.retained = [];
		            return this.xf['@@transducer/step'](result, input);
		        };
		        XDropLastWhile.prototype.retain = function (result, input) {
		            this.retained.push(input);
		            return result;
		        };
		        return _curry2(function _xdropLastWhile(fn, xf) {
		            return new XDropLastWhile(fn, xf);
		        });
		    }();

		    var _xgroupBy = function () {
		        function XGroupBy(f, xf) {
		            this.xf = xf;
		            this.f = f;
		            this.inputs = {};
		        }
		        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
		        XGroupBy.prototype['@@transducer/result'] = function (result) {
		            var key;
		            for (key in this.inputs) {
		                if (_has(key, this.inputs)) {
		                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
		                    if (result['@@transducer/reduced']) {
		                        result = result['@@transducer/value'];
		                        break;
		                    }
		                }
		            }
		            this.inputs = null;
		            return this.xf['@@transducer/result'](result);
		        };
		        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
		            var key = this.f(input);
		            this.inputs[key] = this.inputs[key] || [
		                key,
		                []
		            ];
		            this.inputs[key][1] = append(input, this.inputs[key][1]);
		            return result;
		        };
		        return _curry2(function _xgroupBy(f, xf) {
		            return new XGroupBy(f, xf);
		        });
		    }();

		    /**
		     * Creates a new list iteration function from an existing one by adding two new
		     * parameters to its callback function: the current index, and the entire list.
		     *
		     * This would turn, for instance, Ramda's simple `map` function into one that
		     * more closely resembles `Array.prototype.map`. Note that this will only work
		     * for functions in which the iteration callback function is the first
		     * parameter, and where the list is the last parameter. (This latter might be
		     * unimportant if the list parameter is not used.)
		     *
		     * @func
		     * @memberOf R
		     * @since v0.15.0
		     * @category Function
		     * @category List
		     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
		     * @param {Function} fn A list iteration function that does not pass index or list to its callback
		     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
		     * @example
		     *
		     *      var mapIndexed = R.addIndex(R.map);
		     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
		     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
		     */
		    var addIndex = _curry1(function addIndex(fn) {
		        return curryN(fn.length, function () {
		            var idx = 0;
		            var origFn = arguments[0];
		            var list = arguments[arguments.length - 1];
		            var args = _slice(arguments);
		            args[0] = function () {
		                var result = origFn.apply(this, _concat(arguments, [
		                    idx,
		                    list
		                ]));
		                idx += 1;
		                return result;
		            };
		            return fn.apply(this, args);
		        });
		    });

		    /**
		     * Wraps a function of any arity (including nullary) in a function that accepts
		     * exactly 2 parameters. Any extraneous parameters will not be passed to the
		     * supplied function.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.2.0
		     * @category Function
		     * @sig (* -> c) -> (a, b -> c)
		     * @param {Function} fn The function to wrap.
		     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
		     *         arity 2.
		     * @example
		     *
		     *      var takesThreeArgs = function(a, b, c) {
		     *        return [a, b, c];
		     *      };
		     *      takesThreeArgs.length; //=> 3
		     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
		     *
		     *      var takesTwoArgs = R.binary(takesThreeArgs);
		     *      takesTwoArgs.length; //=> 2
		     *      // Only 2 arguments are passed to the wrapped function
		     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
		     */
		    var binary = _curry1(function binary(fn) {
		        return nAry(2, fn);
		    });

		    /**
		     * Creates a deep copy of the value which may contain (nested) `Array`s and
		     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
		     * copied, but assigned by their reference.
		     *
		     * Dispatches to a `clone` method if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig {*} -> {*}
		     * @param {*} value The object or array to clone
		     * @return {*} A new object or array.
		     * @example
		     *
		     *      var objects = [{}, {}, {}];
		     *      var objectsClone = R.clone(objects);
		     *      objects[0] === objectsClone[0]; //=> false
		     */
		    var clone = _curry1(function clone(value) {
		        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);
		    });

		    /**
		     * Returns a curried equivalent of the provided function. The curried function
		     * has two unusual capabilities. First, its arguments needn't be provided one
		     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
		     * following are equivalent:
		     *
		     *   - `g(1)(2)(3)`
		     *   - `g(1)(2, 3)`
		     *   - `g(1, 2)(3)`
		     *   - `g(1, 2, 3)`
		     *
		     * Secondly, the special placeholder value `R.__` may be used to specify
		     * "gaps", allowing partial application of any combination of arguments,
		     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
		     * following are equivalent:
		     *
		     *   - `g(1, 2, 3)`
		     *   - `g(_, 2, 3)(1)`
		     *   - `g(_, _, 3)(1)(2)`
		     *   - `g(_, _, 3)(1, 2)`
		     *   - `g(_, 2)(1)(3)`
		     *   - `g(_, 2)(1, 3)`
		     *   - `g(_, 2)(_, 3)(1)`
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (* -> a) -> (* -> a)
		     * @param {Function} fn The function to curry.
		     * @return {Function} A new, curried function.
		     * @see R.curryN
		     * @example
		     *
		     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
		     *
		     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
		     *      var f = curriedAddFourNumbers(1, 2);
		     *      var g = f(3);
		     *      g(4); //=> 10
		     */
		    var curry = _curry1(function curry(fn) {
		        return curryN(fn.length, fn);
		    });

		    /**
		     * Returns all but the first `n` elements of the given list, string, or
		     * transducer/transformer (or object with a `drop` method).
		     *
		     * Dispatches to the `drop` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n
		     * @param {*} list
		     * @return {*}
		     * @see R.take, R.transduce
		     * @example
		     *
		     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
		     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
		     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
		     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
		     *      R.drop(3, 'ramda');               //=> 'da'
		     */
		    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
		        return slice(Math.max(0, n), Infinity, xs);
		    }));

		    /**
		     * Returns a list containing all but the last `n` elements of the given `list`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n The number of elements of `xs` to skip.
		     * @param {Array} xs The collection to consider.
		     * @return {Array}
		     * @see R.takeLast
		     * @example
		     *
		     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
		     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
		     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
		     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
		     *      R.dropLast(3, 'ramda');               //=> 'ra'
		     */
		    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

		    /**
		     * Returns a new list containing all but last the`n` elements of a given list,
		     * passing each value from the right to the supplied predicate function,
		     * skipping elements while the predicate function returns `true`. The predicate
		     * function is passed one argument: (value)*.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [a]
		     * @param {Function} fn The function called per iteration.
		     * @param {Array} list The collection to iterate over.
		     * @return {Array} A new array.
		     * @see R.takeLastWhile, R.addIndex
		     * @example
		     *
		     *      var lteThree = x => x <= 3;
		     *
		     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
		     */
		    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

		    /**
		     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
		     * cyclical data structures.
		     *
		     * Dispatches symmetrically to the `equals` methods of both arguments, if
		     * present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.15.0
		     * @category Relation
		     * @sig a -> b -> Boolean
		     * @param {*} a
		     * @param {*} b
		     * @return {Boolean}
		     * @example
		     *
		     *      R.equals(1, 1); //=> true
		     *      R.equals(1, '1'); //=> false
		     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
		     *
		     *      var a = {}; a.v = a;
		     *      var b = {}; b.v = b;
		     *      R.equals(a, b); //=> true
		     */
		    var equals = _curry2(function equals(a, b) {
		        return _equals(a, b, [], []);
		    });

		    /**
		     * Takes a predicate and a "filterable", and returns a new filterable of the
		     * same type containing the members of the given filterable which satisfy the
		     * given predicate.
		     *
		     * Dispatches to the `filter` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Filterable f => (a -> Boolean) -> f a -> f a
		     * @param {Function} pred
		     * @param {Array} filterable
		     * @return {Array}
		     * @see R.reject, R.transduce, R.addIndex
		     * @example
		     *
		     *      var isEven = n => n % 2 === 0;
		     *
		     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
		     *
		     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
		     */
		    // else
		    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
		        return _isObject(filterable) ? _reduce(function (acc, key) {
		            if (pred(filterable[key])) {
		                acc[key] = filterable[key];
		            }
		            return acc;
		        }, {}, keys(filterable)) : // else
		        _filter(pred, filterable);
		    }));

		    /**
		     * Returns a new list by pulling every item out of it (and all its sub-arrays)
		     * and putting them in a new array, depth-first.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [b]
		     * @param {Array} list The array to consider.
		     * @return {Array} The flattened list.
		     * @see R.unnest
		     * @example
		     *
		     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
		     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
		     */
		    var flatten = _curry1(_makeFlat(true));

		    /**
		     * Returns a new function much like the supplied one, except that the first two
		     * arguments' order is reversed.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
		     * @param {Function} fn The function to invoke with its first two parameters reversed.
		     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
		     * @example
		     *
		     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
		     *
		     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
		     *
		     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
		     */
		    var flip = _curry1(function flip(fn) {
		        return curry(function (a, b) {
		            var args = _slice(arguments);
		            args[0] = b;
		            args[1] = a;
		            return fn.apply(this, args);
		        });
		    });

		    /**
		     * Splits a list into sub-lists stored in an object, based on the result of
		     * calling a String-returning function on each element, and grouping the
		     * results according to values returned.
		     *
		     * Dispatches to the `groupBy` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig (a -> String) -> [a] -> {String: [a]}
		     * @param {Function} fn Function :: a -> String
		     * @param {Array} list The array to group
		     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
		     *         that produced that key when passed to `fn`.
		     * @see R.transduce
		     * @example
		     *
		     *      var byGrade = R.groupBy(function(student) {
		     *        var score = student.score;
		     *        return score < 65 ? 'F' :
		     *               score < 70 ? 'D' :
		     *               score < 80 ? 'C' :
		     *               score < 90 ? 'B' : 'A';
		     *      });
		     *      var students = [{name: 'Abby', score: 84},
		     *                      {name: 'Eddy', score: 58},
		     *                      // ...
		     *                      {name: 'Jack', score: 69}];
		     *      byGrade(students);
		     *      // {
		     *      //   'A': [{name: 'Dianne', score: 99}],
		     *      //   'B': [{name: 'Abby', score: 84}]
		     *      //   // ...,
		     *      //   'F': [{name: 'Eddy', score: 58}]
		     *      // }
		     */
		    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
		        return _reduce(function (acc, elt) {
		            var key = fn(elt);
		            acc[key] = append(elt, acc[key] || (acc[key] = []));
		            return acc;
		        }, {}, list);
		    }));

		    /**
		     * Returns the first element of the given list or string. In some libraries
		     * this function is named `first`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> a | Undefined
		     * @sig String -> String
		     * @param {Array|String} list
		     * @return {*}
		     * @see R.tail, R.init, R.last
		     * @example
		     *
		     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
		     *      R.head([]); //=> undefined
		     *
		     *      R.head('abc'); //=> 'a'
		     *      R.head(''); //=> ''
		     */
		    var head = nth(0);

		    /**
		     * Given a function that generates a key, turns a list of objects into an
		     * object indexing the objects by the given key. Note that if multiple
		     * objects generate the same value for the indexing key only the last value
		     * will be included in the generated object.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
		     * @param {Function} fn Function :: a -> String
		     * @param {Array} array The array of objects to index
		     * @return {Object} An object indexing each array element by the given property.
		     * @example
		     *
		     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
		     *      R.indexBy(R.prop('id'), list);
		     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
		     */
		    var indexBy = _curry2(function indexBy(fn, list) {
		        return _reduce(function (acc, elem) {
		            var key = fn(elem);
		            acc[key] = elem;
		            return acc;
		        }, {}, list);
		    });

		    /**
		     * Returns all but the last element of the given list or string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category List
		     * @sig [a] -> [a]
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @see R.last, R.head, R.tail
		     * @example
		     *
		     *      R.init([1, 2, 3]);  //=> [1, 2]
		     *      R.init([1, 2]);     //=> [1]
		     *      R.init([1]);        //=> []
		     *      R.init([]);         //=> []
		     *
		     *      R.init('abc');  //=> 'ab'
		     *      R.init('ab');   //=> 'a'
		     *      R.init('a');    //=> ''
		     *      R.init('');     //=> ''
		     */
		    var init = slice(0, -1);

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of those
		     * elements common to both lists. Duplication is determined according to the
		     * value returned by applying the supplied predicate to two list elements.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
		     * @param {Function} pred A predicate function that determines whether
		     *        the two supplied elements are equal.
		     * @param {Array} list1 One list of items to compare
		     * @param {Array} list2 A second list of items to compare
		     * @return {Array} A new list containing those elements common to both lists.
		     * @see R.intersection
		     * @example
		     *
		     *      var buffaloSpringfield = [
		     *        {id: 824, name: 'Richie Furay'},
		     *        {id: 956, name: 'Dewey Martin'},
		     *        {id: 313, name: 'Bruce Palmer'},
		     *        {id: 456, name: 'Stephen Stills'},
		     *        {id: 177, name: 'Neil Young'}
		     *      ];
		     *      var csny = [
		     *        {id: 204, name: 'David Crosby'},
		     *        {id: 456, name: 'Stephen Stills'},
		     *        {id: 539, name: 'Graham Nash'},
		     *        {id: 177, name: 'Neil Young'}
		     *      ];
		     *
		     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
		     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
		     */
		    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
		        var results = [];
		        var idx = 0;
		        while (idx < list1.length) {
		            if (_containsWith(pred, list1[idx], list2)) {
		                results[results.length] = list1[idx];
		            }
		            idx += 1;
		        }
		        return uniqWith(pred, results);
		    });

		    /**
		     * Same as R.invertObj, however this accounts for objects with duplicate values
		     * by putting the values into an array.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Object
		     * @sig {s: x} -> {x: [ s, ... ]}
		     * @param {Object} obj The object or array to invert
		     * @return {Object} out A new object with keys
		     * in an array.
		     * @example
		     *
		     *      var raceResultsByFirstName = {
		     *        first: 'alice',
		     *        second: 'jake',
		     *        third: 'alice',
		     *      };
		     *      R.invert(raceResultsByFirstName);
		     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
		     */
		    var invert = _curry1(function invert(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var idx = 0;
		        var out = {};
		        while (idx < len) {
		            var key = props[idx];
		            var val = obj[key];
		            var list = _has(val, out) ? out[val] : out[val] = [];
		            list[list.length] = key;
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new object with the keys of the given object as values, and the
		     * values of the given object, which are coerced to strings, as keys. Note
		     * that the last key found is preferred when handling the same value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Object
		     * @sig {s: x} -> {x: s}
		     * @param {Object} obj The object or array to invert
		     * @return {Object} out A new object
		     * @example
		     *
		     *      var raceResults = {
		     *        first: 'alice',
		     *        second: 'jake'
		     *      };
		     *      R.invertObj(raceResults);
		     *      //=> { 'alice': 'first', 'jake':'second' }
		     *
		     *      // Alternatively:
		     *      var raceResults = ['alice', 'jake'];
		     *      R.invertObj(raceResults);
		     *      //=> { 'alice': '0', 'jake':'1' }
		     */
		    var invertObj = _curry1(function invertObj(obj) {
		        var props = keys(obj);
		        var len = props.length;
		        var idx = 0;
		        var out = {};
		        while (idx < len) {
		            var key = props[idx];
		            out[obj[key]] = key;
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns `true` if the given value is its type's empty value; `false`
		     * otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Logic
		     * @sig a -> Boolean
		     * @param {*} x
		     * @return {Boolean}
		     * @see R.empty
		     * @example
		     *
		     *      R.isEmpty([1, 2, 3]);   //=> false
		     *      R.isEmpty([]);          //=> true
		     *      R.isEmpty('');          //=> true
		     *      R.isEmpty(null);        //=> false
		     *      R.isEmpty({});          //=> true
		     *      R.isEmpty({length: 0}); //=> false
		     */
		    var isEmpty = _curry1(function isEmpty(x) {
		        return x != null && equals(x, empty(x));
		    });

		    /**
		     * Returns the last element of the given list or string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.4
		     * @category List
		     * @sig [a] -> a | Undefined
		     * @sig String -> String
		     * @param {*} list
		     * @return {*}
		     * @see R.init, R.head, R.tail
		     * @example
		     *
		     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
		     *      R.last([]); //=> undefined
		     *
		     *      R.last('abc'); //=> 'c'
		     *      R.last(''); //=> ''
		     */
		    var last = nth(-1);

		    /**
		     * Returns the position of the last occurrence of an item in an array, or -1 if
		     * the item is not included in the array. `R.equals` is used to determine
		     * equality.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig a -> [a] -> Number
		     * @param {*} target The item to find.
		     * @param {Array} xs The array to search in.
		     * @return {Number} the index of the target, or -1 if the target is not found.
		     * @see R.indexOf
		     * @example
		     *
		     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
		     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
		     */
		    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
		        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
		            return xs.lastIndexOf(target);
		        } else {
		            var idx = xs.length - 1;
		            while (idx >= 0) {
		                if (equals(xs[idx], target)) {
		                    return idx;
		                }
		                idx -= 1;
		            }
		            return -1;
		        }
		    });

		    /**
		     * Takes a function and
		     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
		     * applies the function to each of the functor's values, and returns
		     * a functor of the same shape.
		     *
		     * Ramda provides suitable `map` implementations for `Array` and `Object`,
		     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
		     *
		     * Dispatches to the `map` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * Also treats functions as functors and will compose them together.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Functor f => (a -> b) -> f a -> f b
		     * @param {Function} fn The function to be called on every element of the input `list`.
		     * @param {Array} list The list to be iterated over.
		     * @return {Array} The new list.
		     * @see R.transduce, R.addIndex
		     * @example
		     *
		     *      var double = x => x * 2;
		     *
		     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
		     *
		     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
		     */
		    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
		        switch (Object.prototype.toString.call(functor)) {
		        case '[object Function]':
		            return curryN(functor.length, function () {
		                return fn.call(this, functor.apply(this, arguments));
		            });
		        case '[object Object]':
		            return _reduce(function (acc, key) {
		                acc[key] = fn(functor[key]);
		                return acc;
		            }, {}, keys(functor));
		        default:
		            return _map(fn, functor);
		        }
		    }));

		    /**
		     * An Object-specific version of `map`. The function is applied to three
		     * arguments: *(value, key, obj)*. If only the value is significant, use
		     * `map` instead.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Object
		     * @sig ((*, String, Object) -> *) -> Object -> Object
		     * @param {Function} fn
		     * @param {Object} obj
		     * @return {Object}
		     * @see R.map
		     * @example
		     *
		     *      var values = { x: 1, y: 2, z: 3 };
		     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
		     *
		     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
		     */
		    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
		        return _reduce(function (acc, key) {
		            acc[key] = fn(obj[key], key, obj);
		            return acc;
		        }, {}, keys(obj));
		    });

		    /**
		     * Creates a new object with the own properties of the two provided objects. If
		     * a key exists in both objects, the provided function is applied to the values
		     * associated with the key in each object, with the result being used as the
		     * value associated with the key in the returned object. The key will be
		     * excluded from the returned object if the resulting value is `undefined`.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Object
		     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
		     * @param {Function} fn
		     * @param {Object} l
		     * @param {Object} r
		     * @return {Object}
		     * @see R.merge, R.mergeWithKey
		     * @example
		     *
		     *      R.mergeWith(R.concat,
		     *                  { a: true, values: [10, 20] },
		     *                  { b: true, values: [15, 35] });
		     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
		     */
		    var mergeWith = _curry3(function mergeWith(fn, l, r) {
		        return mergeWithKey(function (_, _l, _r) {
		            return fn(_l, _r);
		        }, l, r);
		    });

		    /**
		     * Takes a function `f` and a list of arguments, and returns a function `g`.
		     * When applied, `g` returns the result of applying `f` to the arguments
		     * provided initially followed by the arguments provided to `g`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Function
		     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
		     * @param {Function} f
		     * @param {Array} args
		     * @return {Function}
		     * @see R.partialRight
		     * @example
		     *
		     *      var multiply = (a, b) => a * b;
		     *      var double = R.partial(multiply, [2]);
		     *      double(2); //=> 4
		     *
		     *      var greet = (salutation, title, firstName, lastName) =>
		     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
		     *
		     *      var sayHello = R.partial(greet, ['Hello']);
		     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
		     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
		     */
		    var partial = _createPartialApplicator(_concat);

		    /**
		     * Takes a function `f` and a list of arguments, and returns a function `g`.
		     * When applied, `g` returns the result of applying `f` to the arguments
		     * provided to `g` followed by the arguments provided initially.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Function
		     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
		     * @param {Function} f
		     * @param {Array} args
		     * @return {Function}
		     * @see R.partial
		     * @example
		     *
		     *      var greet = (salutation, title, firstName, lastName) =>
		     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
		     *
		     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
		     *
		     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
		     */
		    var partialRight = _createPartialApplicator(flip(_concat));

		    /**
		     * Takes a predicate and a list and returns the pair of lists of elements which
		     * do and do not satisfy the predicate, respectively.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.4
		     * @category List
		     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
		     * @param {Function} pred A predicate to determine which array the element belongs to.
		     * @param {Array} list The array to partition.
		     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
		     *         and second an array of elements that did not satisfy.
		     * @see R.filter, R.reject
		     * @example
		     *
		     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
		     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
		     */
		    var partition = _curry2(function partition(pred, list) {
		        return _reduce(function (acc, elt) {
		            var xs = acc[pred(elt) ? 0 : 1];
		            xs[xs.length] = elt;
		            return acc;
		        }, [
		            [],
		            []
		        ], list);
		    });

		    /**
		     * Determines whether a nested path on an object has a specific value, in
		     * `R.equals` terms. Most likely used to filter a list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Relation
		     * @sig [String] -> * -> {String: *} -> Boolean
		     * @param {Array} path The path of the nested property to use
		     * @param {*} val The value to compare the nested property with
		     * @param {Object} obj The object to check the nested property in
		     * @return {Boolean} `true` if the value equals the nested object property,
		     *         `false` otherwise.
		     * @example
		     *
		     *      var user1 = { address: { zipCode: 90210 } };
		     *      var user2 = { address: { zipCode: 55555 } };
		     *      var user3 = { name: 'Bob' };
		     *      var users = [ user1, user2, user3 ];
		     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
		     *      R.filter(isFamous, users); //=> [ user1 ]
		     */
		    var pathEq = _curry3(function pathEq(_path, val, obj) {
		        return equals(path(_path, obj), val);
		    });

		    /**
		     * Returns a new list by plucking the same named property off all objects in
		     * the list supplied.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig k -> [{k: v}] -> [v]
		     * @param {Number|String} key The key name to pluck off of each object.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of values for the given key.
		     * @see R.props
		     * @example
		     *
		     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
		     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
		     */
		    var pluck = _curry2(function pluck(p, list) {
		        return map(prop(p), list);
		    });

		    /**
		     * Reasonable analog to SQL `select` statement.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @category Relation
		     * @sig [k] -> [{k: v}] -> [{k: v}]
		     * @param {Array} props The property names to project
		     * @param {Array} objs The objects to query
		     * @return {Array} An array of objects with just the `props` properties.
		     * @example
		     *
		     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
		     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
		     *      var kids = [abby, fred];
		     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
		     */
		    // passing `identity` gives correct arity
		    var project = useWith(_map, [
		        pickAll,
		        identity
		    ]);

		    /**
		     * Returns `true` if the specified object property is equal, in `R.equals`
		     * terms, to the given value; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig String -> a -> Object -> Boolean
		     * @param {String} name
		     * @param {*} val
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.equals, R.propSatisfies
		     * @example
		     *
		     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
		     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
		     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
		     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
		     *      var kids = [abby, fred, rusty, alois];
		     *      var hasBrownHair = R.propEq('hair', 'brown');
		     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
		     */
		    var propEq = _curry3(function propEq(name, val, obj) {
		        return propSatisfies(equals(val), name, obj);
		    });

		    /**
		     * Returns `true` if the specified object property is of the given type;
		     * `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Type
		     * @sig Type -> String -> Object -> Boolean
		     * @param {Function} type
		     * @param {String} name
		     * @param {*} obj
		     * @return {Boolean}
		     * @see R.is, R.propSatisfies
		     * @example
		     *
		     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
		     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
		     *      R.propIs(Number, 'x', {});            //=> false
		     */
		    var propIs = _curry3(function propIs(type, name, obj) {
		        return propSatisfies(is(type), name, obj);
		    });

		    /**
		     * Returns a single item by iterating through the list, successively calling
		     * the iterator function and passing it an accumulator value and the current
		     * value from the array, and then passing the result to the next call.
		     *
		     * The iterator function receives two values: *(acc, value)*. It may use
		     * `R.reduced` to shortcut the iteration.
		     *
		     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
		     * arrays), unlike the native `Array.prototype.reduce` method. For more details
		     * on this behavior, see:
		     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
		     *
		     * Dispatches to the `reduce` method of the third argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig ((a, b) -> a) -> a -> [b] -> a
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array.
		     * @param {*} acc The accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @see R.reduced, R.addIndex
		     * @example
		     *
		     *      var numbers = [1, 2, 3];
		     *      var add = (a, b) => a + b;
		     *
		     *      R.reduce(add, 10, numbers); //=> 16
		     */
		    var reduce = _curry3(_reduce);

		    /**
		     * The complement of `filter`.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig Filterable f => (a -> Boolean) -> f a -> f a
		     * @param {Function} pred
		     * @param {Array} filterable
		     * @return {Array}
		     * @see R.filter, R.transduce, R.addIndex
		     * @example
		     *
		     *      var isOdd = (n) => n % 2 === 1;
		     *
		     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
		     *
		     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
		     */
		    var reject = _curry2(function reject(pred, filterable) {
		        return filter(_complement(pred), filterable);
		    });

		    /**
		     * Returns a fixed list of size `n` containing a specified identical value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.1
		     * @category List
		     * @sig a -> n -> [a]
		     * @param {*} value The value to repeat.
		     * @param {Number} n The desired size of the output list.
		     * @return {Array} A new array containing `n` `value`s.
		     * @example
		     *
		     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
		     *
		     *      var obj = {};
		     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
		     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
		     */
		    var repeat = _curry2(function repeat(value, n) {
		        return times(always(value), n);
		    });

		    /**
		     * Adds together all the elements of a list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list An array of numbers
		     * @return {Number} The sum of all the numbers in the list.
		     * @see R.reduce
		     * @example
		     *
		     *      R.sum([2,4,6,8,100,1]); //=> 121
		     */
		    var sum = reduce(add, 0);

		    /**
		     * Returns a new list containing the last `n` elements of the given list.
		     * If `n > list.length`, returns a list of `list.length` elements.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig Number -> [a] -> [a]
		     * @sig Number -> String -> String
		     * @param {Number} n The number of elements to return.
		     * @param {Array} xs The collection to consider.
		     * @return {Array}
		     * @see R.dropLast
		     * @example
		     *
		     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
		     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
		     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
		     *      R.takeLast(3, 'ramda');               //=> 'mda'
		     */
		    var takeLast = _curry2(function takeLast(n, xs) {
		        return drop(n >= 0 ? xs.length - n : 0, xs);
		    });

		    /**
		     * Initializes a transducer using supplied iterator function. Returns a single
		     * item by iterating through the list, successively calling the transformed
		     * iterator function and passing it an accumulator value and the current value
		     * from the array, and then passing the result to the next call.
		     *
		     * The iterator function receives two values: *(acc, value)*. It will be
		     * wrapped as a transformer to initialize the transducer. A transformer can be
		     * passed directly in place of an iterator function. In both cases, iteration
		     * may be stopped early with the `R.reduced` function.
		     *
		     * A transducer is a function that accepts a transformer and returns a
		     * transformer and can be composed directly.
		     *
		     * A transformer is an an object that provides a 2-arity reducing iterator
		     * function, step, 0-arity initial value function, init, and 1-arity result
		     * extraction function, result. The step function is used as the iterator
		     * function in reduce. The result function is used to convert the final
		     * accumulator into the return type and in most cases is R.identity. The init
		     * function can be used to provide an initial accumulator, but is ignored by
		     * transduce.
		     *
		     * The iteration is performed with R.reduce after initializing the transducer.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category List
		     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
		     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
		     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
		     *        current element from the array. Wrapped as transformer, if necessary, and used to
		     *        initialize the transducer
		     * @param {*} acc The initial accumulator value.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @see R.reduce, R.reduced, R.into
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
		     *
		     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
		     */
		    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
		        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
		    });

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of the elements
		     * of each list. Duplication is determined according to the value returned by
		     * applying the supplied predicate to two list elements.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The first and second lists concatenated, with
		     *         duplicates removed.
		     * @see R.union
		     * @example
		     *
		     *      var l1 = [{a: 1}, {a: 2}];
		     *      var l2 = [{a: 1}, {a: 4}];
		     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
		     */
		    var unionWith = _curry3(function unionWith(pred, list1, list2) {
		        return uniqWith(pred, _concat(list1, list2));
		    });

		    /**
		     * Takes a spec object and a test object; returns true if the test satisfies
		     * the spec, false otherwise. An object satisfies the spec if, for each of the
		     * spec's own properties, accessing that property of the object gives the same
		     * value (in `R.equals` terms) as accessing that property of the spec.
		     *
		     * `whereEq` is a specialization of [`where`](#where).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Object
		     * @sig {String: *} -> {String: *} -> Boolean
		     * @param {Object} spec
		     * @param {Object} testObj
		     * @return {Boolean}
		     * @see R.where
		     * @example
		     *
		     *      // pred :: Object -> Boolean
		     *      var pred = R.whereEq({a: 1, b: 2});
		     *
		     *      pred({a: 1});              //=> false
		     *      pred({a: 1, b: 2});        //=> true
		     *      pred({a: 1, b: 2, c: 3});  //=> true
		     *      pred({a: 1, b: 1});        //=> false
		     */
		    var whereEq = _curry2(function whereEq(spec, testObj) {
		        return where(map(equals, spec), testObj);
		    });

		    var _flatCat = function () {
		        var preservingReduced = function (xf) {
		            return {
		                '@@transducer/init': _xfBase.init,
		                '@@transducer/result': function (result) {
		                    return xf['@@transducer/result'](result);
		                },
		                '@@transducer/step': function (result, input) {
		                    var ret = xf['@@transducer/step'](result, input);
		                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
		                }
		            };
		        };
		        return function _xcat(xf) {
		            var rxf = preservingReduced(xf);
		            return {
		                '@@transducer/init': _xfBase.init,
		                '@@transducer/result': function (result) {
		                    return rxf['@@transducer/result'](result);
		                },
		                '@@transducer/step': function (result, input) {
		                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
		                }
		            };
		        };
		    }();

		    // Array.prototype.indexOf doesn't exist below IE9
		    // manually crawl the list to distinguish between +0 and -0
		    // NaN
		    // non-zero numbers can utilise Set
		    // all these types can utilise Set
		    // null can utilise Set
		    // anything else not covered above, defer to R.equals
		    var _indexOf = function _indexOf(list, a, idx) {
		        var inf, item;
		        // Array.prototype.indexOf doesn't exist below IE9
		        if (typeof list.indexOf === 'function') {
		            switch (typeof a) {
		            case 'number':
		                if (a === 0) {
		                    // manually crawl the list to distinguish between +0 and -0
		                    inf = 1 / a;
		                    while (idx < list.length) {
		                        item = list[idx];
		                        if (item === 0 && 1 / item === inf) {
		                            return idx;
		                        }
		                        idx += 1;
		                    }
		                    return -1;
		                } else if (a !== a) {
		                    // NaN
		                    while (idx < list.length) {
		                        item = list[idx];
		                        if (typeof item === 'number' && item !== item) {
		                            return idx;
		                        }
		                        idx += 1;
		                    }
		                    return -1;
		                }
		                // non-zero numbers can utilise Set
		                return list.indexOf(a, idx);
		            // all these types can utilise Set
		            case 'string':
		            case 'boolean':
		            case 'function':
		            case 'undefined':
		                return list.indexOf(a, idx);
		            case 'object':
		                if (a === null) {
		                    // null can utilise Set
		                    return list.indexOf(a, idx);
		                }
		            }
		        }
		        // anything else not covered above, defer to R.equals
		        while (idx < list.length) {
		            if (equals(list[idx], a)) {
		                return idx;
		            }
		            idx += 1;
		        }
		        return -1;
		    };

		    var _xchain = _curry2(function _xchain(f, xf) {
		        return map(f, _flatCat(xf));
		    });

		    /**
		     * Takes a list of predicates and returns a predicate that returns true for a
		     * given list of arguments if every one of the provided predicates is satisfied
		     * by those arguments.
		     *
		     * The function returned is a curried function whose arity matches that of the
		     * highest-arity predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Logic
		     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
		     * @param {Array} preds
		     * @return {Function}
		     * @see R.anyPass
		     * @example
		     *
		     *      var isQueen = R.propEq('rank', 'Q');
		     *      var isSpade = R.propEq('suit', '♠︎');
		     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
		     *
		     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
		     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
		     */
		    var allPass = _curry1(function allPass(preds) {
		        return curryN(reduce(max, 0, pluck('length', preds)), function () {
		            var idx = 0;
		            var len = preds.length;
		            while (idx < len) {
		                if (!preds[idx].apply(this, arguments)) {
		                    return false;
		                }
		                idx += 1;
		            }
		            return true;
		        });
		    });

		    /**
		     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
		     * `false`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category List
		     * @sig [a] -> Boolean
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if all elements are unique, else `false`.
		     * @example
		     *
		     *      R.allUniq(['1', 1]); //=> true
		     *      R.allUniq([1, 1]);   //=> false
		     *      R.allUniq([[42], [42]]); //=> false
		     */
		    var allUniq = _curry1(function allUniq(list) {
		        var len = list.length;
		        var idx = 0;
		        while (idx < len) {
		            if (_indexOf(list, list[idx], idx + 1) >= 0) {
		                return false;
		            }
		            idx += 1;
		        }
		        return true;
		    });

		    /**
		     * Takes a list of predicates and returns a predicate that returns true for a
		     * given list of arguments if at least one of the provided predicates is
		     * satisfied by those arguments.
		     *
		     * The function returned is a curried function whose arity matches that of the
		     * highest-arity predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Logic
		     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
		     * @param {Array} preds
		     * @return {Function}
		     * @see R.allPass
		     * @example
		     *
		     *      var gte = R.anyPass([R.gt, R.equals]);
		     *
		     *      gte(3, 2); //=> true
		     *      gte(2, 2); //=> true
		     *      gte(2, 3); //=> false
		     */
		    var anyPass = _curry1(function anyPass(preds) {
		        return curryN(reduce(max, 0, pluck('length', preds)), function () {
		            var idx = 0;
		            var len = preds.length;
		            while (idx < len) {
		                if (preds[idx].apply(this, arguments)) {
		                    return true;
		                }
		                idx += 1;
		            }
		            return false;
		        });
		    });

		    /**
		     * ap applies a list of functions to a list of values.
		     *
		     * Dispatches to the `ap` method of the second argument, if present. Also
		     * treats functions as applicatives.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category Function
		     * @sig [f] -> [a] -> [f a]
		     * @param {Array} fns An array of functions
		     * @param {Array} vs An array of values
		     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
		     * @example
		     *
		     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
		     */
		    // else
		    var ap = _curry2(function ap(applicative, fn) {
		        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
		            return applicative.apply(this, arguments)(fn.apply(this, arguments));
		        }) : // else
		        _reduce(function (acc, f) {
		            return _concat(acc, map(f, fn));
		        }, [], applicative);
		    });

		    /**
		     * Returns the result of calling its first argument with the remaining
		     * arguments. This is occasionally useful as a converging function for
		     * `R.converge`: the left branch can produce a function while the right branch
		     * produces a value to be passed to that function as an argument.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category Function
		     * @sig (*... -> a),*... -> a
		     * @param {Function} fn The function to apply to the remaining arguments.
		     * @param {...*} args Any number of positional arguments.
		     * @return {*}
		     * @see R.apply
		     * @example
		     *
		     *      var indentN = R.pipe(R.times(R.always(' ')),
		     *                           R.join(''),
		     *                           R.replace(/^(?!$)/gm));
		     *
		     *      var format = R.converge(R.call, [
		     *                                  R.pipe(R.prop('indent'), indentN),
		     *                                  R.prop('value')
		     *                              ]);
		     *
		     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
		     */
		    var call = curry(function call(fn) {
		        return fn.apply(this, _slice(arguments, 1));
		    });

		    /**
		     * `chain` maps a function over a list and concatenates the results. `chain`
		     * is also known as `flatMap` in some libraries
		     *
		     * Dispatches to the `chain` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category List
		     * @sig (a -> [b]) -> [a] -> [b]
		     * @param {Function} fn
		     * @param {Array} list
		     * @return {Array}
		     * @example
		     *
		     *      var duplicate = n => [n, n];
		     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
		     */
		    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
		        if (typeof monad === 'function') {
		            return function () {
		                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
		            };
		        }
		        return _makeFlat(false)(map(fn, monad));
		    }));

		    /**
		     * Turns a list of Functors into a Functor of a list, applying a mapping
		     * function to the elements of the list along the way.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category List
		     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]
		     * @param {Function} fn The transformation function
		     * @param {Function} of A function that returns the data type to return
		     * @param {Array} list An array of functors of the same type
		     * @return {*}
		     * @see R.traverse
		     * @deprecated since v0.19.0
		     * @example
		     *
		     *      var add10 = R.map(R.add(10));
		     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
		     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
		     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
		     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
		     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     *
		     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));
		     *      R.commuteMap(fetch, Future.of, [
		     *        'http://ramdajs.com',
		     *        'http://github.com/ramda'
		     *      ]); //=> Future([IncomingMessage, IncomingMessage])
		     */
		    var commuteMap = _curry3(function commuteMap(fn, of, list) {
		        function consF(acc, x) {
		            return ap(map(prepend, fn(x)), acc);
		        }
		        return reduceRight(consF, of([]), list);
		    });

		    /**
		     * Wraps a constructor function inside a curried function that can be called
		     * with the same arguments and returns the same type. The arity of the function
		     * returned is specified to allow using variadic constructor functions.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.4.0
		     * @category Function
		     * @sig Number -> (* -> {*}) -> (* -> {*})
		     * @param {Number} n The arity of the constructor function.
		     * @param {Function} Fn The constructor function to wrap.
		     * @return {Function} A wrapped, curried constructor function.
		     * @example
		     *
		     *      // Variadic constructor function
		     *      var Widget = () => {
		     *        this.children = Array.prototype.slice.call(arguments);
		     *        // ...
		     *      };
		     *      Widget.prototype = {
		     *        // ...
		     *      };
		     *      var allConfigs = [
		     *        // ...
		     *      ];
		     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
		     */
		    var constructN = _curry2(function constructN(n, Fn) {
		        if (n > 10) {
		            throw new Error('Constructor with greater than ten arguments');
		        }
		        if (n === 0) {
		            return function () {
		                return new Fn();
		            };
		        }
		        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
		            switch (arguments.length) {
		            case 1:
		                return new Fn($0);
		            case 2:
		                return new Fn($0, $1);
		            case 3:
		                return new Fn($0, $1, $2);
		            case 4:
		                return new Fn($0, $1, $2, $3);
		            case 5:
		                return new Fn($0, $1, $2, $3, $4);
		            case 6:
		                return new Fn($0, $1, $2, $3, $4, $5);
		            case 7:
		                return new Fn($0, $1, $2, $3, $4, $5, $6);
		            case 8:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
		            case 9:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
		            case 10:
		                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
		            }
		        }));
		    });

		    /**
		     * Accepts a converging function and a list of branching functions and returns
		     * a new function. When invoked, this new function is applied to some
		     * arguments, each branching function is applied to those same arguments. The
		     * results of each branching function are passed as arguments to the converging
		     * function to produce the return value.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.4.2
		     * @category Function
		     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
		     * @param {Function} after A function. `after` will be invoked with the return values of
		     *        `fn1` and `fn2` as its arguments.
		     * @param {Array} functions A list of functions.
		     * @return {Function} A new function.
		     * @example
		     *
		     *      var add = (a, b) => a + b;
		     *      var multiply = (a, b) => a * b;
		     *      var subtract = (a, b) => a - b;
		     *
		     *      //≅ multiply( add(1, 2), subtract(1, 2) );
		     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
		     *
		     *      var add3 = (a, b, c) => a + b + c;
		     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
		     */
		    var converge = _curry2(function converge(after, fns) {
		        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
		            var args = arguments;
		            var context = this;
		            return after.apply(context, _map(function (fn) {
		                return fn.apply(context, args);
		            }, fns));
		        });
		    });

		    /**
		     * Returns a new list without any consecutively repeating elements. Equality is
		     * determined by applying the supplied predicate two consecutive elements. The
		     * first element in a series of equal element is the one being preserved.
		     *
		     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category List
		     * @sig (a, a -> Boolean) -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list The array to consider.
		     * @return {Array} `list` without repeating elements.
		     * @see R.transduce
		     * @example
		     *
		     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);
		     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
		     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
		     */
		    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
		        var result = [];
		        var idx = 1;
		        var len = list.length;
		        if (len !== 0) {
		            result[0] = list[0];
		            while (idx < len) {
		                if (!pred(last(result), list[idx])) {
		                    result[result.length] = list[idx];
		                }
		                idx += 1;
		            }
		        }
		        return result;
		    }));

		    /**
		     * Takes a function and two values in its domain and returns `true` if the
		     * values map to the same value in the codomain; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.18.0
		     * @category Relation
		     * @sig (a -> b) -> a -> a -> Boolean
		     * @param {Function} f
		     * @param {*} x
		     * @param {*} y
		     * @return {Boolean}
		     * @example
		     *
		     *      R.eqBy(Math.abs, 5, -5); //=> true
		     */
		    var eqBy = _curry3(function eqBy(f, x, y) {
		        return equals(f(x), f(y));
		    });

		    /**
		     * Reports whether two objects have the same value, in `R.equals` terms, for
		     * the specified property. Useful as a curried predicate.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig k -> {k: v} -> {k: v} -> Boolean
		     * @param {String} prop The name of the property to compare
		     * @param {Object} obj1
		     * @param {Object} obj2
		     * @return {Boolean}
		     *
		     * @example
		     *
		     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
		     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
		     *      R.eqProps('a', o1, o2); //=> false
		     *      R.eqProps('c', o1, o2); //=> true
		     */
		    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
		        return equals(obj1[prop], obj2[prop]);
		    });

		    /**
		     * Returns the position of the first occurrence of an item in an array, or -1
		     * if the item is not included in the array. `R.equals` is used to determine
		     * equality.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig a -> [a] -> Number
		     * @param {*} target The item to find.
		     * @param {Array} xs The array to search in.
		     * @return {Number} the index of the target, or -1 if the target is not found.
		     * @see R.lastIndexOf
		     * @example
		     *
		     *      R.indexOf(3, [1,2,3,4]); //=> 2
		     *      R.indexOf(10, [1,2,3,4]); //=> -1
		     */
		    var indexOf = _curry2(function indexOf(target, xs) {
		        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
		    });

		    /**
		     * juxt applies a list of functions to a list of values.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Function
		     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
		     * @param {Array} fns An array of functions
		     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
		     * @example
		     *
		     *      var range = R.juxt([Math.min, Math.max]);
		     *      range(3, 4, 9, -3); //=> [-3, 9]
		     */
		    var juxt = _curry1(function juxt(fns) {
		        return function () {
		            return map(apply(__, arguments), fns);
		        };
		    });

		    /**
		     * Returns a lens for the given getter and setter functions. The getter "gets"
		     * the value of the focus; the setter "sets" the value of the focus. The setter
		     * should not mutate the data structure.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
		     * @param {Function} getter
		     * @param {Function} setter
		     * @return {Lens}
		     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
		     * @example
		     *
		     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
		     *
		     *      R.view(xLens, {x: 1, y: 2});            //=> 1
		     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
		     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
		     */
		    var lens = _curry2(function lens(getter, setter) {
		        return function (f) {
		            return function (s) {
		                return map(function (v) {
		                    return setter(v, s);
		                }, f(getter(s)));
		            };
		        };
		    });

		    /**
		     * Returns a lens whose focus is the specified index.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig Number -> Lens s a
		     * @param {Number} n
		     * @return {Lens}
		     * @see R.view, R.set, R.over
		     * @example
		     *
		     *      var headLens = R.lensIndex(0);
		     *
		     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
		     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
		     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
		     */
		    var lensIndex = _curry1(function lensIndex(n) {
		        return lens(nth(n), update(n));
		    });

		    /**
		     * Returns a lens whose focus is the specified path.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig [String] -> Lens s a
		     * @param {Array} path The path to use.
		     * @return {Lens}
		     * @see R.view, R.set, R.over
		     * @example
		     *
		     *      var xyLens = R.lensPath(['x', 'y']);
		     *
		     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
		     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
		     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
		     */
		    var lensPath = _curry1(function lensPath(p) {
		        return lens(path(p), assocPath(p));
		    });

		    /**
		     * Returns a lens whose focus is the specified property.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Object
		     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
		     * @sig String -> Lens s a
		     * @param {String} k
		     * @return {Lens}
		     * @see R.view, R.set, R.over
		     * @example
		     *
		     *      var xLens = R.lensProp('x');
		     *
		     *      R.view(xLens, {x: 1, y: 2});            //=> 1
		     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
		     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
		     */
		    var lensProp = _curry1(function lensProp(k) {
		        return lens(prop(k), assoc(k));
		    });

		    /**
		     * "lifts" a function to be the specified arity, so that it may "map over" that
		     * many lists (or other objects that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply)).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Function
		     * @sig Number -> (*... -> *) -> ([*]... -> [*])
		     * @param {Function} fn The function to lift into higher context
		     * @return {Function} The lifted function.
		     * @see R.lift
		     * @example
		     *
		     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
		     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
		     */
		    var liftN = _curry2(function liftN(arity, fn) {
		        var lifted = curryN(arity, fn);
		        return curryN(arity, function () {
		            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
		        });
		    });

		    /**
		     * Returns the mean of the given list of numbers.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list
		     * @return {Number}
		     * @example
		     *
		     *      R.mean([2, 7, 9]); //=> 6
		     *      R.mean([]); //=> NaN
		     */
		    var mean = _curry1(function mean(list) {
		        return sum(list) / list.length;
		    });

		    /**
		     * Returns the median of the given list of numbers.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list
		     * @return {Number}
		     * @example
		     *
		     *      R.median([2, 9, 7]); //=> 7
		     *      R.median([7, 2, 10, 9]); //=> 8
		     *      R.median([]); //=> NaN
		     */
		    var median = _curry1(function median(list) {
		        var len = list.length;
		        if (len === 0) {
		            return NaN;
		        }
		        var width = 2 - len % 2;
		        var idx = (len - width) / 2;
		        return mean(_slice(list).sort(function (a, b) {
		            return a < b ? -1 : a > b ? 1 : 0;
		        }).slice(idx, idx + width));
		    });

		    /**
		     * Create a new object with the own properties of the first object merged with
		     * the own properties of the second object. If a key exists in both objects,
		     * the value from the second object will be used.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig {k: v} -> {k: v} -> {k: v}
		     * @param {Object} l
		     * @param {Object} r
		     * @return {Object}
		     * @see R.mergeWith, R.mergeWithKey
		     * @example
		     *
		     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
		     *      //=> { 'name': 'fred', 'age': 40 }
		     *
		     *      var resetToDefault = R.merge(R.__, {x: 0});
		     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
		     */
		    var merge = mergeWith(function (l, r) {
		        return r;
		    });

		    /**
		     * Merges a list of objects together into one object.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category List
		     * @sig [{k: v}] -> {k: v}
		     * @param {Array} list An array of objects
		     * @return {Object} A merged object.
		     * @see R.reduce
		     * @example
		     *
		     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
		     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
		     */
		    var mergeAll = _curry1(function mergeAll(list) {
		        return reduce(merge, {}, list);
		    });

		    /**
		     * Performs left-to-right function composition. The leftmost function may have
		     * any arity; the remaining functions must be unary.
		     *
		     * In some libraries this function is named `sequence`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.compose
		     * @example
		     *
		     *      var f = R.pipe(Math.pow, R.negate, R.inc);
		     *
		     *      f(3, 4); // -(3^4) + 1
		     */
		    var pipe = function pipe() {
		        if (arguments.length === 0) {
		            throw new Error('pipe requires at least one argument');
		        }
		        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
		    };

		    /**
		     * Performs left-to-right composition of one or more Promise-returning
		     * functions. The leftmost function may have any arity; the remaining functions
		     * must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Function
		     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.composeP
		     * @example
		     *
		     *      //  followersForUser :: String -> Promise [User]
		     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
		     */
		    var pipeP = function pipeP() {
		        if (arguments.length === 0) {
		            throw new Error('pipeP requires at least one argument');
		        }
		        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
		    };

		    /**
		     * Multiplies together all the elements of a list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Math
		     * @sig [Number] -> Number
		     * @param {Array} list An array of numbers
		     * @return {Number} The product of all the numbers in the list.
		     * @see R.reduce
		     * @example
		     *
		     *      R.product([2,4,6,8,100,1]); //=> 38400
		     */
		    var product = reduce(multiply, 1);

		    /**
		     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
		     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
		     * Applicative of Traversable.
		     *
		     * Dispatches to the `sequence` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
		     * @param {Function} of
		     * @param {*} traversable
		     * @return {*}
		     * @see R.traverse
		     * @example
		     *
		     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
		     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     *
		     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
		     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
		     */
		    var sequence = _curry2(function sequence(of, traversable) {
		        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
		            return ap(map(prepend, x), acc);
		        }, of([]), traversable);
		    });

		    /**
		     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
		     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
		     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
		     * into an Applicative of Traversable.
		     *
		     * Dispatches to the `sequence` method of the third argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
		     * @param {Function} of
		     * @param {Function} f
		     * @param {*} traversable
		     * @return {*}
		     * @see R.sequence
		     * @example
		     *
		     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Just(3)]);   //=> Just([-1, -2, -3])
		     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     *
		     *      R.traverse(R.of, R.negate, Just([1, 2, 3])); //=> [Just(-1), Just(-2), Just(-3)]
		     *      R.traverse(R.of, R.negate, Nothing());       //=> [Nothing()]
		     */
		    var traverse = _curry3(function traverse(of, f, traversable) {
		        return sequence(of, map(f, traversable));
		    });

		    /**
		     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
		     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.3.0
		     * @category List
		     * @sig Chain c => c (c a) -> c a
		     * @param {*} list
		     * @return {*}
		     * @see R.flatten, R.chain
		     * @example
		     *
		     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
		     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
		     */
		    var unnest = chain(_identity);

		    var _contains = function _contains(a, list) {
		        return _indexOf(list, a, 0) >= 0;
		    };

		    var _stepCat = function () {
		        var _stepCatArray = {
		            '@@transducer/init': Array,
		            '@@transducer/step': function (xs, x) {
		                return _concat(xs, [x]);
		            },
		            '@@transducer/result': _identity
		        };
		        var _stepCatString = {
		            '@@transducer/init': String,
		            '@@transducer/step': function (a, b) {
		                return a + b;
		            },
		            '@@transducer/result': _identity
		        };
		        var _stepCatObject = {
		            '@@transducer/init': Object,
		            '@@transducer/step': function (result, input) {
		                return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
		            },
		            '@@transducer/result': _identity
		        };
		        return function _stepCat(obj) {
		            if (_isTransformer(obj)) {
		                return obj;
		            }
		            if (isArrayLike(obj)) {
		                return _stepCatArray;
		            }
		            if (typeof obj === 'string') {
		                return _stepCatString;
		            }
		            if (typeof obj === 'object') {
		                return _stepCatObject;
		            }
		            throw new Error('Cannot create transformer for ' + obj);
		        };
		    }();

		    //  mapPairs :: (Object, [String]) -> [String]
		    var _toString = function _toString(x, seen) {
		        var recur = function recur(y) {
		            var xs = seen.concat([x]);
		            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
		        };
		        //  mapPairs :: (Object, [String]) -> [String]
		        var mapPairs = function (obj, keys) {
		            return _map(function (k) {
		                return _quote(k) + ': ' + recur(obj[k]);
		            }, keys.slice().sort());
		        };
		        switch (Object.prototype.toString.call(x)) {
		        case '[object Arguments]':
		            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
		        case '[object Array]':
		            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
		                return /^\d+$/.test(k);
		            }, keys(x)))).join(', ') + ']';
		        case '[object Boolean]':
		            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
		        case '[object Date]':
		            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
		        case '[object Null]':
		            return 'null';
		        case '[object Number]':
		            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
		        case '[object String]':
		            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
		        case '[object Undefined]':
		            return 'undefined';
		        default:
		            if (typeof x.toString === 'function') {
		                var repr = x.toString();
		                if (repr !== '[object Object]') {
		                    return repr;
		                }
		            }
		            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
		        }
		    };

		    /**
		     * Turns a list of Functors into a Functor of a list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.8.0
		     * @category List
		     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
		     * @param {Function} of A function that returns the data type to return
		     * @param {Array} list An array of functors of the same type
		     * @return {*}
		     * @see R.sequence
		     * @deprecated since v0.19.0
		     * @example
		     *
		     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
		     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
		     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
		     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
		     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
		     */
		    var commute = commuteMap(identity);

		    /**
		     * Performs right-to-left function composition. The rightmost function may have
		     * any arity; the remaining functions must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.pipe
		     * @example
		     *
		     *      var f = R.compose(R.inc, R.negate, Math.pow);
		     *
		     *      f(3, 4); // -(3^4) + 1
		     */
		    var compose = function compose() {
		        if (arguments.length === 0) {
		            throw new Error('compose requires at least one argument');
		        }
		        return pipe.apply(this, reverse(arguments));
		    };

		    /**
		     * Returns the right-to-left Kleisli composition of the provided functions,
		     * each of which must return a value of a type supported by [`chain`](#chain).
		     *
		     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Function
		     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
		     * @param {...Function}
		     * @return {Function}
		     * @see R.pipeK
		     * @example
		     *
		     *      //  parseJson :: String -> Maybe *
		     *      //  get :: String -> Object -> Maybe *
		     *
		     *      //  getStateCode :: Maybe String -> Maybe String
		     *      var getStateCode = R.composeK(
		     *        R.compose(Maybe.of, R.toUpper),
		     *        get('state'),
		     *        get('address'),
		     *        get('user'),
		     *        parseJson
		     *      );
		     *
		     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
		     *      //=> Just('NY')
		     *      getStateCode(Maybe.of('[Invalid JSON]'));
		     *      //=> Nothing()
		     */
		    var composeK = function composeK() {
		        return compose.apply(this, prepend(identity, map(chain, arguments)));
		    };

		    /**
		     * Performs right-to-left composition of one or more Promise-returning
		     * functions. The rightmost function may have any arity; the remaining
		     * functions must be unary.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.10.0
		     * @category Function
		     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
		     * @param {...Function} functions
		     * @return {Function}
		     * @see R.pipeP
		     * @example
		     *
		     *      //  followersForUser :: String -> Promise [User]
		     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
		     */
		    var composeP = function composeP() {
		        if (arguments.length === 0) {
		            throw new Error('composeP requires at least one argument');
		        }
		        return pipeP.apply(this, reverse(arguments));
		    };

		    /**
		     * Wraps a constructor function inside a curried function that can be called
		     * with the same arguments and returns the same type.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (* -> {*}) -> (* -> {*})
		     * @param {Function} Fn The constructor function to wrap.
		     * @return {Function} A wrapped, curried constructor function.
		     * @example
		     *
		     *      // Constructor function
		     *      var Widget = config => {
		     *        // ...
		     *      };
		     *      Widget.prototype = {
		     *        // ...
		     *      };
		     *      var allConfigs = [
		     *        // ...
		     *      ];
		     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
		     */
		    var construct = _curry1(function construct(Fn) {
		        return constructN(Fn.length, Fn);
		    });

		    /**
		     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
		     * least one element of the given list; `false` otherwise.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig a -> [a] -> Boolean
		     * @param {Object} a The item to compare against.
		     * @param {Array} list The array to consider.
		     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
		     * @see R.any
		     * @example
		     *
		     *      R.contains(3, [1, 2, 3]); //=> true
		     *      R.contains(4, [1, 2, 3]); //=> false
		     *      R.contains([42], [[42]]); //=> true
		     */
		    var contains = _curry2(_contains);

		    /**
		     * Finds the set (i.e. no duplicates) of all elements in the first list not
		     * contained in the second list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig [*] -> [*] -> [*]
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The elements in `list1` that are not in `list2`.
		     * @see R.differenceWith
		     * @example
		     *
		     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
		     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
		     */
		    var difference = _curry2(function difference(first, second) {
		        var out = [];
		        var idx = 0;
		        var firstLen = first.length;
		        while (idx < firstLen) {
		            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
		                out[out.length] = first[idx];
		            }
		            idx += 1;
		        }
		        return out;
		    });

		    /**
		     * Returns a new list without any consecutively repeating elements. `R.equals`
		     * is used to determine equality.
		     *
		     * Dispatches to the `dropRepeats` method of the first argument, if present.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category List
		     * @sig [a] -> [a]
		     * @param {Array} list The array to consider.
		     * @return {Array} `list` without repeating elements.
		     * @see R.transduce
		     * @example
		     *
		     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
		     */
		    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

		    /**
		     * Transforms the items of the list with the transducer and appends the
		     * transformed items to the accumulator using an appropriate iterator function
		     * based on the accumulator type.
		     *
		     * The accumulator can be an array, string, object or a transformer. Iterated
		     * items will be appended to arrays and concatenated to strings. Objects will
		     * be merged directly or 2-item arrays will be merged as key, value pairs.
		     *
		     * The accumulator can also be a transformer object that provides a 2-arity
		     * reducing iterator function, step, 0-arity initial value function, init, and
		     * 1-arity result extraction function result. The step function is used as the
		     * iterator function in reduce. The result function is used to convert the
		     * final accumulator into the return type and in most cases is R.identity. The
		     * init function is used to provide the initial accumulator.
		     *
		     * The iteration is performed with R.reduce after initializing the transducer.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category List
		     * @sig a -> (b -> b) -> [c] -> a
		     * @param {*} acc The initial accumulator value.
		     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
		     * @param {Array} list The list to iterate over.
		     * @return {*} The final, accumulated value.
		     * @example
		     *
		     *      var numbers = [1, 2, 3, 4];
		     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
		     *
		     *      R.into([], transducer, numbers); //=> [2, 3]
		     *
		     *      var intoArray = R.into([]);
		     *      intoArray(transducer, numbers); //=> [2, 3]
		     */
		    var into = _curry3(function into(acc, xf, list) {
		        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
		    });

		    /**
		     * "lifts" a function of arity > 1 so that it may "map over" an Array or other
		     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
		     *
		     * @func
		     * @memberOf R
		     * @since v0.7.0
		     * @category Function
		     * @sig (*... -> *) -> ([*]... -> [*])
		     * @param {Function} fn The function to lift into higher context
		     * @return {Function} The lifted function.
		     * @see R.liftN
		     * @example
		     *
		     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
		     *
		     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
		     *
		     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
		     *
		     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
		     */
		    var lift = _curry1(function lift(fn) {
		        return liftN(fn.length, fn);
		    });

		    /**
		     * Returns a partial copy of an object omitting the keys specified.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Object
		     * @sig [String] -> {String: *} -> {String: *}
		     * @param {Array} names an array of String property names to omit from the new object
		     * @param {Object} obj The object to copy from
		     * @return {Object} A new object with properties from `names` not on it.
		     * @see R.pick
		     * @example
		     *
		     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
		     */
		    var omit = _curry2(function omit(names, obj) {
		        var result = {};
		        for (var prop in obj) {
		            if (!_contains(prop, names)) {
		                result[prop] = obj[prop];
		            }
		        }
		        return result;
		    });

		    /**
		     * Returns the left-to-right Kleisli composition of the provided functions,
		     * each of which must return a value of a type supported by [`chain`](#chain).
		     *
		     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category Function
		     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
		     * @param {...Function}
		     * @return {Function}
		     * @see R.composeK
		     * @example
		     *
		     *      //  parseJson :: String -> Maybe *
		     *      //  get :: String -> Object -> Maybe *
		     *
		     *      //  getStateCode :: Maybe String -> Maybe String
		     *      var getStateCode = R.pipeK(
		     *        parseJson,
		     *        get('user'),
		     *        get('address'),
		     *        get('state'),
		     *        R.compose(Maybe.of, R.toUpper)
		     *      );
		     *
		     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
		     *      //=> Just('NY')
		     *      getStateCode(Maybe.of('[Invalid JSON]'));
		     *      //=> Nothing()
		     */
		    var pipeK = function pipeK() {
		        return composeK.apply(this, reverse(arguments));
		    };

		    /**
		     * Returns the string representation of the given value. `eval`'ing the output
		     * should result in a value equivalent to the input value. Many of the built-in
		     * `toString` methods do not satisfy this requirement.
		     *
		     * If the given value is an `[object Object]` with a `toString` method other
		     * than `Object.prototype.toString`, this method is invoked with no arguments
		     * to produce the return value. This means user-defined constructor functions
		     * can provide a suitable `toString` method. For example:
		     *
		     *     function Point(x, y) {
		     *       this.x = x;
		     *       this.y = y;
		     *     }
		     *
		     *     Point.prototype.toString = function() {
		     *       return 'new Point(' + this.x + ', ' + this.y + ')';
		     *     };
		     *
		     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
		     *
		     * @func
		     * @memberOf R
		     * @since v0.14.0
		     * @category String
		     * @sig * -> String
		     * @param {*} val
		     * @return {String}
		     * @example
		     *
		     *      R.toString(42); //=> '42'
		     *      R.toString('abc'); //=> '"abc"'
		     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
		     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
		     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
		     */
		    var toString = _curry1(function toString(val) {
		        return _toString(val, []);
		    });

		    /**
		     * Returns a new list containing only one copy of each element in the original
		     * list, based upon the value returned by applying the supplied function to
		     * each list element. Prefers the first item if the supplied function produces
		     * the same value on two items. `R.equals` is used for comparison.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.16.0
		     * @category List
		     * @sig (a -> b) -> [a] -> [a]
		     * @param {Function} fn A function used to produce a value to use during comparisons.
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
		     */
		    /* globals Set */
		    // distinguishing between +0 and -0 is not supported by Set
		    /* falls through */
		    // these types can all utilise Set
		    // prevent scan for null by tracking as a boolean
		    /* falls through */
		    // scan through all previously applied items
		    var uniqBy = _curry2(/* globals Set */
		    typeof Set === 'undefined' ? function uniqBy(fn, list) {
		        var idx = 0;
		        var applied = [];
		        var result = [];
		        var appliedItem, item;
		        while (idx < list.length) {
		            item = list[idx];
		            appliedItem = fn(item);
		            if (!_contains(appliedItem, applied)) {
		                result.push(item);
		                applied.push(appliedItem);
		            }
		            idx += 1;
		        }
		        return result;
		    } : function uniqBySet(fn, list) {
		        var set = new Set();
		        var applied = [];
		        var prevSetSize = 0;
		        var result = [];
		        var nullExists = false;
		        var negZeroExists = false;
		        var idx = 0;
		        var appliedItem, item, newSetSize;
		        while (idx < list.length) {
		            item = list[idx];
		            appliedItem = fn(item);
		            switch (typeof appliedItem) {
		            case 'number':
		                // distinguishing between +0 and -0 is not supported by Set
		                if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {
		                    negZeroExists = true;
		                    result.push(item);
		                    break;
		                }
		            /* falls through */
		            case 'string':
		            case 'boolean':
		            case 'function':
		            case 'undefined':
		                // these types can all utilise Set
		                set.add(appliedItem);
		                newSetSize = set.size;
		                if (newSetSize > prevSetSize) {
		                    result.push(item);
		                    prevSetSize = newSetSize;
		                }
		                break;
		            case 'object':
		                if (appliedItem === null) {
		                    if (!nullExists) {
		                        // prevent scan for null by tracking as a boolean
		                        nullExists = true;
		                        result.push(null);
		                    }
		                    break;
		                }
		            /* falls through */
		            default:
		                // scan through all previously applied items
		                if (!_contains(appliedItem, applied)) {
		                    applied.push(appliedItem);
		                    result.push(item);
		                }
		            }
		            idx += 1;
		        }
		        return result;
		    });

		    /**
		     * Returns a new list without values in the first argument.
		     * `R.equals` is used to determine equality.
		     *
		     * Acts as a transducer if a transformer is given in list position.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category List
		     * @sig [a] -> [a] -> [a]
		     * @param {Array} list1 The values to be removed from `list2`.
		     * @param {Array} list2 The array to remove values from.
		     * @return {Array} The new array without values in `list1`.
		     * @see R.transduce
		     * @example
		     *
		     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
		     */
		    var without = _curry2(function (xs, list) {
		        return reject(flip(_contains)(xs), list);
		    });

		    /**
		     * Takes a function `f` and returns a function `g` such that:
		     *
		     *   - applying `g` to zero or more arguments will give __true__ if applying
		     *     the same arguments to `f` gives a logical __false__ value; and
		     *
		     *   - applying `g` to zero or more arguments will give __false__ if applying
		     *     the same arguments to `f` gives a logical __true__ value.
		     *
		     * `R.complement` will work on all other functors as well.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category Logic
		     * @sig (*... -> *) -> (*... -> Boolean)
		     * @param {Function} f
		     * @return {Function}
		     * @see R.not
		     * @example
		     *
		     *      var isEven = n => n % 2 === 0;
		     *      var isOdd = R.complement(isEven);
		     *      isOdd(21); //=> true
		     *      isOdd(42); //=> false
		     */
		    var complement = lift(not);

		    /**
		     * Turns a named method with a specified arity into a function that can be
		     * called directly supplied with arguments and a target object.
		     *
		     * The returned function is curried and accepts `arity + 1` parameters where
		     * the final parameter is the target object.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
		     * @param {Number} arity Number of arguments the returned function should take
		     *        before the target object.
		     * @param {String} method Name of the method to call.
		     * @return {Function} A new curried function.
		     * @example
		     *
		     *      var sliceFrom = R.invoker(1, 'slice');
		     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
		     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
		     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
		     */
		    var invoker = _curry2(function invoker(arity, method) {
		        return curryN(arity + 1, function () {
		            var target = arguments[arity];
		            if (target != null && is(Function, target[method])) {
		                return target[method].apply(target, _slice(arguments, 0, arity));
		            }
		            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
		        });
		    });

		    /**
		     * Returns a string made by inserting the `separator` between each element and
		     * concatenating all the elements into a single string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig String -> [a] -> String
		     * @param {Number|String} separator The string used to separate the elements.
		     * @param {Array} xs The elements to join into a string.
		     * @return {String} str The string made by concatenating `xs` with `separator`.
		     * @see R.split
		     * @example
		     *
		     *      var spacer = R.join(' ');
		     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
		     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
		     */
		    var join = invoker(1, 'join');

		    /**
		     * Creates a new function that, when invoked, caches the result of calling `fn`
		     * for a given argument set and returns the result. Subsequent calls to the
		     * memoized `fn` with the same argument set will not result in an additional
		     * call to `fn`; instead, the cached result for that set of arguments will be
		     * returned.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Function
		     * @sig (*... -> a) -> (*... -> a)
		     * @param {Function} fn The function to memoize.
		     * @return {Function} Memoized version of `fn`.
		     * @example
		     *
		     *      var count = 0;
		     *      var factorial = R.memoize(n => {
		     *        count += 1;
		     *        return R.product(R.range(1, n + 1));
		     *      });
		     *      factorial(5); //=> 120
		     *      factorial(5); //=> 120
		     *      factorial(5); //=> 120
		     *      count; //=> 1
		     */
		    var memoize = _curry1(function memoize(fn) {
		        var cache = {};
		        return _arity(fn.length, function () {
		            var key = toString(arguments);
		            if (!_has(key, cache)) {
		                cache[key] = fn.apply(this, arguments);
		            }
		            return cache[key];
		        });
		    });

		    /**
		     * Splits a string into an array of strings based on the given
		     * separator.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category String
		     * @sig (String | RegExp) -> String -> [String]
		     * @param {String|RegExp} sep The pattern.
		     * @param {String} str The string to separate into an array.
		     * @return {Array} The array of strings from `str` separated by `str`.
		     * @see R.join
		     * @example
		     *
		     *      var pathComponents = R.split('/');
		     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
		     *
		     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
		     */
		    var split = invoker(1, 'split');

		    /**
		     * Determines whether a given string matches a given regular expression.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.12.0
		     * @category String
		     * @sig RegExp -> String -> Boolean
		     * @param {RegExp} pattern
		     * @param {String} str
		     * @return {Boolean}
		     * @see R.match
		     * @example
		     *
		     *      R.test(/^x/, 'xyz'); //=> true
		     *      R.test(/^y/, 'xyz'); //=> false
		     */
		    var test = _curry2(function test(pattern, str) {
		        if (!_isRegExp(pattern)) {
		            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
		        }
		        return _cloneRegExp(pattern).test(str);
		    });

		    /**
		     * The lower case version of a string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to lower case.
		     * @return {String} The lower case version of `str`.
		     * @see R.toUpper
		     * @example
		     *
		     *      R.toLower('XYZ'); //=> 'xyz'
		     */
		    var toLower = invoker(0, 'toLowerCase');

		    /**
		     * The upper case version of a string.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.9.0
		     * @category String
		     * @sig String -> String
		     * @param {String} str The string to upper case.
		     * @return {String} The upper case version of `str`.
		     * @see R.toLower
		     * @example
		     *
		     *      R.toUpper('abc'); //=> 'ABC'
		     */
		    var toUpper = invoker(0, 'toUpperCase');

		    /**
		     * Returns a new list containing only one copy of each element in the original
		     * list. `R.equals` is used to determine equality.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [a]
		     * @param {Array} list The array to consider.
		     * @return {Array} The list of unique items.
		     * @example
		     *
		     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
		     *      R.uniq([1, '1']);     //=> [1, '1']
		     *      R.uniq([[42], [42]]); //=> [[42]]
		     */
		    var uniq = uniqBy(identity);

		    /**
		     * Returns the result of concatenating the given lists or strings.
		     *
		     * Dispatches to the `concat` method of the second argument, if present.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category List
		     * @sig [a] -> [a] -> [a]
		     * @sig String -> String -> String
		     * @param {Array|String} a
		     * @param {Array|String} b
		     * @return {Array|String}
		     *
		     * @example
		     *
		     *      R.concat([], []); //=> []
		     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
		     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
		     */
		    var concat = flip(invoker(1, 'concat'));

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of those
		     * elements common to both lists.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig [*] -> [*] -> [*]
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The list of elements found in both `list1` and `list2`.
		     * @see R.intersectionWith
		     * @example
		     *
		     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
		     */
		    var intersection = _curry2(function intersection(list1, list2) {
		        return uniq(_filter(flip(_contains)(list1), list2));
		    });

		    /**
		     * Finds the set (i.e. no duplicates) of all elements contained in the first or
		     * second list, but not both.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Relation
		     * @sig [*] -> [*] -> [*]
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The elements in `list1` or `list2`, but not both.
		     * @see R.symmetricDifferenceWith
		     * @example
		     *
		     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
		     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
		     */
		    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
		        return concat(difference(list1, list2), difference(list2, list1));
		    });

		    /**
		     * Finds the set (i.e. no duplicates) of all elements contained in the first or
		     * second list, but not both. Duplication is determined according to the value
		     * returned by applying the supplied predicate to two list elements.
		     *
		     * @func
		     * @memberOf R
		     * @since 0.19.1
		     * @since 0.19.0
		     * @category Relation
		     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
		     * @param {Function} pred A predicate used to test whether two items are equal.
		     * @param {Array} list1 The first list.
		     * @param {Array} list2 The second list.
		     * @return {Array} The elements in `list1` or `list2`, but not both.
		     * @see R.symmetricDifference
		     * @example
		     *
		     *      var eqA = R.eqBy(R.prop('a'));
		     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
		     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
		     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
		     */
		    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
		        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
		    });

		    /**
		     * Combines two lists into a set (i.e. no duplicates) composed of the elements
		     * of each list.
		     *
		     * @func
		     * @memberOf R
		     * @since v0.1.0
		     * @category Relation
		     * @sig [*] -> [*] -> [*]
		     * @param {Array} as The first list.
		     * @param {Array} bs The second list.
		     * @return {Array} The first and second lists concatenated, with
		     *         duplicates removed.
		     * @example
		     *
		     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
		     */
		    var union = _curry2(compose(uniq, _concat));

		    var R = {
		        F: F,
		        T: T,
		        __: __,
		        add: add,
		        addIndex: addIndex,
		        adjust: adjust,
		        all: all,
		        allPass: allPass,
		        allUniq: allUniq,
		        always: always,
		        and: and,
		        any: any,
		        anyPass: anyPass,
		        ap: ap,
		        aperture: aperture,
		        append: append,
		        apply: apply,
		        assoc: assoc,
		        assocPath: assocPath,
		        binary: binary,
		        bind: bind,
		        both: both,
		        call: call,
		        chain: chain,
		        clone: clone,
		        commute: commute,
		        commuteMap: commuteMap,
		        comparator: comparator,
		        complement: complement,
		        compose: compose,
		        composeK: composeK,
		        composeP: composeP,
		        concat: concat,
		        cond: cond,
		        construct: construct,
		        constructN: constructN,
		        contains: contains,
		        converge: converge,
		        countBy: countBy,
		        curry: curry,
		        curryN: curryN,
		        dec: dec,
		        defaultTo: defaultTo,
		        difference: difference,
		        differenceWith: differenceWith,
		        dissoc: dissoc,
		        dissocPath: dissocPath,
		        divide: divide,
		        drop: drop,
		        dropLast: dropLast,
		        dropLastWhile: dropLastWhile,
		        dropRepeats: dropRepeats,
		        dropRepeatsWith: dropRepeatsWith,
		        dropWhile: dropWhile,
		        either: either,
		        empty: empty,
		        eqBy: eqBy,
		        eqProps: eqProps,
		        equals: equals,
		        evolve: evolve,
		        filter: filter,
		        find: find,
		        findIndex: findIndex,
		        findLast: findLast,
		        findLastIndex: findLastIndex,
		        flatten: flatten,
		        flip: flip,
		        forEach: forEach,
		        fromPairs: fromPairs,
		        groupBy: groupBy,
		        gt: gt,
		        gte: gte,
		        has: has,
		        hasIn: hasIn,
		        head: head,
		        identical: identical,
		        identity: identity,
		        ifElse: ifElse,
		        inc: inc,
		        indexBy: indexBy,
		        indexOf: indexOf,
		        init: init,
		        insert: insert,
		        insertAll: insertAll,
		        intersection: intersection,
		        intersectionWith: intersectionWith,
		        intersperse: intersperse,
		        into: into,
		        invert: invert,
		        invertObj: invertObj,
		        invoker: invoker,
		        is: is,
		        isArrayLike: isArrayLike,
		        isEmpty: isEmpty,
		        isNil: isNil,
		        join: join,
		        juxt: juxt,
		        keys: keys,
		        keysIn: keysIn,
		        last: last,
		        lastIndexOf: lastIndexOf,
		        length: length,
		        lens: lens,
		        lensIndex: lensIndex,
		        lensPath: lensPath,
		        lensProp: lensProp,
		        lift: lift,
		        liftN: liftN,
		        lt: lt,
		        lte: lte,
		        map: map,
		        mapAccum: mapAccum,
		        mapAccumRight: mapAccumRight,
		        mapObjIndexed: mapObjIndexed,
		        match: match,
		        mathMod: mathMod,
		        max: max,
		        maxBy: maxBy,
		        mean: mean,
		        median: median,
		        memoize: memoize,
		        merge: merge,
		        mergeAll: mergeAll,
		        mergeWith: mergeWith,
		        mergeWithKey: mergeWithKey,
		        min: min,
		        minBy: minBy,
		        modulo: modulo,
		        multiply: multiply,
		        nAry: nAry,
		        negate: negate,
		        none: none,
		        not: not,
		        nth: nth,
		        nthArg: nthArg,
		        objOf: objOf,
		        of: of,
		        omit: omit,
		        once: once,
		        or: or,
		        over: over,
		        pair: pair,
		        partial: partial,
		        partialRight: partialRight,
		        partition: partition,
		        path: path,
		        pathEq: pathEq,
		        pathOr: pathOr,
		        pathSatisfies: pathSatisfies,
		        pick: pick,
		        pickAll: pickAll,
		        pickBy: pickBy,
		        pipe: pipe,
		        pipeK: pipeK,
		        pipeP: pipeP,
		        pluck: pluck,
		        prepend: prepend,
		        product: product,
		        project: project,
		        prop: prop,
		        propEq: propEq,
		        propIs: propIs,
		        propOr: propOr,
		        propSatisfies: propSatisfies,
		        props: props,
		        range: range,
		        reduce: reduce,
		        reduceRight: reduceRight,
		        reduced: reduced,
		        reject: reject,
		        remove: remove,
		        repeat: repeat,
		        replace: replace,
		        reverse: reverse,
		        scan: scan,
		        sequence: sequence,
		        set: set,
		        slice: slice,
		        sort: sort,
		        sortBy: sortBy,
		        split: split,
		        splitAt: splitAt,
		        splitEvery: splitEvery,
		        splitWhen: splitWhen,
		        subtract: subtract,
		        sum: sum,
		        symmetricDifference: symmetricDifference,
		        symmetricDifferenceWith: symmetricDifferenceWith,
		        tail: tail,
		        take: take,
		        takeLast: takeLast,
		        takeLastWhile: takeLastWhile,
		        takeWhile: takeWhile,
		        tap: tap,
		        test: test,
		        times: times,
		        toLower: toLower,
		        toPairs: toPairs,
		        toPairsIn: toPairsIn,
		        toString: toString,
		        toUpper: toUpper,
		        transduce: transduce,
		        transpose: transpose,
		        traverse: traverse,
		        trim: trim,
		        type: type,
		        unapply: unapply,
		        unary: unary,
		        uncurryN: uncurryN,
		        unfold: unfold,
		        union: union,
		        unionWith: unionWith,
		        uniq: uniq,
		        uniqBy: uniqBy,
		        uniqWith: uniqWith,
		        unless: unless,
		        unnest: unnest,
		        update: update,
		        useWith: useWith,
		        values: values,
		        valuesIn: valuesIn,
		        view: view,
		        when: when,
		        where: where,
		        whereEq: whereEq,
		        without: without,
		        wrap: wrap,
		        xprod: xprod,
		        zip: zip,
		        zipObj: zipObj,
		        zipWith: zipWith
		    };
		  /* eslint-env amd */

		  /* TEST_ENTRY_POINT */

		  if (true) {
		    module.exports = R;
		  } else if (typeof define === 'function' && define.amd) {
		    define(function() { return R; });
		  } else {
		    this.R = R;
		  }

		}.call(this));


	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.isImportDeclaration = exports.isCompiletimeStatement = exports.isCompiletimeDeclaration = exports.isSyntaxDeclarationStatement = exports.isExportSyntax = exports.isParenthesizedExpression = exports.isFunctionWithName = exports.isFunctionTerm = exports.isSyntaxrecDeclaration = exports.isSyntaxDeclaration = exports.isEOF = exports.isVariableDeclarator = exports.isVariableDeclaration = exports.isSyntaxTemplate = exports.isTemplateElement = exports.isSwitchDefault = exports.isSwitchCase = exports.isSuper = exports.isSpreadElement = exports.isScript = exports.isFunctionDeclaration = exports.isFunctionBody = exports.isFormalParameters = exports.isDirective = exports.isCatchClause = exports.isBlock = exports.isPragma = exports.isWithStatement = exports.isWhileStatement = exports.isVariableDeclarationStatement = exports.isTryFinallyStatement = exports.isTryCatchStatement = exports.isThrowStatement = exports.isSwitchStatementWithDefault = exports.isSwitchStatement = exports.isReturnStatement = exports.isLabeledStatement = exports.isIfStatement = exports.isForStatement = exports.isForOfStatement = exports.isForInStatement = exports.isExpressionStatement = exports.isEmptyStatement = exports.isDoWhileStatement = exports.isDebuggerStatement = exports.isCompoundAssignmentExpression = exports.isContinueStatement = exports.isBreakStatement = exports.isBlockStatement = exports.isYieldGeneratorExpression = exports.isYieldExpression = exports.isUpdateExpression = exports.isThisExpression = exports.isTemplateExpression = exports.isStaticMemberExpression = exports.isUnaryExpression = exports.isObjectExpression = exports.isNewTargetExpression = exports.isNewExpression = exports.isIdentifierExpression = exports.isFunctionExpression = exports.isConditionalExpression = exports.isComputedMemberExpression = exports.isComputedAssignmentExpression = exports.isCallExpression = exports.isBinaryExpression = exports.isAssignmentExpression = exports.isArrowExpression = exports.isArrayExpression = exports.isLiteralStringExpression = exports.isLiteralRegExpExpression = exports.isLiteralNumericExpression = exports.isLiteralNullExpression = exports.isLiteralInfinityExpression = exports.isLiteralBooleanExpression = exports.isStaticPropertyName = exports.isComputedPropertyName = exports.isShorthandProperty = exports.isDataProperty = exports.isSetter = exports.isGetter = exports.isMethod = exports.isExportSpecifier = exports.isExportDefault = exports.isExport = exports.isExportFrom = exports.isExportAllFrom = exports.isImportSpecifier = exports.isImportNamespace = exports.isImport = exports.isModule = exports.isClassElement = exports.isClassDeclaration = exports.isClassExpression = exports.isBindingPropertyProperty = exports.isBindingPropertyIdentifier = exports.isObjectBinding = exports.isArrayBinding = exports.isBindingIdentifier = exports.isBindingWithDefault = undefined;

		var _immutable = __webpack_require__(9);

		var _errors = __webpack_require__(11);

		var _utils = __webpack_require__(27);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _ramda = __webpack_require__(25);

		var R = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class Term {
		  constructor(type_1182, props_1183) {
		    this.type = type_1182;
		    this.loc = null;
		    for (let prop of Object.keys(props_1183)) {
		      this[prop] = props_1183[prop];
		    }
		  }
		  extend(props_1184) {
		    let newProps_1185 = {};
		    for (let field of fieldsIn_1181(this)) {
		      if (props_1184.hasOwnProperty(field)) {
		        newProps_1185[field] = props_1184[field];
		      } else {
		        newProps_1185[field] = this[field];
		      }
		    }
		    return new Term(this.type, newProps_1185);
		  }
		  gen() {
		    var _ref = arguments.length <= 0 || arguments[0] === undefined ? { includeImports: true } : arguments[0];

		    let includeImports = _ref.includeImports;

		    let next_1186 = {};
		    for (let field of fieldsIn_1181(this)) {
		      if (this[field] == null) {
		        next_1186[field] = null;
		      } else if (this[field] instanceof Term) {
		        next_1186[field] = this[field].gen(includeImports);
		      } else if (_immutable.List.isList(this[field])) {
		        let pred = includeImports ? R.complement(isCompiletimeStatement_1179) : R.both(R.complement(isImportDeclaration_1180), R.complement(isCompiletimeStatement_1179));
		        next_1186[field] = this[field].filter(pred).map(term_1187 => term_1187 instanceof Term ? term_1187.gen(includeImports) : term_1187);
		      } else {
		        next_1186[field] = this[field];
		      }
		    }
		    return new Term(this.type, next_1186);
		  }
		  visit(f_1188) {
		    let next_1189 = {};
		    for (let field of fieldsIn_1181(this)) {
		      if (this[field] == null) {
		        next_1189[field] = null;
		      } else if (_immutable.List.isList(this[field])) {
		        next_1189[field] = this[field].map(field_1190 => field_1190 != null ? f_1188(field_1190) : null);
		      } else {
		        next_1189[field] = f_1188(this[field]);
		      }
		    }
		    return this.extend(next_1189);
		  }
		  addScope(scope_1191, bindings_1192, phase_1193, options_1194) {
		    return this.visit(term_1195 => {
		      if (typeof term_1195.addScope === "function") {
		        return term_1195.addScope(scope_1191, bindings_1192, phase_1193, options_1194);
		      }
		      return term_1195;
		    });
		  }
		  removeScope(scope_1196, phase_1197) {
		    return this.visit(term_1198 => {
		      if (typeof term_1198.removeScope === "function") {
		        return term_1198.removeScope(scope_1196, phase_1197);
		      }
		      return term_1198;
		    });
		  }
		  lineNumber() {
		    for (let field of fieldsIn_1181(this)) {
		      if (typeof this[field] && this[field].lineNumber === "function") {
		        return this[field].lineNumber();
		      }
		    }
		  }
		  setLineNumber(line_1199) {
		    let next_1200 = {};
		    for (let field of fieldsIn_1181(this)) {
		      if (this[field] == null) {
		        next_1200[field] = null;
		      } else if (typeof this[field].setLineNumber === "function") {
		        next_1200[field] = this[field].setLineNumber(line_1199);
		      } else if (_immutable.List.isList(this[field])) {
		        next_1200[field] = this[field].map(f_1201 => f_1201.setLineNumber(line_1199));
		      } else {
		        next_1200[field] = this[field];
		      }
		    }
		    return new Term(this.type, next_1200);
		  }
		}
		exports.default = Term;
		const isBindingWithDefault_1081 = R.whereEq({ type: "BindingWithDefault" });
		;
		const isBindingIdentifier_1082 = R.whereEq({ type: "BindingIdentifier" });
		;
		const isArrayBinding_1083 = R.whereEq({ type: "ArrayBinding" });
		;
		const isObjectBinding_1084 = R.whereEq({ type: "ObjectBinding" });
		;
		const isBindingPropertyIdentifier_1085 = R.whereEq({ type: "BindingPropertyIdentifier" });
		;
		const isBindingPropertyProperty_1086 = R.whereEq({ type: "BindingPropertyIdentifier" });
		;
		const isClassExpression_1087 = R.whereEq({ type: "ClassExpression" });
		;
		const isClassDeclaration_1088 = R.whereEq({ type: "ClassDeclaration" });
		;
		const isClassElement_1089 = R.whereEq({ type: "ClassElement" });
		;
		const isModule_1090 = R.whereEq({ type: "Module" });
		;
		const isImport_1091 = R.whereEq({ type: "Import" });
		;
		const isImportNamespace_1092 = R.whereEq({ type: "ImportNamespace" });
		;
		const isImportSpecifier_1093 = R.whereEq({ type: "ImportSpecifier" });
		;
		const isExportAllFrom_1094 = R.whereEq({ type: "ExportAllFrom" });
		;
		const isExportFrom_1095 = R.whereEq({ type: "ExportFrom" });
		;
		const isExport_1096 = R.whereEq({ type: "Export" });
		;
		const isExportDefault_1097 = R.whereEq({ type: "ExportDefault" });
		;
		const isExportSpecifier_1098 = R.whereEq({ type: "ExportSpecifier" });
		;
		const isMethod_1099 = R.whereEq({ type: "Method" });
		;
		const isGetter_1100 = R.whereEq({ type: "Getter" });
		;
		const isSetter_1101 = R.whereEq({ type: "Setter" });
		;
		const isDataProperty_1102 = R.whereEq({ type: "DataProperty" });
		;
		const isShorthandProperty_1103 = R.whereEq({ type: "ShorthandProperty" });
		;
		const isComputedPropertyName_1104 = R.whereEq({ type: "ComputedPropertyName" });
		;
		const isStaticPropertyName_1105 = R.whereEq({ type: "StaticPropertyName" });
		;
		const isLiteralBooleanExpression_1106 = R.whereEq({ type: "LiteralBooleanExpression" });
		;
		const isLiteralInfinityExpression_1107 = R.whereEq({ type: "LiteralInfinityExpression" });
		;
		const isLiteralNullExpression_1108 = R.whereEq({ type: "LiteralNullExpression" });
		;
		const isLiteralNumericExpression_1109 = R.whereEq({ type: "LiteralNumericExpression" });
		;
		const isLiteralRegExpExpression_1110 = R.whereEq({ type: "LiteralRegExpExpression" });
		;
		const isLiteralStringExpression_1111 = R.whereEq({ type: "LiteralStringExpression" });
		;
		const isArrayExpression_1112 = R.whereEq({ type: "ArrayExpression" });
		;
		const isArrowExpression_1113 = R.whereEq({ type: "ArrowExpression" });
		;
		const isAssignmentExpression_1114 = R.whereEq({ type: "AssignmentExpression" });
		;
		const isBinaryExpression_1115 = R.whereEq({ type: "BinaryExpression" });
		;
		const isCallExpression_1116 = R.whereEq({ type: "CallExpression" });
		;
		const isComputedAssignmentExpression_1117 = R.whereEq({ type: "ComputedAssignmentExpression" });
		;
		const isComputedMemberExpression_1118 = R.whereEq({ type: "ComputedMemberExpression" });
		;
		const isConditionalExpression_1119 = R.whereEq({ type: "ConditionalExpression" });
		;
		const isFunctionExpression_1120 = R.whereEq({ type: "FunctionExpression" });
		;
		const isIdentifierExpression_1121 = R.whereEq({ type: "IdentifierExpression" });
		;
		const isNewExpression_1122 = R.whereEq({ type: "NewExpression" });
		;
		const isNewTargetExpression_1123 = R.whereEq({ type: "NewTargetExpression" });
		;
		const isObjectExpression_1124 = R.whereEq({ type: "ObjectExpression" });
		;
		const isUnaryExpression_1125 = R.whereEq({ type: "UnaryExpression" });
		;
		const isStaticMemberExpression_1126 = R.whereEq({ type: "StaticMemberExpression" });
		;
		const isTemplateExpression_1127 = R.whereEq({ type: "TemplateExpression" });
		;
		const isThisExpression_1128 = R.whereEq({ type: "ThisExpression" });
		;
		const isUpdateExpression_1129 = R.whereEq({ type: "UpdateExpression" });
		;
		const isYieldExpression_1130 = R.whereEq({ type: "YieldExpression" });
		;
		const isYieldGeneratorExpression_1131 = R.whereEq({ type: "YieldGeneratorExpression" });
		;
		const isBlockStatement_1132 = R.whereEq({ type: "BlockStatement" });
		;
		const isBreakStatement_1133 = R.whereEq({ type: "BreakStatement" });
		;
		const isContinueStatement_1134 = R.whereEq({ type: "ContinueStatement" });
		;
		const isCompoundAssignmentExpression_1135 = R.whereEq({ type: "CompoundAssignmentExpression" });
		;
		const isDebuggerStatement_1136 = R.whereEq({ type: "DebuggerStatement" });
		;
		const isDoWhileStatement_1137 = R.whereEq({ type: "DoWhileStatement" });
		;
		const isEmptyStatement_1138 = R.whereEq({ type: "EmptyStatement" });
		;
		const isExpressionStatement_1139 = R.whereEq({ type: "ExpressionStatement" });
		;
		const isForInStatement_1140 = R.whereEq({ type: "ForInStatement" });
		;
		const isForOfStatement_1141 = R.whereEq({ type: "ForOfStatement" });
		;
		const isForStatement_1142 = R.whereEq({ type: "ForStatement" });
		;
		const isIfStatement_1143 = R.whereEq({ type: "IfStatement" });
		;
		const isLabeledStatement_1144 = R.whereEq({ type: "LabeledStatement" });
		;
		const isReturnStatement_1145 = R.whereEq({ type: "ReturnStatement" });
		;
		const isSwitchStatement_1146 = R.whereEq({ type: "SwitchStatement" });
		;
		const isSwitchStatementWithDefault_1147 = R.whereEq({ type: "SwitchStatementWithDefault" });
		;
		const isThrowStatement_1148 = R.whereEq({ type: "ThrowStatement" });
		;
		const isTryCatchStatement_1149 = R.whereEq({ type: "TryCatchStatement" });
		;
		const isTryFinallyStatement_1150 = R.whereEq({ type: "TryFinallyStatement" });
		;
		const isVariableDeclarationStatement_1151 = R.whereEq({ type: "VariableDeclarationStatement" });
		;
		const isWhileStatement_1152 = R.whereEq({ type: "WhileStatement" });
		;
		const isWithStatement_1153 = R.whereEq({ type: "WithStatement" });
		;
		const isPragma_1154 = R.whereEq({ type: "Pragma" });
		;
		const isBlock_1155 = R.whereEq({ type: "Block" });
		;
		const isCatchClause_1156 = R.whereEq({ type: "CatchClause" });
		;
		const isDirective_1157 = R.whereEq({ type: "Directive" });
		;
		const isFormalParameters_1158 = R.whereEq({ type: "FormalParameters" });
		;
		const isFunctionBody_1159 = R.whereEq({ type: "FunctionBody" });
		;
		const isFunctionDeclaration_1160 = R.whereEq({ type: "FunctionDeclaration" });
		;
		const isScript_1161 = R.whereEq({ type: "Script" });
		;
		const isSpreadElement_1162 = R.whereEq({ type: "SpreadElement" });
		;
		const isSuper_1163 = R.whereEq({ type: "Super" });
		;
		const isSwitchCase_1164 = R.whereEq({ type: "SwitchCase" });
		;
		const isSwitchDefault_1165 = R.whereEq({ type: "SwitchDefault" });
		;
		const isTemplateElement_1166 = R.whereEq({ type: "TemplateElement" });
		;
		const isSyntaxTemplate_1167 = R.whereEq({ type: "SyntaxTemplate" });
		;
		const isVariableDeclaration_1168 = R.whereEq({ type: "VariableDeclaration" });
		;
		const isVariableDeclarator_1169 = R.whereEq({ type: "VariableDeclarator" });
		;
		const isEOF_1170 = R.whereEq({ type: "EOF" });
		;
		const isSyntaxDeclaration_1171 = R.both(isVariableDeclaration_1168, R.whereEq({ kind: "syntax" }));
		;
		const isSyntaxrecDeclaration_1172 = R.both(isVariableDeclaration_1168, R.whereEq({ kind: "syntaxrec" }));
		;
		const isFunctionTerm_1173 = R.either(isFunctionDeclaration_1160, isFunctionExpression_1120);
		;
		const isFunctionWithName_1174 = R.and(isFunctionTerm_1173, R.complement(R.where({ name: R.isNil })));
		;
		const isParenthesizedExpression_1175 = R.whereEq({ type: "ParenthesizedExpression" });
		;
		const isExportSyntax_1176 = R.both(isExport_1096, exp_1202 => R.or(isSyntaxDeclaration_1171(exp_1202.declaration), isSyntaxrecDeclaration_1172(exp_1202.declaration)));
		;
		const isSyntaxDeclarationStatement_1177 = R.both(isVariableDeclarationStatement_1151, decl_1203 => isCompiletimeDeclaration_1178(decl_1203.declaration));
		;
		const isCompiletimeDeclaration_1178 = R.either(isSyntaxDeclaration_1171, isSyntaxrecDeclaration_1172);
		;
		const isCompiletimeStatement_1179 = term_1204 => {
		  return term_1204 instanceof Term && isVariableDeclarationStatement_1151(term_1204) && isCompiletimeDeclaration_1178(term_1204.declaration);
		};
		;
		const isImportDeclaration_1180 = R.either(isImport_1091, isImportNamespace_1092);
		;
		const fieldsIn_1181 = R.cond([[isBindingWithDefault_1081, R.always(_immutable.List.of("binding", "init"))], [isBindingIdentifier_1082, R.always(_immutable.List.of("name"))], [isArrayBinding_1083, R.always(_immutable.List.of("elements", "restElement"))], [isObjectBinding_1084, R.always(_immutable.List.of("properties"))], [isBindingPropertyIdentifier_1085, R.always(_immutable.List.of("binding", "init"))], [isBindingPropertyProperty_1086, R.always(_immutable.List.of("name", "binding"))], [isClassExpression_1087, R.always(_immutable.List.of("name", "super", "elements"))], [isClassDeclaration_1088, R.always(_immutable.List.of("name", "super", "elements"))], [isClassElement_1089, R.always(_immutable.List.of("isStatic", "method"))], [isModule_1090, R.always(_immutable.List.of("directives", "items"))], [isImport_1091, R.always(_immutable.List.of("moduleSpecifier", "defaultBinding", "namedImports", "forSyntax"))], [isImportNamespace_1092, R.always(_immutable.List.of("moduleSpecifier", "defaultBinding", "namespaceBinding"))], [isImportSpecifier_1093, R.always(_immutable.List.of("name", "binding"))], [isExportAllFrom_1094, R.always(_immutable.List.of("moduleSpecifier"))], [isExportFrom_1095, R.always(_immutable.List.of("namedExports", "moduleSpecifier"))], [isExport_1096, R.always(_immutable.List.of("declaration"))], [isExportDefault_1097, R.always(_immutable.List.of("body"))], [isExportSpecifier_1098, R.always(_immutable.List.of("name", "exportedName"))], [isMethod_1099, R.always(_immutable.List.of("name", "body", "isGenerator", "params"))], [isGetter_1100, R.always(_immutable.List.of("name", "body"))], [isSetter_1101, R.always(_immutable.List.of("name", "body", "param"))], [isDataProperty_1102, R.always(_immutable.List.of("name", "expression"))], [isShorthandProperty_1103, R.always(_immutable.List.of("expression"))], [isStaticPropertyName_1105, R.always(_immutable.List.of("value"))], [isLiteralBooleanExpression_1106, R.always(_immutable.List.of("value"))], [isLiteralInfinityExpression_1107, R.always((0, _immutable.List)())], [isLiteralNullExpression_1108, R.always((0, _immutable.List)())], [isLiteralNumericExpression_1109, R.always(_immutable.List.of("value"))], [isLiteralRegExpExpression_1110, R.always(_immutable.List.of("pattern", "flags"))], [isLiteralStringExpression_1111, R.always(_immutable.List.of("value"))], [isArrayExpression_1112, R.always(_immutable.List.of("elements"))], [isArrowExpression_1113, R.always(_immutable.List.of("params", "body"))], [isAssignmentExpression_1114, R.always(_immutable.List.of("binding", "expression"))], [isBinaryExpression_1115, R.always(_immutable.List.of("operator", "left", "right"))], [isCallExpression_1116, R.always(_immutable.List.of("callee", "arguments"))], [isComputedAssignmentExpression_1117, R.always(_immutable.List.of("operator", "binding", "expression"))], [isComputedMemberExpression_1118, R.always(_immutable.List.of("object", "expression"))], [isConditionalExpression_1119, R.always(_immutable.List.of("test", "consequent", "alternate"))], [isFunctionExpression_1120, R.always(_immutable.List.of("name", "isGenerator", "params", "body"))], [isIdentifierExpression_1121, R.always(_immutable.List.of("name"))], [isNewExpression_1122, R.always(_immutable.List.of("callee", "arguments"))], [isNewTargetExpression_1123, R.always((0, _immutable.List)())], [isObjectExpression_1124, R.always(_immutable.List.of("properties"))], [isUnaryExpression_1125, R.always(_immutable.List.of("operator", "operand"))], [isStaticMemberExpression_1126, R.always(_immutable.List.of("object", "property"))], [isTemplateExpression_1127, R.always(_immutable.List.of("tag", "elements"))], [isThisExpression_1128, R.always((0, _immutable.List)())], [isUpdateExpression_1129, R.always(_immutable.List.of("isPrefix", "operator", "operand"))], [isYieldExpression_1130, R.always(_immutable.List.of("expression"))], [isYieldGeneratorExpression_1131, R.always(_immutable.List.of("expression"))], [isBlockStatement_1132, R.always(_immutable.List.of("block"))], [isBreakStatement_1133, R.always(_immutable.List.of("label"))], [isContinueStatement_1134, R.always(_immutable.List.of("label"))], [isCompoundAssignmentExpression_1135, R.always(_immutable.List.of("binding", "operator", "expression"))], [isDebuggerStatement_1136, R.always((0, _immutable.List)())], [isDoWhileStatement_1137, R.always(_immutable.List.of("test", "body"))], [isEmptyStatement_1138, R.always((0, _immutable.List)())], [isExpressionStatement_1139, R.always(_immutable.List.of("expression"))], [isForInStatement_1140, R.always(_immutable.List.of("left", "right", "body"))], [isForOfStatement_1141, R.always(_immutable.List.of("left", "right", "body"))], [isForStatement_1142, R.always(_immutable.List.of("init", "test", "update", "body"))], [isIfStatement_1143, R.always(_immutable.List.of("test", "consequent", "alternate"))], [isLabeledStatement_1144, R.always(_immutable.List.of("label", "body"))], [isReturnStatement_1145, R.always(_immutable.List.of("expression"))], [isSwitchStatement_1146, R.always(_immutable.List.of("discriminant", "cases"))], [isSwitchStatementWithDefault_1147, R.always(_immutable.List.of("discriminant", "preDefaultCases", "defaultCase", "postDefaultCases"))], [isThrowStatement_1148, R.always(_immutable.List.of("expression"))], [isTryCatchStatement_1149, R.always(_immutable.List.of("body", "catchClause"))], [isTryFinallyStatement_1150, R.always(_immutable.List.of("body", "catchClause", "finalizer"))], [isVariableDeclarationStatement_1151, R.always(_immutable.List.of("declaration"))], [isWithStatement_1153, R.always(_immutable.List.of("object", "body"))], [isWhileStatement_1152, R.always(_immutable.List.of("test", "body"))], [isPragma_1154, R.always(_immutable.List.of("kind", "items"))], [isBlock_1155, R.always(_immutable.List.of("statements"))], [isCatchClause_1156, R.always(_immutable.List.of("binding", "body"))], [isDirective_1157, R.always(_immutable.List.of("rawValue"))], [isFormalParameters_1158, R.always(_immutable.List.of("items", "rest"))], [isFunctionBody_1159, R.always(_immutable.List.of("directives", "statements"))], [isFunctionDeclaration_1160, R.always(_immutable.List.of("name", "isGenerator", "params", "body"))], [isScript_1161, R.always(_immutable.List.of("directives", "statements"))], [isSpreadElement_1162, R.always(_immutable.List.of("expression"))], [isSuper_1163, R.always((0, _immutable.List)())], [isSwitchCase_1164, R.always(_immutable.List.of("test", "consequent"))], [isSwitchDefault_1165, R.always(_immutable.List.of("consequent"))], [isTemplateElement_1166, R.always(_immutable.List.of("rawValue"))], [isSyntaxTemplate_1167, R.always(_immutable.List.of("template"))], [isVariableDeclaration_1168, R.always(_immutable.List.of("kind", "declarators"))], [isVariableDeclarator_1169, R.always(_immutable.List.of("binding", "init"))], [isParenthesizedExpression_1175, R.always(_immutable.List.of("inner"))], [R.T, type_1205 => (0, _errors.assert)(false, "Missing case in fields: " + type_1205.type)]]);
		exports.isBindingWithDefault = isBindingWithDefault_1081;
		exports.isBindingIdentifier = isBindingIdentifier_1082;
		exports.isArrayBinding = isArrayBinding_1083;
		exports.isObjectBinding = isObjectBinding_1084;
		exports.isBindingPropertyIdentifier = isBindingPropertyIdentifier_1085;
		exports.isBindingPropertyProperty = isBindingPropertyProperty_1086;
		exports.isClassExpression = isClassExpression_1087;
		exports.isClassDeclaration = isClassDeclaration_1088;
		exports.isClassElement = isClassElement_1089;
		exports.isModule = isModule_1090;
		exports.isImport = isImport_1091;
		exports.isImportNamespace = isImportNamespace_1092;
		exports.isImportSpecifier = isImportSpecifier_1093;
		exports.isExportAllFrom = isExportAllFrom_1094;
		exports.isExportFrom = isExportFrom_1095;
		exports.isExport = isExport_1096;
		exports.isExportDefault = isExportDefault_1097;
		exports.isExportSpecifier = isExportSpecifier_1098;
		exports.isMethod = isMethod_1099;
		exports.isGetter = isGetter_1100;
		exports.isSetter = isSetter_1101;
		exports.isDataProperty = isDataProperty_1102;
		exports.isShorthandProperty = isShorthandProperty_1103;
		exports.isComputedPropertyName = isComputedPropertyName_1104;
		exports.isStaticPropertyName = isStaticPropertyName_1105;
		exports.isLiteralBooleanExpression = isLiteralBooleanExpression_1106;
		exports.isLiteralInfinityExpression = isLiteralInfinityExpression_1107;
		exports.isLiteralNullExpression = isLiteralNullExpression_1108;
		exports.isLiteralNumericExpression = isLiteralNumericExpression_1109;
		exports.isLiteralRegExpExpression = isLiteralRegExpExpression_1110;
		exports.isLiteralStringExpression = isLiteralStringExpression_1111;
		exports.isArrayExpression = isArrayExpression_1112;
		exports.isArrowExpression = isArrowExpression_1113;
		exports.isAssignmentExpression = isAssignmentExpression_1114;
		exports.isBinaryExpression = isBinaryExpression_1115;
		exports.isCallExpression = isCallExpression_1116;
		exports.isComputedAssignmentExpression = isComputedAssignmentExpression_1117;
		exports.isComputedMemberExpression = isComputedMemberExpression_1118;
		exports.isConditionalExpression = isConditionalExpression_1119;
		exports.isFunctionExpression = isFunctionExpression_1120;
		exports.isIdentifierExpression = isIdentifierExpression_1121;
		exports.isNewExpression = isNewExpression_1122;
		exports.isNewTargetExpression = isNewTargetExpression_1123;
		exports.isObjectExpression = isObjectExpression_1124;
		exports.isUnaryExpression = isUnaryExpression_1125;
		exports.isStaticMemberExpression = isStaticMemberExpression_1126;
		exports.isTemplateExpression = isTemplateExpression_1127;
		exports.isThisExpression = isThisExpression_1128;
		exports.isUpdateExpression = isUpdateExpression_1129;
		exports.isYieldExpression = isYieldExpression_1130;
		exports.isYieldGeneratorExpression = isYieldGeneratorExpression_1131;
		exports.isBlockStatement = isBlockStatement_1132;
		exports.isBreakStatement = isBreakStatement_1133;
		exports.isContinueStatement = isContinueStatement_1134;
		exports.isCompoundAssignmentExpression = isCompoundAssignmentExpression_1135;
		exports.isDebuggerStatement = isDebuggerStatement_1136;
		exports.isDoWhileStatement = isDoWhileStatement_1137;
		exports.isEmptyStatement = isEmptyStatement_1138;
		exports.isExpressionStatement = isExpressionStatement_1139;
		exports.isForInStatement = isForInStatement_1140;
		exports.isForOfStatement = isForOfStatement_1141;
		exports.isForStatement = isForStatement_1142;
		exports.isIfStatement = isIfStatement_1143;
		exports.isLabeledStatement = isLabeledStatement_1144;
		exports.isReturnStatement = isReturnStatement_1145;
		exports.isSwitchStatement = isSwitchStatement_1146;
		exports.isSwitchStatementWithDefault = isSwitchStatementWithDefault_1147;
		exports.isThrowStatement = isThrowStatement_1148;
		exports.isTryCatchStatement = isTryCatchStatement_1149;
		exports.isTryFinallyStatement = isTryFinallyStatement_1150;
		exports.isVariableDeclarationStatement = isVariableDeclarationStatement_1151;
		exports.isWhileStatement = isWhileStatement_1152;
		exports.isWithStatement = isWithStatement_1153;
		exports.isPragma = isPragma_1154;
		exports.isBlock = isBlock_1155;
		exports.isCatchClause = isCatchClause_1156;
		exports.isDirective = isDirective_1157;
		exports.isFormalParameters = isFormalParameters_1158;
		exports.isFunctionBody = isFunctionBody_1159;
		exports.isFunctionDeclaration = isFunctionDeclaration_1160;
		exports.isScript = isScript_1161;
		exports.isSpreadElement = isSpreadElement_1162;
		exports.isSuper = isSuper_1163;
		exports.isSwitchCase = isSwitchCase_1164;
		exports.isSwitchDefault = isSwitchDefault_1165;
		exports.isTemplateElement = isTemplateElement_1166;
		exports.isSyntaxTemplate = isSyntaxTemplate_1167;
		exports.isVariableDeclaration = isVariableDeclaration_1168;
		exports.isVariableDeclarator = isVariableDeclarator_1169;
		exports.isEOF = isEOF_1170;
		exports.isSyntaxDeclaration = isSyntaxDeclaration_1171;
		exports.isSyntaxrecDeclaration = isSyntaxrecDeclaration_1172;
		exports.isFunctionTerm = isFunctionTerm_1173;
		exports.isFunctionWithName = isFunctionWithName_1174;
		exports.isParenthesizedExpression = isParenthesizedExpression_1175;
		exports.isExportSyntax = isExportSyntax_1176;
		exports.isSyntaxDeclarationStatement = isSyntaxDeclarationStatement_1177;
		exports.isCompiletimeDeclaration = isCompiletimeDeclaration_1178;
		exports.isCompiletimeStatement = isCompiletimeStatement_1179;
		exports.isImportDeclaration = isImportDeclaration_1180;
		//# sourceMappingURL=data:application/json;base64,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O1FBQ2tDLHlCLEdBQWxDLDhCO1FBQ2tDLHlCLEdBQWxDLDhCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQytCLHNCLEdBQS9CLDJCO1FBQzJCLGtCLEdBQTNCLHVCO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQ3VDLDhCLEdBQXZDLG1DO1FBQ21DLDBCLEdBQW5DLCtCO1FBQ2dDLHVCLEdBQWhDLDRCO1FBQzZCLG9CLEdBQTdCLHlCO1FBQytCLHNCLEdBQS9CLDJCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDOEIscUIsR0FBOUIsMEI7UUFDMkIsa0IsR0FBM0IsdUI7UUFDMEIsaUIsR0FBMUIsc0I7UUFDaUMsd0IsR0FBakMsNkI7UUFDNkIsb0IsR0FBN0IseUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDMkIsa0IsR0FBM0IsdUI7UUFDMEIsaUIsR0FBMUIsc0I7UUFDbUMsMEIsR0FBbkMsK0I7UUFDeUIsZ0IsR0FBekIscUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDdUMsOEIsR0FBdkMsbUM7UUFDNEIsbUIsR0FBNUIsd0I7UUFDMkIsa0IsR0FBM0IsdUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDOEIscUIsR0FBOUIsMEI7UUFDeUIsZ0IsR0FBekIscUI7UUFDeUIsZ0IsR0FBekIscUI7UUFDdUIsYyxHQUF2QixtQjtRQUNzQixhLEdBQXRCLGtCO1FBQzJCLGtCLEdBQTNCLHVCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQzBCLGlCLEdBQTFCLHNCO1FBQ3FDLDRCLEdBQXJDLGlDO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQzRCLG1CLEdBQTVCLHdCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQ3VDLDhCLEdBQXZDLG1DO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDaUIsUSxHQUFqQixhO1FBQ2dCLE8sR0FBaEIsWTtRQUNzQixhLEdBQXRCLGtCO1FBQ29CLFcsR0FBcEIsZ0I7UUFDMkIsa0IsR0FBM0IsdUI7UUFDdUIsYyxHQUF2QixtQjtRQUM4QixxQixHQUE5QiwwQjtRQUNpQixRLEdBQWpCLGE7UUFDd0IsZSxHQUF4QixvQjtRQUNnQixPLEdBQWhCLFk7UUFDcUIsWSxHQUFyQixpQjtRQUN3QixlLEdBQXhCLG9CO1FBQzBCLGlCLEdBQTFCLHNCO1FBQ3lCLGdCLEdBQXpCLHFCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQzZCLG9CLEdBQTdCLHlCO1FBQ2MsSyxHQUFkLFU7UUFDNEIsbUIsR0FBNUIsd0I7UUFDK0Isc0IsR0FBL0IsMkI7UUFDdUIsYyxHQUF2QixtQjtRQUMyQixrQixHQUEzQix1QjtRQUNrQyx5QixHQUFsQyw4QjtRQUN1QixjLEdBQXZCLG1CO1FBQ3FDLDRCLEdBQXJDLGlDO1FBQ2lDLHdCLEdBQWpDLDZCO1FBQytCLHNCLEdBQS9CLDJCO1FBQzRCLG1CLEdBQTVCLHdCIiwiZmlsZSI6InRlcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQge2Fzc2VydCwgZXhwZWN0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7bWl4aW59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgU3ludGF4IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0ICAqIGFzIFIgZnJvbSBcInJhbWRhXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtIHtcbiAgY29uc3RydWN0b3IodHlwZV8xMTgyLCBwcm9wc18xMTgzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZV8xMTgyO1xuICAgIHRoaXMubG9jID0gbnVsbDtcbiAgICBmb3IgKGxldCBwcm9wIG9mIE9iamVjdC5rZXlzKHByb3BzXzExODMpKSB7XG4gICAgICB0aGlzW3Byb3BdID0gcHJvcHNfMTE4M1twcm9wXTtcbiAgICB9XG4gIH1cbiAgZXh0ZW5kKHByb3BzXzExODQpIHtcbiAgICBsZXQgbmV3UHJvcHNfMTE4NSA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODEodGhpcykpIHtcbiAgICAgIGlmIChwcm9wc18xMTg0Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICBuZXdQcm9wc18xMTg1W2ZpZWxkXSA9IHByb3BzXzExODRbZmllbGRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3UHJvcHNfMTE4NVtmaWVsZF0gPSB0aGlzW2ZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKHRoaXMudHlwZSwgbmV3UHJvcHNfMTE4NSk7XG4gIH1cbiAgZ2VuKHtpbmNsdWRlSW1wb3J0c30gPSB7aW5jbHVkZUltcG9ydHM6IHRydWV9KSB7XG4gICAgbGV0IG5leHRfMTE4NiA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODEodGhpcykpIHtcbiAgICAgIGlmICh0aGlzW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICAgIG5leHRfMTE4NltmaWVsZF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzW2ZpZWxkXSBpbnN0YW5jZW9mIFRlcm0pIHtcbiAgICAgICAgbmV4dF8xMTg2W2ZpZWxkXSA9IHRoaXNbZmllbGRdLmdlbihpbmNsdWRlSW1wb3J0cyk7XG4gICAgICB9IGVsc2UgaWYgKExpc3QuaXNMaXN0KHRoaXNbZmllbGRdKSkge1xuICAgICAgICBsZXQgcHJlZCA9IGluY2x1ZGVJbXBvcnRzID8gUi5jb21wbGVtZW50KGlzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE3OSkgOiBSLmJvdGgoUi5jb21wbGVtZW50KGlzSW1wb3J0RGVjbGFyYXRpb25fMTE4MCksIFIuY29tcGxlbWVudChpc0NvbXBpbGV0aW1lU3RhdGVtZW50XzExNzkpKTtcbiAgICAgICAgbmV4dF8xMTg2W2ZpZWxkXSA9IHRoaXNbZmllbGRdLmZpbHRlcihwcmVkKS5tYXAodGVybV8xMTg3ID0+IHRlcm1fMTE4NyBpbnN0YW5jZW9mIFRlcm0gPyB0ZXJtXzExODcuZ2VuKGluY2x1ZGVJbXBvcnRzKSA6IHRlcm1fMTE4Nyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0XzExODZbZmllbGRdID0gdGhpc1tmaWVsZF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybSh0aGlzLnR5cGUsIG5leHRfMTE4Nik7XG4gIH1cbiAgdmlzaXQoZl8xMTg4KSB7XG4gICAgbGV0IG5leHRfMTE4OSA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkc0luXzExODEodGhpcykpIHtcbiAgICAgIGlmICh0aGlzW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICAgIG5leHRfMTE4OVtmaWVsZF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChMaXN0LmlzTGlzdCh0aGlzW2ZpZWxkXSkpIHtcbiAgICAgICAgbmV4dF8xMTg5W2ZpZWxkXSA9IHRoaXNbZmllbGRdLm1hcChmaWVsZF8xMTkwID0+IGZpZWxkXzExOTAgIT0gbnVsbCA/IGZfMTE4OChmaWVsZF8xMTkwKSA6IG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dF8xMTg5W2ZpZWxkXSA9IGZfMTE4OCh0aGlzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZChuZXh0XzExODkpO1xuICB9XG4gIGFkZFNjb3BlKHNjb3BlXzExOTEsIGJpbmRpbmdzXzExOTIsIHBoYXNlXzExOTMsIG9wdGlvbnNfMTE5NCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KHRlcm1fMTE5NSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRlcm1fMTE5NS5hZGRTY29wZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0ZXJtXzExOTUuYWRkU2NvcGUoc2NvcGVfMTE5MSwgYmluZGluZ3NfMTE5MiwgcGhhc2VfMTE5Mywgb3B0aW9uc18xMTk0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXJtXzExOTU7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlU2NvcGUoc2NvcGVfMTE5NiwgcGhhc2VfMTE5Nykge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KHRlcm1fMTE5OCA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRlcm1fMTE5OC5yZW1vdmVTY29wZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0ZXJtXzExOTgucmVtb3ZlU2NvcGUoc2NvcGVfMTE5NiwgcGhhc2VfMTE5Nyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVybV8xMTk4O1xuICAgIH0pO1xuICB9XG4gIGxpbmVOdW1iZXIoKSB7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzSW5fMTE4MSh0aGlzKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXSAmJiB0aGlzW2ZpZWxkXS5saW5lTnVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZmllbGRdLmxpbmVOdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0TGluZU51bWJlcihsaW5lXzExOTkpIHtcbiAgICBsZXQgbmV4dF8xMjAwID0ge307XG4gICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzSW5fMTE4MSh0aGlzKSkge1xuICAgICAgaWYgKHRoaXNbZmllbGRdID09IG51bGwpIHtcbiAgICAgICAgbmV4dF8xMjAwW2ZpZWxkXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXS5zZXRMaW5lTnVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbmV4dF8xMjAwW2ZpZWxkXSA9IHRoaXNbZmllbGRdLnNldExpbmVOdW1iZXIobGluZV8xMTk5KTtcbiAgICAgIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodGhpc1tmaWVsZF0pKSB7XG4gICAgICAgIG5leHRfMTIwMFtmaWVsZF0gPSB0aGlzW2ZpZWxkXS5tYXAoZl8xMjAxID0+IGZfMTIwMS5zZXRMaW5lTnVtYmVyKGxpbmVfMTE5OSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dF8xMjAwW2ZpZWxkXSA9IHRoaXNbZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0odGhpcy50eXBlLCBuZXh0XzEyMDApO1xuICB9XG59XG5jb25zdCBpc0JpbmRpbmdXaXRoRGVmYXVsdF8xMDgxID0gUi53aGVyZUVxKHt0eXBlOiBcIkJpbmRpbmdXaXRoRGVmYXVsdFwifSk7XG47XG5jb25zdCBpc0JpbmRpbmdJZGVudGlmaWVyXzEwODIgPSBSLndoZXJlRXEoe3R5cGU6IFwiQmluZGluZ0lkZW50aWZpZXJcIn0pO1xuO1xuY29uc3QgaXNBcnJheUJpbmRpbmdfMTA4MyA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJheUJpbmRpbmdcIn0pO1xuO1xuY29uc3QgaXNPYmplY3RCaW5kaW5nXzEwODQgPSBSLndoZXJlRXEoe3R5cGU6IFwiT2JqZWN0QmluZGluZ1wifSk7XG47XG5jb25zdCBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJfMTA4NSA9IFIud2hlcmVFcSh7dHlwZTogXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCJ9KTtcbjtcbmNvbnN0IGlzQmluZGluZ1Byb3BlcnR5UHJvcGVydHlfMTA4NiA9IFIud2hlcmVFcSh7dHlwZTogXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCJ9KTtcbjtcbmNvbnN0IGlzQ2xhc3NFeHByZXNzaW9uXzEwODcgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ2xhc3NFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQ2xhc3NEZWNsYXJhdGlvbl8xMDg4ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNsYXNzRGVjbGFyYXRpb25cIn0pO1xuO1xuY29uc3QgaXNDbGFzc0VsZW1lbnRfMTA4OSA9IFIud2hlcmVFcSh7dHlwZTogXCJDbGFzc0VsZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNNb2R1bGVfMTA5MCA9IFIud2hlcmVFcSh7dHlwZTogXCJNb2R1bGVcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnRfMTA5MSA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnRcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnROYW1lc3BhY2VfMTA5MiA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnROYW1lc3BhY2VcIn0pO1xuO1xuY29uc3QgaXNJbXBvcnRTcGVjaWZpZXJfMTA5MyA9IFIud2hlcmVFcSh7dHlwZTogXCJJbXBvcnRTcGVjaWZpZXJcIn0pO1xuO1xuY29uc3QgaXNFeHBvcnRBbGxGcm9tXzEwOTQgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwb3J0QWxsRnJvbVwifSk7XG47XG5jb25zdCBpc0V4cG9ydEZyb21fMTA5NSA9IFIud2hlcmVFcSh7dHlwZTogXCJFeHBvcnRGcm9tXCJ9KTtcbjtcbmNvbnN0IGlzRXhwb3J0XzEwOTYgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwb3J0XCJ9KTtcbjtcbmNvbnN0IGlzRXhwb3J0RGVmYXVsdF8xMDk3ID0gUi53aGVyZUVxKHt0eXBlOiBcIkV4cG9ydERlZmF1bHRcIn0pO1xuO1xuY29uc3QgaXNFeHBvcnRTcGVjaWZpZXJfMTA5OCA9IFIud2hlcmVFcSh7dHlwZTogXCJFeHBvcnRTcGVjaWZpZXJcIn0pO1xuO1xuY29uc3QgaXNNZXRob2RfMTA5OSA9IFIud2hlcmVFcSh7dHlwZTogXCJNZXRob2RcIn0pO1xuO1xuY29uc3QgaXNHZXR0ZXJfMTEwMCA9IFIud2hlcmVFcSh7dHlwZTogXCJHZXR0ZXJcIn0pO1xuO1xuY29uc3QgaXNTZXR0ZXJfMTEwMSA9IFIud2hlcmVFcSh7dHlwZTogXCJTZXR0ZXJcIn0pO1xuO1xuY29uc3QgaXNEYXRhUHJvcGVydHlfMTEwMiA9IFIud2hlcmVFcSh7dHlwZTogXCJEYXRhUHJvcGVydHlcIn0pO1xuO1xuY29uc3QgaXNTaG9ydGhhbmRQcm9wZXJ0eV8xMTAzID0gUi53aGVyZUVxKHt0eXBlOiBcIlNob3J0aGFuZFByb3BlcnR5XCJ9KTtcbjtcbmNvbnN0IGlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWVfMTEwNCA9IFIud2hlcmVFcSh7dHlwZTogXCJDb21wdXRlZFByb3BlcnR5TmFtZVwifSk7XG47XG5jb25zdCBpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTA1ID0gUi53aGVyZUVxKHt0eXBlOiBcIlN0YXRpY1Byb3BlcnR5TmFtZVwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxCb29sZWFuRXhwcmVzc2lvbl8xMTA2ID0gUi53aGVyZUVxKHt0eXBlOiBcIkxpdGVyYWxCb29sZWFuRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxJbmZpbml0eUV4cHJlc3Npb25fMTEwNyA9IFIud2hlcmVFcSh7dHlwZTogXCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbE51bGxFeHByZXNzaW9uXzExMDggPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbE51bGxFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXzExMDkgPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25fMTExMCA9IFIud2hlcmVFcSh7dHlwZTogXCJMaXRlcmFsUmVnRXhwRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uXzExMTEgPSBSLndoZXJlRXEoe3R5cGU6IFwiTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBcnJheUV4cHJlc3Npb25fMTExMiA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJheUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBcnJvd0V4cHJlc3Npb25fMTExMyA9IFIud2hlcmVFcSh7dHlwZTogXCJBcnJvd0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTE0ID0gUi53aGVyZUVxKHt0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQmluYXJ5RXhwcmVzc2lvbl8xMTE1ID0gUi53aGVyZUVxKHt0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDYWxsRXhwcmVzc2lvbl8xMTE2ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTE3ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNvbXB1dGVkQXNzaWdubWVudEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb25fMTExOCA9IFIud2hlcmVFcSh7dHlwZTogXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNDb25kaXRpb25hbEV4cHJlc3Npb25fMTExOSA9IFIud2hlcmVFcSh7dHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyMCA9IFIud2hlcmVFcSh7dHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNJZGVudGlmaWVyRXhwcmVzc2lvbl8xMTIxID0gUi53aGVyZUVxKHt0eXBlOiBcIklkZW50aWZpZXJFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzTmV3RXhwcmVzc2lvbl8xMTIyID0gUi53aGVyZUVxKHt0eXBlOiBcIk5ld0V4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNOZXdUYXJnZXRFeHByZXNzaW9uXzExMjMgPSBSLndoZXJlRXEoe3R5cGU6IFwiTmV3VGFyZ2V0RXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc09iamVjdEV4cHJlc3Npb25fMTEyNCA9IFIud2hlcmVFcSh7dHlwZTogXCJPYmplY3RFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzVW5hcnlFeHByZXNzaW9uXzExMjUgPSBSLndoZXJlRXEoe3R5cGU6IFwiVW5hcnlFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTI2ID0gUi53aGVyZUVxKHt0eXBlOiBcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNUZW1wbGF0ZUV4cHJlc3Npb25fMTEyNyA9IFIud2hlcmVFcSh7dHlwZTogXCJUZW1wbGF0ZUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNUaGlzRXhwcmVzc2lvbl8xMTI4ID0gUi53aGVyZUVxKHt0eXBlOiBcIlRoaXNFeHByZXNzaW9uXCJ9KTtcbjtcbmNvbnN0IGlzVXBkYXRlRXhwcmVzc2lvbl8xMTI5ID0gUi53aGVyZUVxKHt0eXBlOiBcIlVwZGF0ZUV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNZaWVsZEV4cHJlc3Npb25fMTEzMCA9IFIud2hlcmVFcSh7dHlwZTogXCJZaWVsZEV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25fMTEzMSA9IFIud2hlcmVFcSh7dHlwZTogXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIn0pO1xuO1xuY29uc3QgaXNCbG9ja1N0YXRlbWVudF8xMTMyID0gUi53aGVyZUVxKHt0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzQnJlYWtTdGF0ZW1lbnRfMTEzMyA9IFIud2hlcmVFcSh7dHlwZTogXCJCcmVha1N0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0NvbnRpbnVlU3RhdGVtZW50XzExMzQgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExMzUgPSBSLndoZXJlRXEoe3R5cGU6IFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0RlYnVnZ2VyU3RhdGVtZW50XzExMzYgPSBSLndoZXJlRXEoe3R5cGU6IFwiRGVidWdnZXJTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNEb1doaWxlU3RhdGVtZW50XzExMzcgPSBSLndoZXJlRXEoe3R5cGU6IFwiRG9XaGlsZVN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0VtcHR5U3RhdGVtZW50XzExMzggPSBSLndoZXJlRXEoe3R5cGU6IFwiRW1wdHlTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNFeHByZXNzaW9uU3RhdGVtZW50XzExMzkgPSBSLndoZXJlRXEoe3R5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0ZvckluU3RhdGVtZW50XzExNDAgPSBSLndoZXJlRXEoe3R5cGU6IFwiRm9ySW5TdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNGb3JPZlN0YXRlbWVudF8xMTQxID0gUi53aGVyZUVxKHt0eXBlOiBcIkZvck9mU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzRm9yU3RhdGVtZW50XzExNDIgPSBSLndoZXJlRXEoe3R5cGU6IFwiRm9yU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzSWZTdGF0ZW1lbnRfMTE0MyA9IFIud2hlcmVFcSh7dHlwZTogXCJJZlN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc0xhYmVsZWRTdGF0ZW1lbnRfMTE0NCA9IFIud2hlcmVFcSh7dHlwZTogXCJMYWJlbGVkU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzUmV0dXJuU3RhdGVtZW50XzExNDUgPSBSLndoZXJlRXEoe3R5cGU6IFwiUmV0dXJuU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoU3RhdGVtZW50XzExNDYgPSBSLndoZXJlRXEoe3R5cGU6IFwiU3dpdGNoU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHRfMTE0NyA9IFIud2hlcmVFcSh7dHlwZTogXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwifSk7XG47XG5jb25zdCBpc1Rocm93U3RhdGVtZW50XzExNDggPSBSLndoZXJlRXEoe3R5cGU6IFwiVGhyb3dTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNUcnlDYXRjaFN0YXRlbWVudF8xMTQ5ID0gUi53aGVyZUVxKHt0eXBlOiBcIlRyeUNhdGNoU3RhdGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzVHJ5RmluYWxseVN0YXRlbWVudF8xMTUwID0gUi53aGVyZUVxKHt0eXBlOiBcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XzExNTEgPSBSLndoZXJlRXEoe3R5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc1doaWxlU3RhdGVtZW50XzExNTIgPSBSLndoZXJlRXEoe3R5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNXaXRoU3RhdGVtZW50XzExNTMgPSBSLndoZXJlRXEoe3R5cGU6IFwiV2l0aFN0YXRlbWVudFwifSk7XG47XG5jb25zdCBpc1ByYWdtYV8xMTU0ID0gUi53aGVyZUVxKHt0eXBlOiBcIlByYWdtYVwifSk7XG47XG5jb25zdCBpc0Jsb2NrXzExNTUgPSBSLndoZXJlRXEoe3R5cGU6IFwiQmxvY2tcIn0pO1xuO1xuY29uc3QgaXNDYXRjaENsYXVzZV8xMTU2ID0gUi53aGVyZUVxKHt0eXBlOiBcIkNhdGNoQ2xhdXNlXCJ9KTtcbjtcbmNvbnN0IGlzRGlyZWN0aXZlXzExNTcgPSBSLndoZXJlRXEoe3R5cGU6IFwiRGlyZWN0aXZlXCJ9KTtcbjtcbmNvbnN0IGlzRm9ybWFsUGFyYW1ldGVyc18xMTU4ID0gUi53aGVyZUVxKHt0eXBlOiBcIkZvcm1hbFBhcmFtZXRlcnNcIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkJvZHlfMTE1OSA9IFIud2hlcmVFcSh7dHlwZTogXCJGdW5jdGlvbkJvZHlcIn0pO1xuO1xuY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uXzExNjAgPSBSLndoZXJlRXEoe3R5cGU6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwifSk7XG47XG5jb25zdCBpc1NjcmlwdF8xMTYxID0gUi53aGVyZUVxKHt0eXBlOiBcIlNjcmlwdFwifSk7XG47XG5jb25zdCBpc1NwcmVhZEVsZW1lbnRfMTE2MiA9IFIud2hlcmVFcSh7dHlwZTogXCJTcHJlYWRFbGVtZW50XCJ9KTtcbjtcbmNvbnN0IGlzU3VwZXJfMTE2MyA9IFIud2hlcmVFcSh7dHlwZTogXCJTdXBlclwifSk7XG47XG5jb25zdCBpc1N3aXRjaENhc2VfMTE2NCA9IFIud2hlcmVFcSh7dHlwZTogXCJTd2l0Y2hDYXNlXCJ9KTtcbjtcbmNvbnN0IGlzU3dpdGNoRGVmYXVsdF8xMTY1ID0gUi53aGVyZUVxKHt0eXBlOiBcIlN3aXRjaERlZmF1bHRcIn0pO1xuO1xuY29uc3QgaXNUZW1wbGF0ZUVsZW1lbnRfMTE2NiA9IFIud2hlcmVFcSh7dHlwZTogXCJUZW1wbGF0ZUVsZW1lbnRcIn0pO1xuO1xuY29uc3QgaXNTeW50YXhUZW1wbGF0ZV8xMTY3ID0gUi53aGVyZUVxKHt0eXBlOiBcIlN5bnRheFRlbXBsYXRlXCJ9KTtcbjtcbmNvbnN0IGlzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTY4ID0gUi53aGVyZUVxKHt0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIn0pO1xuO1xuY29uc3QgaXNWYXJpYWJsZURlY2xhcmF0b3JfMTE2OSA9IFIud2hlcmVFcSh7dHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIn0pO1xuO1xuY29uc3QgaXNFT0ZfMTE3MCA9IFIud2hlcmVFcSh7dHlwZTogXCJFT0ZcIn0pO1xuO1xuY29uc3QgaXNTeW50YXhEZWNsYXJhdGlvbl8xMTcxID0gUi5ib3RoKGlzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTY4LCBSLndoZXJlRXEoe2tpbmQ6IFwic3ludGF4XCJ9KSk7XG47XG5jb25zdCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uXzExNzIgPSBSLmJvdGgoaXNWYXJpYWJsZURlY2xhcmF0aW9uXzExNjgsIFIud2hlcmVFcSh7a2luZDogXCJzeW50YXhyZWNcIn0pKTtcbjtcbmNvbnN0IGlzRnVuY3Rpb25UZXJtXzExNzMgPSBSLmVpdGhlcihpc0Z1bmN0aW9uRGVjbGFyYXRpb25fMTE2MCwgaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyMCk7XG47XG5jb25zdCBpc0Z1bmN0aW9uV2l0aE5hbWVfMTE3NCA9IFIuYW5kKGlzRnVuY3Rpb25UZXJtXzExNzMsIFIuY29tcGxlbWVudChSLndoZXJlKHtuYW1lOiBSLmlzTmlsfSkpKTtcbjtcbmNvbnN0IGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25fMTE3NSA9IFIud2hlcmVFcSh7dHlwZTogXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwifSk7XG47XG5jb25zdCBpc0V4cG9ydFN5bnRheF8xMTc2ID0gUi5ib3RoKGlzRXhwb3J0XzEwOTYsIGV4cF8xMjAyID0+IFIub3IoaXNTeW50YXhEZWNsYXJhdGlvbl8xMTcxKGV4cF8xMjAyLmRlY2xhcmF0aW9uKSwgaXNTeW50YXhyZWNEZWNsYXJhdGlvbl8xMTcyKGV4cF8xMjAyLmRlY2xhcmF0aW9uKSkpO1xuO1xuY29uc3QgaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudF8xMTc3ID0gUi5ib3RoKGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTUxLCBkZWNsXzEyMDMgPT4gaXNDb21waWxldGltZURlY2xhcmF0aW9uXzExNzgoZGVjbF8xMjAzLmRlY2xhcmF0aW9uKSk7XG47XG5jb25zdCBpc0NvbXBpbGV0aW1lRGVjbGFyYXRpb25fMTE3OCA9IFIuZWl0aGVyKGlzU3ludGF4RGVjbGFyYXRpb25fMTE3MSwgaXNTeW50YXhyZWNEZWNsYXJhdGlvbl8xMTcyKTtcbjtcbmNvbnN0IGlzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE3OSA9IHRlcm1fMTIwNCA9PiB7XG4gIHJldHVybiB0ZXJtXzEyMDQgaW5zdGFuY2VvZiBUZXJtICYmIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTUxKHRlcm1fMTIwNCkgJiYgaXNDb21waWxldGltZURlY2xhcmF0aW9uXzExNzgodGVybV8xMjA0LmRlY2xhcmF0aW9uKTtcbn07XG47XG5jb25zdCBpc0ltcG9ydERlY2xhcmF0aW9uXzExODAgPSBSLmVpdGhlcihpc0ltcG9ydF8xMDkxLCBpc0ltcG9ydE5hbWVzcGFjZV8xMDkyKTtcbjtcbmNvbnN0IGZpZWxkc0luXzExODEgPSBSLmNvbmQoW1tpc0JpbmRpbmdXaXRoRGVmYXVsdF8xMDgxLCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzQmluZGluZ0lkZW50aWZpZXJfMTA4MiwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIikpXSwgW2lzQXJyYXlCaW5kaW5nXzEwODMsIFIuYWx3YXlzKExpc3Qub2YoXCJlbGVtZW50c1wiLCBcInJlc3RFbGVtZW50XCIpKV0sIFtpc09iamVjdEJpbmRpbmdfMTA4NCwgUi5hbHdheXMoTGlzdC5vZihcInByb3BlcnRpZXNcIikpXSwgW2lzQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcl8xMDg1LCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzQmluZGluZ1Byb3BlcnR5UHJvcGVydHlfMTA4NiwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJiaW5kaW5nXCIpKV0sIFtpc0NsYXNzRXhwcmVzc2lvbl8xMDg3LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcInN1cGVyXCIsIFwiZWxlbWVudHNcIikpXSwgW2lzQ2xhc3NEZWNsYXJhdGlvbl8xMDg4LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcInN1cGVyXCIsIFwiZWxlbWVudHNcIikpXSwgW2lzQ2xhc3NFbGVtZW50XzEwODksIFIuYWx3YXlzKExpc3Qub2YoXCJpc1N0YXRpY1wiLCBcIm1ldGhvZFwiKSldLCBbaXNNb2R1bGVfMTA5MCwgUi5hbHdheXMoTGlzdC5vZihcImRpcmVjdGl2ZXNcIiwgXCJpdGVtc1wiKSldLCBbaXNJbXBvcnRfMTA5MSwgUi5hbHdheXMoTGlzdC5vZihcIm1vZHVsZVNwZWNpZmllclwiLCBcImRlZmF1bHRCaW5kaW5nXCIsIFwibmFtZWRJbXBvcnRzXCIsIFwiZm9yU3ludGF4XCIpKV0sIFtpc0ltcG9ydE5hbWVzcGFjZV8xMDkyLCBSLmFsd2F5cyhMaXN0Lm9mKFwibW9kdWxlU3BlY2lmaWVyXCIsIFwiZGVmYXVsdEJpbmRpbmdcIiwgXCJuYW1lc3BhY2VCaW5kaW5nXCIpKV0sIFtpc0ltcG9ydFNwZWNpZmllcl8xMDkzLCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJpbmRpbmdcIikpXSwgW2lzRXhwb3J0QWxsRnJvbV8xMDk0LCBSLmFsd2F5cyhMaXN0Lm9mKFwibW9kdWxlU3BlY2lmaWVyXCIpKV0sIFtpc0V4cG9ydEZyb21fMTA5NSwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVkRXhwb3J0c1wiLCBcIm1vZHVsZVNwZWNpZmllclwiKSldLCBbaXNFeHBvcnRfMTA5NiwgUi5hbHdheXMoTGlzdC5vZihcImRlY2xhcmF0aW9uXCIpKV0sIFtpc0V4cG9ydERlZmF1bHRfMTA5NywgUi5hbHdheXMoTGlzdC5vZihcImJvZHlcIikpXSwgW2lzRXhwb3J0U3BlY2lmaWVyXzEwOTgsIFIuYWx3YXlzKExpc3Qub2YoXCJuYW1lXCIsIFwiZXhwb3J0ZWROYW1lXCIpKV0sIFtpc01ldGhvZF8xMDk5LCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJvZHlcIiwgXCJpc0dlbmVyYXRvclwiLCBcInBhcmFtc1wiKSldLCBbaXNHZXR0ZXJfMTEwMCwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJib2R5XCIpKV0sIFtpc1NldHRlcl8xMTAxLCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImJvZHlcIiwgXCJwYXJhbVwiKSldLCBbaXNEYXRhUHJvcGVydHlfMTEwMiwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc1Nob3J0aGFuZFByb3BlcnR5XzExMDMsIFIuYWx3YXlzKExpc3Qub2YoXCJleHByZXNzaW9uXCIpKV0sIFtpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTA1LCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uXzExMDYsIFIuYWx3YXlzKExpc3Qub2YoXCJ2YWx1ZVwiKSldLCBbaXNMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXzExMDcsIFIuYWx3YXlzKExpc3QoKSldLCBbaXNMaXRlcmFsTnVsbEV4cHJlc3Npb25fMTEwOCwgUi5hbHdheXMoTGlzdCgpKV0sIFtpc0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbl8xMTA5LCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25fMTExMCwgUi5hbHdheXMoTGlzdC5vZihcInBhdHRlcm5cIiwgXCJmbGFnc1wiKSldLCBbaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbl8xMTExLCBSLmFsd2F5cyhMaXN0Lm9mKFwidmFsdWVcIikpXSwgW2lzQXJyYXlFeHByZXNzaW9uXzExMTIsIFIuYWx3YXlzKExpc3Qub2YoXCJlbGVtZW50c1wiKSldLCBbaXNBcnJvd0V4cHJlc3Npb25fMTExMywgUi5hbHdheXMoTGlzdC5vZihcInBhcmFtc1wiLCBcImJvZHlcIikpXSwgW2lzQXNzaWdubWVudEV4cHJlc3Npb25fMTExNCwgUi5hbHdheXMoTGlzdC5vZihcImJpbmRpbmdcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc0JpbmFyeUV4cHJlc3Npb25fMTExNSwgUi5hbHdheXMoTGlzdC5vZihcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIpKV0sIFtpc0NhbGxFeHByZXNzaW9uXzExMTYsIFIuYWx3YXlzKExpc3Qub2YoXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIikpXSwgW2lzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTE3LCBSLmFsd2F5cyhMaXN0Lm9mKFwib3BlcmF0b3JcIiwgXCJiaW5kaW5nXCIsIFwiZXhwcmVzc2lvblwiKSldLCBbaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb25fMTExOCwgUi5hbHdheXMoTGlzdC5vZihcIm9iamVjdFwiLCBcImV4cHJlc3Npb25cIikpXSwgW2lzQ29uZGl0aW9uYWxFeHByZXNzaW9uXzExMTksIFIuYWx3YXlzKExpc3Qub2YoXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiKSldLCBbaXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyMCwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIiwgXCJpc0dlbmVyYXRvclwiLCBcInBhcmFtc1wiLCBcImJvZHlcIikpXSwgW2lzSWRlbnRpZmllckV4cHJlc3Npb25fMTEyMSwgUi5hbHdheXMoTGlzdC5vZihcIm5hbWVcIikpXSwgW2lzTmV3RXhwcmVzc2lvbl8xMTIyLCBSLmFsd2F5cyhMaXN0Lm9mKFwiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIpKV0sIFtpc05ld1RhcmdldEV4cHJlc3Npb25fMTEyMywgUi5hbHdheXMoTGlzdCgpKV0sIFtpc09iamVjdEV4cHJlc3Npb25fMTEyNCwgUi5hbHdheXMoTGlzdC5vZihcInByb3BlcnRpZXNcIikpXSwgW2lzVW5hcnlFeHByZXNzaW9uXzExMjUsIFIuYWx3YXlzKExpc3Qub2YoXCJvcGVyYXRvclwiLCBcIm9wZXJhbmRcIikpXSwgW2lzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTI2LCBSLmFsd2F5cyhMaXN0Lm9mKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIikpXSwgW2lzVGVtcGxhdGVFeHByZXNzaW9uXzExMjcsIFIuYWx3YXlzKExpc3Qub2YoXCJ0YWdcIiwgXCJlbGVtZW50c1wiKSldLCBbaXNUaGlzRXhwcmVzc2lvbl8xMTI4LCBSLmFsd2F5cyhMaXN0KCkpXSwgW2lzVXBkYXRlRXhwcmVzc2lvbl8xMTI5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiaXNQcmVmaXhcIiwgXCJvcGVyYXRvclwiLCBcIm9wZXJhbmRcIikpXSwgW2lzWWllbGRFeHByZXNzaW9uXzExMzAsIFIuYWx3YXlzKExpc3Qub2YoXCJleHByZXNzaW9uXCIpKV0sIFtpc1lpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbl8xMTMxLCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNCbG9ja1N0YXRlbWVudF8xMTMyLCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmxvY2tcIikpXSwgW2lzQnJlYWtTdGF0ZW1lbnRfMTEzMywgUi5hbHdheXMoTGlzdC5vZihcImxhYmVsXCIpKV0sIFtpc0NvbnRpbnVlU3RhdGVtZW50XzExMzQsIFIuYWx3YXlzKExpc3Qub2YoXCJsYWJlbFwiKSldLCBbaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExMzUsIFIuYWx3YXlzKExpc3Qub2YoXCJiaW5kaW5nXCIsIFwib3BlcmF0b3JcIiwgXCJleHByZXNzaW9uXCIpKV0sIFtpc0RlYnVnZ2VyU3RhdGVtZW50XzExMzYsIFIuYWx3YXlzKExpc3QoKSldLCBbaXNEb1doaWxlU3RhdGVtZW50XzExMzcsIFIuYWx3YXlzKExpc3Qub2YoXCJ0ZXN0XCIsIFwiYm9keVwiKSldLCBbaXNFbXB0eVN0YXRlbWVudF8xMTM4LCBSLmFsd2F5cyhMaXN0KCkpXSwgW2lzRXhwcmVzc2lvblN0YXRlbWVudF8xMTM5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNGb3JJblN0YXRlbWVudF8xMTQwLCBSLmFsd2F5cyhMaXN0Lm9mKFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiKSldLCBbaXNGb3JPZlN0YXRlbWVudF8xMTQxLCBSLmFsd2F5cyhMaXN0Lm9mKFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiKSldLCBbaXNGb3JTdGF0ZW1lbnRfMTE0MiwgUi5hbHdheXMoTGlzdC5vZihcImluaXRcIiwgXCJ0ZXN0XCIsIFwidXBkYXRlXCIsIFwiYm9keVwiKSldLCBbaXNJZlN0YXRlbWVudF8xMTQzLCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIikpXSwgW2lzTGFiZWxlZFN0YXRlbWVudF8xMTQ0LCBSLmFsd2F5cyhMaXN0Lm9mKFwibGFiZWxcIiwgXCJib2R5XCIpKV0sIFtpc1JldHVyblN0YXRlbWVudF8xMTQ1LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZXhwcmVzc2lvblwiKSldLCBbaXNTd2l0Y2hTdGF0ZW1lbnRfMTE0NiwgUi5hbHdheXMoTGlzdC5vZihcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCIpKV0sIFtpc1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0XzExNDcsIFIuYWx3YXlzKExpc3Qub2YoXCJkaXNjcmltaW5hbnRcIiwgXCJwcmVEZWZhdWx0Q2FzZXNcIiwgXCJkZWZhdWx0Q2FzZVwiLCBcInBvc3REZWZhdWx0Q2FzZXNcIikpXSwgW2lzVGhyb3dTdGF0ZW1lbnRfMTE0OCwgUi5hbHdheXMoTGlzdC5vZihcImV4cHJlc3Npb25cIikpXSwgW2lzVHJ5Q2F0Y2hTdGF0ZW1lbnRfMTE0OSwgUi5hbHdheXMoTGlzdC5vZihcImJvZHlcIiwgXCJjYXRjaENsYXVzZVwiKSldLCBbaXNUcnlGaW5hbGx5U3RhdGVtZW50XzExNTAsIFIuYWx3YXlzKExpc3Qub2YoXCJib2R5XCIsIFwiY2F0Y2hDbGF1c2VcIiwgXCJmaW5hbGl6ZXJcIikpXSwgW2lzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTUxLCBSLmFsd2F5cyhMaXN0Lm9mKFwiZGVjbGFyYXRpb25cIikpXSwgW2lzV2l0aFN0YXRlbWVudF8xMTUzLCBSLmFsd2F5cyhMaXN0Lm9mKFwib2JqZWN0XCIsIFwiYm9keVwiKSldLCBbaXNXaGlsZVN0YXRlbWVudF8xMTUyLCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVzdFwiLCBcImJvZHlcIikpXSwgW2lzUHJhZ21hXzExNTQsIFIuYWx3YXlzKExpc3Qub2YoXCJraW5kXCIsIFwiaXRlbXNcIikpXSwgW2lzQmxvY2tfMTE1NSwgUi5hbHdheXMoTGlzdC5vZihcInN0YXRlbWVudHNcIikpXSwgW2lzQ2F0Y2hDbGF1c2VfMTE1NiwgUi5hbHdheXMoTGlzdC5vZihcImJpbmRpbmdcIiwgXCJib2R5XCIpKV0sIFtpc0RpcmVjdGl2ZV8xMTU3LCBSLmFsd2F5cyhMaXN0Lm9mKFwicmF3VmFsdWVcIikpXSwgW2lzRm9ybWFsUGFyYW1ldGVyc18xMTU4LCBSLmFsd2F5cyhMaXN0Lm9mKFwiaXRlbXNcIiwgXCJyZXN0XCIpKV0sIFtpc0Z1bmN0aW9uQm9keV8xMTU5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiZGlyZWN0aXZlc1wiLCBcInN0YXRlbWVudHNcIikpXSwgW2lzRnVuY3Rpb25EZWNsYXJhdGlvbl8xMTYwLCBSLmFsd2F5cyhMaXN0Lm9mKFwibmFtZVwiLCBcImlzR2VuZXJhdG9yXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiKSldLCBbaXNTY3JpcHRfMTE2MSwgUi5hbHdheXMoTGlzdC5vZihcImRpcmVjdGl2ZXNcIiwgXCJzdGF0ZW1lbnRzXCIpKV0sIFtpc1NwcmVhZEVsZW1lbnRfMTE2MiwgUi5hbHdheXMoTGlzdC5vZihcImV4cHJlc3Npb25cIikpXSwgW2lzU3VwZXJfMTE2MywgUi5hbHdheXMoTGlzdCgpKV0sIFtpc1N3aXRjaENhc2VfMTE2NCwgUi5hbHdheXMoTGlzdC5vZihcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIpKV0sIFtpc1N3aXRjaERlZmF1bHRfMTE2NSwgUi5hbHdheXMoTGlzdC5vZihcImNvbnNlcXVlbnRcIikpXSwgW2lzVGVtcGxhdGVFbGVtZW50XzExNjYsIFIuYWx3YXlzKExpc3Qub2YoXCJyYXdWYWx1ZVwiKSldLCBbaXNTeW50YXhUZW1wbGF0ZV8xMTY3LCBSLmFsd2F5cyhMaXN0Lm9mKFwidGVtcGxhdGVcIikpXSwgW2lzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTY4LCBSLmFsd2F5cyhMaXN0Lm9mKFwia2luZFwiLCBcImRlY2xhcmF0b3JzXCIpKV0sIFtpc1ZhcmlhYmxlRGVjbGFyYXRvcl8xMTY5LCBSLmFsd2F5cyhMaXN0Lm9mKFwiYmluZGluZ1wiLCBcImluaXRcIikpXSwgW2lzUGFyZW50aGVzaXplZEV4cHJlc3Npb25fMTE3NSwgUi5hbHdheXMoTGlzdC5vZihcImlubmVyXCIpKV0sIFtSLlQsIHR5cGVfMTIwNSA9PiBhc3NlcnQoZmFsc2UsIFwiTWlzc2luZyBjYXNlIGluIGZpZWxkczogXCIgKyB0eXBlXzEyMDUudHlwZSldXSk7XG5leHBvcnQge2lzQmluZGluZ1dpdGhEZWZhdWx0XzEwODEgYXMgaXNCaW5kaW5nV2l0aERlZmF1bHR9O1xuZXhwb3J0IHtpc0JpbmRpbmdJZGVudGlmaWVyXzEwODIgYXMgaXNCaW5kaW5nSWRlbnRpZmllcn07XG5leHBvcnQge2lzQXJyYXlCaW5kaW5nXzEwODMgYXMgaXNBcnJheUJpbmRpbmd9O1xuZXhwb3J0IHtpc09iamVjdEJpbmRpbmdfMTA4NCBhcyBpc09iamVjdEJpbmRpbmd9O1xuZXhwb3J0IHtpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJfMTA4NSBhcyBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJ9O1xuZXhwb3J0IHtpc0JpbmRpbmdQcm9wZXJ0eVByb3BlcnR5XzEwODYgYXMgaXNCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eX07XG5leHBvcnQge2lzQ2xhc3NFeHByZXNzaW9uXzEwODcgYXMgaXNDbGFzc0V4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NsYXNzRGVjbGFyYXRpb25fMTA4OCBhcyBpc0NsYXNzRGVjbGFyYXRpb259O1xuZXhwb3J0IHtpc0NsYXNzRWxlbWVudF8xMDg5IGFzIGlzQ2xhc3NFbGVtZW50fTtcbmV4cG9ydCB7aXNNb2R1bGVfMTA5MCBhcyBpc01vZHVsZX07XG5leHBvcnQge2lzSW1wb3J0XzEwOTEgYXMgaXNJbXBvcnR9O1xuZXhwb3J0IHtpc0ltcG9ydE5hbWVzcGFjZV8xMDkyIGFzIGlzSW1wb3J0TmFtZXNwYWNlfTtcbmV4cG9ydCB7aXNJbXBvcnRTcGVjaWZpZXJfMTA5MyBhcyBpc0ltcG9ydFNwZWNpZmllcn07XG5leHBvcnQge2lzRXhwb3J0QWxsRnJvbV8xMDk0IGFzIGlzRXhwb3J0QWxsRnJvbX07XG5leHBvcnQge2lzRXhwb3J0RnJvbV8xMDk1IGFzIGlzRXhwb3J0RnJvbX07XG5leHBvcnQge2lzRXhwb3J0XzEwOTYgYXMgaXNFeHBvcnR9O1xuZXhwb3J0IHtpc0V4cG9ydERlZmF1bHRfMTA5NyBhcyBpc0V4cG9ydERlZmF1bHR9O1xuZXhwb3J0IHtpc0V4cG9ydFNwZWNpZmllcl8xMDk4IGFzIGlzRXhwb3J0U3BlY2lmaWVyfTtcbmV4cG9ydCB7aXNNZXRob2RfMTA5OSBhcyBpc01ldGhvZH07XG5leHBvcnQge2lzR2V0dGVyXzExMDAgYXMgaXNHZXR0ZXJ9O1xuZXhwb3J0IHtpc1NldHRlcl8xMTAxIGFzIGlzU2V0dGVyfTtcbmV4cG9ydCB7aXNEYXRhUHJvcGVydHlfMTEwMiBhcyBpc0RhdGFQcm9wZXJ0eX07XG5leHBvcnQge2lzU2hvcnRoYW5kUHJvcGVydHlfMTEwMyBhcyBpc1Nob3J0aGFuZFByb3BlcnR5fTtcbmV4cG9ydCB7aXNDb21wdXRlZFByb3BlcnR5TmFtZV8xMTA0IGFzIGlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWV9O1xuZXhwb3J0IHtpc1N0YXRpY1Byb3BlcnR5TmFtZV8xMTA1IGFzIGlzU3RhdGljUHJvcGVydHlOYW1lfTtcbmV4cG9ydCB7aXNMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb25fMTEwNiBhcyBpc0xpdGVyYWxCb29sZWFuRXhwcmVzc2lvbn07XG5leHBvcnQge2lzTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbl8xMTA3IGFzIGlzTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbn07XG5leHBvcnQge2lzTGl0ZXJhbE51bGxFeHByZXNzaW9uXzExMDggYXMgaXNMaXRlcmFsTnVsbEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbl8xMTA5IGFzIGlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbl8xMTEwIGFzIGlzTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uXzExMTEgYXMgaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbn07XG5leHBvcnQge2lzQXJyYXlFeHByZXNzaW9uXzExMTIgYXMgaXNBcnJheUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0Fycm93RXhwcmVzc2lvbl8xMTEzIGFzIGlzQXJyb3dFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTE0IGFzIGlzQXNzaWdubWVudEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0JpbmFyeUV4cHJlc3Npb25fMTExNSBhcyBpc0JpbmFyeUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NhbGxFeHByZXNzaW9uXzExMTYgYXMgaXNDYWxsRXhwcmVzc2lvbn07XG5leHBvcnQge2lzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbl8xMTE3IGFzIGlzQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbn07XG5leHBvcnQge2lzQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uXzExMTggYXMgaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb259O1xuZXhwb3J0IHtpc0NvbmRpdGlvbmFsRXhwcmVzc2lvbl8xMTE5IGFzIGlzQ29uZGl0aW9uYWxFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNGdW5jdGlvbkV4cHJlc3Npb25fMTEyMCBhcyBpc0Z1bmN0aW9uRXhwcmVzc2lvbn07XG5leHBvcnQge2lzSWRlbnRpZmllckV4cHJlc3Npb25fMTEyMSBhcyBpc0lkZW50aWZpZXJFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNOZXdFeHByZXNzaW9uXzExMjIgYXMgaXNOZXdFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNOZXdUYXJnZXRFeHByZXNzaW9uXzExMjMgYXMgaXNOZXdUYXJnZXRFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNPYmplY3RFeHByZXNzaW9uXzExMjQgYXMgaXNPYmplY3RFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNVbmFyeUV4cHJlc3Npb25fMTEyNSBhcyBpc1VuYXJ5RXhwcmVzc2lvbn07XG5leHBvcnQge2lzU3RhdGljTWVtYmVyRXhwcmVzc2lvbl8xMTI2IGFzIGlzU3RhdGljTWVtYmVyRXhwcmVzc2lvbn07XG5leHBvcnQge2lzVGVtcGxhdGVFeHByZXNzaW9uXzExMjcgYXMgaXNUZW1wbGF0ZUV4cHJlc3Npb259O1xuZXhwb3J0IHtpc1RoaXNFeHByZXNzaW9uXzExMjggYXMgaXNUaGlzRXhwcmVzc2lvbn07XG5leHBvcnQge2lzVXBkYXRlRXhwcmVzc2lvbl8xMTI5IGFzIGlzVXBkYXRlRXhwcmVzc2lvbn07XG5leHBvcnQge2lzWWllbGRFeHByZXNzaW9uXzExMzAgYXMgaXNZaWVsZEV4cHJlc3Npb259O1xuZXhwb3J0IHtpc1lpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbl8xMTMxIGFzIGlzWWllbGRHZW5lcmF0b3JFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNCbG9ja1N0YXRlbWVudF8xMTMyIGFzIGlzQmxvY2tTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0JyZWFrU3RhdGVtZW50XzExMzMgYXMgaXNCcmVha1N0YXRlbWVudH07XG5leHBvcnQge2lzQ29udGludWVTdGF0ZW1lbnRfMTEzNCBhcyBpc0NvbnRpbnVlU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uXzExMzUgYXMgaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9ufTtcbmV4cG9ydCB7aXNEZWJ1Z2dlclN0YXRlbWVudF8xMTM2IGFzIGlzRGVidWdnZXJTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0RvV2hpbGVTdGF0ZW1lbnRfMTEzNyBhcyBpc0RvV2hpbGVTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0VtcHR5U3RhdGVtZW50XzExMzggYXMgaXNFbXB0eVN0YXRlbWVudH07XG5leHBvcnQge2lzRXhwcmVzc2lvblN0YXRlbWVudF8xMTM5IGFzIGlzRXhwcmVzc2lvblN0YXRlbWVudH07XG5leHBvcnQge2lzRm9ySW5TdGF0ZW1lbnRfMTE0MCBhcyBpc0ZvckluU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNGb3JPZlN0YXRlbWVudF8xMTQxIGFzIGlzRm9yT2ZTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0ZvclN0YXRlbWVudF8xMTQyIGFzIGlzRm9yU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNJZlN0YXRlbWVudF8xMTQzIGFzIGlzSWZTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc0xhYmVsZWRTdGF0ZW1lbnRfMTE0NCBhcyBpc0xhYmVsZWRTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc1JldHVyblN0YXRlbWVudF8xMTQ1IGFzIGlzUmV0dXJuU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNTd2l0Y2hTdGF0ZW1lbnRfMTE0NiBhcyBpc1N3aXRjaFN0YXRlbWVudH07XG5leHBvcnQge2lzU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHRfMTE0NyBhcyBpc1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0fTtcbmV4cG9ydCB7aXNUaHJvd1N0YXRlbWVudF8xMTQ4IGFzIGlzVGhyb3dTdGF0ZW1lbnR9O1xuZXhwb3J0IHtpc1RyeUNhdGNoU3RhdGVtZW50XzExNDkgYXMgaXNUcnlDYXRjaFN0YXRlbWVudH07XG5leHBvcnQge2lzVHJ5RmluYWxseVN0YXRlbWVudF8xMTUwIGFzIGlzVHJ5RmluYWxseVN0YXRlbWVudH07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudF8xMTUxIGFzIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudH07XG5leHBvcnQge2lzV2hpbGVTdGF0ZW1lbnRfMTE1MiBhcyBpc1doaWxlU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNXaXRoU3RhdGVtZW50XzExNTMgYXMgaXNXaXRoU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNQcmFnbWFfMTE1NCBhcyBpc1ByYWdtYX07XG5leHBvcnQge2lzQmxvY2tfMTE1NSBhcyBpc0Jsb2NrfTtcbmV4cG9ydCB7aXNDYXRjaENsYXVzZV8xMTU2IGFzIGlzQ2F0Y2hDbGF1c2V9O1xuZXhwb3J0IHtpc0RpcmVjdGl2ZV8xMTU3IGFzIGlzRGlyZWN0aXZlfTtcbmV4cG9ydCB7aXNGb3JtYWxQYXJhbWV0ZXJzXzExNTggYXMgaXNGb3JtYWxQYXJhbWV0ZXJzfTtcbmV4cG9ydCB7aXNGdW5jdGlvbkJvZHlfMTE1OSBhcyBpc0Z1bmN0aW9uQm9keX07XG5leHBvcnQge2lzRnVuY3Rpb25EZWNsYXJhdGlvbl8xMTYwIGFzIGlzRnVuY3Rpb25EZWNsYXJhdGlvbn07XG5leHBvcnQge2lzU2NyaXB0XzExNjEgYXMgaXNTY3JpcHR9O1xuZXhwb3J0IHtpc1NwcmVhZEVsZW1lbnRfMTE2MiBhcyBpc1NwcmVhZEVsZW1lbnR9O1xuZXhwb3J0IHtpc1N1cGVyXzExNjMgYXMgaXNTdXBlcn07XG5leHBvcnQge2lzU3dpdGNoQ2FzZV8xMTY0IGFzIGlzU3dpdGNoQ2FzZX07XG5leHBvcnQge2lzU3dpdGNoRGVmYXVsdF8xMTY1IGFzIGlzU3dpdGNoRGVmYXVsdH07XG5leHBvcnQge2lzVGVtcGxhdGVFbGVtZW50XzExNjYgYXMgaXNUZW1wbGF0ZUVsZW1lbnR9O1xuZXhwb3J0IHtpc1N5bnRheFRlbXBsYXRlXzExNjcgYXMgaXNTeW50YXhUZW1wbGF0ZX07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdGlvbl8xMTY4IGFzIGlzVmFyaWFibGVEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzVmFyaWFibGVEZWNsYXJhdG9yXzExNjkgYXMgaXNWYXJpYWJsZURlY2xhcmF0b3J9O1xuZXhwb3J0IHtpc0VPRl8xMTcwIGFzIGlzRU9GfTtcbmV4cG9ydCB7aXNTeW50YXhEZWNsYXJhdGlvbl8xMTcxIGFzIGlzU3ludGF4RGVjbGFyYXRpb259O1xuZXhwb3J0IHtpc1N5bnRheHJlY0RlY2xhcmF0aW9uXzExNzIgYXMgaXNTeW50YXhyZWNEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzRnVuY3Rpb25UZXJtXzExNzMgYXMgaXNGdW5jdGlvblRlcm19O1xuZXhwb3J0IHtpc0Z1bmN0aW9uV2l0aE5hbWVfMTE3NCBhcyBpc0Z1bmN0aW9uV2l0aE5hbWV9O1xuZXhwb3J0IHtpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uXzExNzUgYXMgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbn07XG5leHBvcnQge2lzRXhwb3J0U3ludGF4XzExNzYgYXMgaXNFeHBvcnRTeW50YXh9O1xuZXhwb3J0IHtpc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50XzExNzcgYXMgaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudH07XG5leHBvcnQge2lzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbl8xMTc4IGFzIGlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbn07XG5leHBvcnQge2lzQ29tcGlsZXRpbWVTdGF0ZW1lbnRfMTE3OSBhcyBpc0NvbXBpbGV0aW1lU3RhdGVtZW50fTtcbmV4cG9ydCB7aXNJbXBvcnREZWNsYXJhdGlvbl8xMTgwIGFzIGlzSW1wb3J0RGVjbGFyYXRpb259Il19

	/***/ },
	/* 27 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		function mixin_1291(target_1292, source_1293) {
		  class F extends target_1292 {}
		  Object.getOwnPropertyNames(source_1293.prototype).forEach(name_1294 => {
		    if (name_1294 !== "constructor") {
		      let newProp = Object.getOwnPropertyDescriptor(source_1293.prototype, name_1294);
		      Object.defineProperty(F.prototype, name_1294, newProp);
		    }
		  });
		  return F;
		}
		exports.mixin = mixin_1291;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBUyxVQUFULENBQW9CLFdBQXBCLEVBQWlDLFdBQWpDLEVBQThDO0FBQzVDLFFBQU0sQ0FBTixTQUFnQixXQUFoQixDQUE0QjtBQUM1QixTQUFPLG1CQUFQLENBQTJCLFlBQVksU0FBdkMsRUFBa0QsT0FBbEQsQ0FBMEQsYUFBYTtBQUNyRSxRQUFJLGNBQWMsYUFBbEIsRUFBaUM7QUFDL0IsVUFBSSxVQUFVLE9BQU8sd0JBQVAsQ0FBZ0MsWUFBWSxTQUE1QyxFQUF1RCxTQUF2RCxDQUFkO0FBQ0EsYUFBTyxjQUFQLENBQXNCLEVBQUUsU0FBeEIsRUFBbUMsU0FBbkMsRUFBOEMsT0FBOUM7QUFDRDtBQUNGLEdBTEQ7QUFNQSxTQUFPLENBQVA7QUFDRDtRQUNxQixLLEdBQWQsVSIsImZpbGUiOiJ1dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1peGluXzEyOTEodGFyZ2V0XzEyOTIsIHNvdXJjZV8xMjkzKSB7XG4gIGNsYXNzIEYgZXh0ZW5kcyB0YXJnZXRfMTI5MiB7fVxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VfMTI5My5wcm90b3R5cGUpLmZvckVhY2gobmFtZV8xMjk0ID0+IHtcbiAgICBpZiAobmFtZV8xMjk0ICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGxldCBuZXdQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VfMTI5My5wcm90b3R5cGUsIG5hbWVfMTI5NCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRi5wcm90b3R5cGUsIG5hbWVfMTI5NCwgbmV3UHJvcCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEY7XG59XG5leHBvcnQge21peGluXzEyOTEgYXMgbWl4aW59Il19

	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _transforms = __webpack_require__(29);

		class Env {
		  constructor() {
		    this.map = new Map();
		    this.map.set("function", _transforms.FunctionDeclTransform);
		    this.map.set("var", _transforms.VariableDeclTransform);
		    this.map.set("let", _transforms.LetDeclTransform);
		    this.map.set("const", _transforms.ConstDeclTransform);
		    this.map.set("syntaxQuote", _transforms.SyntaxQuoteTransform);
		    this.map.set("syntaxrec", _transforms.SyntaxrecDeclTransform);
		    this.map.set("syntax", _transforms.SyntaxDeclTransform);
		    this.map.set("return", _transforms.ReturnStatementTransform);
		    this.map.set("while", _transforms.WhileTransform);
		    this.map.set("if", _transforms.IfTransform);
		    this.map.set("for", _transforms.ForTransform);
		    this.map.set("switch", _transforms.SwitchTransform);
		    this.map.set("break", _transforms.BreakTransform);
		    this.map.set("continue", _transforms.ContinueTransform);
		    this.map.set("do", _transforms.DoTransform);
		    this.map.set("debugger", _transforms.DebuggerTransform);
		    this.map.set("with", _transforms.WithTransform);
		    this.map.set("try", _transforms.TryTransform);
		    this.map.set("throw", _transforms.ThrowTransform);
		    this.map.set("new", _transforms.NewTransform);
		  }
		  has(key_312) {
		    return this.map.has(key_312);
		  }
		  get(key_313) {
		    return this.map.get(key_313);
		  }
		  set(key_314, val_315) {
		    return this.map.set(key_314, val_315);
		  }
		}
		exports.default = Env;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2Vudi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFDZSxNQUFNLEdBQU4sQ0FBVTtBQUN2QixnQkFBYztBQUNaLFNBQUssR0FBTCxHQUFXLElBQUksR0FBSixFQUFYO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsYUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxXQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFFBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsUUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxRQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsVUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxJQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsTUFBYjtBQUNBLFNBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsS0FBYjtBQUNEO0FBQ0QsTUFBSSxPQUFKLEVBQWE7QUFDWCxXQUFPLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiLENBQVA7QUFDRDtBQUNELE1BQUksT0FBSixFQUFhO0FBQ1gsV0FBTyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsT0FBYixDQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQUosRUFBYSxPQUFiLEVBQXNCO0FBQ3BCLFdBQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBUDtBQUNEO0FBaENzQjtrQkFBSixHIiwiZmlsZSI6ImVudi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtLCBWYXJpYWJsZURlY2xUcmFuc2Zvcm0sIExldERlY2xUcmFuc2Zvcm0sIENvbnN0RGVjbFRyYW5zZm9ybSwgU3ludGF4RGVjbFRyYW5zZm9ybSwgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSwgU3ludGF4UXVvdGVUcmFuc2Zvcm0sIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSwgSWZUcmFuc2Zvcm0sIEZvclRyYW5zZm9ybSwgU3dpdGNoVHJhbnNmb3JtLCBCcmVha1RyYW5zZm9ybSwgQ29udGludWVUcmFuc2Zvcm0sIERvVHJhbnNmb3JtLCBEZWJ1Z2dlclRyYW5zZm9ybSwgV2l0aFRyYW5zZm9ybSwgVHJ5VHJhbnNmb3JtLCBUaHJvd1RyYW5zZm9ybSwgTmV3VHJhbnNmb3JtLCBXaGlsZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW52IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwO1xuICAgIHRoaXMubWFwLnNldChcImZ1bmN0aW9uXCIsIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwidmFyXCIsIFZhcmlhYmxlRGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwibGV0XCIsIExldERlY2xUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImNvbnN0XCIsIENvbnN0RGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwic3ludGF4UXVvdGVcIiwgU3ludGF4UXVvdGVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcInN5bnRheHJlY1wiLCBTeW50YXhyZWNEZWNsVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJzeW50YXhcIiwgU3ludGF4RGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwicmV0dXJuXCIsIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwid2hpbGVcIiwgV2hpbGVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImlmXCIsIElmVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJmb3JcIiwgRm9yVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJzd2l0Y2hcIiwgU3dpdGNoVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJicmVha1wiLCBCcmVha1RyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwiY29udGludWVcIiwgQ29udGludWVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldChcImRvXCIsIERvVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJkZWJ1Z2dlclwiLCBEZWJ1Z2dlclRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwid2l0aFwiLCBXaXRoVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJ0cnlcIiwgVHJ5VHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoXCJ0aHJvd1wiLCBUaHJvd1RyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KFwibmV3XCIsIE5ld1RyYW5zZm9ybSk7XG4gIH1cbiAgaGFzKGtleV8zMTIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleV8zMTIpO1xuICB9XG4gIGdldChrZXlfMzEzKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXlfMzEzKTtcbiAgfVxuICBzZXQoa2V5XzMxNCwgdmFsXzMxNSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5zZXQoa2V5XzMxNCwgdmFsXzMxNSk7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 29 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		class FunctionDeclTransform_1267 {}
		class VariableDeclTransform_1268 {}
		class NewTransform_1269 {}
		class ThrowTransform_1270 {}
		class LetDeclTransform_1271 {}
		class ConstDeclTransform_1272 {}
		class TryTransform_1273 {}
		class WhileTransform_1274 {}
		class IfTransform_1275 {}
		class ForTransform_1276 {}
		class SwitchTransform_1277 {}
		class BreakTransform_1278 {}
		class ContinueTransform_1279 {}
		class DoTransform_1280 {}
		class WithTransform_1281 {}
		class DebuggerTransform_1282 {}
		class SyntaxrecDeclTransform_1283 {}
		class SyntaxDeclTransform_1284 {}
		class SyntaxQuoteTransform_1285 {}
		class ReturnStatementTransform_1286 {}
		class VarBindingTransform_1287 {
		  constructor(id_1289) {
		    this.id = id_1289;
		  }
		}
		class CompiletimeTransform_1288 {
		  constructor(value_1290) {
		    this.value = value_1290;
		  }
		}
		exports.FunctionDeclTransform = FunctionDeclTransform_1267;
		exports.VariableDeclTransform = VariableDeclTransform_1268;
		exports.NewTransform = NewTransform_1269;
		exports.ThrowTransform = ThrowTransform_1270;
		exports.LetDeclTransform = LetDeclTransform_1271;
		exports.ConstDeclTransform = ConstDeclTransform_1272;
		exports.TryTransform = TryTransform_1273;
		exports.WhileTransform = WhileTransform_1274;
		exports.IfTransform = IfTransform_1275;
		exports.ForTransform = ForTransform_1276;
		exports.SwitchTransform = SwitchTransform_1277;
		exports.BreakTransform = BreakTransform_1278;
		exports.ContinueTransform = ContinueTransform_1279;
		exports.DoTransform = DoTransform_1280;
		exports.WithTransform = WithTransform_1281;
		exports.DebuggerTransform = DebuggerTransform_1282;
		exports.SyntaxrecDeclTransform = SyntaxrecDeclTransform_1283;
		exports.SyntaxDeclTransform = SyntaxDeclTransform_1284;
		exports.SyntaxQuoteTransform = SyntaxQuoteTransform_1285;
		exports.ReturnStatementTransform = ReturnStatementTransform_1286;
		exports.VarBindingTransform = VarBindingTransform_1287;
		exports.CompiletimeTransform = CompiletimeTransform_1288;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3RyYW5zZm9ybXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNLDBCQUFOLENBQWlDO0FBQ2pDLE1BQU0sMEJBQU4sQ0FBaUM7QUFDakMsTUFBTSxpQkFBTixDQUF3QjtBQUN4QixNQUFNLG1CQUFOLENBQTBCO0FBQzFCLE1BQU0scUJBQU4sQ0FBNEI7QUFDNUIsTUFBTSx1QkFBTixDQUE4QjtBQUM5QixNQUFNLGlCQUFOLENBQXdCO0FBQ3hCLE1BQU0sbUJBQU4sQ0FBMEI7QUFDMUIsTUFBTSxnQkFBTixDQUF1QjtBQUN2QixNQUFNLGlCQUFOLENBQXdCO0FBQ3hCLE1BQU0sb0JBQU4sQ0FBMkI7QUFDM0IsTUFBTSxtQkFBTixDQUEwQjtBQUMxQixNQUFNLHNCQUFOLENBQTZCO0FBQzdCLE1BQU0sZ0JBQU4sQ0FBdUI7QUFDdkIsTUFBTSxrQkFBTixDQUF5QjtBQUN6QixNQUFNLHNCQUFOLENBQTZCO0FBQzdCLE1BQU0sMkJBQU4sQ0FBa0M7QUFDbEMsTUFBTSx3QkFBTixDQUErQjtBQUMvQixNQUFNLHlCQUFOLENBQWdDO0FBQ2hDLE1BQU0sNkJBQU4sQ0FBb0M7QUFDcEMsTUFBTSx3QkFBTixDQUErQjtBQUM3QixjQUFZLE9BQVosRUFBcUI7QUFDbkIsU0FBSyxFQUFMLEdBQVUsT0FBVjtBQUNEO0FBSDRCO0FBSy9CLE1BQU0seUJBQU4sQ0FBZ0M7QUFDOUIsY0FBWSxVQUFaLEVBQXdCO0FBQ3RCLFNBQUssS0FBTCxHQUFhLFVBQWI7QUFDRDtBQUg2QjtRQUtNLHFCLEdBQTlCLDBCO1FBQzhCLHFCLEdBQTlCLDBCO1FBQ3FCLFksR0FBckIsaUI7UUFDdUIsYyxHQUF2QixtQjtRQUN5QixnQixHQUF6QixxQjtRQUMyQixrQixHQUEzQix1QjtRQUNxQixZLEdBQXJCLGlCO1FBQ3VCLGMsR0FBdkIsbUI7UUFDb0IsVyxHQUFwQixnQjtRQUNxQixZLEdBQXJCLGlCO1FBQ3dCLGUsR0FBeEIsb0I7UUFDdUIsYyxHQUF2QixtQjtRQUMwQixpQixHQUExQixzQjtRQUNvQixXLEdBQXBCLGdCO1FBQ3NCLGEsR0FBdEIsa0I7UUFDMEIsaUIsR0FBMUIsc0I7UUFDK0Isc0IsR0FBL0IsMkI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDNkIsb0IsR0FBN0IseUI7UUFDaUMsd0IsR0FBakMsNkI7UUFDNEIsbUIsR0FBNUIsd0I7UUFDNkIsb0IsR0FBN0IseUIiLCJmaWxlIjoidHJhbnNmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybV8xMjY3IHt9XG5jbGFzcyBWYXJpYWJsZURlY2xUcmFuc2Zvcm1fMTI2OCB7fVxuY2xhc3MgTmV3VHJhbnNmb3JtXzEyNjkge31cbmNsYXNzIFRocm93VHJhbnNmb3JtXzEyNzAge31cbmNsYXNzIExldERlY2xUcmFuc2Zvcm1fMTI3MSB7fVxuY2xhc3MgQ29uc3REZWNsVHJhbnNmb3JtXzEyNzIge31cbmNsYXNzIFRyeVRyYW5zZm9ybV8xMjczIHt9XG5jbGFzcyBXaGlsZVRyYW5zZm9ybV8xMjc0IHt9XG5jbGFzcyBJZlRyYW5zZm9ybV8xMjc1IHt9XG5jbGFzcyBGb3JUcmFuc2Zvcm1fMTI3NiB7fVxuY2xhc3MgU3dpdGNoVHJhbnNmb3JtXzEyNzcge31cbmNsYXNzIEJyZWFrVHJhbnNmb3JtXzEyNzgge31cbmNsYXNzIENvbnRpbnVlVHJhbnNmb3JtXzEyNzkge31cbmNsYXNzIERvVHJhbnNmb3JtXzEyODAge31cbmNsYXNzIFdpdGhUcmFuc2Zvcm1fMTI4MSB7fVxuY2xhc3MgRGVidWdnZXJUcmFuc2Zvcm1fMTI4MiB7fVxuY2xhc3MgU3ludGF4cmVjRGVjbFRyYW5zZm9ybV8xMjgzIHt9XG5jbGFzcyBTeW50YXhEZWNsVHJhbnNmb3JtXzEyODQge31cbmNsYXNzIFN5bnRheFF1b3RlVHJhbnNmb3JtXzEyODUge31cbmNsYXNzIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybV8xMjg2IHt9XG5jbGFzcyBWYXJCaW5kaW5nVHJhbnNmb3JtXzEyODcge1xuICBjb25zdHJ1Y3RvcihpZF8xMjg5KSB7XG4gICAgdGhpcy5pZCA9IGlkXzEyODk7XG4gIH1cbn1cbmNsYXNzIENvbXBpbGV0aW1lVHJhbnNmb3JtXzEyODgge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZV8xMjkwKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXzEyOTA7XG4gIH1cbn1cbmV4cG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtXzEyNjcgYXMgRnVuY3Rpb25EZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7VmFyaWFibGVEZWNsVHJhbnNmb3JtXzEyNjggYXMgVmFyaWFibGVEZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7TmV3VHJhbnNmb3JtXzEyNjkgYXMgTmV3VHJhbnNmb3JtfTtcbmV4cG9ydCB7VGhyb3dUcmFuc2Zvcm1fMTI3MCBhcyBUaHJvd1RyYW5zZm9ybX07XG5leHBvcnQge0xldERlY2xUcmFuc2Zvcm1fMTI3MSBhcyBMZXREZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29uc3REZWNsVHJhbnNmb3JtXzEyNzIgYXMgQ29uc3REZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7VHJ5VHJhbnNmb3JtXzEyNzMgYXMgVHJ5VHJhbnNmb3JtfTtcbmV4cG9ydCB7V2hpbGVUcmFuc2Zvcm1fMTI3NCBhcyBXaGlsZVRyYW5zZm9ybX07XG5leHBvcnQge0lmVHJhbnNmb3JtXzEyNzUgYXMgSWZUcmFuc2Zvcm19O1xuZXhwb3J0IHtGb3JUcmFuc2Zvcm1fMTI3NiBhcyBGb3JUcmFuc2Zvcm19O1xuZXhwb3J0IHtTd2l0Y2hUcmFuc2Zvcm1fMTI3NyBhcyBTd2l0Y2hUcmFuc2Zvcm19O1xuZXhwb3J0IHtCcmVha1RyYW5zZm9ybV8xMjc4IGFzIEJyZWFrVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29udGludWVUcmFuc2Zvcm1fMTI3OSBhcyBDb250aW51ZVRyYW5zZm9ybX07XG5leHBvcnQge0RvVHJhbnNmb3JtXzEyODAgYXMgRG9UcmFuc2Zvcm19O1xuZXhwb3J0IHtXaXRoVHJhbnNmb3JtXzEyODEgYXMgV2l0aFRyYW5zZm9ybX07XG5leHBvcnQge0RlYnVnZ2VyVHJhbnNmb3JtXzEyODIgYXMgRGVidWdnZXJUcmFuc2Zvcm19O1xuZXhwb3J0IHtTeW50YXhyZWNEZWNsVHJhbnNmb3JtXzEyODMgYXMgU3ludGF4cmVjRGVjbFRyYW5zZm9ybX07XG5leHBvcnQge1N5bnRheERlY2xUcmFuc2Zvcm1fMTI4NCBhcyBTeW50YXhEZWNsVHJhbnNmb3JtfTtcbmV4cG9ydCB7U3ludGF4UXVvdGVUcmFuc2Zvcm1fMTI4NSBhcyBTeW50YXhRdW90ZVRyYW5zZm9ybX07XG5leHBvcnQge1JldHVyblN0YXRlbWVudFRyYW5zZm9ybV8xMjg2IGFzIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybX07XG5leHBvcnQge1ZhckJpbmRpbmdUcmFuc2Zvcm1fMTI4NyBhcyBWYXJCaW5kaW5nVHJhbnNmb3JtfTtcbmV4cG9ydCB7Q29tcGlsZXRpbWVUcmFuc2Zvcm1fMTI4OCBhcyBDb21waWxldGltZVRyYW5zZm9ybX0iXX0=

	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.MonoidalReducer = exports.CloneReducer = undefined;
		exports.default = reduce;

		var _cloneReducer = __webpack_require__(31);

		Object.defineProperty(exports, "CloneReducer", {
		  enumerable: true,
		  get: function get() {
		    return _cloneReducer.default;
		  }
		});

		var _monoidalReducer = __webpack_require__(33);

		Object.defineProperty(exports, "MonoidalReducer", {
		  enumerable: true,
		  get: function get() {
		    return _monoidalReducer.default;
		  }
		});

		var _shiftSpec = __webpack_require__(32);

		var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function transformWithSpec(transformer, node, spec) {
		  switch (spec.typeName) {
		    case "Enum":
		    case "String":
		    case "Number":
		    case "Boolean":
		    case "SourceSpan":
		      return node;
		    case "Const":
		      // TODO: checked version
		      return transformWithSpec(transformer, node, spec.argument);
		    case "Maybe":
		      return node && transformWithSpec(transformer, node, spec.argument);
		    case "List":
		      return node.map(function (e) {
		        return transformWithSpec(transformer, e, spec.argument);
		      });
		    case "Union":
		      // TODO: checked version
		      return transformWithSpec(transformer, node, _shiftSpec2.default[node.type]);
		    default:
		      var state = {};
		      spec.fields.forEach(function (field) {
		        var v = transformWithSpec(transformer, node[field.name], field.type);
		        state[field.name] = v == null ? null : v;
		      });
		      if (typeof transformer["reduce" + node.type] !== "function") {
		        throw new Error("Encountered " + node.type + ", which the provided reducer does not handle.");
		      }
		      return transformer["reduce" + node.type](node, state);
		  }
		} /**
		   * Copyright 2014 Shape Security, Inc.
		   *
		   * Licensed under the Apache License, Version 2.0 (the "License")
		   * you may not use this file except in compliance with the License.
		   * You may obtain a copy of the License at
		   *
		   *     http://www.apache.org/licenses/LICENSE-2.0
		   *
		   * Unless required by applicable law or agreed to in writing, software
		   * distributed under the License is distributed on an "AS IS" BASIS,
		   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   * See the License for the specific language governing permissions and
		   * limitations under the License.
		   */

		function reduce(reducer, reducible) {
		  return transformWithSpec(reducer, reducible, _shiftSpec2.default[reducible.type]);
		}

	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _shiftSpec = __webpack_require__(32);

		var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
		                                                                                                                                                           * Copyright 2014 Shape Security, Inc.
		                                                                                                                                                           *
		                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License")
		                                                                                                                                                           * you may not use this file except in compliance with the License.
		                                                                                                                                                           * You may obtain a copy of the License at
		                                                                                                                                                           *
		                                                                                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
		                                                                                                                                                           *
		                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
		                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
		                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		                                                                                                                                                           * See the License for the specific language governing permissions and
		                                                                                                                                                           * limitations under the License.
		                                                                                                                                                           */

		var CloneReducer = function CloneReducer() {
		  _classCallCheck(this, CloneReducer);
		};

		exports.default = CloneReducer;

		for (var typeName in _shiftSpec2.default) {
		  var type = _shiftSpec2.default[typeName];
		  Object.defineProperty(CloneReducer.prototype, "reduce" + typeName, {
		    value: function value(node, state) {
		      return state;
		    }
		  });
		}

	/***/ },
	/* 32 */
	/***/ function(module, exports) {

		// Generated by src/generate-spec.js. 

		/**
		 * Copyright 2015 Shape Security, Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */

		// Hack to make Babel6 import this as a module.
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		// Meta data generated from spec.idl.
		exports.default = (function() {
		  var SPEC = {};

		  var BOOLEAN = { typeName: "Boolean" };
		  var DOUBLE = { typeName: "Number" };
		  var STRING = { typeName: "String" };
		  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
		  function List(arg) { return { typeName: "List", argument: arg }; }
		  function Const(arg) { return { typeName: "Const", argument: arg }; }
		  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }

		  var TYPE_INDICATOR = {
		    typeName: "Enum",
		    values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
		  };

		  var VariableDeclarationKind = {
		    typeName: "Enum",
		    values: ["var", "let", "const"]
		  };

		  var CompoundAssignmentOperator = {
		    typeName: "Enum",
		    values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
		  };

		  var BinaryOperator = {
		    typeName: "Enum",
		    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
		  };

		  var UnaryOperator = {
		    typeName: "Enum",
		    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
		  };

		  var UpdateOperator = {
		    typeName: "Enum",
		    values: ["++", "--"]
		  };

		  var SourceLocation = SPEC.SourceLocation = {};
		  var SourceSpan = SPEC.SourceSpan = {};
		  var BindingWithDefault = SPEC.BindingWithDefault = {};
		  var BindingIdentifier = SPEC.BindingIdentifier = {};
		  var ArrayBinding = SPEC.ArrayBinding = {};
		  var ObjectBinding = SPEC.ObjectBinding = {};
		  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
		  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
		  var ClassExpression = SPEC.ClassExpression = {};
		  var ClassDeclaration = SPEC.ClassDeclaration = {};
		  var ClassElement = SPEC.ClassElement = {};
		  var Module = SPEC.Module = {};
		  var Import = SPEC.Import = {};
		  var ImportNamespace = SPEC.ImportNamespace = {};
		  var ImportSpecifier = SPEC.ImportSpecifier = {};
		  var ExportAllFrom = SPEC.ExportAllFrom = {};
		  var ExportFrom = SPEC.ExportFrom = {};
		  var Export = SPEC.Export = {};
		  var ExportDefault = SPEC.ExportDefault = {};
		  var ExportSpecifier = SPEC.ExportSpecifier = {};
		  var Method = SPEC.Method = {};
		  var Getter = SPEC.Getter = {};
		  var Setter = SPEC.Setter = {};
		  var DataProperty = SPEC.DataProperty = {};
		  var ShorthandProperty = SPEC.ShorthandProperty = {};
		  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
		  var StaticPropertyName = SPEC.StaticPropertyName = {};
		  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
		  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
		  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
		  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
		  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
		  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
		  var ArrayExpression = SPEC.ArrayExpression = {};
		  var ArrowExpression = SPEC.ArrowExpression = {};
		  var AssignmentExpression = SPEC.AssignmentExpression = {};
		  var BinaryExpression = SPEC.BinaryExpression = {};
		  var CallExpression = SPEC.CallExpression = {};
		  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
		  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
		  var ConditionalExpression = SPEC.ConditionalExpression = {};
		  var FunctionExpression = SPEC.FunctionExpression = {};
		  var IdentifierExpression = SPEC.IdentifierExpression = {};
		  var NewExpression = SPEC.NewExpression = {};
		  var NewTargetExpression = SPEC.NewTargetExpression = {};
		  var ObjectExpression = SPEC.ObjectExpression = {};
		  var UnaryExpression = SPEC.UnaryExpression = {};
		  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
		  var TemplateExpression = SPEC.TemplateExpression = {};
		  var ThisExpression = SPEC.ThisExpression = {};
		  var UpdateExpression = SPEC.UpdateExpression = {};
		  var YieldExpression = SPEC.YieldExpression = {};
		  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
		  var BlockStatement = SPEC.BlockStatement = {};
		  var BreakStatement = SPEC.BreakStatement = {};
		  var ContinueStatement = SPEC.ContinueStatement = {};
		  var DebuggerStatement = SPEC.DebuggerStatement = {};
		  var DoWhileStatement = SPEC.DoWhileStatement = {};
		  var EmptyStatement = SPEC.EmptyStatement = {};
		  var ExpressionStatement = SPEC.ExpressionStatement = {};
		  var ForInStatement = SPEC.ForInStatement = {};
		  var ForOfStatement = SPEC.ForOfStatement = {};
		  var ForStatement = SPEC.ForStatement = {};
		  var IfStatement = SPEC.IfStatement = {};
		  var LabeledStatement = SPEC.LabeledStatement = {};
		  var ReturnStatement = SPEC.ReturnStatement = {};
		  var SwitchStatement = SPEC.SwitchStatement = {};
		  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
		  var ThrowStatement = SPEC.ThrowStatement = {};
		  var TryCatchStatement = SPEC.TryCatchStatement = {};
		  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
		  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
		  var WhileStatement = SPEC.WhileStatement = {};
		  var WithStatement = SPEC.WithStatement = {};
		  var Block = SPEC.Block = {};
		  var CatchClause = SPEC.CatchClause = {};
		  var Directive = SPEC.Directive = {};
		  var FormalParameters = SPEC.FormalParameters = {};
		  var FunctionBody = SPEC.FunctionBody = {};
		  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
		  var Script = SPEC.Script = {};
		  var SpreadElement = SPEC.SpreadElement = {};
		  var Super = SPEC.Super = {};
		  var SwitchCase = SPEC.SwitchCase = {};
		  var SwitchDefault = SPEC.SwitchDefault = {};
		  var TemplateElement = SPEC.TemplateElement = {};
		  var VariableDeclaration = SPEC.VariableDeclaration = {};
		  var VariableDeclarator = SPEC.VariableDeclarator = {};

		  var Class = Union(ClassExpression, ClassDeclaration);
		  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
		  var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
		  var ImportDeclaration = Union(Import, ImportNamespace);
		  var MethodDefinition = Union(Method, Getter, Setter);
		  var NamedObjectProperty = Union(MethodDefinition, DataProperty);
		  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
		  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
		  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
		  var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
		  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
		  var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
		  var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
		  var Function = Union(FunctionExpression, FunctionDeclaration);

		  SourceLocation.typeName = "SourceLocation";
		  SourceLocation.fields = [
		    { name: "line", type: DOUBLE },
		    { name: "column", type: DOUBLE },
		    { name: "offset", type: DOUBLE },
		  ];

		  SourceSpan.typeName = "SourceSpan";
		  SourceSpan.fields = [
		    { name: "source", type: Maybe(STRING) },
		    { name: "start", type: SourceLocation },
		    { name: "end", type: SourceLocation },
		  ];

		  BindingWithDefault.typeName = "BindingWithDefault";
		  BindingWithDefault.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "init", type: Expression },
		  ];

		  BindingIdentifier.typeName = "BindingIdentifier";
		  BindingIdentifier.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: STRING },
		  ];

		  ArrayBinding.typeName = "ArrayBinding";
		  ArrayBinding.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) },
		    { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) },
		  ];

		  ObjectBinding.typeName = "ObjectBinding";
		  ObjectBinding.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "properties", type: List(BindingProperty) },
		  ];

		  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
		  BindingPropertyIdentifier.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "binding", type: BindingIdentifier },
		    { name: "init", type: Maybe(Expression) },
		  ];

		  BindingPropertyProperty.typeName = "BindingPropertyProperty";
		  BindingPropertyProperty.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: PropertyName },
		    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
		  ];

		  ClassExpression.typeName = "ClassExpression";
		  ClassExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: Maybe(BindingIdentifier) },
		    { name: "super", type: Maybe(Expression) },
		    { name: "elements", type: List(ClassElement) },
		  ];

		  ClassDeclaration.typeName = "ClassDeclaration";
		  ClassDeclaration.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: BindingIdentifier },
		    { name: "super", type: Maybe(Expression) },
		    { name: "elements", type: List(ClassElement) },
		  ];

		  ClassElement.typeName = "ClassElement";
		  ClassElement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "isStatic", type: BOOLEAN },
		    { name: "method", type: MethodDefinition },
		  ];

		  Module.typeName = "Module";
		  Module.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "directives", type: List(Directive) },
		    { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) },
		  ];

		  Import.typeName = "Import";
		  Import.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "moduleSpecifier", type: STRING },
		    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
		    { name: "namedImports", type: List(ImportSpecifier) },
		  ];

		  ImportNamespace.typeName = "ImportNamespace";
		  ImportNamespace.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "moduleSpecifier", type: STRING },
		    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
		    { name: "namespaceBinding", type: BindingIdentifier },
		  ];

		  ImportSpecifier.typeName = "ImportSpecifier";
		  ImportSpecifier.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: Maybe(STRING) },
		    { name: "binding", type: BindingIdentifier },
		  ];

		  ExportAllFrom.typeName = "ExportAllFrom";
		  ExportAllFrom.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "moduleSpecifier", type: STRING },
		  ];

		  ExportFrom.typeName = "ExportFrom";
		  ExportFrom.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "namedExports", type: List(ExportSpecifier) },
		    { name: "moduleSpecifier", type: Maybe(STRING) },
		  ];

		  Export.typeName = "Export";
		  Export.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) },
		  ];

		  ExportDefault.typeName = "ExportDefault";
		  ExportDefault.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) },
		  ];

		  ExportSpecifier.typeName = "ExportSpecifier";
		  ExportSpecifier.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: Maybe(STRING) },
		    { name: "exportedName", type: STRING },
		  ];

		  Method.typeName = "Method";
		  Method.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: PropertyName },
		    { name: "isGenerator", type: BOOLEAN },
		    { name: "params", type: FormalParameters },
		    { name: "body", type: FunctionBody },
		  ];

		  Getter.typeName = "Getter";
		  Getter.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: PropertyName },
		    { name: "body", type: FunctionBody },
		  ];

		  Setter.typeName = "Setter";
		  Setter.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: PropertyName },
		    { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
		    { name: "body", type: FunctionBody },
		  ];

		  DataProperty.typeName = "DataProperty";
		  DataProperty.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: PropertyName },
		    { name: "expression", type: Expression },
		  ];

		  ShorthandProperty.typeName = "ShorthandProperty";
		  ShorthandProperty.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: STRING },
		  ];

		  ComputedPropertyName.typeName = "ComputedPropertyName";
		  ComputedPropertyName.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Expression },
		  ];

		  StaticPropertyName.typeName = "StaticPropertyName";
		  StaticPropertyName.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "value", type: STRING },
		  ];

		  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
		  LiteralBooleanExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "value", type: BOOLEAN },
		  ];

		  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
		  LiteralInfinityExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  LiteralNullExpression.typeName = "LiteralNullExpression";
		  LiteralNullExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  LiteralNumericExpression.typeName = "LiteralNumericExpression";
		  LiteralNumericExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "value", type: DOUBLE },
		  ];

		  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
		  LiteralRegExpExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "pattern", type: STRING },
		    { name: "flags", type: STRING },
		  ];

		  LiteralStringExpression.typeName = "LiteralStringExpression";
		  LiteralStringExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "value", type: STRING },
		  ];

		  ArrayExpression.typeName = "ArrayExpression";
		  ArrayExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) },
		  ];

		  ArrowExpression.typeName = "ArrowExpression";
		  ArrowExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "params", type: FormalParameters },
		    { name: "body", type: Union(FunctionBody, Expression) },
		  ];

		  AssignmentExpression.typeName = "AssignmentExpression";
		  AssignmentExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "expression", type: Expression },
		  ];

		  BinaryExpression.typeName = "BinaryExpression";
		  BinaryExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "operator", type: BinaryOperator },
		    { name: "left", type: Expression },
		    { name: "right", type: Expression },
		  ];

		  CallExpression.typeName = "CallExpression";
		  CallExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "callee", type: Union(Expression, Super) },
		    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
		  ];

		  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
		  CompoundAssignmentExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "operator", type: CompoundAssignmentOperator },
		    { name: "binding", type: Union(BindingIdentifier, MemberExpression) },
		    { name: "expression", type: Expression },
		  ];

		  ComputedMemberExpression.typeName = "ComputedMemberExpression";
		  ComputedMemberExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "object", type: Union(Expression, Super) },
		    { name: "expression", type: Expression },
		  ];

		  ConditionalExpression.typeName = "ConditionalExpression";
		  ConditionalExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "test", type: Expression },
		    { name: "consequent", type: Expression },
		    { name: "alternate", type: Expression },
		  ];

		  FunctionExpression.typeName = "FunctionExpression";
		  FunctionExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "isGenerator", type: BOOLEAN },
		    { name: "name", type: Maybe(BindingIdentifier) },
		    { name: "params", type: FormalParameters },
		    { name: "body", type: FunctionBody },
		  ];

		  IdentifierExpression.typeName = "IdentifierExpression";
		  IdentifierExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "name", type: STRING },
		  ];

		  NewExpression.typeName = "NewExpression";
		  NewExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "callee", type: Expression },
		    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
		  ];

		  NewTargetExpression.typeName = "NewTargetExpression";
		  NewTargetExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  ObjectExpression.typeName = "ObjectExpression";
		  ObjectExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "properties", type: List(ObjectProperty) },
		  ];

		  UnaryExpression.typeName = "UnaryExpression";
		  UnaryExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "operator", type: UnaryOperator },
		    { name: "operand", type: Expression },
		  ];

		  StaticMemberExpression.typeName = "StaticMemberExpression";
		  StaticMemberExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "object", type: Union(Expression, Super) },
		    { name: "property", type: STRING },
		  ];

		  TemplateExpression.typeName = "TemplateExpression";
		  TemplateExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "tag", type: Maybe(Expression) },
		    { name: "elements", type: List(Union(Expression, TemplateElement)) },
		  ];

		  ThisExpression.typeName = "ThisExpression";
		  ThisExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  UpdateExpression.typeName = "UpdateExpression";
		  UpdateExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "isPrefix", type: BOOLEAN },
		    { name: "operator", type: UpdateOperator },
		    { name: "operand", type: Union(BindingIdentifier, MemberExpression) },
		  ];

		  YieldExpression.typeName = "YieldExpression";
		  YieldExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Maybe(Expression) },
		  ];

		  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
		  YieldGeneratorExpression.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Expression },
		  ];

		  BlockStatement.typeName = "BlockStatement";
		  BlockStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "block", type: Block },
		  ];

		  BreakStatement.typeName = "BreakStatement";
		  BreakStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "label", type: Maybe(STRING) },
		  ];

		  ContinueStatement.typeName = "ContinueStatement";
		  ContinueStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "label", type: Maybe(STRING) },
		  ];

		  DebuggerStatement.typeName = "DebuggerStatement";
		  DebuggerStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  DoWhileStatement.typeName = "DoWhileStatement";
		  DoWhileStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "body", type: Statement },
		    { name: "test", type: Expression },
		  ];

		  EmptyStatement.typeName = "EmptyStatement";
		  EmptyStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  ExpressionStatement.typeName = "ExpressionStatement";
		  ExpressionStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Expression },
		  ];

		  ForInStatement.typeName = "ForInStatement";
		  ForInStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "right", type: Expression },
		    { name: "body", type: Statement },
		  ];

		  ForOfStatement.typeName = "ForOfStatement";
		  ForOfStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "right", type: Expression },
		    { name: "body", type: Statement },
		  ];

		  ForStatement.typeName = "ForStatement";
		  ForStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) },
		    { name: "test", type: Maybe(Expression) },
		    { name: "update", type: Maybe(Expression) },
		    { name: "body", type: Statement },
		  ];

		  IfStatement.typeName = "IfStatement";
		  IfStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "test", type: Expression },
		    { name: "consequent", type: Statement },
		    { name: "alternate", type: Maybe(Statement) },
		  ];

		  LabeledStatement.typeName = "LabeledStatement";
		  LabeledStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "label", type: STRING },
		    { name: "body", type: Statement },
		  ];

		  ReturnStatement.typeName = "ReturnStatement";
		  ReturnStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Maybe(Expression) },
		  ];

		  SwitchStatement.typeName = "SwitchStatement";
		  SwitchStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "discriminant", type: Expression },
		    { name: "cases", type: List(SwitchCase) },
		  ];

		  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
		  SwitchStatementWithDefault.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "discriminant", type: Expression },
		    { name: "preDefaultCases", type: List(SwitchCase) },
		    { name: "defaultCase", type: SwitchDefault },
		    { name: "postDefaultCases", type: List(SwitchCase) },
		  ];

		  ThrowStatement.typeName = "ThrowStatement";
		  ThrowStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Expression },
		  ];

		  TryCatchStatement.typeName = "TryCatchStatement";
		  TryCatchStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "body", type: Block },
		    { name: "catchClause", type: CatchClause },
		  ];

		  TryFinallyStatement.typeName = "TryFinallyStatement";
		  TryFinallyStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "body", type: Block },
		    { name: "catchClause", type: Maybe(CatchClause) },
		    { name: "finalizer", type: Block },
		  ];

		  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
		  VariableDeclarationStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "declaration", type: VariableDeclaration },
		  ];

		  WhileStatement.typeName = "WhileStatement";
		  WhileStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "test", type: Expression },
		    { name: "body", type: Statement },
		  ];

		  WithStatement.typeName = "WithStatement";
		  WithStatement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "object", type: Expression },
		    { name: "body", type: Statement },
		  ];

		  Block.typeName = "Block";
		  Block.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "statements", type: List(Statement) },
		  ];

		  CatchClause.typeName = "CatchClause";
		  CatchClause.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "body", type: Block },
		  ];

		  Directive.typeName = "Directive";
		  Directive.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "rawValue", type: STRING },
		  ];

		  FormalParameters.typeName = "FormalParameters";
		  FormalParameters.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) },
		    { name: "rest", type: Maybe(BindingIdentifier) },
		  ];

		  FunctionBody.typeName = "FunctionBody";
		  FunctionBody.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "directives", type: List(Directive) },
		    { name: "statements", type: List(Statement) },
		  ];

		  FunctionDeclaration.typeName = "FunctionDeclaration";
		  FunctionDeclaration.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "isGenerator", type: BOOLEAN },
		    { name: "name", type: BindingIdentifier },
		    { name: "params", type: FormalParameters },
		    { name: "body", type: FunctionBody },
		  ];

		  Script.typeName = "Script";
		  Script.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "directives", type: List(Directive) },
		    { name: "statements", type: List(Statement) },
		  ];

		  SpreadElement.typeName = "SpreadElement";
		  SpreadElement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "expression", type: Expression },
		  ];

		  Super.typeName = "Super";
		  Super.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" },
		    { name: "loc", type: Maybe(SourceSpan) },
		  ];

		  SwitchCase.typeName = "SwitchCase";
		  SwitchCase.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "test", type: Expression },
		    { name: "consequent", type: List(Statement) },
		  ];

		  SwitchDefault.typeName = "SwitchDefault";
		  SwitchDefault.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "consequent", type: List(Statement) },
		  ];

		  TemplateElement.typeName = "TemplateElement";
		  TemplateElement.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "rawValue", type: STRING },
		  ];

		  VariableDeclaration.typeName = "VariableDeclaration";
		  VariableDeclaration.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "kind", type: VariableDeclarationKind },
		    { name: "declarators", type: List(VariableDeclarator) },
		  ];

		  VariableDeclarator.typeName = "VariableDeclarator";
		  VariableDeclarator.fields = [
		    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
		    { name: "loc", type: Maybe(SourceSpan) },
		    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
		    { name: "init", type: Maybe(Expression) },
		  ];

		  return SPEC;
		}());


	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
		                                                                                                                                                                                                                                                   * Copyright 2014 Shape Security, Inc.
		                                                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                                                   * Licensed under the Apache License, Version 2.0 (the "License")
		                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the License.
		                                                                                                                                                                                                                                                   * You may obtain a copy of the License at
		                                                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                                                   *     http://www.apache.org/licenses/LICENSE-2.0
		                                                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                                                   * Unless required by applicable law or agreed to in writing, software
		                                                                                                                                                                                                                                                   * distributed under the License is distributed on an "AS IS" BASIS,
		                                                                                                                                                                                                                                                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		                                                                                                                                                                                                                                                   * See the License for the specific language governing permissions and
		                                                                                                                                                                                                                                                   * limitations under the License.
		                                                                                                                                                                                                                                                   */

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _shiftSpec = __webpack_require__(32);

		var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var methods = {};

		function id(x) {
		  return x;
		}

		function handlerForFieldOfType(type) {
		  switch (type.typeName) {
		    case "Enum":
		    case "String":
		    case "Boolean":
		    case "Number":
		    case "SourceSpan":
		      return null;
		    case "Const":
		      return handlerForFieldOfType(type.argument);
		    case "Maybe":
		      {
		        var _ret = function () {
		          var subHandler = handlerForFieldOfType(type.argument);
		          if (subHandler == null) return {
		              v: null
		            };
		          return {
		            v: function v(t) {
		              return t == null ? this.identity : subHandler.call(this, t);
		            }
		          };
		        }();

		        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
		      }
		    case "List":
		      {
		        var _ret2 = function () {
		          var subHandler = handlerForFieldOfType(type.argument);
		          if (subHandler == null) return {
		              v: null
		            };
		          return {
		            v: function v(t) {
		              var _this = this;

		              return this.fold(t.map(function (x) {
		                return subHandler.call(_this, x);
		              }));
		            }
		          };
		        }();

		        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
		      }
		    default:
		      return id;
		  }
		}

		var _loop = function _loop(typeName) {
		  var type = _shiftSpec2.default[typeName];

		  var handlers = {};
		  type.fields.forEach(function (field) {
		    var handler = handlerForFieldOfType(field.type);
		    if (handler != null) handlers[field.name] = handler;
		  });
		  var fieldNames = Object.keys(handlers);

		  methods["reduce" + typeName] = {
		    value: function value(node, state) {
		      var _this3 = this;

		      return this.fold(fieldNames.map(function (fieldName) {
		        return handlers[fieldName].call(_this3, state[fieldName]);
		      }));
		    }
		  };
		};

		for (var typeName in _shiftSpec2.default) {
		  _loop(typeName);
		}

		var MonoidalReducer = function () {
		  function MonoidalReducer(monoid) {
		    _classCallCheck(this, MonoidalReducer);

		    this.identity = monoid.empty();
		    var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
		    this.append = function (a, b) {
		      return concat.call(a, b);
		    };
		  }

		  _createClass(MonoidalReducer, [{
		    key: "fold",
		    value: function fold(list, a) {
		      var _this2 = this;

		      return list.reduce(function (memo, x) {
		        return _this2.append(memo, x);
		      }, a == null ? this.identity : a);
		    }
		  }]);

		  return MonoidalReducer;
		}();

		exports.default = MonoidalReducer;

		Object.defineProperties(MonoidalReducer.prototype, methods);

	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _shiftReducer = __webpack_require__(30);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class ParseReducer extends _shiftReducer.CloneReducer {
		  constructor(context_527) {
		    super();
		    this.context = context_527;
		  }
		  reduceModule(node_528, state_529) {
		    return new _terms2.default("Module", { directives: state_529.directives.toArray(), items: state_529.items.toArray() });
		  }
		  reduceImport(node_530, state_531) {
		    let moduleSpecifier_532 = state_531.moduleSpecifier ? state_531.moduleSpecifier.val() : null;
		    return new _terms2.default("Import", { defaultBinding: state_531.defaultBinding, namedImports: state_531.namedImports.toArray(), moduleSpecifier: moduleSpecifier_532, forSyntax: node_530.forSyntax });
		  }
		  reduceImportNamespace(node_533, state_534) {
		    let moduleSpecifier_535 = state_534.moduleSpecifier ? state_534.moduleSpecifier.val() : null;
		    return new _terms2.default("ImportNamespace", { defaultBinding: state_534.defaultBinding, namespaceBinding: state_534.namespaceBinding, moduleSpecifier: moduleSpecifier_535, forSyntax: node_533.forSyntax });
		  }
		  reduceExport(node_536, state_537) {
		    return new _terms2.default("Export", { declaration: state_537.declaration });
		  }
		  reduceExportAllFrom(node_538, state_539) {
		    let moduleSpecifier_540 = state_539.moduleSpecifier ? state_539.moduleSpecifier.val() : null;
		    return new _terms2.default("ExportAllFrom", { moduleSpecifier: moduleSpecifier_540 });
		  }
		  reduceExportFrom(node_541, state_542) {
		    let moduleSpecifier_543 = state_542.moduleSpecifier ? state_542.moduleSpecifier.val() : null;
		    return new _terms2.default("ExportFrom", { moduleSpecifier: moduleSpecifier_543, namedExports: state_542.namedExports.toArray() });
		  }
		  reduceExportSpecifier(node_544, state_545) {
		    let name_546 = state_545.name,
		        exportedName_547 = state_545.exportedName;
		    if (name_546 == null) {
		      name_546 = exportedName_547.resolve(this.context.phase);
		      exportedName_547 = exportedName_547.val();
		    } else {
		      name_546 = name_546.resolve(this.context.phase);
		      exportedName_547 = exportedName_547.val();
		    }
		    return new _terms2.default("ExportSpecifier", { name: name_546, exportedName: exportedName_547 });
		  }
		  reduceImportSpecifier(node_548, state_549) {
		    let name_550 = state_549.name ? state_549.name.resolve(this.context.phase) : null;
		    return new _terms2.default("ImportSpecifier", { name: name_550, binding: state_549.binding });
		  }
		  reduceIdentifierExpression(node_551, state_552) {
		    return new _terms2.default("IdentifierExpression", { name: node_551.name.resolve(this.context.phase) });
		  }
		  reduceLiteralNumericExpression(node_553, state_554) {
		    return new _terms2.default("LiteralNumericExpression", { value: node_553.value.val() });
		  }
		  reduceLiteralBooleanExpression(node_555, state_556) {
		    return new _terms2.default("LiteralBooleanExpression", { value: node_555.value.val() === "true" });
		  }
		  reduceLiteralStringExpression(node_557, state_558) {
		    return new _terms2.default("LiteralStringExpression", { value: node_557.value.token.str });
		  }
		  reduceCallExpression(node_559, state_560) {
		    return new _terms2.default("CallExpression", { callee: state_560.callee, arguments: state_560.arguments.toArray() });
		  }
		  reduceFunctionBody(node_561, state_562) {
		    return new _terms2.default("FunctionBody", { directives: state_562.directives.toArray(), statements: state_562.statements.toArray() });
		  }
		  reduceFormalParameters(node_563, state_564) {
		    return new _terms2.default("FormalParameters", { items: state_564.items.toArray(), rest: state_564.rest });
		  }
		  reduceBindingIdentifier(node_565, state_566) {
		    return new _terms2.default("BindingIdentifier", { name: node_565.name.resolve(this.context.phase) });
		  }
		  reduceBinaryExpression(node_567, state_568) {
		    return new _terms2.default("BinaryExpression", { left: state_568.left, operator: node_567.operator.val(), right: state_568.right });
		  }
		  reduceObjectExpression(node_569, state_570) {
		    return new _terms2.default("ObjectExpression", { properties: state_570.properties.toArray() });
		  }
		  reduceVariableDeclaration(node_571, state_572) {
		    return new _terms2.default("VariableDeclaration", { kind: state_572.kind, declarators: state_572.declarators.toArray() });
		  }
		  reduceStaticPropertyName(node_573, state_574) {
		    return new _terms2.default("StaticPropertyName", { value: node_573.value.val().toString() });
		  }
		  reduceArrayExpression(node_575, state_576) {
		    return new _terms2.default("ArrayExpression", { elements: state_576.elements.toArray() });
		  }
		  reduceStaticMemberExpression(node_577, state_578) {
		    return new _terms2.default("StaticMemberExpression", { object: state_578.object, property: state_578.property.val() });
		  }
		}
		exports.default = ParseReducer;
		//# sourceMappingURL=data:application/json;base64,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LEVBQTRCLEVBQUMsVUFBVSxVQUFVLFFBQVYsQ0FBbUIsT0FBbkIsRUFBWCxFQUE1QixDQUFQO0FBQ0Q7QUFDRCwrQkFBNkIsUUFBN0IsRUFBdUMsU0FBdkMsRUFBa0Q7QUFDaEQsV0FBTyxvQkFBUyx3QkFBVCxFQUFtQyxFQUFDLFFBQVEsVUFBVSxNQUFuQixFQUEyQixVQUFVLFVBQVUsUUFBVixDQUFtQixHQUFuQixFQUFyQyxFQUFuQyxDQUFQO0FBQ0Q7QUFuRm9EO2tCQUFsQyxZIiwiZmlsZSI6InBhcnNlLXJlZHVjZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGVybSBmcm9tIFwiLi90ZXJtc1wiO1xuaW1wb3J0IHtDbG9uZVJlZHVjZXJ9IGZyb20gXCJzaGlmdC1yZWR1Y2VyXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZVJlZHVjZXIgZXh0ZW5kcyBDbG9uZVJlZHVjZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0XzUyNykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF81Mjc7XG4gIH1cbiAgcmVkdWNlTW9kdWxlKG5vZGVfNTI4LCBzdGF0ZV81MjkpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJNb2R1bGVcIiwge2RpcmVjdGl2ZXM6IHN0YXRlXzUyOS5kaXJlY3RpdmVzLnRvQXJyYXkoKSwgaXRlbXM6IHN0YXRlXzUyOS5pdGVtcy50b0FycmF5KCl9KTtcbiAgfVxuICByZWR1Y2VJbXBvcnQobm9kZV81MzAsIHN0YXRlXzUzMSkge1xuICAgIGxldCBtb2R1bGVTcGVjaWZpZXJfNTMyID0gc3RhdGVfNTMxLm1vZHVsZVNwZWNpZmllciA/IHN0YXRlXzUzMS5tb2R1bGVTcGVjaWZpZXIudmFsKCkgOiBudWxsO1xuICAgIHJldHVybiBuZXcgVGVybShcIkltcG9ydFwiLCB7ZGVmYXVsdEJpbmRpbmc6IHN0YXRlXzUzMS5kZWZhdWx0QmluZGluZywgbmFtZWRJbXBvcnRzOiBzdGF0ZV81MzEubmFtZWRJbXBvcnRzLnRvQXJyYXkoKSwgbW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJfNTMyLCBmb3JTeW50YXg6IG5vZGVfNTMwLmZvclN5bnRheH0pO1xuICB9XG4gIHJlZHVjZUltcG9ydE5hbWVzcGFjZShub2RlXzUzMywgc3RhdGVfNTM0KSB7XG4gICAgbGV0IG1vZHVsZVNwZWNpZmllcl81MzUgPSBzdGF0ZV81MzQubW9kdWxlU3BlY2lmaWVyID8gc3RhdGVfNTM0Lm1vZHVsZVNwZWNpZmllci52YWwoKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0TmFtZXNwYWNlXCIsIHtkZWZhdWx0QmluZGluZzogc3RhdGVfNTM0LmRlZmF1bHRCaW5kaW5nLCBuYW1lc3BhY2VCaW5kaW5nOiBzdGF0ZV81MzQubmFtZXNwYWNlQmluZGluZywgbW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJfNTM1LCBmb3JTeW50YXg6IG5vZGVfNTMzLmZvclN5bnRheH0pO1xuICB9XG4gIHJlZHVjZUV4cG9ydChub2RlXzUzNiwgc3RhdGVfNTM3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogc3RhdGVfNTM3LmRlY2xhcmF0aW9ufSk7XG4gIH1cbiAgcmVkdWNlRXhwb3J0QWxsRnJvbShub2RlXzUzOCwgc3RhdGVfNTM5KSB7XG4gICAgbGV0IG1vZHVsZVNwZWNpZmllcl81NDAgPSBzdGF0ZV81MzkubW9kdWxlU3BlY2lmaWVyID8gc3RhdGVfNTM5Lm1vZHVsZVNwZWNpZmllci52YWwoKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0QWxsRnJvbVwiLCB7bW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJfNTQwfSk7XG4gIH1cbiAgcmVkdWNlRXhwb3J0RnJvbShub2RlXzU0MSwgc3RhdGVfNTQyKSB7XG4gICAgbGV0IG1vZHVsZVNwZWNpZmllcl81NDMgPSBzdGF0ZV81NDIubW9kdWxlU3BlY2lmaWVyID8gc3RhdGVfNTQyLm1vZHVsZVNwZWNpZmllci52YWwoKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0RnJvbVwiLCB7bW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJfNTQzLCBuYW1lZEV4cG9ydHM6IHN0YXRlXzU0Mi5uYW1lZEV4cG9ydHMudG9BcnJheSgpfSk7XG4gIH1cbiAgcmVkdWNlRXhwb3J0U3BlY2lmaWVyKG5vZGVfNTQ0LCBzdGF0ZV81NDUpIHtcbiAgICBsZXQgbmFtZV81NDYgPSBzdGF0ZV81NDUubmFtZSwgZXhwb3J0ZWROYW1lXzU0NyA9IHN0YXRlXzU0NS5leHBvcnRlZE5hbWU7XG4gICAgaWYgKG5hbWVfNTQ2ID09IG51bGwpIHtcbiAgICAgIG5hbWVfNTQ2ID0gZXhwb3J0ZWROYW1lXzU0Ny5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgICBleHBvcnRlZE5hbWVfNTQ3ID0gZXhwb3J0ZWROYW1lXzU0Ny52YWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZV81NDYgPSBuYW1lXzU0Ni5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgICBleHBvcnRlZE5hbWVfNTQ3ID0gZXhwb3J0ZWROYW1lXzU0Ny52YWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0U3BlY2lmaWVyXCIsIHtuYW1lOiBuYW1lXzU0NiwgZXhwb3J0ZWROYW1lOiBleHBvcnRlZE5hbWVfNTQ3fSk7XG4gIH1cbiAgcmVkdWNlSW1wb3J0U3BlY2lmaWVyKG5vZGVfNTQ4LCBzdGF0ZV81NDkpIHtcbiAgICBsZXQgbmFtZV81NTAgPSBzdGF0ZV81NDkubmFtZSA/IHN0YXRlXzU0OS5uYW1lLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0U3BlY2lmaWVyXCIsIHtuYW1lOiBuYW1lXzU1MCwgYmluZGluZzogc3RhdGVfNTQ5LmJpbmRpbmd9KTtcbiAgfVxuICByZWR1Y2VJZGVudGlmaWVyRXhwcmVzc2lvbihub2RlXzU1MSwgc3RhdGVfNTUyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IG5vZGVfNTUxLm5hbWUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpfSk7XG4gIH1cbiAgcmVkdWNlTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uKG5vZGVfNTUzLCBzdGF0ZV81NTQpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb25cIiwge3ZhbHVlOiBub2RlXzU1My52YWx1ZS52YWwoKX0pO1xuICB9XG4gIHJlZHVjZUxpdGVyYWxCb29sZWFuRXhwcmVzc2lvbihub2RlXzU1NSwgc3RhdGVfNTU2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uXCIsIHt2YWx1ZTogbm9kZV81NTUudmFsdWUudmFsKCkgPT09IFwidHJ1ZVwifSk7XG4gIH1cbiAgcmVkdWNlTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24obm9kZV81NTcsIHN0YXRlXzU1OCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxTdHJpbmdFeHByZXNzaW9uXCIsIHt2YWx1ZTogbm9kZV81NTcudmFsdWUudG9rZW4uc3RyfSk7XG4gIH1cbiAgcmVkdWNlQ2FsbEV4cHJlc3Npb24obm9kZV81NTksIHN0YXRlXzU2MCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNhbGxFeHByZXNzaW9uXCIsIHtjYWxsZWU6IHN0YXRlXzU2MC5jYWxsZWUsIGFyZ3VtZW50czogc3RhdGVfNTYwLmFyZ3VtZW50cy50b0FycmF5KCl9KTtcbiAgfVxuICByZWR1Y2VGdW5jdGlvbkJvZHkobm9kZV81NjEsIHN0YXRlXzU2Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIkZ1bmN0aW9uQm9keVwiLCB7ZGlyZWN0aXZlczogc3RhdGVfNTYyLmRpcmVjdGl2ZXMudG9BcnJheSgpLCBzdGF0ZW1lbnRzOiBzdGF0ZV81NjIuc3RhdGVtZW50cy50b0FycmF5KCl9KTtcbiAgfVxuICByZWR1Y2VGb3JtYWxQYXJhbWV0ZXJzKG5vZGVfNTYzLCBzdGF0ZV81NjQpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJGb3JtYWxQYXJhbWV0ZXJzXCIsIHtpdGVtczogc3RhdGVfNTY0Lml0ZW1zLnRvQXJyYXkoKSwgcmVzdDogc3RhdGVfNTY0LnJlc3R9KTtcbiAgfVxuICByZWR1Y2VCaW5kaW5nSWRlbnRpZmllcihub2RlXzU2NSwgc3RhdGVfNTY2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5vZGVfNTY1Lm5hbWUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpfSk7XG4gIH1cbiAgcmVkdWNlQmluYXJ5RXhwcmVzc2lvbihub2RlXzU2Nywgc3RhdGVfNTY4KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7bGVmdDogc3RhdGVfNTY4LmxlZnQsIG9wZXJhdG9yOiBub2RlXzU2Ny5vcGVyYXRvci52YWwoKSwgcmlnaHQ6IHN0YXRlXzU2OC5yaWdodH0pO1xuICB9XG4gIHJlZHVjZU9iamVjdEV4cHJlc3Npb24obm9kZV81NjksIHN0YXRlXzU3MCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEV4cHJlc3Npb25cIiwge3Byb3BlcnRpZXM6IHN0YXRlXzU3MC5wcm9wZXJ0aWVzLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZVZhcmlhYmxlRGVjbGFyYXRpb24obm9kZV81NzEsIHN0YXRlXzU3Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwge2tpbmQ6IHN0YXRlXzU3Mi5raW5kLCBkZWNsYXJhdG9yczogc3RhdGVfNTcyLmRlY2xhcmF0b3JzLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZVN0YXRpY1Byb3BlcnR5TmFtZShub2RlXzU3Mywgc3RhdGVfNTc0KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3RhdGljUHJvcGVydHlOYW1lXCIsIHt2YWx1ZTogbm9kZV81NzMudmFsdWUudmFsKCkudG9TdHJpbmcoKX0pO1xuICB9XG4gIHJlZHVjZUFycmF5RXhwcmVzc2lvbihub2RlXzU3NSwgc3RhdGVfNTc2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlFeHByZXNzaW9uXCIsIHtlbGVtZW50czogc3RhdGVfNTc2LmVsZW1lbnRzLnRvQXJyYXkoKX0pO1xuICB9XG4gIHJlZHVjZVN0YXRpY01lbWJlckV4cHJlc3Npb24obm9kZV81NzcsIHN0YXRlXzU3OCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIiwge29iamVjdDogc3RhdGVfNTc4Lm9iamVjdCwgcHJvcGVydHk6IHN0YXRlXzU3OC5wcm9wZXJ0eS52YWwoKX0pO1xuICB9XG59XG4iXX0=

	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.SemiOp = exports.CommaSep = exports.Semi = exports.Seq = exports.ContainsIn = exports.NoIn = exports.Brace = exports.Bracket = exports.Paren = exports.NumberCodeRep = exports.Token = exports.Empty = exports.CodeRep = exports.escapeStringLiteral = exports.getPrecedence = exports.Precedence = exports.Sep = exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.MinimalCodeGen = undefined;
		exports.default = codeGen;

		var _minimalCodegen = __webpack_require__(36);

		Object.defineProperty(exports, "MinimalCodeGen", {
		  enumerable: true,
		  get: function get() {
		    return _minimalCodegen.default;
		  }
		});

		var _formattedCodegen = __webpack_require__(39);

		Object.defineProperty(exports, "ExtensibleCodeGen", {
		  enumerable: true,
		  get: function get() {
		    return _formattedCodegen.ExtensibleCodeGen;
		  }
		});
		Object.defineProperty(exports, "FormattedCodeGen", {
		  enumerable: true,
		  get: function get() {
		    return _formattedCodegen.FormattedCodeGen;
		  }
		});
		Object.defineProperty(exports, "Sep", {
		  enumerable: true,
		  get: function get() {
		    return _formattedCodegen.Sep;
		  }
		});

		var _coderep = __webpack_require__(38);

		Object.defineProperty(exports, "Precedence", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Precedence;
		  }
		});
		Object.defineProperty(exports, "getPrecedence", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.getPrecedence;
		  }
		});
		Object.defineProperty(exports, "escapeStringLiteral", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.escapeStringLiteral;
		  }
		});
		Object.defineProperty(exports, "CodeRep", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.CodeRep;
		  }
		});
		Object.defineProperty(exports, "Empty", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Empty;
		  }
		});
		Object.defineProperty(exports, "Token", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Token;
		  }
		});
		Object.defineProperty(exports, "NumberCodeRep", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.NumberCodeRep;
		  }
		});
		Object.defineProperty(exports, "Paren", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Paren;
		  }
		});
		Object.defineProperty(exports, "Bracket", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Bracket;
		  }
		});
		Object.defineProperty(exports, "Brace", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Brace;
		  }
		});
		Object.defineProperty(exports, "NoIn", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.NoIn;
		  }
		});
		Object.defineProperty(exports, "ContainsIn", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.ContainsIn;
		  }
		});
		Object.defineProperty(exports, "Seq", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Seq;
		  }
		});
		Object.defineProperty(exports, "Semi", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.Semi;
		  }
		});
		Object.defineProperty(exports, "CommaSep", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.CommaSep;
		  }
		});
		Object.defineProperty(exports, "SemiOp", {
		  enumerable: true,
		  get: function get() {
		    return _coderep.SemiOp;
		  }
		});

		var _shiftReducer = __webpack_require__(30);

		var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

		var _token_stream = __webpack_require__(40);

		var _minimalCodegen2 = _interopRequireDefault(_minimalCodegen);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function codeGen(script) {
		  var generator = arguments.length <= 1 || arguments[1] === undefined ? new _minimalCodegen2.default() : arguments[1];

		  var ts = new _token_stream.TokenStream();
		  var rep = (0, _shiftReducer2.default)(generator, script);
		  rep.emit(ts);
		  return ts.result;
		}

	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _objectAssign = __webpack_require__(37);

		var _objectAssign2 = _interopRequireDefault(_objectAssign);

		var _esutils = __webpack_require__(4);

		var _coderep = __webpack_require__(38);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function p(node, precedence, a) {
		  return (0, _coderep.getPrecedence)(node) < precedence ? paren(a) : a;
		}

		function t(token) {
		  return new _coderep.Token(token);
		}

		function paren(rep) {
		  return new _coderep.Paren(rep);
		}

		function brace(rep) {
		  return new _coderep.Brace(rep);
		}

		function bracket(rep) {
		  return new _coderep.Bracket(rep);
		}

		function noIn(rep) {
		  return new _coderep.NoIn(rep);
		}

		function markContainsIn(state) {
		  return state.containsIn ? new _coderep.ContainsIn(state) : state;
		}

		function seq() {
		  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
		    reps[_key] = arguments[_key];
		  }

		  return new _coderep.Seq(reps);
		}

		function semi() {
		  return new _coderep.Semi();
		}

		function semiOp() {
		  return new _coderep.SemiOp();
		}

		function empty() {
		  return new _coderep.Empty();
		}

		function commaSep(pieces) {
		  return new _coderep.CommaSep(pieces);
		}

		function getAssignmentExpr(state) {
		  return state ? state.containsGroup ? paren(state) : state : empty();
		}

		var MinimalCodeGen = function () {
		  function MinimalCodeGen() {
		    _classCallCheck(this, MinimalCodeGen);
		  }

		  _createClass(MinimalCodeGen, [{
		    key: "parenToAvoidBeingDirective",
		    value: function parenToAvoidBeingDirective(element, original) {
		      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
		        return seq(paren(original.children[0]), semiOp());
		      }
		      return original;
		    }
		  }, {
		    key: "reduceArrayExpression",
		    value: function reduceArrayExpression(node, _ref) {
		      var elements = _ref.elements;

		      if (elements.length === 0) {
		        return bracket(empty());
		      }

		      var content = commaSep(elements.map(getAssignmentExpr));
		      if (elements.length > 0 && elements[elements.length - 1] == null) {
		        content = seq(content, t(","));
		      }
		      return bracket(content);
		    }
		  }, {
		    key: "reduceSpreadElement",
		    value: function reduceSpreadElement(node, _ref2) {
		      var expression = _ref2.expression;

		      return seq(t("..."), p(node.expression, _coderep.Precedence.Assignment, expression));
		    }
		  }, {
		    key: "reduceAssignmentExpression",
		    value: function reduceAssignmentExpression(node, _ref3) {
		      var binding = _ref3.binding;
		      var expression = _ref3.expression;

		      var leftCode = binding;
		      var rightCode = expression;
		      var containsIn = expression.containsIn;
		      var startsWithCurly = binding.startsWithCurly;
		      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
		      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
		        rightCode = paren(rightCode);
		        containsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, t("="), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
		    }
		  }, {
		    key: "reduceCompoundAssignmentExpression",
		    value: function reduceCompoundAssignmentExpression(node, _ref4) {
		      var binding = _ref4.binding;
		      var expression = _ref4.expression;

		      var leftCode = binding;
		      var rightCode = expression;
		      var containsIn = expression.containsIn;
		      var startsWithCurly = binding.startsWithCurly;
		      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
		      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
		        rightCode = paren(rightCode);
		        containsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
		    }
		  }, {
		    key: "reduceBinaryExpression",
		    value: function reduceBinaryExpression(node, _ref5) {
		      var left = _ref5.left;
		      var right = _ref5.right;

		      var leftCode = left;
		      var startsWithCurly = left.startsWithCurly;
		      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
		      var leftContainsIn = left.containsIn;
		      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
		        leftCode = paren(leftCode);
		        startsWithCurly = false;
		        startsWithLetSquareBracket = false;
		        startsWithFunctionOrClass = false;
		        leftContainsIn = false;
		      }
		      var rightCode = right;
		      var rightContainsIn = right.containsIn;
		      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
		        rightCode = paren(rightCode);
		        rightContainsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), {
		        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
		        containsGroup: node.operator == ",",
		        startsWithCurly: startsWithCurly,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithFunctionOrClass: startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceBindingWithDefault",
		    value: function reduceBindingWithDefault(node, _ref6) {
		      var binding = _ref6.binding;
		      var init = _ref6.init;

		      return seq(binding, t("="), init);
		    }
		  }, {
		    key: "reduceBindingIdentifier",
		    value: function reduceBindingIdentifier(node) {
		      var a = t(node.name);
		      if (node.name === "let") {
		        a.startsWithLet = true;
		      }
		      return a;
		    }
		  }, {
		    key: "reduceArrayBinding",
		    value: function reduceArrayBinding(node, _ref7) {
		      var elements = _ref7.elements;
		      var restElement = _ref7.restElement;

		      var content = undefined;
		      if (elements.length === 0) {
		        content = restElement == null ? empty() : seq(t("..."), restElement);
		      } else {
		        elements = elements.concat(restElement == null ? [] : [seq(t("..."), restElement)]);
		        content = commaSep(elements.map(getAssignmentExpr));
		        if (elements.length > 0 && elements[elements.length - 1] == null) {
		          content = seq(content, t(","));
		        }
		      }
		      return bracket(content);
		    }
		  }, {
		    key: "reduceObjectBinding",
		    value: function reduceObjectBinding(node, _ref8) {
		      var properties = _ref8.properties;

		      var state = brace(commaSep(properties));
		      state.startsWithCurly = true;
		      return state;
		    }
		  }, {
		    key: "reduceBindingPropertyIdentifier",
		    value: function reduceBindingPropertyIdentifier(node, _ref9) {
		      var binding = _ref9.binding;
		      var init = _ref9.init;

		      if (node.init == null) return binding;
		      return seq(binding, t("="), init);
		    }
		  }, {
		    key: "reduceBindingPropertyProperty",
		    value: function reduceBindingPropertyProperty(node, _ref10) {
		      var name = _ref10.name;
		      var binding = _ref10.binding;

		      return seq(name, t(":"), binding);
		    }
		  }, {
		    key: "reduceBlock",
		    value: function reduceBlock(node, _ref11) {
		      var statements = _ref11.statements;

		      return brace(seq.apply(undefined, _toConsumableArray(statements)));
		    }
		  }, {
		    key: "reduceBlockStatement",
		    value: function reduceBlockStatement(node, _ref12) {
		      var block = _ref12.block;

		      return block;
		    }
		  }, {
		    key: "reduceBreakStatement",
		    value: function reduceBreakStatement(node, _ref13) {
		      var label = _ref13.label;

		      return seq(t("break"), label ? t(label) : empty(), semiOp());
		    }
		  }, {
		    key: "reduceCallExpression",
		    value: function reduceCallExpression(node, _ref14) {
		      var callee = _ref14.callee;
		      var args = _ref14.arguments;

		      return (0, _objectAssign2.default)(seq(p(node.callee, (0, _coderep.getPrecedence)(node), callee), paren(commaSep(args))), {
		        startsWithCurly: callee.startsWithCurly,
		        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
		        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceCatchClause",
		    value: function reduceCatchClause(node, _ref15) {
		      var binding = _ref15.binding;
		      var body = _ref15.body;

		      return seq(t("catch"), paren(binding), body);
		    }
		  }, {
		    key: "reduceClassDeclaration",
		    value: function reduceClassDeclaration(node, _ref16) {
		      var name = _ref16.name;
		      var _super = _ref16.super;
		      var elements = _ref16.elements;

		      var state = seq(t("class"), name);
		      if (_super != null) {
		        state = seq(state, t("extends"), _super);
		      }
		      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
		      return state;
		    }
		  }, {
		    key: "reduceClassExpression",
		    value: function reduceClassExpression(node, _ref17) {
		      var name = _ref17.name;
		      var _super = _ref17.super;
		      var elements = _ref17.elements;

		      var state = t("class");
		      if (name != null) {
		        state = seq(state, name);
		      }
		      if (_super != null) {
		        state = seq(state, t("extends"), _super);
		      }
		      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
		      state.startsWithFunctionOrClass = true;
		      return state;
		    }
		  }, {
		    key: "reduceClassElement",
		    value: function reduceClassElement(node, _ref18) {
		      var method = _ref18.method;

		      if (!node.isStatic) return method;
		      return seq(t("static"), method);
		    }
		  }, {
		    key: "reduceComputedMemberExpression",
		    value: function reduceComputedMemberExpression(node, _ref19) {
		      var object = _ref19.object;
		      var expression = _ref19.expression;

		      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
		      return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
		        startsWithLet: object.startsWithLet,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithCurly: object.startsWithCurly,
		        startsWithFunctionOrClass: object.startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceComputedPropertyName",
		    value: function reduceComputedPropertyName(node, _ref20) {
		      var expression = _ref20.expression;

		      return bracket(expression);
		    }
		  }, {
		    key: "reduceConditionalExpression",
		    value: function reduceConditionalExpression(node, _ref21) {
		      var test = _ref21.test;
		      var consequent = _ref21.consequent;
		      var alternate = _ref21.alternate;

		      var containsIn = test.containsIn || alternate.containsIn;
		      var startsWithCurly = test.startsWithCurly;
		      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
		      return (0, _objectAssign2.default)(seq(p(node.test, _coderep.Precedence.LogicalOR, test), t("?"), p(node.consequent, _coderep.Precedence.Assignment, consequent), t(":"), p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
		        containsIn: containsIn,
		        startsWithCurly: startsWithCurly,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithFunctionOrClass: startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceContinueStatement",
		    value: function reduceContinueStatement(node, _ref22) {
		      var label = _ref22.label;

		      return seq(t("continue"), label ? t(label) : empty(), semiOp());
		    }
		  }, {
		    key: "reduceDataProperty",
		    value: function reduceDataProperty(node, _ref23) {
		      var name = _ref23.name;
		      var expression = _ref23.expression;

		      return seq(name, t(":"), getAssignmentExpr(expression));
		    }
		  }, {
		    key: "reduceDebuggerStatement",
		    value: function reduceDebuggerStatement(node) {
		      return seq(t("debugger"), semiOp());
		    }
		  }, {
		    key: "reduceDoWhileStatement",
		    value: function reduceDoWhileStatement(node, _ref24) {
		      var body = _ref24.body;
		      var test = _ref24.test;

		      return seq(t("do"), body, t("while"), paren(test), semiOp());
		    }
		  }, {
		    key: "reduceEmptyStatement",
		    value: function reduceEmptyStatement(node) {
		      return semi();
		    }
		  }, {
		    key: "reduceExpressionStatement",
		    value: function reduceExpressionStatement(node, _ref25) {
		      var expression = _ref25.expression;

		      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
		      return seq(needsParens ? paren(expression) : expression, semiOp());
		    }
		  }, {
		    key: "reduceForInStatement",
		    value: function reduceForInStatement(node, _ref26) {
		      var left = _ref26.left;
		      var right = _ref26.right;
		      var body = _ref26.body;

		      var leftP = left;
		      switch (node.left.type) {
		        case "VariableDeclaration":
		          leftP = noIn(markContainsIn(left));
		          break;
		        case "BindingIdentifier":
		          if (node.left.name === "let") {
		            leftP = paren(left);
		          }
		          break;
		      }
		      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(leftP, t("in"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceForOfStatement",
		    value: function reduceForOfStatement(node, _ref27) {
		      var left = _ref27.left;
		      var right = _ref27.right;
		      var body = _ref27.body;

		      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
		      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(left.startsWithLet ? paren(left) : left, t("of"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceForStatement",
		    value: function reduceForStatement(node, _ref28) {
		      var init = _ref28.init;
		      var test = _ref28.test;
		      var update = _ref28.update;
		      var body = _ref28.body;

		      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(init ? noIn(markContainsIn(init)) : empty(), semi(), test || empty(), semi(), update || empty())), body), {
		        endsWithMissingElse: body.endsWithMissingElse
		      });
		    }
		  }, {
		    key: "reduceFunctionBody",
		    value: function reduceFunctionBody(node, _ref29) {
		      var directives = _ref29.directives;
		      var statements = _ref29.statements;

		      if (statements.length) {
		        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
		    }
		  }, {
		    key: "reduceFunctionDeclaration",
		    value: function reduceFunctionDeclaration(node, _ref30) {
		      var name = _ref30.name;
		      var params = _ref30.params;
		      var body = _ref30.body;

		      return seq(t("function"), node.isGenerator ? t("*") : empty(), node.name.name === "*default*" ? empty() : name, paren(params), brace(body));
		    }
		  }, {
		    key: "reduceFunctionExpression",
		    value: function reduceFunctionExpression(node, _ref31) {
		      var name = _ref31.name;
		      var params = _ref31.params;
		      var body = _ref31.body;

		      var state = seq(t("function"), node.isGenerator ? t("*") : empty(), name ? name : empty(), paren(params), brace(body));
		      state.startsWithFunctionOrClass = true;
		      return state;
		    }
		  }, {
		    key: "reduceFormalParameters",
		    value: function reduceFormalParameters(node, _ref32) {
		      var items = _ref32.items;
		      var rest = _ref32.rest;

		      return commaSep(items.concat(rest == null ? [] : [seq(t("..."), rest)]));
		    }
		  }, {
		    key: "reduceArrowExpression",
		    value: function reduceArrowExpression(node, _ref33) {
		      var params = _ref33.params;
		      var body = _ref33.body;

		      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
		        params = paren(params);
		      }
		      if (node.body.type === "FunctionBody") {
		        body = brace(body);
		      } else if (body.startsWithCurly) {
		        body = paren(body);
		      }
		      return seq(params, t("=>"), p(node.body, _coderep.Precedence.Assignment, body));
		    }
		  }, {
		    key: "reduceGetter",
		    value: function reduceGetter(node, _ref34) {
		      var name = _ref34.name;
		      var body = _ref34.body;

		      return seq(t("get"), name, paren(empty()), brace(body));
		    }
		  }, {
		    key: "reduceIdentifierExpression",
		    value: function reduceIdentifierExpression(node) {
		      var a = t(node.name);
		      if (node.name === "let") {
		        a.startsWithLet = true;
		      }
		      return a;
		    }
		  }, {
		    key: "reduceIfStatement",
		    value: function reduceIfStatement(node, _ref35) {
		      var test = _ref35.test;
		      var consequent = _ref35.consequent;
		      var alternate = _ref35.alternate;

		      if (alternate && consequent.endsWithMissingElse) {
		        consequent = brace(consequent);
		      }
		      return (0, _objectAssign2.default)(seq(t("if"), paren(test), consequent, alternate ? seq(t("else"), alternate) : empty()), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
		    }
		  }, {
		    key: "reduceImport",
		    value: function reduceImport(node, _ref36) {
		      var defaultBinding = _ref36.defaultBinding;
		      var namedImports = _ref36.namedImports;

		      var bindings = [];
		      if (defaultBinding != null) {
		        bindings.push(defaultBinding);
		      }
		      if (namedImports.length > 0) {
		        bindings.push(brace(commaSep(namedImports)));
		      }
		      if (bindings.length === 0) {
		        return seq(t("import"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
		      }
		      return seq(t("import"), commaSep(bindings), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
		    }
		  }, {
		    key: "reduceImportNamespace",
		    value: function reduceImportNamespace(node, _ref37) {
		      var defaultBinding = _ref37.defaultBinding;
		      var namespaceBinding = _ref37.namespaceBinding;

		      return seq(t("import"), defaultBinding == null ? empty() : seq(defaultBinding, t(",")), t("*"), t("as"), namespaceBinding, t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
		    }
		  }, {
		    key: "reduceImportSpecifier",
		    value: function reduceImportSpecifier(node, _ref38) {
		      var binding = _ref38.binding;

		      if (node.name == null) return binding;
		      return seq(t(node.name), t("as"), binding);
		    }
		  }, {
		    key: "reduceExportAllFrom",
		    value: function reduceExportAllFrom(node) {
		      return seq(t("export"), t("*"), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
		    }
		  }, {
		    key: "reduceExportFrom",
		    value: function reduceExportFrom(node, _ref39) {
		      var namedExports = _ref39.namedExports;

		      return seq(t("export"), brace(commaSep(namedExports)), node.moduleSpecifier == null ? empty() : seq(t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp()));
		    }
		  }, {
		    key: "reduceExport",
		    value: function reduceExport(node, _ref40) {
		      var declaration = _ref40.declaration;

		      switch (node.declaration.type) {
		        case "FunctionDeclaration":
		        case "ClassDeclaration":
		          break;
		        default:
		          declaration = seq(declaration, semiOp());
		      }
		      return seq(t("export"), declaration);
		    }
		  }, {
		    key: "reduceExportDefault",
		    value: function reduceExportDefault(node, _ref41) {
		      var body = _ref41.body;

		      body = body.startsWithFunctionOrClass ? paren(body) : body;
		      switch (node.body.type) {
		        case "FunctionDeclaration":
		        case "ClassDeclaration":
		          break;
		        default:
		          body = seq(body, semiOp());
		      }
		      return seq(t("export default"), body);
		    }
		  }, {
		    key: "reduceExportSpecifier",
		    value: function reduceExportSpecifier(node) {
		      if (node.name == null) return t(node.exportedName);
		      return seq(t(node.name), t("as"), t(node.exportedName));
		    }
		  }, {
		    key: "reduceLabeledStatement",
		    value: function reduceLabeledStatement(node, _ref42) {
		      var label = _ref42.label;
		      var body = _ref42.body;

		      return (0, _objectAssign2.default)(seq(t(label + ":"), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceLiteralBooleanExpression",
		    value: function reduceLiteralBooleanExpression(node) {
		      return t(node.value.toString());
		    }
		  }, {
		    key: "reduceLiteralNullExpression",
		    value: function reduceLiteralNullExpression(node) {
		      return t("null");
		    }
		  }, {
		    key: "reduceLiteralInfinityExpression",
		    value: function reduceLiteralInfinityExpression(node) {
		      return t("2e308");
		    }
		  }, {
		    key: "reduceLiteralNumericExpression",
		    value: function reduceLiteralNumericExpression(node) {
		      return new _coderep.NumberCodeRep(node.value);
		    }
		  }, {
		    key: "reduceLiteralRegExpExpression",
		    value: function reduceLiteralRegExpExpression(node) {
		      return t("/" + node.pattern + "/" + node.flags);
		    }
		  }, {
		    key: "reduceLiteralStringExpression",
		    value: function reduceLiteralStringExpression(node) {
		      return t((0, _coderep.escapeStringLiteral)(node.value));
		    }
		  }, {
		    key: "reduceMethod",
		    value: function reduceMethod(node, _ref43) {
		      var name = _ref43.name;
		      var params = _ref43.params;
		      var body = _ref43.body;

		      return seq(node.isGenerator ? t("*") : empty(), name, paren(params), brace(body));
		    }
		  }, {
		    key: "reduceModule",
		    value: function reduceModule(node, _ref44) {
		      var directives = _ref44.directives;
		      var items = _ref44.items;

		      if (items.length) {
		        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(items)));
		    }
		  }, {
		    key: "reduceNewExpression",
		    value: function reduceNewExpression(node, _ref45) {
		      var callee = _ref45.callee;
		      var args = _ref45.arguments;

		      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? paren(callee) : p(node.callee, (0, _coderep.getPrecedence)(node), callee);
		      return seq(t("new"), calleeRep, args.length === 0 ? empty() : paren(commaSep(args)));
		    }
		  }, {
		    key: "reduceNewTargetExpression",
		    value: function reduceNewTargetExpression() {
		      return t("new.target");
		    }
		  }, {
		    key: "reduceObjectExpression",
		    value: function reduceObjectExpression(node, _ref46) {
		      var properties = _ref46.properties;

		      var state = brace(commaSep(properties));
		      state.startsWithCurly = true;
		      return state;
		    }
		  }, {
		    key: "reduceUpdateExpression",
		    value: function reduceUpdateExpression(node, _ref47) {
		      var operand = _ref47.operand;

		      if (node.isPrefix) {
		        return this.reduceUnaryExpression.apply(this, arguments);
		      } else {
		        return (0, _objectAssign2.default)(seq(p(node.operand, _coderep.Precedence.New, operand), t(node.operator)), {
		          startsWithCurly: operand.startsWithCurly,
		          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
		          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
		        });
		      }
		    }
		  }, {
		    key: "reduceUnaryExpression",
		    value: function reduceUnaryExpression(node, _ref48) {
		      var operand = _ref48.operand;

		      return seq(t(node.operator), p(node.operand, (0, _coderep.getPrecedence)(node), operand));
		    }
		  }, {
		    key: "reduceReturnStatement",
		    value: function reduceReturnStatement(node, _ref49) {
		      var expression = _ref49.expression;

		      return seq(t("return"), expression || empty(), semiOp());
		    }
		  }, {
		    key: "reduceScript",
		    value: function reduceScript(node, _ref50) {
		      var directives = _ref50.directives;
		      var statements = _ref50.statements;

		      if (statements.length) {
		        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
		    }
		  }, {
		    key: "reduceSetter",
		    value: function reduceSetter(node, _ref51) {
		      var name = _ref51.name;
		      var param = _ref51.param;
		      var body = _ref51.body;

		      return seq(t("set"), name, paren(param), brace(body));
		    }
		  }, {
		    key: "reduceShorthandProperty",
		    value: function reduceShorthandProperty(node) {
		      return t(node.name);
		    }
		  }, {
		    key: "reduceStaticMemberExpression",
		    value: function reduceStaticMemberExpression(node, _ref52) {
		      var object = _ref52.object;
		      var property = _ref52.property;

		      var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(property));
		      state.startsWithLet = object.startsWithLet;
		      state.startsWithCurly = object.startsWithCurly;
		      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
		      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
		      return state;
		    }
		  }, {
		    key: "reduceStaticPropertyName",
		    value: function reduceStaticPropertyName(node) {
		      var n;
		      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
		        return t(node.value);
		      } else if (n = parseFloat(node.value), n === n) {
		        return new _coderep.NumberCodeRep(n);
		      }
		      return t((0, _coderep.escapeStringLiteral)(node.value));
		    }
		  }, {
		    key: "reduceSuper",
		    value: function reduceSuper() {
		      return t("super");
		    }
		  }, {
		    key: "reduceSwitchCase",
		    value: function reduceSwitchCase(node, _ref53) {
		      var test = _ref53.test;
		      var consequent = _ref53.consequent;

		      return seq(t("case"), test, t(":"), seq.apply(undefined, _toConsumableArray(consequent)));
		    }
		  }, {
		    key: "reduceSwitchDefault",
		    value: function reduceSwitchDefault(node, _ref54) {
		      var consequent = _ref54.consequent;

		      return seq(t("default:"), seq.apply(undefined, _toConsumableArray(consequent)));
		    }
		  }, {
		    key: "reduceSwitchStatement",
		    value: function reduceSwitchStatement(node, _ref55) {
		      var discriminant = _ref55.discriminant;
		      var cases = _ref55.cases;

		      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(cases))));
		    }
		  }, {
		    key: "reduceSwitchStatementWithDefault",
		    value: function reduceSwitchStatementWithDefault(node, _ref56) {
		      var discriminant = _ref56.discriminant;
		      var preDefaultCases = _ref56.preDefaultCases;
		      var defaultCase = _ref56.defaultCase;
		      var postDefaultCases = _ref56.postDefaultCases;

		      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases)))));
		    }
		  }, {
		    key: "reduceTemplateExpression",
		    value: function reduceTemplateExpression(node, _ref57) {
		      var tag = _ref57.tag;
		      var elements = _ref57.elements;

		      var state = node.tag == null ? empty() : p(node.tag, (0, _coderep.getPrecedence)(node), tag);
		      var templateData = "";
		      state = seq(state, t("`"));
		      for (var i = 0, l = node.elements.length; i < l; ++i) {
		        if (node.elements[i].type === "TemplateElement") {
		          var d = "";
		          if (i > 0) d += "}";
		          d += node.elements[i].rawValue;
		          if (i < l - 1) d += "${";
		          state = seq(state, t(d));
		        } else {
		          state = seq(state, elements[i]);
		        }
		      }
		      state = seq(state, t("`"));
		      if (node.tag != null) {
		        state.startsWithCurly = tag.startsWithCurly;
		        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
		        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
		      }
		      return state;
		    }
		  }, {
		    key: "reduceTemplateElement",
		    value: function reduceTemplateElement(node) {
		      return t(node.rawValue);
		    }
		  }, {
		    key: "reduceThisExpression",
		    value: function reduceThisExpression(node) {
		      return t("this");
		    }
		  }, {
		    key: "reduceThrowStatement",
		    value: function reduceThrowStatement(node, _ref58) {
		      var expression = _ref58.expression;

		      return seq(t("throw"), expression, semiOp());
		    }
		  }, {
		    key: "reduceTryCatchStatement",
		    value: function reduceTryCatchStatement(node, _ref59) {
		      var body = _ref59.body;
		      var catchClause = _ref59.catchClause;

		      return seq(t("try"), body, catchClause);
		    }
		  }, {
		    key: "reduceTryFinallyStatement",
		    value: function reduceTryFinallyStatement(node, _ref60) {
		      var body = _ref60.body;
		      var catchClause = _ref60.catchClause;
		      var finalizer = _ref60.finalizer;

		      return seq(t("try"), body, catchClause || empty(), t("finally"), finalizer);
		    }
		  }, {
		    key: "reduceYieldExpression",
		    value: function reduceYieldExpression(node, _ref61) {
		      var expression = _ref61.expression;

		      if (node.expression == null) return t("yield");
		      return seq(t("yield"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
		    }
		  }, {
		    key: "reduceYieldGeneratorExpression",
		    value: function reduceYieldGeneratorExpression(node, _ref62) {
		      var expression = _ref62.expression;

		      return seq(t("yield"), t("*"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
		    }
		  }, {
		    key: "reduceDirective",
		    value: function reduceDirective(node) {
		      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
		      return seq(t(delim + node.rawValue + delim), semiOp());
		    }
		  }, {
		    key: "reduceVariableDeclaration",
		    value: function reduceVariableDeclaration(node, _ref63) {
		      var declarators = _ref63.declarators;

		      return seq(t(node.kind), commaSep(declarators));
		    }
		  }, {
		    key: "reduceVariableDeclarationStatement",
		    value: function reduceVariableDeclarationStatement(node, _ref64) {
		      var declaration = _ref64.declaration;

		      return seq(declaration, semiOp());
		    }
		  }, {
		    key: "reduceVariableDeclarator",
		    value: function reduceVariableDeclarator(node, _ref65) {
		      var binding = _ref65.binding;
		      var init = _ref65.init;

		      var containsIn = init && init.containsIn && !init.containsGroup;
		      if (init) {
		        if (init.containsGroup) {
		          init = paren(init);
		        } else {
		          init = markContainsIn(init);
		        }
		      }
		      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, t("="), init), { containsIn: containsIn });
		    }
		  }, {
		    key: "reduceWhileStatement",
		    value: function reduceWhileStatement(node, _ref66) {
		      var test = _ref66.test;
		      var body = _ref66.body;

		      return (0, _objectAssign2.default)(seq(t("while"), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceWithStatement",
		    value: function reduceWithStatement(node, _ref67) {
		      var object = _ref67.object;
		      var body = _ref67.body;

		      return (0, _objectAssign2.default)(seq(t("with"), paren(object), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }]);

		  return MinimalCodeGen;
		}();

		exports.default = MinimalCodeGen;

	/***/ },
	/* 37 */
	/***/ function(module, exports) {

		'use strict';
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;

		function ToObject(val) {
			if (val == null) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}

		function ownEnumerableKeys(obj) {
			var keys = Object.getOwnPropertyNames(obj);

			if (Object.getOwnPropertySymbols) {
				keys = keys.concat(Object.getOwnPropertySymbols(obj));
			}

			return keys.filter(function (key) {
				return propIsEnumerable.call(obj, key);
			});
		}

		module.exports = Object.assign || function (target, source) {
			var from;
			var keys;
			var to = ToObject(target);

			for (var s = 1; s < arguments.length; s++) {
				from = arguments[s];
				keys = ownEnumerableKeys(Object(from));

				for (var i = 0; i < keys.length; i++) {
					to[keys[i]] = from[keys[i]];
				}
			}

			return to;
		};


	/***/ },
	/* 38 */
	/***/ function(module, exports) {

		"use strict";

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.getPrecedence = getPrecedence;
		exports.escapeStringLiteral = escapeStringLiteral;

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var Precedence = {
		  Sequence: 0,
		  Yield: 1,
		  Assignment: 1,
		  Conditional: 2,
		  ArrowFunction: 2,
		  LogicalOR: 3,
		  LogicalAND: 4,
		  BitwiseOR: 5,
		  BitwiseXOR: 6,
		  BitwiseAND: 7,
		  Equality: 8,
		  Relational: 9,
		  BitwiseSHIFT: 10,
		  Additive: 11,
		  Multiplicative: 12,
		  Prefix: 13,
		  Postfix: 14,
		  New: 15,
		  Call: 16,
		  TaggedTemplate: 17,
		  Member: 18,
		  Primary: 19
		};

		exports.Precedence = Precedence;

		var BinaryPrecedence = {
		  ",": Precedence.Sequence,
		  "||": Precedence.LogicalOR,
		  "&&": Precedence.LogicalAND,
		  "|": Precedence.BitwiseOR,
		  "^": Precedence.BitwiseXOR,
		  "&": Precedence.BitwiseAND,
		  "==": Precedence.Equality,
		  "!=": Precedence.Equality,
		  "===": Precedence.Equality,
		  "!==": Precedence.Equality,
		  "<": Precedence.Relational,
		  ">": Precedence.Relational,
		  "<=": Precedence.Relational,
		  ">=": Precedence.Relational,
		  "in": Precedence.Relational,
		  "instanceof": Precedence.Relational,
		  "<<": Precedence.BitwiseSHIFT,
		  ">>": Precedence.BitwiseSHIFT,
		  ">>>": Precedence.BitwiseSHIFT,
		  "+": Precedence.Additive,
		  "-": Precedence.Additive,
		  "*": Precedence.Multiplicative,
		  "%": Precedence.Multiplicative,
		  "/": Precedence.Multiplicative
		};

		function getPrecedence(node) {
		  switch (node.type) {
		    case "ArrayExpression":
		    case "FunctionExpression":
		    case "IdentifierExpression":
		    case "LiteralBooleanExpression":
		    case "LiteralNullExpression":
		    case "LiteralNumericExpression":
		    case "LiteralInfinityExpression":
		    case "LiteralRegExpExpression":
		    case "LiteralStringExpression":
		    case "ObjectExpression":
		    case "ThisExpression":
		      return Precedence.Primary;

		    case "ArrowExpression":
		    case "AssignmentExpression":
		    case "CompoundAssignmentExpression":
		    case "YieldExpression":
		    case "YieldGeneratorExpression":
		      return Precedence.Assignment;

		    case "ConditionalExpression":
		      return Precedence.Conditional;

		    case "ComputedMemberExpression":
		    case "StaticMemberExpression":
		      switch (node.object.type) {
		        case "CallExpression":
		        case "ComputedMemberExpression":
		        case "StaticMemberExpression":
		        case "TemplateExpression":
		          return getPrecedence(node.object);
		        default:
		          return Precedence.Member;
		      }

		    case "TemplateExpression":
		      if (node.tag == null) return Precedence.Member;
		      switch (node.tag.type) {
		        case "CallExpression":
		        case "ComputedMemberExpression":
		        case "StaticMemberExpression":
		        case "TemplateExpression":
		          return getPrecedence(node.tag);
		        default:
		          return Precedence.Member;
		      }

		    case "BinaryExpression":
		      return BinaryPrecedence[node.operator];

		    case "CallExpression":
		      return Precedence.Call;
		    case "NewExpression":
		      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;
		    case "UpdateExpression":
		      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;
		    case "UnaryExpression":
		      return Precedence.Prefix;
		  }
		}

		function escapeStringLiteral(stringValue) {
		  var result = "";
		  var nSingle = 0,
		      nDouble = 0;
		  for (var i = 0, l = stringValue.length; i < l; ++i) {
		    var ch = stringValue[i];
		    if (ch === "\"") {
		      ++nDouble;
		    } else if (ch === "'") {
		      ++nSingle;
		    }
		  }
		  var delim = nDouble > nSingle ? "'" : "\"";
		  result += delim;
		  for (var i = 0; i < stringValue.length; i++) {
		    var ch = stringValue.charAt(i);
		    switch (ch) {
		      case delim:
		        result += "\\" + delim;
		        break;
		      case "\b":
		        result += "\\b";
		        break;
		      case "\t":
		        result += "\\t";
		        break;
		      case "\n":
		        result += "\\n";
		        break;
		      case "\u000b":
		        result += "\\v";
		        break;
		      case "\f":
		        result += "\\f";
		        break;
		      case "\r":
		        result += "\\r";
		        break;
		      case "\\":
		        result += "\\\\";
		        break;
		      case "\u2028":
		        result += "\\u2028";
		        break;
		      case "\u2029":
		        result += "\\u2029";
		        break;
		      default:
		        result += ch;
		        break;
		    }
		  }
		  result += delim;
		  return result;
		}

		var CodeRep = exports.CodeRep = function () {
		  function CodeRep() {
		    _classCallCheck(this, CodeRep);

		    this.containsIn = false;
		    this.containsGroup = false;
		    // restricted lookaheads: {, function, class, let, let [
		    this.startsWithCurly = false;
		    this.startsWithFunctionOrClass = false;
		    this.startsWithLet = false;
		    this.startsWithLetSquareBracket = false;
		    this.endsWithMissingElse = false;
		  }

		  _createClass(CodeRep, [{
		    key: "forEach",
		    value: function forEach(f) {
		      // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.
		      f(this);
		    }
		  }]);

		  return CodeRep;
		}();

		var Empty = exports.Empty = function (_CodeRep) {
		  _inherits(Empty, _CodeRep);

		  function Empty() {
		    _classCallCheck(this, Empty);

		    return _possibleConstructorReturn(this, Object.getPrototypeOf(Empty).call(this));
		  }

		  _createClass(Empty, [{
		    key: "emit",
		    value: function emit() {}
		  }]);

		  return Empty;
		}(CodeRep);

		var Token = exports.Token = function (_CodeRep2) {
		  _inherits(Token, _CodeRep2);

		  function Token(token) {
		    _classCallCheck(this, Token);

		    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Token).call(this));

		    _this2.token = token;
		    return _this2;
		  }

		  _createClass(Token, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.put(this.token);
		    }
		  }]);

		  return Token;
		}(CodeRep);

		var NumberCodeRep = exports.NumberCodeRep = function (_CodeRep3) {
		  _inherits(NumberCodeRep, _CodeRep3);

		  function NumberCodeRep(number) {
		    _classCallCheck(this, NumberCodeRep);

		    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberCodeRep).call(this));

		    _this3.number = number;
		    return _this3;
		  }

		  _createClass(NumberCodeRep, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.putNumber(this.number);
		    }
		  }]);

		  return NumberCodeRep;
		}(CodeRep);

		var Paren = exports.Paren = function (_CodeRep4) {
		  _inherits(Paren, _CodeRep4);

		  function Paren(expr) {
		    _classCallCheck(this, Paren);

		    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Paren).call(this));

		    _this4.expr = expr;
		    return _this4;
		  }

		  _createClass(Paren, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.put("(");
		      this.expr.emit(ts, false);
		      ts.put(")");
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.expr.forEach(f);
		    }
		  }]);

		  return Paren;
		}(CodeRep);

		var Bracket = exports.Bracket = function (_CodeRep5) {
		  _inherits(Bracket, _CodeRep5);

		  function Bracket(expr) {
		    _classCallCheck(this, Bracket);

		    var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Bracket).call(this));

		    _this5.expr = expr;
		    return _this5;
		  }

		  _createClass(Bracket, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.put("[");
		      this.expr.emit(ts, false);
		      ts.put("]");
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.expr.forEach(f);
		    }
		  }]);

		  return Bracket;
		}(CodeRep);

		var Brace = exports.Brace = function (_CodeRep6) {
		  _inherits(Brace, _CodeRep6);

		  function Brace(expr) {
		    _classCallCheck(this, Brace);

		    var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(Brace).call(this));

		    _this6.expr = expr;
		    return _this6;
		  }

		  _createClass(Brace, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.put("{");
		      this.expr.emit(ts, false);
		      ts.put("}");
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.expr.forEach(f);
		    }
		  }]);

		  return Brace;
		}(CodeRep);

		var NoIn = exports.NoIn = function (_CodeRep7) {
		  _inherits(NoIn, _CodeRep7);

		  function NoIn(expr) {
		    _classCallCheck(this, NoIn);

		    var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(NoIn).call(this));

		    _this7.expr = expr;
		    return _this7;
		  }

		  _createClass(NoIn, [{
		    key: "emit",
		    value: function emit(ts) {
		      this.expr.emit(ts, true);
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.expr.forEach(f);
		    }
		  }]);

		  return NoIn;
		}(CodeRep);

		var ContainsIn = exports.ContainsIn = function (_CodeRep8) {
		  _inherits(ContainsIn, _CodeRep8);

		  function ContainsIn(expr) {
		    _classCallCheck(this, ContainsIn);

		    var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainsIn).call(this));

		    _this8.expr = expr;
		    return _this8;
		  }

		  _createClass(ContainsIn, [{
		    key: "emit",
		    value: function emit(ts, noIn) {
		      if (noIn) {
		        ts.put("(");
		        this.expr.emit(ts, false);
		        ts.put(")");
		      } else {
		        this.expr.emit(ts, false);
		      }
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.expr.forEach(f);
		    }
		  }]);

		  return ContainsIn;
		}(CodeRep);

		var Seq = exports.Seq = function (_CodeRep9) {
		  _inherits(Seq, _CodeRep9);

		  function Seq(children) {
		    _classCallCheck(this, Seq);

		    var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(Seq).call(this));

		    _this9.children = children;
		    return _this9;
		  }

		  _createClass(Seq, [{
		    key: "emit",
		    value: function emit(ts, noIn) {
		      this.children.forEach(function (cr) {
		        return cr.emit(ts, noIn);
		      });
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.children.forEach(function (x) {
		        return x.forEach(f);
		      });
		    }
		  }]);

		  return Seq;
		}(CodeRep);

		var Semi = exports.Semi = function (_Token) {
		  _inherits(Semi, _Token);

		  function Semi() {
		    _classCallCheck(this, Semi);

		    return _possibleConstructorReturn(this, Object.getPrototypeOf(Semi).call(this, ";"));
		  }

		  return Semi;
		}(Token);

		var CommaSep = exports.CommaSep = function (_CodeRep10) {
		  _inherits(CommaSep, _CodeRep10);

		  function CommaSep(children) {
		    _classCallCheck(this, CommaSep);

		    var _this11 = _possibleConstructorReturn(this, Object.getPrototypeOf(CommaSep).call(this));

		    _this11.children = children;
		    return _this11;
		  }

		  _createClass(CommaSep, [{
		    key: "emit",
		    value: function emit(ts, noIn) {
		      var first = true;
		      this.children.forEach(function (cr) {
		        if (first) {
		          first = false;
		        } else {
		          ts.put(",");
		        }
		        cr.emit(ts, noIn);
		      });
		    }
		  }, {
		    key: "forEach",
		    value: function forEach(f) {
		      f(this);
		      this.children.forEach(function (x) {
		        return x.forEach(f);
		      });
		    }
		  }]);

		  return CommaSep;
		}(CodeRep);

		var SemiOp = exports.SemiOp = function (_CodeRep11) {
		  _inherits(SemiOp, _CodeRep11);

		  function SemiOp() {
		    _classCallCheck(this, SemiOp);

		    return _possibleConstructorReturn(this, Object.getPrototypeOf(SemiOp).call(this));
		  }

		  _createClass(SemiOp, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.putOptionalSemi();
		    }
		  }]);

		  return SemiOp;
		}(CodeRep);

	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.Sep = undefined;

		var _objectAssign = __webpack_require__(37);

		var _objectAssign2 = _interopRequireDefault(_objectAssign);

		var _esutils = __webpack_require__(4);

		var _coderep = __webpack_require__(38);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function empty() {
		  return new _coderep.Empty();
		}

		function noIn(rep) {
		  return new _coderep.NoIn(rep);
		}

		function markContainsIn(state) {
		  return state.containsIn ? new _coderep.ContainsIn(state) : state;
		}

		function seq() {
		  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
		    reps[_key] = arguments[_key];
		  }

		  return new _coderep.Seq(reps);
		}

		function isEmpty(codeRep) {
		  return codeRep instanceof _coderep.Empty || codeRep instanceof Linebreak || codeRep instanceof _coderep.Seq && codeRep.children.every(isEmpty);
		}

		var Sep = {};
		var separatorNames = ["ARRAY_EMPTY", "ARRAY_BEFORE_COMMA", "ARRAY_AFTER_COMMA", "SPREAD", "BEFORE_DEFAULT_EQUALS", "AFTER_DEFAULT_EQUALS", "REST", "OBJECT_BEFORE_COMMA", "OBJECT_AFTER_COMMA", "BEFORE_PROP", "AFTER_PROP", "BEFORE_JUMP_LABEL", "ARGS_BEFORE_COMMA", "ARGS_AFTER_COMMA", "CALL", "BEFORE_CATCH_BINDING", "AFTER_CATCH_BINDING", "BEFORE_CLASS_NAME", "BEFORE_EXTENDS", "AFTER_EXTENDS", "BEFORE_CLASS_DECLARATION_ELEMENTS", "BEFORE_CLASS_EXPRESSION_ELEMENTS", "AFTER_STATIC", "BEFORE_CLASS_ELEMENT", "AFTER_CLASS_ELEMENT", "BEFORE_TERNARY_QUESTION", "AFTER_TERNARY_QUESTION", "BEFORE_TERNARY_COLON", "AFTER_TERNARY_COLON", "COMPUTED_MEMBER_EXPRESSION", "AFTER_DO", "BEFORE_DOWHILE_WHILE", "AFTER_DOWHILE_WHILE", "AFTER_FORIN_FOR", "BEFORE_FORIN_IN", "AFTER_FORIN_FOR", "BEFORE_FORIN_BODY", "AFTER_FOROF_FOR", "BEFORE_FOROF_OF", "AFTER_FOROF_FOR", "BEFORE_FOROF_BODY", "AFTER_FOR_FOR", "BEFORE_FOR_INIT", "AFTER_FOR_INIT", "EMPTY_FOR_INIT", "BEFORE_FOR_TEST", "AFTER_FOR_TEST", "EMPTY_FOR_TEST", "BEFORE_FOR_UPDATE", "AFTER_FOR_UPDATE", "EMPTY_FOR_UPDATE", "BEFORE_FOR_BODY", "BEFORE_GENERATOR_STAR", "AFTER_GENERATOR_STAR", "BEFORE_FUNCTION_PARAMS", "BEFORE_FUNCTION_DECLARATION_BODY", "BEFORE_FUNCTION_EXPRESSION_BODY", "AFTER_FUNCTION_DIRECTIVES", "BEFORE_ARROW", "AFTER_ARROW", "AFTER_GET", "BEFORE_GET_PARAMS", "BEFORE_GET_BODY", "AFTER_IF", "AFTER_IF_TEST", "BEFORE_ELSE", "AFTER_ELSE", "PARAMETER_BEFORE_COMMA", "PARAMETER_AFTER_COMMA", "NAMED_IMPORT_BEFORE_COMMA", "NAMED_IMPORT_AFTER_COMMA", "IMPORT_BEFORE_COMMA", "IMPORT_AFTER_COMMA", "BEFORE_IMPORT_BINDINGS", "BEFORE_IMPORT_MODULE", "AFTER_IMPORT_BINDINGS", "AFTER_FROM", "BEFORE_IMPORT_NAMESPACE", "BEFORE_IMPORT_STAR", "AFTER_IMPORT_STAR", "AFTER_IMPORT_AS", "AFTER_NAMESPACE_BINDING", "BEFORE_IMPORT_AS", "AFTER_IMPORT_AS", "EXPORTS_BEFORE_COMMA", "EXPORTS_AFTER_COMMA", "BEFORE_EXPORT_STAR", "AFTER_EXPORT_STAR", "BEFORE_EXPORT_BINDINGS", "AFTER_EXPORT_BINDINGS", "AFTER_EXPORT", "EXPORT_DEFAULT", "AFTER_EXPORT_DEFAULT", "BEFORE_EXPORT_AS", "AFTER_EXPORT_AS", "BEFORE_LABEL_COLON", "AFTER_LABEL_COLON", "AFTER_METHOD_GENERATOR_STAR", "AFTER_METHOD_NAME", "BEFORE_METHOD_BODY", "AFTER_MODULE_DIRECTIVES", "AFTER_NEW", "BEFORE_NEW_ARGS", "EMPTY_NEW_CALL", "NEW_TARGET_BEFORE_DOT", "NEW_TARGET_AFTER_DOT", "RETURN", "AFTER_SET", "BEFORE_SET_PARAMS", "BEFORE_SET_BODY", "AFTER_SCRIPT_DIRECTIVES", "BEFORE_STATIC_MEMBER_DOT", "AFTER_STATIC_MEMBER_DOT", "BEFORE_CASE_TEST", "AFTER_CASE_TEST", "BEFORE_CASE_BODY", "AFTER_CASE_BODY", "DEFAULT", "AFTER_DEFAULT_BODY", "BEFORE_SWITCH_DISCRIM", "BEFORE_SWITCH_BODY", "TEMPLATE_TAG", "BEFORE_TEMPLATE_EXPRESSION", "AFTER_TEMPLATE_EXPRESSION", "THROW", "AFTER_TRY", "BEFORE_CATCH", "BEFORE_FINALLY", "AFTER_FINALLY", "VARIABLE_DECLARATION", "YIELD", "BEFORE_YIELD_STAR", "AFTER_YIELD_STAR", "DECLARATORS_BEFORE_COMMA", "DECLARATORS_AFTER_COMMA", "BEFORE_INIT_EQUALS", "AFTER_INIT_EQUALS", "AFTER_WHILE", "BEFORE_WHILE_BODY", "AFTER_WITH", "BEFORE_WITH_BODY", "PAREN_AVOIDING_DIRECTIVE_BEFORE", "PAREN_AVOIDING_DIRECTIVE_AFTER", "PRECEDENCE_BEFORE", "PRECEDENCE_AFTER", "EXPRESSION_PAREN_BEFORE", "EXPRESSION_PAREN_AFTER", "CALL_PAREN_BEFORE", "CALL_PAREN_AFTER", "CALL_PAREN_EMPTY", "CATCH_PAREN_BEFORE", "CATCH_PAREN_AFTER", "DO_WHILE_TEST_PAREN_BEFORE", "DO_WHILE_TEST_PAREN_AFTER", "EXPRESSION_STATEMENT_PAREN_BEFORE", "EXPRESSION_STATEMENT_PAREN_AFTER", "FOR_IN_LET_PAREN_BEFORE", "FOR_IN_LET_PAREN_AFTER", "FOR_IN_PAREN_BEFORE", "FOR_IN_PAREN_AFTER", "FOR_OF_LET_PAREN_BEFORE", "FOR_OF_LET_PAREN_AFTER", "FOR_OF_PAREN_BEFORE", "FOR_OF_PAREN_AFTER", "PARAMETERS_PAREN_BEFORE", "PARAMETERS_PAREN_AFTER", "PARAMETERS_PAREN_EMPTY", "ARROW_PARAMETERS_PAREN_BEFORE", "ARROW_PARAMETERS_PAREN_AFTER", "ARROW_PARAMETERS_PAREN_EMPTY", "ARROW_BODY_PAREN_BEFORE", "ARROW_BODY_PAREN_AFTER", "GETTER_PARAMS", "IF_PAREN_BEFORE", "IF_PAREN_AFTER", "EXPORT_PAREN_BEFORE", "EXPORT_PAREN_AFTER", "NEW_CALLEE_PAREN_BEFORE", "NEW_CALLEE_PAREN_AFTER", "NEW_PAREN_BEFORE", "NEW_PAREN_AFTER", "NEW_PAREN_EMPTY", "SETTER_PARAM_BEFORE", "SETTER_PARAM_AFTER", "SWITCH_DISCRIM_PAREN_BEFORE", "SWITCH_DISCRIM_PAREN_AFTER", "WHILE_TEST_PAREN_BEFORE", "WHILE_TEST_PAREN_AFTER", "WITH_PAREN_BEFORE", "WITH_PAREN_AFTER", "OBJECT_BRACE_INITIAL", "OBJECT_BRACE_FINAL", "OBJECT_EMPTY", "BLOCK_BRACE_INITIAL", "BLOCK_BRACE_FINAL", "BLOCK_EMPTY", "CLASS_BRACE_INITIAL", "CLASS_BRACE_FINAL", "CLASS_EMPTY", "CLASS_EXPRESSION_BRACE_INITIAL", "CLASS_EXPRESSION_BRACE_FINAL", "CLASS_EXPRESSION_BRACE_EMPTY", "FUNCTION_BRACE_INITIAL", "FUNCTION_BRACE_FINAL", "FUNCTION_EMPTY", "FUNCTION_EXPRESSION_BRACE_INITIAL", "FUNCTION_EXPRESSION_BRACE_FINAL", "FUNCTION_EXPRESSION_EMPTY", "ARROW_BRACE_INITIAL", "ARROW_BRACE_FINAL", "ARROW_BRACE_EMPTY", "GET_BRACE_INTIAL", "GET_BRACE_FINAL", "GET_BRACE_EMPTY", "MISSING_ELSE_INTIIAL", "MISSING_ELSE_FINAL", "MISSING_ELSE_EMPTY", "IMPORT_BRACE_INTIAL", "IMPORT_BRACE_FINAL", "IMPORT_BRACE_EMPTY", "EXPORT_BRACE_INITIAL", "EXPORT_BRACE_FINAL", "EXPORT_BRACE_EMPTY", "METHOD_BRACE_INTIAL", "METHOD_BRACE_FINAL", "METHOD_BRACE_EMPTY", "SET_BRACE_INTIIAL", "SET_BRACE_FINAL", "SET_BRACE_EMPTY", "SWITCH_BRACE_INTIAL", "SWITCH_BRACE_FINAL", "SWITCH_BRACE_EMPTY", "ARRAY_INITIAL", "ARRAY_FINAL", "COMPUTED_MEMBER_BRACKET_INTIAL", "COMPUTED_MEMBER_BRACKET_FINAL", "COMPUTED_PROPERTY_BRACKET_INTIAL", "COMPUTED_PROPERTY_BRACKET_FINAL"];
		for (var i = 0; i < separatorNames.length; ++i) {
		  Sep[separatorNames[i]] = { type: separatorNames[i] };
		}

		Sep.BEFORE_ASSIGN_OP = function (op) {
		  return {
		    type: "BEFORE_ASSIGN_OP",
		    op: op
		  };
		};

		Sep.AFTER_ASSIGN_OP = function (op) {
		  return {
		    type: "AFTER_ASSIGN_OP",
		    op: op
		  };
		};

		Sep.BEFORE_BINOP = function (op) {
		  return {
		    type: "BEFORE_BINOP",
		    op: op
		  };
		};

		Sep.AFTER_BINOP = function (op) {
		  return {
		    type: "AFTER_BINOP",
		    op: op
		  };
		};

		Sep.BEFORE_POSTFIX = function (op) {
		  return {
		    type: "BEFORE_POSTFIX",
		    op: op
		  };
		};

		Sep.UNARY = function (op) {
		  return {
		    type: "UNARY",
		    op: op
		  };
		};

		Sep.AFTER_STATEMENT = function (node) {
		  return {
		    type: "AFTER_STATEMENT",
		    node: node
		  };
		};

		Sep.BEFORE_FUNCTION_NAME = function (node) {
		  return {
		    type: "BEFORE_FUNCTION_NAME",
		    node: node
		  };
		};
		exports.Sep = Sep;

		var ExtensibleCodeGen = exports.ExtensibleCodeGen = function () {
		  function ExtensibleCodeGen() {
		    _classCallCheck(this, ExtensibleCodeGen);
		  }

		  _createClass(ExtensibleCodeGen, [{
		    key: "parenToAvoidBeingDirective",
		    value: function parenToAvoidBeingDirective(element, original) {
		      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
		        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp());
		      }
		      return original;
		    }
		  }, {
		    key: "t",
		    value: function t(token) {
		      return new _coderep.Token(token);
		    }
		  }, {
		    key: "p",
		    value: function p(node, precedence, a) {
		      return (0, _coderep.getPrecedence)(node) < precedence ? this.paren(a, Sep.PRECEDENCE_BEFORE, Sep.PRECEDENCE_AFTER) : a;
		    }
		  }, {
		    key: "getAssignmentExpr",
		    value: function getAssignmentExpr(state) {
		      return state ? state.containsGroup ? this.paren(state, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER) : state : empty();
		    }
		  }, {
		    key: "paren",
		    value: function paren(rep, first, last, empty) {
		      if (isEmpty(rep)) {
		        return new _coderep.Paren(this.sep(empty));
		      }
		      return new _coderep.Paren(seq(first ? this.sep(first) : new _coderep.Empty(), rep, last ? this.sep(last) : new _coderep.Empty()));
		    }
		  }, {
		    key: "brace",
		    value: function brace(rep, node, first, last, empty) {
		      if (isEmpty(rep)) {
		        return new _coderep.Brace(this.sep(empty));
		      }
		      return new _coderep.Brace(seq(this.sep(first), rep, this.sep(last)));
		    }
		  }, {
		    key: "bracket",
		    value: function bracket(rep, first, last, empty) {
		      if (isEmpty(rep)) {
		        return new _coderep.Bracket(this.sep(empty));
		      }
		      return new _coderep.Bracket(seq(this.sep(first), rep, this.sep(last)));
		    }
		  }, {
		    key: "commaSep",
		    value: function commaSep(pieces, before, after) {
		      var _this = this;

		      var first = true;
		      pieces = pieces.map(function (p) {
		        if (first) {
		          first = false;
		          return p;
		        } else {
		          return seq(_this.sep(before), _this.t(","), _this.sep(after), p);
		        }
		      });
		      return seq.apply(undefined, _toConsumableArray(pieces));
		    }
		  }, {
		    key: "semiOp",
		    value: function semiOp() {
		      return new _coderep.SemiOp();
		    }
		  }, {
		    key: "sep",
		    value: function sep(kind) {
		      return new _coderep.Empty();
		    }
		  }, {
		    key: "reduceArrayExpression",
		    value: function reduceArrayExpression(node, _ref) {
		      var _this2 = this;

		      var elements = _ref.elements;

		      if (elements.length === 0) {
		        return this.bracket(empty(), null, null, Sep.ARRAY_EMPTY);
		      }

		      var content = this.commaSep(elements.map(function (e) {
		        return _this2.getAssignmentExpr(e);
		      }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
		      if (elements.length > 0 && elements[elements.length - 1] == null) {
		        content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
		      }
		      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL);
		    }
		  }, {
		    key: "reduceSpreadElement",
		    value: function reduceSpreadElement(node, _ref2) {
		      var expression = _ref2.expression;

		      return seq(this.t("..."), this.sep(Sep.SPREAD), this.p(node.expression, _coderep.Precedence.Assignment, expression));
		    }
		  }, {
		    key: "reduceAssignmentExpression",
		    value: function reduceAssignmentExpression(node, _ref3) {
		      var binding = _ref3.binding;
		      var expression = _ref3.expression;

		      var leftCode = binding;
		      var rightCode = expression;
		      var containsIn = expression.containsIn;
		      var startsWithCurly = binding.startsWithCurly;
		      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
		      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
		        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
		        containsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP("=")), this.t("="), this.sep(Sep.AFTER_ASSIGN_OP("=")), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
		    }
		  }, {
		    key: "reduceCompoundAssignmentExpression",
		    value: function reduceCompoundAssignmentExpression(node, _ref4) {
		      var binding = _ref4.binding;
		      var expression = _ref4.expression;

		      var leftCode = binding;
		      var rightCode = expression;
		      var containsIn = expression.containsIn;
		      var startsWithCurly = binding.startsWithCurly;
		      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
		      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
		        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
		        containsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_ASSIGN_OP(node.operator)), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
		    }
		  }, {
		    key: "reduceBinaryExpression",
		    value: function reduceBinaryExpression(node, _ref5) {
		      var left = _ref5.left;
		      var right = _ref5.right;

		      var leftCode = left;
		      var startsWithCurly = left.startsWithCurly;
		      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
		      var leftContainsIn = left.containsIn;
		      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
		        leftCode = this.paren(leftCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
		        startsWithCurly = false;
		        startsWithLetSquareBracket = false;
		        startsWithFunctionOrClass = false;
		        leftContainsIn = false;
		      }
		      var rightCode = right;
		      var rightContainsIn = right.containsIn;
		      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
		        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
		        rightContainsIn = false;
		      }
		      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_BINOP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_BINOP(node.operator)), rightCode), {
		        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
		        containsGroup: node.operator == ",",
		        startsWithCurly: startsWithCurly,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithFunctionOrClass: startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceBindingWithDefault",
		    value: function reduceBindingWithDefault(node, _ref6) {
		      var binding = _ref6.binding;
		      var init = _ref6.init;

		      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
		    }
		  }, {
		    key: "reduceBindingIdentifier",
		    value: function reduceBindingIdentifier(node) {
		      var a = this.t(node.name);
		      if (node.name === "let") {
		        a.startsWithLet = true;
		      }
		      return a;
		    }
		  }, {
		    key: "reduceArrayBinding",
		    value: function reduceArrayBinding(node, _ref7) {
		      var _this3 = this;

		      var elements = _ref7.elements;
		      var restElement = _ref7.restElement;

		      var content = undefined;
		      if (elements.length === 0) {
		        content = restElement == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), restElement);
		      } else {
		        elements = elements.concat(restElement == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), restElement)]);
		        content = this.commaSep(elements.map(function (e) {
		          return _this3.getAssignmentExpr(e);
		        }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
		        if (elements.length > 0 && elements[elements.length - 1] == null) {
		          content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
		        }
		      }
		      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
		    }
		  }, {
		    key: "reduceObjectBinding",
		    value: function reduceObjectBinding(node, _ref8) {
		      var properties = _ref8.properties;

		      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
		      state.startsWithCurly = true;
		      return state;
		    }
		  }, {
		    key: "reduceBindingPropertyIdentifier",
		    value: function reduceBindingPropertyIdentifier(node, _ref9) {
		      var binding = _ref9.binding;
		      var init = _ref9.init;

		      if (node.init == null) return binding;
		      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
		    }
		  }, {
		    key: "reduceBindingPropertyProperty",
		    value: function reduceBindingPropertyProperty(node, _ref10) {
		      var name = _ref10.name;
		      var binding = _ref10.binding;

		      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
		    }
		  }, {
		    key: "reduceBlock",
		    value: function reduceBlock(node, _ref11) {
		      var statements = _ref11.statements;

		      return this.brace(seq.apply(undefined, _toConsumableArray(statements)), node, Sep.BLOCK_BRACE_INITIAL, Sep.BLOCK_BRACE_FINAL, Sep.BLOCK_EMPTY);
		    }
		  }, {
		    key: "reduceBlockStatement",
		    value: function reduceBlockStatement(node, _ref12) {
		      var block = _ref12.block;

		      return seq(block, this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceBreakStatement",
		    value: function reduceBreakStatement(node, _ref13) {
		      var label = _ref13.label;

		      return seq(this.t("break"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceCallExpression",
		    value: function reduceCallExpression(node, _ref14) {
		      var callee = _ref14.callee;
		      var args = _ref14.arguments;

		      return (0, _objectAssign2.default)(seq(this.p(node.callee, (0, _coderep.getPrecedence)(node), callee), this.sep(Sep.CALL), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.CALL_PAREN_BEFORE, Sep.CALL_PAREN_AFTER, Sep.CALL_PAREN_EMPTY)), {
		        startsWithCurly: callee.startsWithCurly,
		        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
		        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceCatchClause",
		    value: function reduceCatchClause(node, _ref15) {
		      var binding = _ref15.binding;
		      var body = _ref15.body;

		      return seq(this.t("catch"), this.sep(Sep.BEFORE_CATCH_BINDING), this.paren(binding, Sep.CATCH_PAREN_BEFORE, Sep.CATCH_PAREN_AFTER), this.sep(Sep.AFTER_CATCH_BINDING), body);
		    }
		  }, {
		    key: "reduceClassDeclaration",
		    value: function reduceClassDeclaration(node, _ref16) {
		      var name = _ref16.name;
		      var _super = _ref16.super;
		      var elements = _ref16.elements;

		      var state = seq(this.t("class"), this.sep(Sep.BEFORE_CLASS_NAME), name);
		      if (_super != null) {
		        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
		      }
		      state = seq(state, this.sep(Sep.BEFORE_CLASS_DECLARATION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_BRACE_INITIAL, Sep.CLASS_BRACE_FINAL, Sep.CLASS_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
		      return state;
		    }
		  }, {
		    key: "reduceClassExpression",
		    value: function reduceClassExpression(node, _ref17) {
		      var name = _ref17.name;
		      var _super = _ref17.super;
		      var elements = _ref17.elements;

		      var state = this.t("class");
		      if (name != null) {
		        state = seq(state, this.sep(Sep.BEFORE_CLASS_NAME), name);
		      }
		      if (_super != null) {
		        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
		      }
		      state = seq(state, this.sep(Sep.BEFORE_CLASS_EXPRESSION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_EXPRESSION_BRACE_INITIAL, Sep.CLASS_EXPRESSION_BRACE_FINAL, Sep.CLASS_EXPRESSION_BRACE_EMPTY));
		      state.startsWithFunctionOrClass = true;
		      return state;
		    }
		  }, {
		    key: "reduceClassElement",
		    value: function reduceClassElement(node, _ref18) {
		      var method = _ref18.method;

		      method = seq(this.sep(Sep.BEFORE_CLASS_ELEMENT), method, this.sep(Sep.AFTER_CLASS_ELEMENT));
		      if (!node.isStatic) return method;
		      return seq(this.t("static"), this.sep(Sep.AFTER_STATIC), method);
		    }
		  }, {
		    key: "reduceComputedMemberExpression",
		    value: function reduceComputedMemberExpression(node, _ref19) {
		      var object = _ref19.object;
		      var expression = _ref19.expression;

		      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
		      return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_EXPRESSION), this.bracket(expression, Sep.COMPUTED_MEMBER_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_BRACKET_FINAL)), {
		        startsWithLet: object.startsWithLet,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithCurly: object.startsWithCurly,
		        startsWithFunctionOrClass: object.startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceComputedPropertyName",
		    value: function reduceComputedPropertyName(node, _ref20) {
		      var expression = _ref20.expression;

		      return this.bracket(expression, Sep.COMPUTED_PROPERTY_BRACKET_INTIAL, Sep.COMPUTED_PROPERTY_BRACKET_FINAL);
		    }
		  }, {
		    key: "reduceConditionalExpression",
		    value: function reduceConditionalExpression(node, _ref21) {
		      var test = _ref21.test;
		      var consequent = _ref21.consequent;
		      var alternate = _ref21.alternate;

		      var containsIn = test.containsIn || alternate.containsIn;
		      var startsWithCurly = test.startsWithCurly;
		      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
		      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
		      return (0, _objectAssign2.default)(seq(this.p(node.test, _coderep.Precedence.LogicalOR, test), this.sep(Sep.BEFORE_TERNARY_QUESTION), this.t("?"), this.sep(Sep.AFTER_TERNARY_QUESTION), this.p(node.consequent, _coderep.Precedence.Assignment, consequent), this.sep(Sep.BEFORE_TERNARY_COLON), this.t(":"), this.sep(Sep.AFTER_TERNARY_COLON), this.p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
		        containsIn: containsIn,
		        startsWithCurly: startsWithCurly,
		        startsWithLetSquareBracket: startsWithLetSquareBracket,
		        startsWithFunctionOrClass: startsWithFunctionOrClass
		      });
		    }
		  }, {
		    key: "reduceContinueStatement",
		    value: function reduceContinueStatement(node, _ref22) {
		      var label = _ref22.label;

		      return seq(this.t("continue"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceDataProperty",
		    value: function reduceDataProperty(node, _ref23) {
		      var name = _ref23.name;
		      var expression = _ref23.expression;

		      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), this.getAssignmentExpr(expression));
		    }
		  }, {
		    key: "reduceDebuggerStatement",
		    value: function reduceDebuggerStatement(node) {
		      return seq(this.t("debugger"), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceDoWhileStatement",
		    value: function reduceDoWhileStatement(node, _ref24) {
		      var body = _ref24.body;
		      var test = _ref24.test;

		      return seq(this.t("do"), this.sep(Sep.AFTER_DO), body, this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceEmptyStatement",
		    value: function reduceEmptyStatement(node) {
		      return seq(this.t(";"), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceExpressionStatement",
		    value: function reduceExpressionStatement(node, _ref25) {
		      var expression = _ref25.expression;

		      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
		      return seq(needsParens ? this.paren(expression, Sep.EXPRESSION_STATEMENT_PAREN_BEFORE, Sep.EXPRESSION_STATEMENT_PAREN_AFTER) : expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceForInStatement",
		    value: function reduceForInStatement(node, _ref26) {
		      var left = _ref26.left;
		      var right = _ref26.right;
		      var body = _ref26.body;

		      var leftP = left;
		      switch (node.left.type) {
		        case "VariableDeclaration":
		          leftP = noIn(markContainsIn(left));
		          break;
		        case "BindingIdentifier":
		          if (node.left.name === "let") {
		            leftP = this.paren(left, Sep.FOR_IN_LET_PAREN_BEFORE, Sep.FOR_IN_LET_PAREN_BEFORE);
		          }
		          break;
		      }
		      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FORIN_FOR), this.paren(seq(leftP, this.sep(Sep.BEFORE_FORIN_IN), this.t("in"), this.sep(Sep.AFTER_FORIN_FOR), right), Sep.FOR_IN_PAREN_BEFORE, Sep.FOR_IN_PAREN_AFTER), this.sep(Sep.BEFORE_FORIN_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceForOfStatement",
		    value: function reduceForOfStatement(node, _ref27) {
		      var left = _ref27.left;
		      var right = _ref27.right;
		      var body = _ref27.body;

		      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
		      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOROF_FOR), this.paren(seq(left.startsWithLet ? this.paren(left, Sep.FOR_OF_LET_PAREN_BEFORE, Sep.FOR_OF_LET_PAREN_AFTER) : left, this.sep(Sep.BEFORE_FOROF_OF), this.t("of"), this.sep(Sep.AFTER_FOROF_FOR), right), Sep.FOR_OF_PAREN_BEFORE, Sep.FOR_OF_PAREN_AFTER), this.sep(Sep.BEFORE_FOROF_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceForStatement",
		    value: function reduceForStatement(node, _ref28) {
		      var init = _ref28.init;
		      var test = _ref28.test;
		      var update = _ref28.update;
		      var body = _ref28.body;

		      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOR_FOR), this.paren(seq(init ? seq(this.sep(Sep.BEFORE_FOR_INIT), noIn(markContainsIn(init)), this.sep(Sep.AFTER_FOR_INIT)) : this.sep(Sep.EMPTY_FOR_INIT), this.t(";"), test ? seq(this.sep(Sep.BEFORE_FOR_TEST), test, this.sep(Sep.AFTER_FOR_TEST)) : this.sep(Sep.EMPTY_FOR_TEST), this.t(";"), update ? seq(this.sep(Sep.BEFORE_FOR_UPDATE), update, this.sep(Sep.AFTER_FOR_UPDATE)) : this.sep(Sep.EMPTY_FOR_UPDATE))), this.sep(Sep.BEFORE_FOR_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), {
		        endsWithMissingElse: body.endsWithMissingElse
		      });
		    }
		  }, {
		    key: "reduceFunctionBody",
		    value: function reduceFunctionBody(node, _ref29) {
		      var directives = _ref29.directives;
		      var statements = _ref29.statements;

		      if (statements.length) {
		        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_FUNCTION_DIRECTIVES) : empty()], _toConsumableArray(statements)));
		    }
		  }, {
		    key: "reduceFunctionDeclaration",
		    value: function reduceFunctionDeclaration(node, _ref30) {
		      var name = _ref30.name;
		      var params = _ref30.params;
		      var body = _ref30.body;

		      return seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), node.name.name === "*default*" ? empty() : name, this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_DECLARATION_BODY), this.brace(body, node, Sep.FUNCTION_BRACE_INITIAL, Sep.FUNCTION_BRACE_FINAL, Sep.FUNCTION_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceFunctionExpression",
		    value: function reduceFunctionExpression(node, _ref31) {
		      var name = _ref31.name;
		      var params = _ref31.params;
		      var body = _ref31.body;

		      var state = seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), name ? name : empty(), this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_EXPRESSION_BODY), this.brace(body, node, Sep.FUNCTION_EXPRESSION_BRACE_INITIAL, Sep.FUNCTION_EXPRESSION_BRACE_FINAL, Sep.FUNCTION_EXPRESSION_EMPTY));
		      state.startsWithFunctionOrClass = true;
		      return state;
		    }
		  }, {
		    key: "reduceFormalParameters",
		    value: function reduceFormalParameters(node, _ref32) {
		      var items = _ref32.items;
		      var rest = _ref32.rest;

		      return this.commaSep(items.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]), Sep.PARAMETER_BEFORE_COMMA, Sep.PARAMETER_AFTER_COMMA);
		    }
		  }, {
		    key: "reduceArrowExpression",
		    value: function reduceArrowExpression(node, _ref33) {
		      var params = _ref33.params;
		      var body = _ref33.body;

		      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
		        params = this.paren(params, Sep.ARROW_PARAMETERS_PAREN_BEFORE, Sep.ARROW_PARAMETERS_PAREN_AFTER, Sep.ARROW_PARAMETERS_PAREN_EMPTY);
		      }
		      if (node.body.type === "FunctionBody") {
		        body = this.brace(body, node, Sep.ARROW_BRACE_INITIAL, Sep.ARROW_BRACE_FINAL, Sep.ARROW_BRACE_EMPTY);
		      } else if (body.startsWithCurly) {
		        body = this.paren(body, Sep.ARROW_BODY_PAREN_BEFORE, Sep.ARROW_BODY_PAREN_AFTER);
		      }
		      return seq(params, this.sep(Sep.BEFORE_ARROW), this.t("=>"), this.sep(Sep.AFTER_ARROW), this.p(node.body, _coderep.Precedence.Assignment, body));
		    }
		  }, {
		    key: "reduceGetter",
		    value: function reduceGetter(node, _ref34) {
		      var name = _ref34.name;
		      var body = _ref34.body;

		      return seq(this.t("get"), this.sep(Sep.AFTER_GET), name, this.sep(Sep.BEFORE_GET_PARAMS), this.paren(empty(), null, null, Sep.GETTER_PARAMS), this.sep(Sep.BEFORE_GET_BODY), this.brace(body, node, Sep.GET_BRACE_INTIAL, Sep.GET_BRACE_FINAL, Sep.GET_BRACE_EMPTY));
		    }
		  }, {
		    key: "reduceIdentifierExpression",
		    value: function reduceIdentifierExpression(node) {
		      var a = this.t(node.name);
		      if (node.name === "let") {
		        a.startsWithLet = true;
		      }
		      return a;
		    }
		  }, {
		    key: "reduceIfStatement",
		    value: function reduceIfStatement(node, _ref35) {
		      var test = _ref35.test;
		      var consequent = _ref35.consequent;
		      var alternate = _ref35.alternate;

		      if (alternate && consequent.endsWithMissingElse) {
		        consequent = this.brace(consequent, node, Sep.MISSING_ELSE_INTIIAL, Sep.MISSING_ELSE_FINAL, Sep.MISSING_ELSE_EMPTY);
		      }
		      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), consequent, alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), alternate) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
		    }
		  }, {
		    key: "reduceImport",
		    value: function reduceImport(node, _ref36) {
		      var defaultBinding = _ref36.defaultBinding;
		      var namedImports = _ref36.namedImports;

		      var bindings = [];
		      if (defaultBinding != null) {
		        bindings.push(defaultBinding);
		      }
		      if (namedImports.length > 0) {
		        bindings.push(this.brace(this.commaSep(namedImports, Sep.NAMED_IMPORT_BEFORE_COMMA, Sep.NAMED_IMPORT_AFTER_COMMA), node, Sep.IMPORT_BRACE_INTIAL, Sep.IMPORT_BRACE_FINAL, Sep.IMPORT_BRACE_EMPTY));
		      }
		      if (bindings.length === 0) {
		        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_MODULE), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		      }
		      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_BINDINGS), this.commaSep(bindings, Sep.IMPORT_BEFORE_COMMA, Sep.IMPORT_AFTER_COMMA), this.sep(Sep.AFTER_IMPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceImportNamespace",
		    value: function reduceImportNamespace(node, _ref37) {
		      var defaultBinding = _ref37.defaultBinding;
		      var namespaceBinding = _ref37.namespaceBinding;

		      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_NAMESPACE), defaultBinding == null ? empty() : seq(defaultBinding, this.sep(Sep.IMPORT_BEFORE_COMMA), this.t(","), this.sep(Sep.IMPORT_AFTER_COMMA)), this.sep(Sep.BEFORE_IMPORT_STAR), this.t("*"), this.sep(Sep.AFTER_IMPORT_STAR), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), namespaceBinding, this.sep(Sep.AFTER_NAMESPACE_BINDING), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceImportSpecifier",
		    value: function reduceImportSpecifier(node, _ref38) {
		      var binding = _ref38.binding;

		      if (node.name == null) return binding;
		      return seq(this.t(node.name), this.sep(Sep.BEFORE_IMPORT_AS), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), binding);
		    }
		  }, {
		    key: "reduceExportAllFrom",
		    value: function reduceExportAllFrom(node) {
		      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_STAR), this.t("*"), this.sep(Sep.AFTER_EXPORT_STAR), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceExportFrom",
		    value: function reduceExportFrom(node, _ref39) {
		      var namedExports = _ref39.namedExports;

		      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), node.moduleSpecifier == null ? empty() : seq(this.sep(Sep.AFTER_EXPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node))));
		    }
		  }, {
		    key: "reduceExport",
		    value: function reduceExport(node, _ref40) {
		      var declaration = _ref40.declaration;

		      switch (node.declaration.type) {
		        case "FunctionDeclaration":
		        case "ClassDeclaration":
		          break;
		        default:
		          declaration = seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		      }
		      return seq(this.t("export"), this.sep(Sep.AFTER_EXPORT), declaration);
		    }
		  }, {
		    key: "reduceExportDefault",
		    value: function reduceExportDefault(node, _ref41) {
		      var body = _ref41.body;

		      body = body.startsWithFunctionOrClass ? this.paren(body, Sep.EXPORT_PAREN_BEFORE, Sep.EXPORT_PAREN_AFTER) : body;
		      switch (node.body.type) {
		        case "FunctionDeclaration":
		        case "ClassDeclaration":
		          break;
		        default:
		          body = seq(body, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		      }
		      return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), body);
		    }
		  }, {
		    key: "reduceExportSpecifier",
		    value: function reduceExportSpecifier(node) {
		      if (node.name == null) return this.t(node.exportedName);
		      return seq(this.t(node.name), this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
		    }
		  }, {
		    key: "reduceLabeledStatement",
		    value: function reduceLabeledStatement(node, _ref42) {
		      var label = _ref42.label;
		      var body = _ref42.body;

		      return (0, _objectAssign2.default)(seq(this.t(label), this.sep(Sep.BEFORE_LABEL_COLON), this.t(":"), this.sep(Sep.AFTER_LABEL_COLON), body), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceLiteralBooleanExpression",
		    value: function reduceLiteralBooleanExpression(node) {
		      return this.t(node.value.toString());
		    }
		  }, {
		    key: "reduceLiteralNullExpression",
		    value: function reduceLiteralNullExpression(node) {
		      return this.t("null");
		    }
		  }, {
		    key: "reduceLiteralInfinityExpression",
		    value: function reduceLiteralInfinityExpression(node) {
		      return this.t("2e308");
		    }
		  }, {
		    key: "reduceLiteralNumericExpression",
		    value: function reduceLiteralNumericExpression(node) {
		      return new _coderep.NumberCodeRep(node.value);
		    }
		  }, {
		    key: "reduceLiteralRegExpExpression",
		    value: function reduceLiteralRegExpExpression(node) {
		      return this.t("/" + node.pattern + "/" + node.flags);
		    }
		  }, {
		    key: "reduceLiteralStringExpression",
		    value: function reduceLiteralStringExpression(node) {
		      return this.t((0, _coderep.escapeStringLiteral)(node.value));
		    }
		  }, {
		    key: "reduceMethod",
		    value: function reduceMethod(node, _ref43) {
		      var name = _ref43.name;
		      var params = _ref43.params;
		      var body = _ref43.body;

		      return seq(node.isGenerator ? seq(this.t("*"), this.sep(Sep.AFTER_METHOD_GENERATOR_STAR)) : empty(), name, this.sep(Sep.AFTER_METHOD_NAME), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_METHOD_BODY), this.brace(body, node, Sep.METHOD_BRACE_INTIAL, Sep.METHOD_BRACE_FINAL, Sep.METHOD_BRACE_EMPTY));
		    }
		  }, {
		    key: "reduceModule",
		    value: function reduceModule(node, _ref44) {
		      var directives = _ref44.directives;
		      var items = _ref44.items;

		      if (items.length) {
		        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_MODULE_DIRECTIVES) : empty()], _toConsumableArray(items)));
		    }
		  }, {
		    key: "reduceNewExpression",
		    value: function reduceNewExpression(node, _ref45) {
		      var callee = _ref45.callee;
		      var args = _ref45.arguments;

		      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? this.paren(callee, Sep.NEW_CALLEE_PAREN_BEFORE, Sep.NEW_CALLEE_PAREN_AFTER) : this.p(node.callee, (0, _coderep.getPrecedence)(node), callee);
		      return seq(this.t("new"), this.sep(Sep.AFTER_NEW), calleeRep, args.length === 0 ? this.sep(Sep.EMPTY_NEW_CALL) : seq(this.sep(Sep.BEFORE_NEW_ARGS), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.NEW_PAREN_BEFORE, Sep.NEW_PAREN_AFTER, Sep.NEW_PAREN_EMPTY)));
		    }
		  }, {
		    key: "reduceNewTargetExpression",
		    value: function reduceNewTargetExpression() {
		      return seq(this.t("new"), this.sep(Sep.NEW_TARGET_BEFORE_DOT), this.t("."), this.sep(Sep.NEW_TARGET_AFTER_DOT), this.t("target"));
		    }
		  }, {
		    key: "reduceObjectExpression",
		    value: function reduceObjectExpression(node, _ref46) {
		      var properties = _ref46.properties;

		      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
		      state.startsWithCurly = true;
		      return state;
		    }
		  }, {
		    key: "reduceUpdateExpression",
		    value: function reduceUpdateExpression(node, _ref47) {
		      var operand = _ref47.operand;

		      if (node.isPrefix) {
		        return this.reduceUnaryExpression.apply(this, arguments);
		      } else {
		        return (0, _objectAssign2.default)(seq(this.p(node.operand, _coderep.Precedence.New, operand), this.sep(Sep.BEFORE_POSTFIX(node.operator)), this.t(node.operator)), {
		          startsWithCurly: operand.startsWithCurly,
		          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
		          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
		        });
		      }
		    }
		  }, {
		    key: "reduceUnaryExpression",
		    value: function reduceUnaryExpression(node, _ref48) {
		      var operand = _ref48.operand;

		      return seq(this.t(node.operator), this.sep(Sep.UNARY(node.operator)), this.p(node.operand, (0, _coderep.getPrecedence)(node), operand));
		    }
		  }, {
		    key: "reduceReturnStatement",
		    value: function reduceReturnStatement(node, _ref49) {
		      var expression = _ref49.expression;

		      return seq(this.t("return"), expression ? seq(this.sep(Sep.RETURN), expression) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceScript",
		    value: function reduceScript(node, _ref50) {
		      var directives = _ref50.directives;
		      var statements = _ref50.statements;

		      if (statements.length) {
		        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
		      }
		      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_SCRIPT_DIRECTIVES) : empty()], _toConsumableArray(statements)));
		    }
		  }, {
		    key: "reduceSetter",
		    value: function reduceSetter(node, _ref51) {
		      var name = _ref51.name;
		      var param = _ref51.param;
		      var body = _ref51.body;

		      return seq(this.t("set"), this.sep(Sep.AFTER_SET), name, this.sep(Sep.BEFORE_SET_PARAMS), this.paren(param, Sep.SETTER_PARAM_BEFORE, Sep.SETTER_PARAM_AFTER), this.sep(Sep.BEFORE_SET_BODY), this.brace(body, node, Sep.SET_BRACE_INTIIAL, Sep.SET_BRACE_FINAL, Sep.SET_BRACE_EMPTY));
		    }
		  }, {
		    key: "reduceShorthandProperty",
		    value: function reduceShorthandProperty(node) {
		      return this.t(node.name);
		    }
		  }, {
		    key: "reduceStaticMemberExpression",
		    value: function reduceStaticMemberExpression(node, _ref52) {
		      var object = _ref52.object;
		      var property = _ref52.property;

		      var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_DOT), this.t(property));
		      state.startsWithLet = object.startsWithLet;
		      state.startsWithCurly = object.startsWithCurly;
		      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
		      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
		      return state;
		    }
		  }, {
		    key: "reduceStaticPropertyName",
		    value: function reduceStaticPropertyName(node) {
		      var n;
		      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
		        return this.t(node.value);
		      } else if (n = parseFloat(node.value), n === n) {
		        return new _coderep.NumberCodeRep(n);
		      }
		      return this.t((0, _coderep.escapeStringLiteral)(node.value));
		    }
		  }, {
		    key: "reduceSuper",
		    value: function reduceSuper() {
		      return this.t("super");
		    }
		  }, {
		    key: "reduceSwitchCase",
		    value: function reduceSwitchCase(node, _ref53) {
		      var test = _ref53.test;
		      var consequent = _ref53.consequent;

		      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_CASE_BODY));
		    }
		  }, {
		    key: "reduceSwitchDefault",
		    value: function reduceSwitchDefault(node, _ref54) {
		      var consequent = _ref54.consequent;

		      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_DEFAULT_BODY));
		    }
		  }, {
		    key: "reduceSwitchStatement",
		    value: function reduceSwitchStatement(node, _ref55) {
		      var discriminant = _ref55.discriminant;
		      var cases = _ref55.cases;

		      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(cases)), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceSwitchStatementWithDefault",
		    value: function reduceSwitchStatementWithDefault(node, _ref56) {
		      var discriminant = _ref56.discriminant;
		      var preDefaultCases = _ref56.preDefaultCases;
		      var defaultCase = _ref56.defaultCase;
		      var postDefaultCases = _ref56.postDefaultCases;

		      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases))), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceTemplateExpression",
		    value: function reduceTemplateExpression(node, _ref57) {
		      var tag = _ref57.tag;
		      var elements = _ref57.elements;

		      var state = node.tag == null ? empty() : seq(this.p(node.tag, (0, _coderep.getPrecedence)(node), tag), this.sep(Sep.TEMPLATE_TAG));
		      var templateData = "";
		      state = seq(state, this.t("`"));
		      for (var i = 0, l = node.elements.length; i < l; ++i) {
		        if (node.elements[i].type === "TemplateElement") {
		          var d = "";
		          if (i > 0) d += "}";
		          d += node.elements[i].rawValue;
		          if (i < l - 1) d += "${";
		          state = seq(state, this.t(d));
		        } else {
		          state = seq(state, this.sep(Sep.BEFORE_TEMPLATE_EXPRESSION), elements[i], this.sep(Sep.AFTER_TEMPLATE_EXPRESSION));
		        }
		      }
		      state = seq(state, this.t("`"));
		      if (node.tag != null) {
		        state.startsWithCurly = tag.startsWithCurly;
		        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
		        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
		      }
		      return state;
		    }
		  }, {
		    key: "reduceTemplateElement",
		    value: function reduceTemplateElement(node) {
		      return this.t(node.rawValue);
		    }
		  }, {
		    key: "reduceThisExpression",
		    value: function reduceThisExpression(node) {
		      return this.t("this");
		    }
		  }, {
		    key: "reduceThrowStatement",
		    value: function reduceThrowStatement(node, _ref58) {
		      var expression = _ref58.expression;

		      return seq(this.t("throw"), this.sep(Sep.THROW), expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceTryCatchStatement",
		    value: function reduceTryCatchStatement(node, _ref59) {
		      var body = _ref59.body;
		      var catchClause = _ref59.catchClause;

		      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, this.sep(Sep.BEFORE_CATCH), catchClause, this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceTryFinallyStatement",
		    value: function reduceTryFinallyStatement(node, _ref60) {
		      var body = _ref60.body;
		      var catchClause = _ref60.catchClause;
		      var finalizer = _ref60.finalizer;

		      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, catchClause ? seq(this.sep(Sep.BEFORE_CATCH), catchClause) : empty(), this.sep(Sep.BEFORE_FINALLY), this.t("finally"), this.sep(Sep.AFTER_FINALLY), finalizer, this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceYieldExpression",
		    value: function reduceYieldExpression(node, _ref61) {
		      var expression = _ref61.expression;

		      if (node.expression == null) return this.t("yield");
		      return seq(this.t("yield"), this.sep(Sep.YIELD), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
		    }
		  }, {
		    key: "reduceYieldGeneratorExpression",
		    value: function reduceYieldGeneratorExpression(node, _ref62) {
		      var expression = _ref62.expression;

		      return seq(this.t("yield"), this.sep(Sep.BEFORE_YIELD_STAR), this.t("*"), this.sep(Sep.AFTER_YIELD_STAR), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
		    }
		  }, {
		    key: "reduceDirective",
		    value: function reduceDirective(node) {
		      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
		      return seq(this.t(delim + node.rawValue + delim), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceVariableDeclaration",
		    value: function reduceVariableDeclaration(node, _ref63) {
		      var declarators = _ref63.declarators;

		      return seq(this.t(node.kind), this.sep(Sep.VARIABLE_DECLARATION), this.commaSep(declarators, Sep.DECLARATORS_BEFORE_COMMA, Sep.DECLARATORS_AFTER_COMMA));
		    }
		  }, {
		    key: "reduceVariableDeclarationStatement",
		    value: function reduceVariableDeclarationStatement(node, _ref64) {
		      var declaration = _ref64.declaration;

		      return seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceVariableDeclarator",
		    value: function reduceVariableDeclarator(node, _ref65) {
		      var binding = _ref65.binding;
		      var init = _ref65.init;

		      var containsIn = init && init.containsIn && !init.containsGroup;
		      if (init) {
		        if (init.containsGroup) {
		          init = this.paren(init, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
		        } else {
		          init = markContainsIn(init);
		        }
		      }
		      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, this.sep(Sep.BEFORE_INIT_EQUALS), this.t("="), this.sep(Sep.AFTER_INIT_EQUALS), init), { containsIn: containsIn });
		    }
		  }, {
		    key: "reduceWhileStatement",
		    value: function reduceWhileStatement(node, _ref66) {
		      var test = _ref66.test;
		      var body = _ref66.body;

		      return (0, _objectAssign2.default)(seq(this.t("while"), this.sep(Sep.AFTER_WHILE), this.paren(test, Sep.WHILE_TEST_PAREN_BEFORE, Sep.WHILE_TEST_PAREN_AFTER), this.sep(Sep.BEFORE_WHILE_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }, {
		    key: "reduceWithStatement",
		    value: function reduceWithStatement(node, _ref67) {
		      var object = _ref67.object;
		      var body = _ref67.body;

		      return (0, _objectAssign2.default)(seq(this.t("with"), this.sep(Sep.AFTER_WITH), this.paren(object, Sep.WITH_PAREN_BEFORE, Sep.WITH_PAREN_AFTER), this.sep(Sep.BEFORE_WITH_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
		    }
		  }]);

		  return ExtensibleCodeGen;
		}();

		var INDENT = "  ";

		var Linebreak = function (_CodeRep) {
		  _inherits(Linebreak, _CodeRep);

		  function Linebreak() {
		    _classCallCheck(this, Linebreak);

		    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Linebreak).call(this));

		    _this4.indentation = 0;
		    return _this4;
		  }

		  _createClass(Linebreak, [{
		    key: "emit",
		    value: function emit(ts) {
		      ts.put("\n");
		      for (var i = 0; i < this.indentation; ++i) {
		        ts.put(INDENT);
		      }
		    }
		  }]);

		  return Linebreak;
		}(_coderep.CodeRep);

		function withoutTrailingLinebreak(state) {
		  if (state && state instanceof _coderep.Seq) {
		    var lastChild = state.children[state.children.length - 1];
		    /* istanbul ignore next */
		    while (lastChild instanceof _coderep.Empty) {
		      state.children.pop();
		      lastChild = state.children[state.children.length - 1];
		    }
		    /* istanbul ignore else */
		    if (lastChild instanceof _coderep.Seq) {
		      withoutTrailingLinebreak(lastChild);
		    } else if (lastChild instanceof Linebreak) {
		      state.children.pop();
		    }
		  }
		  return state;
		}

		function indent(rep, includingFinal) {
		  var finalLinebreak = undefined;
		  function indentNode(node) {
		    if (node instanceof Linebreak) {
		      finalLinebreak = node;
		      ++node.indentation;
		    }
		  }
		  rep.forEach(indentNode);
		  if (!includingFinal) {
		    --finalLinebreak.indentation;
		  }
		  return rep;
		}

		var FormattedCodeGen = exports.FormattedCodeGen = function (_ExtensibleCodeGen) {
		  _inherits(FormattedCodeGen, _ExtensibleCodeGen);

		  function FormattedCodeGen() {
		    _classCallCheck(this, FormattedCodeGen);

		    return _possibleConstructorReturn(this, Object.getPrototypeOf(FormattedCodeGen).apply(this, arguments));
		  }

		  _createClass(FormattedCodeGen, [{
		    key: "parenToAvoidBeingDirective",
		    value: function parenToAvoidBeingDirective(element, original) {
		      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
		        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(element)));
		      }
		      return original;
		    }
		  }, {
		    key: "brace",
		    value: function brace(rep, node) {
		      if (isEmpty(rep)) {
		        return this.t("{}");
		      }

		      switch (node.type) {
		        case "ObjectBinding":
		        case "Import":
		        case "ExportFrom":
		        case "ObjectExpression":
		          return new _coderep.Brace(rep);
		      }

		      rep = seq(new Linebreak(), rep);
		      indent(rep, false);
		      return new _coderep.Brace(rep);
		    }
		  }, {
		    key: "reduceDoWhileStatement",
		    value: function reduceDoWhileStatement(node, _ref68) {
		      var body = _ref68.body;
		      var test = _ref68.test;

		      return seq(this.t("do"), this.sep(Sep.AFTER_DO), withoutTrailingLinebreak(body), this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
		    }
		  }, {
		    key: "reduceIfStatement",
		    value: function reduceIfStatement(node, _ref69) {
		      var test = _ref69.test;
		      var consequent = _ref69.consequent;
		      var alternate = _ref69.alternate;

		      if (alternate && consequent.endsWithMissingElse) {
		        consequent = this.brace(consequent, node);
		      }
		      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), withoutTrailingLinebreak(consequent), alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), withoutTrailingLinebreak(alternate)) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
		    }
		  }, {
		    key: "reduceSwitchCase",
		    value: function reduceSwitchCase(node, _ref70) {
		      var test = _ref70.test;
		      var consequent = _ref70.consequent;

		      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
		      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), consequent, this.sep(Sep.AFTER_CASE_BODY));
		    }
		  }, {
		    key: "reduceSwitchDefault",
		    value: function reduceSwitchDefault(node, _ref71) {
		      var consequent = _ref71.consequent;

		      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
		      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), consequent, this.sep(Sep.AFTER_DEFAULT_BODY));
		    }
		  }, {
		    key: "sep",
		    value: function sep(separator) {
		      switch (separator.type) {
		        case "ARRAY_AFTER_COMMA":
		        case "OBJECT_AFTER_COMMA":
		        case "ARGS_AFTER_COMMA":
		        case "PARAMETER_AFTER_COMMA":
		        case "DECLARATORS_AFTER_COMMA":
		        case "NAMED_IMPORT_AFTER_COMMA":
		        case "IMPORT_AFTER_COMMA":
		        case "BEFORE_DEFAULT_EQUALS":
		        case "AFTER_DEFAULT_EQUALS":
		        case "AFTER_PROP":
		        case "BEFORE_JUMP_LABEL":
		        case "BEFORE_CATCH":
		        case "BEFORE_CATCH_BINDING":
		        case "AFTER_CATCH_BINDING":
		        case "BEFORE_CLASS_NAME":
		        case "BEFORE_EXTENDS":
		        case "AFTER_EXTENDS":
		        case "BEFORE_CLASS_DECLARATION_ELEMENTS":
		        case "BEFORE_CLASS_EXPRESSION_ELEMENTS":
		        case "AFTER_STATIC":
		        case "BEFORE_TERNARY_QUESTION":
		        case "AFTER_TERNARY_QUESTION":
		        case "BEFORE_TERNARY_COLON":
		        case "AFTER_TERNARY_COLON":
		        case "AFTER_DO":
		        case "BEFORE_DOWHILE_WHILE":
		        case "AFTER_DOWHILE_WHILE":
		        case "AFTER_FORIN_FOR":
		        case "BEFORE_FORIN_IN":
		        case "AFTER_FORIN_FOR":
		        case "BEFORE_FORIN_BODY":
		        case "AFTER_FOROF_FOR":
		        case "BEFORE_FOROF_OF":
		        case "AFTER_FOROF_FOR":
		        case "BEFORE_FOROF_BODY":
		        case "AFTER_FOR_FOR":
		        case "BEFORE_FOR_TEST":
		        case "BEFORE_FOR_UPDATE":
		        case "BEFORE_FOR_BODY":
		        case "BEFORE_FUNCTION_DECLARATION_BODY":
		        case "BEFORE_FUNCTION_EXPRESSION_BODY":
		        case "BEFORE_ARROW":
		        case "AFTER_ARROW":
		        case "AFTER_GET":
		        case "BEFORE_GET_BODY":
		        case "AFTER_IF":
		        case "AFTER_IF_TEST":
		        case "BEFORE_ELSE":
		        case "AFTER_ELSE":
		        case "BEFORE_IMPORT_BINDINGS":
		        case "BEFORE_IMPORT_MODULE":
		        case "AFTER_IMPORT_BINDINGS":
		        case "AFTER_FROM":
		        case "BEFORE_IMPORT_NAMESPACE":
		        case "BEFORE_IMPORT_STAR":
		        case "AFTER_IMPORT_STAR":
		        case "AFTER_IMPORT_AS":
		        case "AFTER_NAMESPACE_BINDING":
		        case "BEFORE_IMPORT_AS":
		        case "AFTER_IMPORT_AS":
		        case "EXPORTS_AFTER_COMMA":
		        case "BEFORE_EXPORT_STAR":
		        case "AFTER_EXPORT_STAR":
		        case "BEFORE_EXPORT_BINDINGS":
		        case "AFTER_EXPORT_BINDINGS":
		        case "AFTER_EXPORT":
		        case "AFTER_EXPORT_DEFAULT":
		        case "BEFORE_EXPORT_AS":
		        case "AFTER_EXPORT_AS":
		        case "AFTER_LABEL_COLON":
		        case "BEFORE_METHOD_BODY":
		        case "AFTER_NEW":
		        case "RETURN":
		        case "AFTER_SET":
		        case "BEFORE_SET_BODY":
		        case "BEFORE_SET_PARAMS":
		        case "BEFORE_CASE_TEST":
		        case "BEFORE_SWITCH_DISCRIM":
		        case "BEFORE_SWITCH_BODY":
		        case "THROW":
		        case "AFTER_TRY":
		        case "BEFORE_CATCH":
		        case "BEFORE_FINALLY":
		        case "AFTER_FINALLY":
		        case "VARIABLE_DECLARATION":
		        case "YIELD":
		        case "AFTER_YIELD_STAR":
		        case "DECLARATORS_AFTER_COMMA":
		        case "BEFORE_INIT_EQUALS":
		        case "AFTER_INIT_EQUALS":
		        case "AFTER_WHILE":
		        case "BEFORE_WHILE_BODY":
		        case "AFTER_WITH":
		        case "BEFORE_WITH_BODY":
		        case "BEFORE_FUNCTION_NAME":
		        case "AFTER_BINOP":
		        case "BEFORE_ASSIGN_OP":
		        case "AFTER_ASSIGN_OP":
		          return this.t(" ");
		        case "AFTER_STATEMENT":
		          switch (separator.node.type) {
		            case "ForInStatement":
		            case "ForOfStatement":
		            case "ForStatement":
		            case "WhileStatement":
		            case "WithStatement":
		              return empty(); // because those already end with an AFTER_STATEMENT
		            default:
		              return new Linebreak();
		          }
		        case "AFTER_CLASS_ELEMENT":
		        case "BEFORE_CASE_BODY":
		        case "AFTER_CASE_BODY":
		        case "AFTER_DEFAULT_BODY":
		          return new Linebreak();
		        case "BEFORE_BINOP":
		          return separator.op === "," ? empty() : this.t(" ");
		        case "UNARY":
		          return separator.op === "delete" || separator.op === "void" || separator.op === "typeof" ? this.t(" ") : empty();
		        default:
		          return empty();
		      }
		    }
		  }]);

		  return FormattedCodeGen;
		}(ExtensibleCodeGen);

	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2014 Shape Security, Inc.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.TokenStream = undefined;

		var _esutils = __webpack_require__(4);

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function numberDot(fragment) {
		  if (fragment.indexOf(".") < 0 && fragment.indexOf("e") < 0) {
		    return "..";
		  }
		  return ".";
		}

		function renderNumber(n) {
		  var s;
		  if (n >= 1e3 && n % 10 === 0) {
		    s = n.toString(10);
		    if (/[eE]/.test(s)) {
		      return s.replace(/[eE]\+/, "e");
		    }
		    return n.toString(10).replace(/0+$/, function (match) {
		      return "e" + match.length;
		    });
		  } else if (n % 1 === 0) {
		    if (n > 1e15 && n < 1e20) {
		      return "0x" + n.toString(16).toUpperCase();
		    }
		    return n.toString(10).replace(/[eE]\+/, "e");
		  } else {
		    return n.toString(10).replace(/^0\./, ".").replace(/[eE]\+/, "e");
		  }
		}

		var TokenStream = exports.TokenStream = function () {
		  function TokenStream() {
		    _classCallCheck(this, TokenStream);

		    this.result = "";
		    this.lastNumber = null;
		    this.lastChar = null;
		    this.optionalSemi = false;
		  }

		  _createClass(TokenStream, [{
		    key: "putNumber",
		    value: function putNumber(number) {
		      var tokenStr = renderNumber(number);
		      this.put(tokenStr);
		      this.lastNumber = tokenStr;
		    }
		  }, {
		    key: "putOptionalSemi",
		    value: function putOptionalSemi() {
		      this.optionalSemi = true;
		    }
		  }, {
		    key: "put",
		    value: function put(tokenStr) {
		      if (this.optionalSemi) {
		        this.optionalSemi = false;
		        if (tokenStr !== "}") {
		          this.put(";");
		        }
		      }
		      if (this.lastNumber !== null && tokenStr.length == 1) {
		        if (tokenStr === ".") {
		          this.result += numberDot(this.lastNumber);
		          this.lastNumber = null;
		          this.lastChar = ".";
		          return;
		        }
		      }
		      this.lastNumber = null;
		      var rightChar = tokenStr.charAt(0);
		      var lastChar = this.lastChar;
		      this.lastChar = tokenStr.charAt(tokenStr.length - 1);
		      if (lastChar && ((lastChar == "+" || lastChar == "-") && lastChar == rightChar || _esutils.code.isIdentifierPartES6(lastChar.charCodeAt(0)) && _esutils.code.isIdentifierPartES6(rightChar.charCodeAt(0)) || lastChar == "/" && rightChar == "i")) {
		        this.result += " ";
		      }

		      this.result += tokenStr;
		    }
		  }]);

		  return TokenStream;
		}();

	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Scope = exports.freshScope = undefined;

		var _errors = __webpack_require__(11);

		var _symbol = __webpack_require__(42);

		let scopeIndex_579 = 0;
		function freshScope_580() {
		  let name_582 = arguments.length <= 0 || arguments[0] === undefined ? "scope" : arguments[0];

		  scopeIndex_579++;
		  return (0, _symbol.Symbol)(name_582 + "_" + scopeIndex_579);
		}
		;
		function Scope_581(name_583) {
		  return (0, _symbol.Symbol)(name_583);
		}
		exports.freshScope = freshScope_580;
		exports.Scope = Scope_581;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Njb3BlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQSxJQUFJLGlCQUFpQixDQUFyQjtBQUNBLFNBQVMsY0FBVCxHQUE0QztBQUFBLE1BQXBCLFFBQW9CLHlEQUFULE9BQVM7O0FBQzFDO0FBQ0EsU0FBTyxvQkFBTyxXQUFXLEdBQVgsR0FBaUIsY0FBeEIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsRUFBNkI7QUFDM0IsU0FBTyxvQkFBTyxRQUFQLENBQVA7QUFDRDtRQUN5QixVLEdBQWxCLGM7UUFDYSxLLEdBQWIsUyIsImZpbGUiOiJzY29wZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXhwZWN0LCBhc3NlcnR9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHtTeW1ib2wsIGdlbnN5bX0gZnJvbSBcIi4vc3ltYm9sXCI7XG5sZXQgc2NvcGVJbmRleF81NzkgPSAwO1xuZnVuY3Rpb24gZnJlc2hTY29wZV81ODAobmFtZV81ODIgPSBcInNjb3BlXCIpIHtcbiAgc2NvcGVJbmRleF81NzkrKztcbiAgcmV0dXJuIFN5bWJvbChuYW1lXzU4MiArIFwiX1wiICsgc2NvcGVJbmRleF81NzkpO1xufVxuO1xuZnVuY3Rpb24gU2NvcGVfNTgxKG5hbWVfNTgzKSB7XG4gIHJldHVybiBTeW1ib2wobmFtZV81ODMpO1xufVxuZXhwb3J0IHtmcmVzaFNjb3BlXzU4MCBhcyBmcmVzaFNjb3BlfTtcbmV4cG9ydCB7U2NvcGVfNTgxIGFzIFNjb3BlfSJdfQ==

	/***/ },
	/* 42 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		let internedMap_769 = new Map();
		let counter_770 = 0;
		function gensym_771(name_774) {
		  let prefix_775 = name_774 == null ? "s_" : name_774 + "_";
		  let sym_776 = new Symbol_772(prefix_775 + counter_770);
		  counter_770++;
		  return sym_776;
		}
		function Symbol_772(name_777) {
		  this.name = name_777;
		}
		Symbol_772.prototype.toString = function () {
		  return this.name;
		};
		function makeSymbol_773(name_778) {
		  if (internedMap_769.has(name_778)) {
		    return internedMap_769.get(name_778);
		  } else {
		    let sym = new Symbol_772(name_778);
		    internedMap_769.set(name_778, sym);
		    return sym;
		  }
		}
		exports.Symbol = makeSymbol_773;
		exports.SymbolClass = Symbol_772;
		exports.gensym = gensym_771;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N5bWJvbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUksa0JBQWtCLElBQUksR0FBSixFQUF0QjtBQUNBLElBQUksY0FBYyxDQUFsQjtBQUNBLFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QjtBQUM1QixNQUFJLGFBQWEsWUFBWSxJQUFaLEdBQW1CLElBQW5CLEdBQTBCLFdBQVcsR0FBdEQ7QUFDQSxNQUFJLFVBQVUsSUFBSSxVQUFKLENBQWUsYUFBYSxXQUE1QixDQUFkO0FBQ0E7QUFDQSxTQUFPLE9BQVA7QUFDRDtBQUNELFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QjtBQUM1QixPQUFLLElBQUwsR0FBWSxRQUFaO0FBQ0Q7QUFDRCxXQUFXLFNBQVgsQ0FBcUIsUUFBckIsR0FBZ0MsWUFBWTtBQUMxQyxTQUFPLEtBQUssSUFBWjtBQUNELENBRkQ7QUFHQSxTQUFTLGNBQVQsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDaEMsTUFBSSxnQkFBZ0IsR0FBaEIsQ0FBb0IsUUFBcEIsQ0FBSixFQUFtQztBQUNqQyxXQUFPLGdCQUFnQixHQUFoQixDQUFvQixRQUFwQixDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSSxNQUFNLElBQUksVUFBSixDQUFlLFFBQWYsQ0FBVjtBQUNBLG9CQUFnQixHQUFoQixDQUFvQixRQUFwQixFQUE4QixHQUE5QjtBQUNBLFdBQU8sR0FBUDtBQUNEO0FBQ0Y7UUFDeUIsTSxHQUFsQixjO1FBQXdDLFcsR0FBZCxVO1FBQ1osTSxHQUFkLFUiLCJmaWxlIjoic3ltYm9sLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGludGVybmVkTWFwXzc2OSA9IG5ldyBNYXA7XG5sZXQgY291bnRlcl83NzAgPSAwO1xuZnVuY3Rpb24gZ2Vuc3ltXzc3MShuYW1lXzc3NCkge1xuICBsZXQgcHJlZml4Xzc3NSA9IG5hbWVfNzc0ID09IG51bGwgPyBcInNfXCIgOiBuYW1lXzc3NCArIFwiX1wiO1xuICBsZXQgc3ltXzc3NiA9IG5ldyBTeW1ib2xfNzcyKHByZWZpeF83NzUgKyBjb3VudGVyXzc3MCk7XG4gIGNvdW50ZXJfNzcwKys7XG4gIHJldHVybiBzeW1fNzc2O1xufVxuZnVuY3Rpb24gU3ltYm9sXzc3MihuYW1lXzc3Nykge1xuICB0aGlzLm5hbWUgPSBuYW1lXzc3Nztcbn1cblN5bWJvbF83NzIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5uYW1lO1xufTtcbmZ1bmN0aW9uIG1ha2VTeW1ib2xfNzczKG5hbWVfNzc4KSB7XG4gIGlmIChpbnRlcm5lZE1hcF83NjkuaGFzKG5hbWVfNzc4KSkge1xuICAgIHJldHVybiBpbnRlcm5lZE1hcF83NjkuZ2V0KG5hbWVfNzc4KTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3ltID0gbmV3IFN5bWJvbF83NzIobmFtZV83NzgpO1xuICAgIGludGVybmVkTWFwXzc2OS5zZXQobmFtZV83NzgsIHN5bSk7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxufVxuZXhwb3J0IHttYWtlU3ltYm9sXzc3MyBhcyBTeW1ib2wsIFN5bWJvbF83NzIgYXMgU3ltYm9sQ2xhc3N9O1xuZXhwb3J0IHtnZW5zeW1fNzcxIGFzIGdlbnN5bX0iXX0=

	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Modules = exports.Module = undefined;

		var _immutable = __webpack_require__(9);

		var _env = __webpack_require__(28);

		var _env2 = _interopRequireDefault(_env);

		var _store = __webpack_require__(44);

		var _store2 = _interopRequireDefault(_store);

		var _shiftReader = __webpack_require__(1);

		var _shiftReader2 = _interopRequireDefault(_shiftReader);

		var _tokenExpander = __webpack_require__(47);

		var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

		var _termExpander = __webpack_require__(51);

		var _termExpander2 = _interopRequireDefault(_termExpander);

		var _bindingMap = __webpack_require__(12);

		var _bindingMap2 = _interopRequireDefault(_bindingMap);

		var _symbol = __webpack_require__(42);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _loadSyntax = __webpack_require__(50);

		var _compiler = __webpack_require__(53);

		var _compiler2 = _interopRequireDefault(_compiler);

		var _transforms = __webpack_require__(29);

		var _scope = __webpack_require__(41);

		var _errors = __webpack_require__(11);

		var _hygieneUtils = __webpack_require__(64);

		var _syntax = __webpack_require__(10);

		var _utilsDirname = __webpack_require__(65);

		var _utilsDirname2 = _interopRequireDefault(_utilsDirname);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class Module_423 {
		  constructor(moduleSpecifier_428, isNative_429, importEntries_430, exportEntries_431, pragmas_432, body_433) {
		    this.moduleSpecifier = moduleSpecifier_428;
		    this.isNative = isNative_429;
		    this.importEntries = importEntries_430;
		    this.exportEntries = exportEntries_431;
		    this.pragmas = pragmas_432;
		    this.body = body_433;
		  }
		}
		const findBindingIdentifierName_424 = term_434 => {
		  (0, _errors.assert)(term_434.name, `not implemented yet for type ${ term_434.type }`);
		  return term_434.name;
		};
		const convertExport_425 = term_435 => {
		  let declaration_436 = term_435.declaration;
		  let bindings_437 = [];
		  if ((0, _terms.isVariableDeclaration)(declaration_436)) {
		    bindings_437 = declaration_436.declarators.map(decl_439 => findBindingIdentifierName_424(decl_439.binding));
		  } else if ((0, _terms.isFunctionDeclaration)(declaration_436) || (0, _terms.isClassDeclaration)(declaration_436)) {
		    bindings_437.push(findBindingIdentifierName_424(declaration_436.name));
		  }
		  let namedExports_438 = bindings_437.map(binding_440 => {
		    return new _terms2.default("ExportSpecifier", { name: null, exportedName: binding_440 });
		  });
		  return new _terms2.default("ExportFrom", { moduleSpecifier: null, namedExports: (0, _immutable.List)(namedExports_438) });
		};
		const pragmaRegep_426 = /^\s*#\w*/;
		class Modules_427 {
		  constructor(context_441) {
		    this.compiledModules = new Map();
		    this.context = context_441;
		    this.context.modules = this;
		  }
		  loadString(str_442) {
		    let checkPragma_443 = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

		    let hasPragma_444 = pragmaRegep_426.test(str_442);
		    if (checkPragma_443 && !hasPragma_444) {
		      return { isNative: true, body: (0, _immutable.List)() };
		    }
		    return { isNative: !hasPragma_444, body: new _shiftReader2.default(str_442).read() };
		  }
		  load(path_445) {
		    return this.loadString(this.context.moduleLoader(path_445));
		  }
		  compile(mod_446, path_447) {
		    let stxl_448 = mod_446.body;
		    let outScope_449 = (0, _scope.freshScope)("outsideEdge");
		    let inScope_450 = (0, _scope.freshScope)(`insideEdge0`);
		    let compiler_451 = new _compiler2.default(0, new _env2.default(), new _store2.default(), _.merge(this.context, { currentScope: [outScope_449, inScope_450], cwd: path_447 === "<<entrypoint>>" ? this.context.cwd : (0, _utilsDirname2.default)(path_447) }));
		    let terms_452 = compiler_451.compile(stxl_448.map(s_457 => s_457.addScope(outScope_449, this.context.bindings, _syntax.ALL_PHASES).addScope(inScope_450, this.context.bindings, 0)));
		    let importEntries_453 = [];
		    let exportEntries_454 = [];
		    let pragmas_455 = [];
		    let filteredTerms_456 = terms_452.reduce((acc_458, t_459) => {
		      return _.cond([[_terms.isImport, t_460 => {
		        importEntries_453.push(t_460);
		        return acc_458;
		      }], [_terms.isExport, t_461 => {
		        if (t_461.declaration) {
		          exportEntries_454.push(convertExport_425(t_461));
		          if ((0, _terms.isVariableDeclaration)(t_461.declaration)) {
		            return acc_458.concat(new _terms2.default("VariableDeclarationStatement", { declaration: t_461.declaration }));
		          }
		          return acc_458.concat(t_461.declaration);
		        }
		        exportEntries_454.push(t_461);
		        return acc_458;
		      }], [_terms.isPragma, t_462 => {
		        pragmas_455.push(t_462);
		        return acc_458;
		      }], [_.T, t_463 => acc_458.concat(t_463)]])(t_459);
		    }, (0, _immutable.List)());
		    return new Module_423(path_447, mod_446.isNative, (0, _immutable.List)(importEntries_453), (0, _immutable.List)(exportEntries_454), (0, _immutable.List)(pragmas_455), filteredTerms_456);
		  }
		  compileEntrypoint(source_464, filename_465) {
		    let enforcePragma_466 = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

		    let stxl_467 = this.loadString(source_464, false);
		    if (enforcePragma_466 && stxl_467.isNative) {
		      throw new Error(`Entrypoint ${ filename_465 } must begin with #lang pragma`);
		    }
		    return this.getAtPhase("<<entrypoint>>", 0, this.context.cwd, stxl_467);
		  }
		  getAtPhase(rawPath_468, phase_469, cwd_470) {
		    let rawStxl_471 = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

		    let path_472 = rawPath_468 === "<<entrypoint>>" ? rawPath_468 : this.context.moduleResolver(rawPath_468, cwd_470);
		    let mapKey_473 = `${ path_472 }:${ phase_469 }`;
		    if (!this.compiledModules.has(mapKey_473)) {
		      if (phase_469 === 0) {
		        let stxl = rawStxl_471 != null ? rawStxl_471 : this.load(path_472);
		        this.compiledModules.set(mapKey_473, this.compile(stxl, path_472));
		      } else {
		        let rawMod = this.getAtPhase(rawPath_468, 0, cwd_470, rawStxl_471);
		        let scope = (0, _scope.freshScope)(`insideEdge${ phase_469 }`);
		        this.compiledModules.set(mapKey_473, new Module_423(rawMod.moduleSpecifier, false, rawMod.importEntries.map(term_474 => term_474.addScope(scope, this.context.bindings, phase_469)), rawMod.exportEntries.map(term_475 => term_475.addScope(scope, this.context.bindings, phase_469)), rawMod.pragmas, rawMod.body.map(term_476 => term_476.addScope(scope, this.context.bindings, phase_469))));
		      }
		    }
		    return this.compiledModules.get(mapKey_473);
		  }
		  has(rawPath_477) {
		    let phase_478 = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

		    let path_479 = rawPath_477 === "<<entrypoint>>" ? rawPath_477 : this.context.moduleResolver(rawPath_477, this.context.cwd);
		    let key_480 = `${ path_479 }:${ phase_478 }`;
		    return this.compiledModules.has(key_480) && !this.compiledModules.get(key_480).isNative;
		  }
		  registerSyntaxDeclaration(term_481, phase_482, store_483) {
		    term_481.declarators.forEach(decl_484 => {
		      let val_485 = (0, _loadSyntax.evalCompiletimeValue)(decl_484.init.gen(), _.merge(this.context, { phase: phase_482 + 1, store: store_483 }));
		      (0, _hygieneUtils.collectBindings)(decl_484.binding).forEach(stx_486 => {
		        if (phase_482 !== 0) {
		          let newBinding = (0, _symbol.gensym)(stx_486.val());
		          this.context.bindings.add(stx_486, { binding: newBinding, phase: phase_482, skipDup: false });
		        }
		        let resolvedName_487 = stx_486.resolve(phase_482);
		        store_483.set(resolvedName_487, new _transforms.CompiletimeTransform(val_485));
		      });
		    });
		  }
		  registerVariableDeclaration(term_488, phase_489, store_490) {
		    term_488.declarators.forEach(decl_491 => {
		      (0, _hygieneUtils.collectBindings)(decl_491.binding).forEach(stx_492 => {
		        if (phase_489 !== 0) {
		          let newBinding = (0, _symbol.gensym)(stx_492.val());
		          this.context.bindings.add(stx_492, { binding: newBinding, phase: phase_489, skipDup: term_488.kind === "var" });
		        }
		        let resolvedName_493 = stx_492.resolve(phase_489);
		        store_490.set(resolvedName_493, new _transforms.VarBindingTransform(stx_492));
		      });
		    });
		  }
		  registerFunctionOrClass(term_494, phase_495, store_496) {
		    (0, _hygieneUtils.collectBindings)(term_494.name).forEach(stx_497 => {
		      if (phase_495 !== 0) {
		        let newBinding = (0, _symbol.gensym)(stx_497.val());
		        this.context.bindings.add(stx_497, { binding: newBinding, phase: phase_495, skipDup: false });
		      }
		      let resolvedName_498 = stx_497.resolve(phase_495);
		      store_496.set(resolvedName_498, new _transforms.VarBindingTransform(stx_497));
		    });
		  }
		  visit(mod_499, phase_500, store_501) {
		    mod_499.body.forEach(term_502 => {
		      if ((0, _terms.isSyntaxDeclarationStatement)(term_502)) {
		        this.registerSyntaxDeclaration(term_502.declaration, phase_500, store_501);
		      }
		    });
		    return store_501;
		  }
		  invoke(mod_503, phase_504, store_505) {
		    let body_506 = mod_503.body.filter(_.complement(_terms.isCompiletimeStatement)).map(term_508 => {
		      term_508 = term_508.gen();
		      if ((0, _terms.isVariableDeclarationStatement)(term_508)) {
		        this.registerVariableDeclaration(term_508.declaration, phase_504, store_505);
		      } else if ((0, _terms.isFunctionDeclaration)(term_508)) {
		        this.registerFunctionOrClass(term_508, phase_504, store_505);
		      }
		      return term_508;
		    });
		    let exportsObj_507 = (0, _loadSyntax.evalRuntimeValues)(body_506, _.merge(this.context, { store: store_505, phase: phase_504 }));
		    return store_505;
		  }
		}
		exports.Module = Module_423;
		exports.Modules = Modules_427;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L21vZHVsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztJQUFhLEM7Ozs7OztBQUNiLE1BQU0sVUFBTixDQUFpQjtBQUNmLGNBQVksbUJBQVosRUFBaUMsWUFBakMsRUFBK0MsaUJBQS9DLEVBQWtFLGlCQUFsRSxFQUFxRixXQUFyRixFQUFrRyxRQUFsRyxFQUE0RztBQUMxRyxTQUFLLGVBQUwsR0FBdUIsbUJBQXZCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLFlBQWhCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLGlCQUFyQjtBQUNBLFNBQUssYUFBTCxHQUFxQixpQkFBckI7QUFDQSxTQUFLLE9BQUwsR0FBZSxXQUFmO0FBQ0EsU0FBSyxJQUFMLEdBQVksUUFBWjtBQUNEO0FBUmM7QUFVakIsTUFBTSxnQ0FBZ0MsWUFBWTtBQUNoRCxzQkFBTyxTQUFTLElBQWhCLEVBQXNCLENBQUMsNkJBQUQsR0FBZ0MsU0FBUyxJQUF6QyxFQUE4QyxBQUE5QyxDQUF0QjtBQUNBLFNBQU8sU0FBUyxJQUFoQjtBQUNELENBSEQ7QUFJQSxNQUFNLG9CQUFvQixZQUFZO0FBQ3BDLE1BQUksa0JBQWtCLFNBQVMsV0FBL0I7QUFDQSxNQUFJLGVBQWUsRUFBbkI7QUFDQSxNQUFJLGtDQUFzQixlQUF0QixDQUFKLEVBQTRDO0FBQzFDLG1CQUFlLGdCQUFnQixXQUFoQixDQUE0QixHQUE1QixDQUFnQyxZQUFZLDhCQUE4QixTQUFTLE9BQXZDLENBQTVDLENBQWY7QUFDRCxHQUZELE1BRU8sSUFBSSxrQ0FBc0IsZUFBdEIsS0FBMEMsK0JBQW1CLGVBQW5CLENBQTlDLEVBQW1GO0FBQ3hGLGlCQUFhLElBQWIsQ0FBa0IsOEJBQThCLGdCQUFnQixJQUE5QyxDQUFsQjtBQUNEO0FBQ0QsTUFBSSxtQkFBbUIsYUFBYSxHQUFiLENBQWlCLGVBQWU7QUFDckQsV0FBTyxvQkFBUyxpQkFBVCxFQUE0QixFQUFDLE1BQU0sSUFBUCxFQUFhLGNBQWMsV0FBM0IsRUFBNUIsQ0FBUDtBQUNELEdBRnNCLENBQXZCO0FBR0EsU0FBTyxvQkFBUyxZQUFULEVBQXVCLEVBQUMsaUJBQWlCLElBQWxCLEVBQXdCLGNBQWMscUJBQUssZ0JBQUwsQ0FBdEMsRUFBdkIsQ0FBUDtBQUNELENBWkQ7QUFhQSxNQUFNLGtCQUFrQixVQUF4QjtBQUNBLE1BQU0sV0FBTixDQUFrQjtBQUNoQixjQUFZLFdBQVosRUFBeUI7QUFDdkIsU0FBSyxlQUFMLEdBQXVCLElBQUksR0FBSixFQUF2QjtBQUNBLFNBQUssT0FBTCxHQUFlLFdBQWY7QUFDQSxTQUFLLE9BQUwsQ0FBYSxPQUFiLEdBQXVCLElBQXZCO0FBQ0Q7QUFDRCxhQUFXLE9BQVgsRUFBNEM7QUFBQSxRQUF4QixlQUF3Qix5REFBTixJQUFNOztBQUMxQyxRQUFJLGdCQUFnQixnQkFBZ0IsSUFBaEIsQ0FBcUIsT0FBckIsQ0FBcEI7QUFDQSxRQUFJLG1CQUFtQixDQUFDLGFBQXhCLEVBQXVDO0FBQ3JDLGFBQU8sRUFBQyxVQUFVLElBQVgsRUFBaUIsTUFBTSxzQkFBdkIsRUFBUDtBQUNEO0FBQ0QsV0FBTyxFQUFDLFVBQVUsQ0FBQyxhQUFaLEVBQTJCLE1BQU0sMEJBQVcsT0FBWCxFQUFvQixJQUFwQixFQUFqQyxFQUFQO0FBQ0Q7QUFDRCxPQUFLLFFBQUwsRUFBZTtBQUNiLFdBQU8sS0FBSyxVQUFMLENBQWdCLEtBQUssT0FBTCxDQUFhLFlBQWIsQ0FBMEIsUUFBMUIsQ0FBaEIsQ0FBUDtBQUNEO0FBQ0QsVUFBUSxPQUFSLEVBQWlCLFFBQWpCLEVBQTJCO0FBQ3pCLFFBQUksV0FBVyxRQUFRLElBQXZCO0FBQ0EsUUFBSSxlQUFlLHVCQUFXLGFBQVgsQ0FBbkI7QUFDQSxRQUFJLGNBQWMsdUJBQVcsQ0FBQyxXQUFELENBQVgsQ0FBbEI7QUFDQSxRQUFJLGVBQWUsdUJBQWEsQ0FBYixFQUFnQixtQkFBaEIsRUFBeUIscUJBQXpCLEVBQW9DLEVBQUUsS0FBRixDQUFRLEtBQUssT0FBYixFQUFzQixFQUFDLGNBQWMsQ0FBQyxZQUFELEVBQWUsV0FBZixDQUFmLEVBQTRDLEtBQUssYUFBYSxnQkFBYixHQUFnQyxLQUFLLE9BQUwsQ0FBYSxHQUE3QyxHQUFtRCw0QkFBUSxRQUFSLENBQXBHLEVBQXRCLENBQXBDLENBQW5CO0FBQ0EsUUFBSSxZQUFZLGFBQWEsT0FBYixDQUFxQixTQUFTLEdBQVQsQ0FBYSxTQUFTLE1BQU0sUUFBTixDQUFlLFlBQWYsRUFBNkIsS0FBSyxPQUFMLENBQWEsUUFBMUMsc0JBQWdFLFFBQWhFLENBQXlFLFdBQXpFLEVBQXNGLEtBQUssT0FBTCxDQUFhLFFBQW5HLEVBQTZHLENBQTdHLENBQXRCLENBQXJCLENBQWhCO0FBQ0EsUUFBSSxvQkFBb0IsRUFBeEI7QUFDQSxRQUFJLG9CQUFvQixFQUF4QjtBQUNBLFFBQUksY0FBYyxFQUFsQjtBQUNBLFFBQUksb0JBQW9CLFVBQVUsTUFBVixDQUFpQixDQUFDLE9BQUQsRUFBVSxLQUFWLEtBQW9CO0FBQzNELGFBQU8sRUFBRSxJQUFGLENBQU8sQ0FBQyxrQkFBVyxTQUFTO0FBQ2pDLDBCQUFrQixJQUFsQixDQUF1QixLQUF2QjtBQUNBLGVBQU8sT0FBUDtBQUNELE9BSGMsQ0FBRCxFQUdWLGtCQUFXLFNBQVM7QUFDdEIsWUFBSSxNQUFNLFdBQVYsRUFBdUI7QUFDckIsNEJBQWtCLElBQWxCLENBQXVCLGtCQUFrQixLQUFsQixDQUF2QjtBQUNBLGNBQUksa0NBQXNCLE1BQU0sV0FBNUIsQ0FBSixFQUE4QztBQUM1QyxtQkFBTyxRQUFRLE1BQVIsQ0FBZSxvQkFBUyw4QkFBVCxFQUF5QyxFQUFDLGFBQWEsTUFBTSxXQUFwQixFQUF6QyxDQUFmLENBQVA7QUFDRDtBQUNELGlCQUFPLFFBQVEsTUFBUixDQUFlLE1BQU0sV0FBckIsQ0FBUDtBQUNEO0FBQ0QsMEJBQWtCLElBQWxCLENBQXVCLEtBQXZCO0FBQ0EsZUFBTyxPQUFQO0FBQ0QsT0FWRyxDQUhVLEVBYVYsa0JBQVcsU0FBUztBQUN0QixvQkFBWSxJQUFaLENBQWlCLEtBQWpCO0FBQ0EsZUFBTyxPQUFQO0FBQ0QsT0FIRyxDQWJVLEVBZ0JWLENBQUMsRUFBRSxDQUFILEVBQU0sU0FBUyxRQUFRLE1BQVIsQ0FBZSxLQUFmLENBQWYsQ0FoQlUsQ0FBUCxFQWdCcUMsS0FoQnJDLENBQVA7QUFpQkQsS0FsQnVCLEVBa0JyQixzQkFsQnFCLENBQXhCO0FBbUJBLFdBQU8sSUFBSSxVQUFKLENBQWUsUUFBZixFQUF5QixRQUFRLFFBQWpDLEVBQTJDLHFCQUFLLGlCQUFMLENBQTNDLEVBQW9FLHFCQUFLLGlCQUFMLENBQXBFLEVBQTZGLHFCQUFLLFdBQUwsQ0FBN0YsRUFBZ0gsaUJBQWhILENBQVA7QUFDRDtBQUNELG9CQUFrQixVQUFsQixFQUE4QixZQUE5QixFQUF1RTtBQUFBLFFBQTNCLGlCQUEyQix5REFBUCxLQUFPOztBQUNyRSxRQUFJLFdBQVcsS0FBSyxVQUFMLENBQWdCLFVBQWhCLEVBQTRCLEtBQTVCLENBQWY7QUFDQSxRQUFJLHFCQUFxQixTQUFTLFFBQWxDLEVBQTRDO0FBQzFDLFlBQU0sSUFBSSxLQUFKLENBQVUsQ0FBQyxXQUFELEdBQWMsWUFBZCxFQUEyQiw2QkFBM0IsQ0FBVixDQUFOO0FBQ0Q7QUFDRCxXQUFPLEtBQUssVUFBTCxDQUFnQixnQkFBaEIsRUFBa0MsQ0FBbEMsRUFBcUMsS0FBSyxPQUFMLENBQWEsR0FBbEQsRUFBdUQsUUFBdkQsQ0FBUDtBQUNEO0FBQ0QsYUFBVyxXQUFYLEVBQXdCLFNBQXhCLEVBQW1DLE9BQW5DLEVBQWdFO0FBQUEsUUFBcEIsV0FBb0IseURBQU4sSUFBTTs7QUFDOUQsUUFBSSxXQUFXLGdCQUFnQixnQkFBaEIsR0FBbUMsV0FBbkMsR0FBaUQsS0FBSyxPQUFMLENBQWEsY0FBYixDQUE0QixXQUE1QixFQUF5QyxPQUF6QyxDQUFoRTtBQUNBLFFBQUksYUFBYSxDQUFDLEFBQUQsR0FBRyxRQUFILEVBQVksQ0FBWixHQUFlLFNBQWYsRUFBeUIsQUFBekIsQ0FBakI7QUFDQSxRQUFJLENBQUMsS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLFVBQXpCLENBQUwsRUFBMkM7QUFDekMsVUFBSSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLFlBQUksT0FBTyxlQUFlLElBQWYsR0FBc0IsV0FBdEIsR0FBb0MsS0FBSyxJQUFMLENBQVUsUUFBVixDQUEvQztBQUNBLGFBQUssZUFBTCxDQUFxQixHQUFyQixDQUF5QixVQUF6QixFQUFxQyxLQUFLLE9BQUwsQ0FBYSxJQUFiLEVBQW1CLFFBQW5CLENBQXJDO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSSxTQUFTLEtBQUssVUFBTCxDQUFnQixXQUFoQixFQUE2QixDQUE3QixFQUFnQyxPQUFoQyxFQUF5QyxXQUF6QyxDQUFiO0FBQ0EsWUFBSSxRQUFRLHVCQUFXLENBQUMsVUFBRCxHQUFhLFNBQWIsRUFBdUIsQUFBdkIsQ0FBWCxDQUFaO0FBQ0EsYUFBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLFVBQXpCLEVBQXFDLElBQUksVUFBSixDQUFlLE9BQU8sZUFBdEIsRUFBdUMsS0FBdkMsRUFBOEMsT0FBTyxhQUFQLENBQXFCLEdBQXJCLENBQXlCLFlBQVksU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCLEtBQUssT0FBTCxDQUFhLFFBQXRDLEVBQWdELFNBQWhELENBQXJDLENBQTlDLEVBQWdKLE9BQU8sYUFBUCxDQUFxQixHQUFyQixDQUF5QixZQUFZLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QixLQUFLLE9BQUwsQ0FBYSxRQUF0QyxFQUFnRCxTQUFoRCxDQUFyQyxDQUFoSixFQUFrUCxPQUFPLE9BQXpQLEVBQWtRLE9BQU8sSUFBUCxDQUFZLEdBQVosQ0FBZ0IsWUFBWSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUIsS0FBSyxPQUFMLENBQWEsUUFBdEMsRUFBZ0QsU0FBaEQsQ0FBNUIsQ0FBbFEsQ0FBckM7QUFDRDtBQUNGO0FBQ0QsV0FBTyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBeUIsVUFBekIsQ0FBUDtBQUNEO0FBQ0QsTUFBSSxXQUFKLEVBQWdDO0FBQUEsUUFBZixTQUFlLHlEQUFILENBQUc7O0FBQzlCLFFBQUksV0FBVyxnQkFBZ0IsZ0JBQWhCLEdBQW1DLFdBQW5DLEdBQWlELEtBQUssT0FBTCxDQUFhLGNBQWIsQ0FBNEIsV0FBNUIsRUFBeUMsS0FBSyxPQUFMLENBQWEsR0FBdEQsQ0FBaEU7QUFDQSxRQUFJLFVBQVUsQ0FBQyxBQUFELEdBQUcsUUFBSCxFQUFZLENBQVosR0FBZSxTQUFmLEVBQXlCLEFBQXpCLENBQWQ7QUFDQSxXQUFPLEtBQUssZUFBTCxDQUFxQixHQUFyQixDQUF5QixPQUF6QixLQUFxQyxDQUFDLEtBQUssZUFBTCxDQUFxQixHQUFyQixDQUF5QixPQUF6QixFQUFrQyxRQUEvRTtBQUNEO0FBQ0QsNEJBQTBCLFFBQTFCLEVBQW9DLFNBQXBDLEVBQStDLFNBQS9DLEVBQTBEO0FBQ3hELGFBQVMsV0FBVCxDQUFxQixPQUFyQixDQUE2QixZQUFZO0FBQ3ZDLFVBQUksVUFBVSxzQ0FBcUIsU0FBUyxJQUFULENBQWMsR0FBZCxFQUFyQixFQUEwQyxFQUFFLEtBQUYsQ0FBUSxLQUFLLE9BQWIsRUFBc0IsRUFBQyxPQUFPLFlBQVksQ0FBcEIsRUFBdUIsT0FBTyxTQUE5QixFQUF0QixDQUExQyxDQUFkO0FBQ0EseUNBQWdCLFNBQVMsT0FBekIsRUFBa0MsT0FBbEMsQ0FBMEMsV0FBVztBQUNuRCxZQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsY0FBSSxhQUFhLG9CQUFPLFFBQVEsR0FBUixFQUFQLENBQWpCO0FBQ0EsZUFBSyxPQUFMLENBQWEsUUFBYixDQUFzQixHQUF0QixDQUEwQixPQUExQixFQUFtQyxFQUFDLFNBQVMsVUFBVixFQUFzQixPQUFPLFNBQTdCLEVBQXdDLFNBQVMsS0FBakQsRUFBbkM7QUFDRDtBQUNELFlBQUksbUJBQW1CLFFBQVEsT0FBUixDQUFnQixTQUFoQixDQUF2QjtBQUNBLGtCQUFVLEdBQVYsQ0FBYyxnQkFBZCxFQUFnQyxxQ0FBeUIsT0FBekIsQ0FBaEM7QUFDRCxPQVBEO0FBUUQsS0FWRDtBQVdEO0FBQ0QsOEJBQTRCLFFBQTVCLEVBQXNDLFNBQXRDLEVBQWlELFNBQWpELEVBQTREO0FBQzFELGFBQVMsV0FBVCxDQUFxQixPQUFyQixDQUE2QixZQUFZO0FBQ3ZDLHlDQUFnQixTQUFTLE9BQXpCLEVBQWtDLE9BQWxDLENBQTBDLFdBQVc7QUFDbkQsWUFBSSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLGNBQUksYUFBYSxvQkFBTyxRQUFRLEdBQVIsRUFBUCxDQUFqQjtBQUNBLGVBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsR0FBdEIsQ0FBMEIsT0FBMUIsRUFBbUMsRUFBQyxTQUFTLFVBQVYsRUFBc0IsT0FBTyxTQUE3QixFQUF3QyxTQUFTLFNBQVMsSUFBVCxLQUFrQixLQUFuRSxFQUFuQztBQUNEO0FBQ0QsWUFBSSxtQkFBbUIsUUFBUSxPQUFSLENBQWdCLFNBQWhCLENBQXZCO0FBQ0Esa0JBQVUsR0FBVixDQUFjLGdCQUFkLEVBQWdDLG9DQUF3QixPQUF4QixDQUFoQztBQUNELE9BUEQ7QUFRRCxLQVREO0FBVUQ7QUFDRCwwQkFBd0IsUUFBeEIsRUFBa0MsU0FBbEMsRUFBNkMsU0FBN0MsRUFBd0Q7QUFDdEQsdUNBQWdCLFNBQVMsSUFBekIsRUFBK0IsT0FBL0IsQ0FBdUMsV0FBVztBQUNoRCxVQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsWUFBSSxhQUFhLG9CQUFPLFFBQVEsR0FBUixFQUFQLENBQWpCO0FBQ0EsYUFBSyxPQUFMLENBQWEsUUFBYixDQUFzQixHQUF0QixDQUEwQixPQUExQixFQUFtQyxFQUFDLFNBQVMsVUFBVixFQUFzQixPQUFPLFNBQTdCLEVBQXdDLFNBQVMsS0FBakQsRUFBbkM7QUFDRDtBQUNELFVBQUksbUJBQW1CLFFBQVEsT0FBUixDQUFnQixTQUFoQixDQUF2QjtBQUNBLGdCQUFVLEdBQVYsQ0FBYyxnQkFBZCxFQUFnQyxvQ0FBd0IsT0FBeEIsQ0FBaEM7QUFDRCxLQVBEO0FBUUQ7QUFDRCxRQUFNLE9BQU4sRUFBZSxTQUFmLEVBQTBCLFNBQTFCLEVBQXFDO0FBQ25DLFlBQVEsSUFBUixDQUFhLE9BQWIsQ0FBcUIsWUFBWTtBQUMvQixVQUFJLHlDQUE2QixRQUE3QixDQUFKLEVBQTRDO0FBQzFDLGFBQUsseUJBQUwsQ0FBK0IsU0FBUyxXQUF4QyxFQUFxRCxTQUFyRCxFQUFnRSxTQUFoRTtBQUNEO0FBQ0YsS0FKRDtBQUtBLFdBQU8sU0FBUDtBQUNEO0FBQ0QsU0FBTyxPQUFQLEVBQWdCLFNBQWhCLEVBQTJCLFNBQTNCLEVBQXNDO0FBQ3BDLFFBQUksV0FBVyxRQUFRLElBQVIsQ0FBYSxNQUFiLENBQW9CLEVBQUUsVUFBRiwrQkFBcEIsRUFBMEQsR0FBMUQsQ0FBOEQsWUFBWTtBQUN2RixpQkFBVyxTQUFTLEdBQVQsRUFBWDtBQUNBLFVBQUksMkNBQStCLFFBQS9CLENBQUosRUFBOEM7QUFDNUMsYUFBSywyQkFBTCxDQUFpQyxTQUFTLFdBQTFDLEVBQXVELFNBQXZELEVBQWtFLFNBQWxFO0FBQ0QsT0FGRCxNQUVPLElBQUksa0NBQXNCLFFBQXRCLENBQUosRUFBcUM7QUFDMUMsYUFBSyx1QkFBTCxDQUE2QixRQUE3QixFQUF1QyxTQUF2QyxFQUFrRCxTQUFsRDtBQUNEO0FBQ0QsYUFBTyxRQUFQO0FBQ0QsS0FSYyxDQUFmO0FBU0EsUUFBSSxpQkFBaUIsbUNBQWtCLFFBQWxCLEVBQTRCLEVBQUUsS0FBRixDQUFRLEtBQUssT0FBYixFQUFzQixFQUFDLE9BQU8sU0FBUixFQUFtQixPQUFPLFNBQTFCLEVBQXRCLENBQTVCLENBQXJCO0FBQ0EsV0FBTyxTQUFQO0FBQ0Q7QUFoSWU7UUFrSUksTSxHQUFkLFU7UUFDZSxPLEdBQWYsVyIsImZpbGUiOiJtb2R1bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQgRW52IGZyb20gXCIuL2VudlwiO1xuaW1wb3J0IFN0b3JlIGZyb20gXCIuL3N0b3JlXCI7XG5pbXBvcnQgUmVhZGVyIGZyb20gXCIuL3NoaWZ0LXJlYWRlclwiO1xuaW1wb3J0IFRva2VuRXhwYW5kZXIgZnJvbSBcIi4vdG9rZW4tZXhwYW5kZXIuanNcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSBcIi4vYmluZGluZy1tYXAuanNcIjtcbmltcG9ydCB7Z2Vuc3ltfSBmcm9tIFwiLi9zeW1ib2xcIjtcbmltcG9ydCBUZXJtLCB7aXNFT0YsIGlzQmluZGluZ0lkZW50aWZpZXIsIGlzRnVuY3Rpb25EZWNsYXJhdGlvbiwgaXNGdW5jdGlvbkV4cHJlc3Npb24sIGlzRnVuY3Rpb25UZXJtLCBpc0Z1bmN0aW9uV2l0aE5hbWUsIGlzU3ludGF4RGVjbGFyYXRpb24sIGlzU3ludGF4cmVjRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50LCBpc0ltcG9ydCwgaXNFeHBvcnQsIGlzRXhwb3J0RnJvbSwgaXNFeHBvcnRBbGxGcm9tLCBpc0V4cG9ydERlZmF1bHQsIGlzRXhwb3J0U3ludGF4LCBpc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50LCBpc1ByYWdtYSwgaXNDb21waWxldGltZURlY2xhcmF0aW9uLCBpc0NvbXBpbGV0aW1lU3RhdGVtZW50LCBpc0NsYXNzRGVjbGFyYXRpb259IGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge2V2YWxDb21waWxldGltZVZhbHVlLCBldmFsUnVudGltZVZhbHVlc30gZnJvbSBcIi4vbG9hZC1zeW50YXhcIjtcbmltcG9ydCBDb21waWxlciBmcm9tIFwiLi9jb21waWxlclwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtTY29wZSwgZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7Y29sbGVjdEJpbmRpbmdzfSBmcm9tIFwiLi9oeWdpZW5lLXV0aWxzXCI7XG5pbXBvcnQge0FMTF9QSEFTRVN9IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0IGRpcm5hbWUgZnJvbSBcInV0aWxzLWRpcm5hbWVcIjtcbmltcG9ydCAgKiBhcyBfIGZyb20gXCJyYW1kYVwiO1xuY2xhc3MgTW9kdWxlXzQyMyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZVNwZWNpZmllcl80MjgsIGlzTmF0aXZlXzQyOSwgaW1wb3J0RW50cmllc180MzAsIGV4cG9ydEVudHJpZXNfNDMxLCBwcmFnbWFzXzQzMiwgYm9keV80MzMpIHtcbiAgICB0aGlzLm1vZHVsZVNwZWNpZmllciA9IG1vZHVsZVNwZWNpZmllcl80Mjg7XG4gICAgdGhpcy5pc05hdGl2ZSA9IGlzTmF0aXZlXzQyOTtcbiAgICB0aGlzLmltcG9ydEVudHJpZXMgPSBpbXBvcnRFbnRyaWVzXzQzMDtcbiAgICB0aGlzLmV4cG9ydEVudHJpZXMgPSBleHBvcnRFbnRyaWVzXzQzMTtcbiAgICB0aGlzLnByYWdtYXMgPSBwcmFnbWFzXzQzMjtcbiAgICB0aGlzLmJvZHkgPSBib2R5XzQzMztcbiAgfVxufVxuY29uc3QgZmluZEJpbmRpbmdJZGVudGlmaWVyTmFtZV80MjQgPSB0ZXJtXzQzNCA9PiB7XG4gIGFzc2VydCh0ZXJtXzQzNC5uYW1lLCBgbm90IGltcGxlbWVudGVkIHlldCBmb3IgdHlwZSAke3Rlcm1fNDM0LnR5cGV9YCk7XG4gIHJldHVybiB0ZXJtXzQzNC5uYW1lO1xufTtcbmNvbnN0IGNvbnZlcnRFeHBvcnRfNDI1ID0gdGVybV80MzUgPT4ge1xuICBsZXQgZGVjbGFyYXRpb25fNDM2ID0gdGVybV80MzUuZGVjbGFyYXRpb247XG4gIGxldCBiaW5kaW5nc180MzcgPSBbXTtcbiAgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbl80MzYpKSB7XG4gICAgYmluZGluZ3NfNDM3ID0gZGVjbGFyYXRpb25fNDM2LmRlY2xhcmF0b3JzLm1hcChkZWNsXzQzOSA9PiBmaW5kQmluZGluZ0lkZW50aWZpZXJOYW1lXzQyNChkZWNsXzQzOS5iaW5kaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uXzQzNikgfHwgaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uXzQzNikpIHtcbiAgICBiaW5kaW5nc180MzcucHVzaChmaW5kQmluZGluZ0lkZW50aWZpZXJOYW1lXzQyNChkZWNsYXJhdGlvbl80MzYubmFtZSkpO1xuICB9XG4gIGxldCBuYW1lZEV4cG9ydHNfNDM4ID0gYmluZGluZ3NfNDM3Lm1hcChiaW5kaW5nXzQ0MCA9PiB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0U3BlY2lmaWVyXCIsIHtuYW1lOiBudWxsLCBleHBvcnRlZE5hbWU6IGJpbmRpbmdfNDQwfSk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRGcm9tXCIsIHttb2R1bGVTcGVjaWZpZXI6IG51bGwsIG5hbWVkRXhwb3J0czogTGlzdChuYW1lZEV4cG9ydHNfNDM4KX0pO1xufTtcbmNvbnN0IHByYWdtYVJlZ2VwXzQyNiA9IC9eXFxzKiNcXHcqLztcbmNsYXNzIE1vZHVsZXNfNDI3IHtcbiAgY29uc3RydWN0b3IoY29udGV4dF80NDEpIHtcbiAgICB0aGlzLmNvbXBpbGVkTW9kdWxlcyA9IG5ldyBNYXA7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF80NDE7XG4gICAgdGhpcy5jb250ZXh0Lm1vZHVsZXMgPSB0aGlzO1xuICB9XG4gIGxvYWRTdHJpbmcoc3RyXzQ0MiwgY2hlY2tQcmFnbWFfNDQzID0gdHJ1ZSkge1xuICAgIGxldCBoYXNQcmFnbWFfNDQ0ID0gcHJhZ21hUmVnZXBfNDI2LnRlc3Qoc3RyXzQ0Mik7XG4gICAgaWYgKGNoZWNrUHJhZ21hXzQ0MyAmJiAhaGFzUHJhZ21hXzQ0NCkge1xuICAgICAgcmV0dXJuIHtpc05hdGl2ZTogdHJ1ZSwgYm9keTogTGlzdCgpfTtcbiAgICB9XG4gICAgcmV0dXJuIHtpc05hdGl2ZTogIWhhc1ByYWdtYV80NDQsIGJvZHk6IG5ldyBSZWFkZXIoc3RyXzQ0MikucmVhZCgpfTtcbiAgfVxuICBsb2FkKHBhdGhfNDQ1KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZFN0cmluZyh0aGlzLmNvbnRleHQubW9kdWxlTG9hZGVyKHBhdGhfNDQ1KSk7XG4gIH1cbiAgY29tcGlsZShtb2RfNDQ2LCBwYXRoXzQ0Nykge1xuICAgIGxldCBzdHhsXzQ0OCA9IG1vZF80NDYuYm9keTtcbiAgICBsZXQgb3V0U2NvcGVfNDQ5ID0gZnJlc2hTY29wZShcIm91dHNpZGVFZGdlXCIpO1xuICAgIGxldCBpblNjb3BlXzQ1MCA9IGZyZXNoU2NvcGUoYGluc2lkZUVkZ2UwYCk7XG4gICAgbGV0IGNvbXBpbGVyXzQ1MSA9IG5ldyBDb21waWxlcigwLCBuZXcgRW52LCBuZXcgU3RvcmUsIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7Y3VycmVudFNjb3BlOiBbb3V0U2NvcGVfNDQ5LCBpblNjb3BlXzQ1MF0sIGN3ZDogcGF0aF80NDcgPT09IFwiPDxlbnRyeXBvaW50Pj5cIiA/IHRoaXMuY29udGV4dC5jd2QgOiBkaXJuYW1lKHBhdGhfNDQ3KX0pKTtcbiAgICBsZXQgdGVybXNfNDUyID0gY29tcGlsZXJfNDUxLmNvbXBpbGUoc3R4bF80NDgubWFwKHNfNDU3ID0+IHNfNDU3LmFkZFNjb3BlKG91dFNjb3BlXzQ0OSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKS5hZGRTY29wZShpblNjb3BlXzQ1MCwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCAwKSkpO1xuICAgIGxldCBpbXBvcnRFbnRyaWVzXzQ1MyA9IFtdO1xuICAgIGxldCBleHBvcnRFbnRyaWVzXzQ1NCA9IFtdO1xuICAgIGxldCBwcmFnbWFzXzQ1NSA9IFtdO1xuICAgIGxldCBmaWx0ZXJlZFRlcm1zXzQ1NiA9IHRlcm1zXzQ1Mi5yZWR1Y2UoKGFjY180NTgsIHRfNDU5KSA9PiB7XG4gICAgICByZXR1cm4gXy5jb25kKFtbaXNJbXBvcnQsIHRfNDYwID0+IHtcbiAgICAgICAgaW1wb3J0RW50cmllc180NTMucHVzaCh0XzQ2MCk7XG4gICAgICAgIHJldHVybiBhY2NfNDU4O1xuICAgICAgfV0sIFtpc0V4cG9ydCwgdF80NjEgPT4ge1xuICAgICAgICBpZiAodF80NjEuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBleHBvcnRFbnRyaWVzXzQ1NC5wdXNoKGNvbnZlcnRFeHBvcnRfNDI1KHRfNDYxKSk7XG4gICAgICAgICAgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbih0XzQ2MS5kZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NfNDU4LmNvbmNhdChuZXcgVGVybShcIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnRcIiwge2RlY2xhcmF0aW9uOiB0XzQ2MS5kZWNsYXJhdGlvbn0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjY180NTguY29uY2F0KHRfNDYxLmRlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRFbnRyaWVzXzQ1NC5wdXNoKHRfNDYxKTtcbiAgICAgICAgcmV0dXJuIGFjY180NTg7XG4gICAgICB9XSwgW2lzUHJhZ21hLCB0XzQ2MiA9PiB7XG4gICAgICAgIHByYWdtYXNfNDU1LnB1c2godF80NjIpO1xuICAgICAgICByZXR1cm4gYWNjXzQ1ODtcbiAgICAgIH1dLCBbXy5ULCB0XzQ2MyA9PiBhY2NfNDU4LmNvbmNhdCh0XzQ2MyldXSkodF80NTkpO1xuICAgIH0sIExpc3QoKSk7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVfNDIzKHBhdGhfNDQ3LCBtb2RfNDQ2LmlzTmF0aXZlLCBMaXN0KGltcG9ydEVudHJpZXNfNDUzKSwgTGlzdChleHBvcnRFbnRyaWVzXzQ1NCksIExpc3QocHJhZ21hc180NTUpLCBmaWx0ZXJlZFRlcm1zXzQ1Nik7XG4gIH1cbiAgY29tcGlsZUVudHJ5cG9pbnQoc291cmNlXzQ2NCwgZmlsZW5hbWVfNDY1LCBlbmZvcmNlUHJhZ21hXzQ2NiA9IGZhbHNlKSB7XG4gICAgbGV0IHN0eGxfNDY3ID0gdGhpcy5sb2FkU3RyaW5nKHNvdXJjZV80NjQsIGZhbHNlKTtcbiAgICBpZiAoZW5mb3JjZVByYWdtYV80NjYgJiYgc3R4bF80NjcuaXNOYXRpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW50cnlwb2ludCAke2ZpbGVuYW1lXzQ2NX0gbXVzdCBiZWdpbiB3aXRoICNsYW5nIHByYWdtYWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBdFBoYXNlKFwiPDxlbnRyeXBvaW50Pj5cIiwgMCwgdGhpcy5jb250ZXh0LmN3ZCwgc3R4bF80NjcpO1xuICB9XG4gIGdldEF0UGhhc2UocmF3UGF0aF80NjgsIHBoYXNlXzQ2OSwgY3dkXzQ3MCwgcmF3U3R4bF80NzEgPSBudWxsKSB7XG4gICAgbGV0IHBhdGhfNDcyID0gcmF3UGF0aF80NjggPT09IFwiPDxlbnRyeXBvaW50Pj5cIiA/IHJhd1BhdGhfNDY4IDogdGhpcy5jb250ZXh0Lm1vZHVsZVJlc29sdmVyKHJhd1BhdGhfNDY4LCBjd2RfNDcwKTtcbiAgICBsZXQgbWFwS2V5XzQ3MyA9IGAke3BhdGhfNDcyfToke3BoYXNlXzQ2OX1gO1xuICAgIGlmICghdGhpcy5jb21waWxlZE1vZHVsZXMuaGFzKG1hcEtleV80NzMpKSB7XG4gICAgICBpZiAocGhhc2VfNDY5ID09PSAwKSB7XG4gICAgICAgIGxldCBzdHhsID0gcmF3U3R4bF80NzEgIT0gbnVsbCA/IHJhd1N0eGxfNDcxIDogdGhpcy5sb2FkKHBhdGhfNDcyKTtcbiAgICAgICAgdGhpcy5jb21waWxlZE1vZHVsZXMuc2V0KG1hcEtleV80NzMsIHRoaXMuY29tcGlsZShzdHhsLCBwYXRoXzQ3MikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJhd01vZCA9IHRoaXMuZ2V0QXRQaGFzZShyYXdQYXRoXzQ2OCwgMCwgY3dkXzQ3MCwgcmF3U3R4bF80NzEpO1xuICAgICAgICBsZXQgc2NvcGUgPSBmcmVzaFNjb3BlKGBpbnNpZGVFZGdlJHtwaGFzZV80Njl9YCk7XG4gICAgICAgIHRoaXMuY29tcGlsZWRNb2R1bGVzLnNldChtYXBLZXlfNDczLCBuZXcgTW9kdWxlXzQyMyhyYXdNb2QubW9kdWxlU3BlY2lmaWVyLCBmYWxzZSwgcmF3TW9kLmltcG9ydEVudHJpZXMubWFwKHRlcm1fNDc0ID0+IHRlcm1fNDc0LmFkZFNjb3BlKHNjb3BlLCB0aGlzLmNvbnRleHQuYmluZGluZ3MsIHBoYXNlXzQ2OSkpLCByYXdNb2QuZXhwb3J0RW50cmllcy5tYXAodGVybV80NzUgPT4gdGVybV80NzUuYWRkU2NvcGUoc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgcGhhc2VfNDY5KSksIHJhd01vZC5wcmFnbWFzLCByYXdNb2QuYm9keS5tYXAodGVybV80NzYgPT4gdGVybV80NzYuYWRkU2NvcGUoc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgcGhhc2VfNDY5KSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRNb2R1bGVzLmdldChtYXBLZXlfNDczKTtcbiAgfVxuICBoYXMocmF3UGF0aF80NzcsIHBoYXNlXzQ3OCA9IDApIHtcbiAgICBsZXQgcGF0aF80NzkgPSByYXdQYXRoXzQ3NyA9PT0gXCI8PGVudHJ5cG9pbnQ+PlwiID8gcmF3UGF0aF80NzcgOiB0aGlzLmNvbnRleHQubW9kdWxlUmVzb2x2ZXIocmF3UGF0aF80NzcsIHRoaXMuY29udGV4dC5jd2QpO1xuICAgIGxldCBrZXlfNDgwID0gYCR7cGF0aF80Nzl9OiR7cGhhc2VfNDc4fWA7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRNb2R1bGVzLmhhcyhrZXlfNDgwKSAmJiAhdGhpcy5jb21waWxlZE1vZHVsZXMuZ2V0KGtleV80ODApLmlzTmF0aXZlO1xuICB9XG4gIHJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24odGVybV80ODEsIHBoYXNlXzQ4Miwgc3RvcmVfNDgzKSB7XG4gICAgdGVybV80ODEuZGVjbGFyYXRvcnMuZm9yRWFjaChkZWNsXzQ4NCA9PiB7XG4gICAgICBsZXQgdmFsXzQ4NSA9IGV2YWxDb21waWxldGltZVZhbHVlKGRlY2xfNDg0LmluaXQuZ2VuKCksIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHBoYXNlXzQ4MiArIDEsIHN0b3JlOiBzdG9yZV80ODN9KSk7XG4gICAgICBjb2xsZWN0QmluZGluZ3MoZGVjbF80ODQuYmluZGluZykuZm9yRWFjaChzdHhfNDg2ID0+IHtcbiAgICAgICAgaWYgKHBoYXNlXzQ4MiAhPT0gMCkge1xuICAgICAgICAgIGxldCBuZXdCaW5kaW5nID0gZ2Vuc3ltKHN0eF80ODYudmFsKCkpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzQ4Niwge2JpbmRpbmc6IG5ld0JpbmRpbmcsIHBoYXNlOiBwaGFzZV80ODIsIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc29sdmVkTmFtZV80ODcgPSBzdHhfNDg2LnJlc29sdmUocGhhc2VfNDgyKTtcbiAgICAgICAgc3RvcmVfNDgzLnNldChyZXNvbHZlZE5hbWVfNDg3LCBuZXcgQ29tcGlsZXRpbWVUcmFuc2Zvcm0odmFsXzQ4NSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fNDg4LCBwaGFzZV80ODksIHN0b3JlXzQ5MCkge1xuICAgIHRlcm1fNDg4LmRlY2xhcmF0b3JzLmZvckVhY2goZGVjbF80OTEgPT4ge1xuICAgICAgY29sbGVjdEJpbmRpbmdzKGRlY2xfNDkxLmJpbmRpbmcpLmZvckVhY2goc3R4XzQ5MiA9PiB7XG4gICAgICAgIGlmIChwaGFzZV80ODkgIT09IDApIHtcbiAgICAgICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShzdHhfNDkyLnZhbCgpKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MuYWRkKHN0eF80OTIsIHtiaW5kaW5nOiBuZXdCaW5kaW5nLCBwaGFzZTogcGhhc2VfNDg5LCBza2lwRHVwOiB0ZXJtXzQ4OC5raW5kID09PSBcInZhclwifSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc29sdmVkTmFtZV80OTMgPSBzdHhfNDkyLnJlc29sdmUocGhhc2VfNDg5KTtcbiAgICAgICAgc3RvcmVfNDkwLnNldChyZXNvbHZlZE5hbWVfNDkzLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfNDkyKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uT3JDbGFzcyh0ZXJtXzQ5NCwgcGhhc2VfNDk1LCBzdG9yZV80OTYpIHtcbiAgICBjb2xsZWN0QmluZGluZ3ModGVybV80OTQubmFtZSkuZm9yRWFjaChzdHhfNDk3ID0+IHtcbiAgICAgIGlmIChwaGFzZV80OTUgIT09IDApIHtcbiAgICAgICAgbGV0IG5ld0JpbmRpbmcgPSBnZW5zeW0oc3R4XzQ5Ny52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzQ5Nywge2JpbmRpbmc6IG5ld0JpbmRpbmcsIHBoYXNlOiBwaGFzZV80OTUsIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzb2x2ZWROYW1lXzQ5OCA9IHN0eF80OTcucmVzb2x2ZShwaGFzZV80OTUpO1xuICAgICAgc3RvcmVfNDk2LnNldChyZXNvbHZlZE5hbWVfNDk4LCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfNDk3KSk7XG4gICAgfSk7XG4gIH1cbiAgdmlzaXQobW9kXzQ5OSwgcGhhc2VfNTAwLCBzdG9yZV81MDEpIHtcbiAgICBtb2RfNDk5LmJvZHkuZm9yRWFjaCh0ZXJtXzUwMiA9PiB7XG4gICAgICBpZiAoaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudCh0ZXJtXzUwMikpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclN5bnRheERlY2xhcmF0aW9uKHRlcm1fNTAyLmRlY2xhcmF0aW9uLCBwaGFzZV81MDAsIHN0b3JlXzUwMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0b3JlXzUwMTtcbiAgfVxuICBpbnZva2UobW9kXzUwMywgcGhhc2VfNTA0LCBzdG9yZV81MDUpIHtcbiAgICBsZXQgYm9keV81MDYgPSBtb2RfNTAzLmJvZHkuZmlsdGVyKF8uY29tcGxlbWVudChpc0NvbXBpbGV0aW1lU3RhdGVtZW50KSkubWFwKHRlcm1fNTA4ID0+IHtcbiAgICAgIHRlcm1fNTA4ID0gdGVybV81MDguZ2VuKCk7XG4gICAgICBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm1fNTA4KSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtXzUwOC5kZWNsYXJhdGlvbiwgcGhhc2VfNTA0LCBzdG9yZV81MDUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uRGVjbGFyYXRpb24odGVybV81MDgpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvbk9yQ2xhc3ModGVybV81MDgsIHBoYXNlXzUwNCwgc3RvcmVfNTA1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXJtXzUwODtcbiAgICB9KTtcbiAgICBsZXQgZXhwb3J0c09ial81MDcgPSBldmFsUnVudGltZVZhbHVlcyhib2R5XzUwNiwgXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtzdG9yZTogc3RvcmVfNTA1LCBwaGFzZTogcGhhc2VfNTA0fSkpO1xuICAgIHJldHVybiBzdG9yZV81MDU7XG4gIH1cbn1cbmV4cG9ydCB7TW9kdWxlXzQyMyBhcyBNb2R1bGV9O1xuZXhwb3J0IHtNb2R1bGVzXzQyNyBhcyBNb2R1bGVzfSJdfQ==

	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _vm = __webpack_require__(45);

		var _vm2 = _interopRequireDefault(_vm);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class Store {
		  constructor() {
		    this.map = new Map();
		    this.nodeContext = _vm2.default.createContext();
		  }
		  has(key_747) {
		    return this.map.has(key_747);
		  }
		  get(key_748) {
		    return this.map.get(key_748);
		  }
		  set(key_749, val_750) {
		    this.nodeContext[key_749] = val_750;
		    return this.map.set(key_749, val_750);
		  }
		  getNodeContext() {
		    return this.nodeContext;
		  }
		}
		exports.default = Store;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3N0b3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFDZSxNQUFNLEtBQU4sQ0FBWTtBQUN6QixnQkFBYztBQUNaLFNBQUssR0FBTCxHQUFXLElBQUksR0FBSixFQUFYO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLGFBQUcsYUFBSCxFQUFuQjtBQUNEO0FBQ0QsTUFBSSxPQUFKLEVBQWE7QUFDWCxXQUFPLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxPQUFiLENBQVA7QUFDRDtBQUNELE1BQUksT0FBSixFQUFhO0FBQ1gsV0FBTyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWEsT0FBYixDQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQUosRUFBYSxPQUFiLEVBQXNCO0FBQ3BCLFNBQUssV0FBTCxDQUFpQixPQUFqQixJQUE0QixPQUE1QjtBQUNBLFdBQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBUDtBQUNEO0FBQ0QsbUJBQWlCO0FBQ2YsV0FBTyxLQUFLLFdBQVo7QUFDRDtBQWpCd0I7a0JBQU4sSyIsImZpbGUiOiJzdG9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2bSBmcm9tIFwidm1cIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwO1xuICAgIHRoaXMubm9kZUNvbnRleHQgPSB2bS5jcmVhdGVDb250ZXh0KCk7XG4gIH1cbiAgaGFzKGtleV83NDcpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleV83NDcpO1xuICB9XG4gIGdldChrZXlfNzQ4KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXlfNzQ4KTtcbiAgfVxuICBzZXQoa2V5Xzc0OSwgdmFsXzc1MCkge1xuICAgIHRoaXMubm9kZUNvbnRleHRba2V5Xzc0OV0gPSB2YWxfNzUwO1xuICAgIHJldHVybiB0aGlzLm1hcC5zZXQoa2V5Xzc0OSwgdmFsXzc1MCk7XG4gIH1cbiAgZ2V0Tm9kZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNvbnRleHQ7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {

		var indexOf = __webpack_require__(46);

		var Object_keys = function (obj) {
		    if (Object.keys) return Object.keys(obj)
		    else {
		        var res = [];
		        for (var key in obj) res.push(key)
		        return res;
		    }
		};

		var forEach = function (xs, fn) {
		    if (xs.forEach) return xs.forEach(fn)
		    else for (var i = 0; i < xs.length; i++) {
		        fn(xs[i], i, xs);
		    }
		};

		var defineProp = (function() {
		    try {
		        Object.defineProperty({}, '_', {});
		        return function(obj, name, value) {
		            Object.defineProperty(obj, name, {
		                writable: true,
		                enumerable: false,
		                configurable: true,
		                value: value
		            })
		        };
		    } catch(e) {
		        return function(obj, name, value) {
		            obj[name] = value;
		        };
		    }
		}());

		var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
		'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
		'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
		'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
		'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

		function Context() {}
		Context.prototype = {};

		var Script = exports.Script = function NodeScript (code) {
		    if (!(this instanceof Script)) return new Script(code);
		    this.code = code;
		};

		Script.prototype.runInContext = function (context) {
		    if (!(context instanceof Context)) {
		        throw new TypeError("needs a 'context' argument.");
		    }
		    
		    var iframe = document.createElement('iframe');
		    if (!iframe.style) iframe.style = {};
		    iframe.style.display = 'none';
		    
		    document.body.appendChild(iframe);
		    
		    var win = iframe.contentWindow;
		    var wEval = win.eval, wExecScript = win.execScript;

		    if (!wEval && wExecScript) {
		        // win.eval() magically appears when this is called in IE:
		        wExecScript.call(win, 'null');
		        wEval = win.eval;
		    }
		    
		    forEach(Object_keys(context), function (key) {
		        win[key] = context[key];
		    });
		    forEach(globals, function (key) {
		        if (context[key]) {
		            win[key] = context[key];
		        }
		    });
		    
		    var winKeys = Object_keys(win);

		    var res = wEval.call(win, this.code);
		    
		    forEach(Object_keys(win), function (key) {
		        // Avoid copying circular objects like `top` and `window` by only
		        // updating existing context properties or new properties in the `win`
		        // that was only introduced after the eval.
		        if (key in context || indexOf(winKeys, key) === -1) {
		            context[key] = win[key];
		        }
		    });

		    forEach(globals, function (key) {
		        if (!(key in context)) {
		            defineProp(context, key, win[key]);
		        }
		    });
		    
		    document.body.removeChild(iframe);
		    
		    return res;
		};

		Script.prototype.runInThisContext = function () {
		    return eval(this.code); // maybe...
		};

		Script.prototype.runInNewContext = function (context) {
		    var ctx = Script.createContext(context);
		    var res = this.runInContext(ctx);

		    forEach(Object_keys(ctx), function (key) {
		        context[key] = ctx[key];
		    });

		    return res;
		};

		forEach(Object_keys(Script.prototype), function (name) {
		    exports[name] = Script[name] = function (code) {
		        var s = Script(code);
		        return s[name].apply(s, [].slice.call(arguments, 1));
		    };
		});

		exports.createScript = function (code) {
		    return exports.Script(code);
		};

		exports.createContext = Script.createContext = function (context) {
		    var copy = new Context();
		    if(typeof context === 'object') {
		        forEach(Object_keys(context), function (key) {
		            copy[key] = context[key];
		        });
		    }
		    return copy;
		};


	/***/ },
	/* 46 */
	/***/ function(module, exports) {

		
		var indexOf = [].indexOf;

		module.exports = function(arr, obj){
		  if (indexOf) return arr.indexOf(obj);
		  for (var i = 0; i < arr.length; ++i) {
		    if (arr[i] === obj) return i;
		  }
		  return -1;
		};

	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _immutable = __webpack_require__(9);

		var _enforester = __webpack_require__(48);

		var _termExpander = __webpack_require__(51);

		var _termExpander2 = _interopRequireDefault(_termExpander);

		var _bindingMap = __webpack_require__(12);

		var _bindingMap2 = _interopRequireDefault(_bindingMap);

		var _env = __webpack_require__(28);

		var _env2 = _interopRequireDefault(_env);

		var _shiftReader = __webpack_require__(1);

		var _shiftReader2 = _interopRequireDefault(_shiftReader);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _symbol = __webpack_require__(42);

		var _transforms = __webpack_require__(29);

		var _errors = __webpack_require__(11);

		var _loadSyntax = __webpack_require__(50);

		var _scope = __webpack_require__(41);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _astDispatcher = __webpack_require__(61);

		var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

		var _hygieneUtils = __webpack_require__(64);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function bindImports_1206(impTerm_1209, exModule_1210, context_1211) {
		  let names_1212 = [];
		  let phase_1213 = impTerm_1209.forSyntax ? context_1211.phase + 1 : context_1211.phase;
		  impTerm_1209.namedImports.forEach(specifier_1214 => {
		    let name_1215 = specifier_1214.binding.name;
		    let exportName_1216 = findNameInExports_1207(name_1215, exModule_1210.exportEntries);
		    if (exportName_1216 != null) {
		      let newBinding = (0, _symbol.gensym)(name_1215.val());
		      context_1211.store.set(newBinding.toString(), new _transforms.VarBindingTransform(name_1215));
		      context_1211.bindings.addForward(name_1215, exportName_1216, newBinding, phase_1213);
		      names_1212.push(name_1215);
		    }
		  });
		  return (0, _immutable.List)(names_1212);
		}
		function findNameInExports_1207(name_1217, exp_1218) {
		  let foundNames_1219 = exp_1218.reduce((acc_1220, e_1221) => {
		    if ((0, _terms.isExportFrom)(e_1221)) {
		      return acc_1220.concat(e_1221.namedExports.reduce((acc_1222, specifier_1223) => {
		        if (specifier_1223.exportedName.val() === name_1217.val()) {
		          return acc_1222.concat(specifier_1223.exportedName);
		        }
		        return acc_1222;
		      }, (0, _immutable.List)()));
		    } else if ((0, _terms.isExport)(e_1221)) {
		      return acc_1220.concat(e_1221.declaration.declarators.reduce((acc_1224, decl_1225) => {
		        if (decl_1225.binding.name.val() === name_1217.val()) {
		          return acc_1224.concat(decl_1225.binding.name);
		        }
		        return acc_1224;
		      }, (0, _immutable.List)()));
		    }
		    return acc_1220;
		  }, (0, _immutable.List)());
		  (0, _errors.assert)(foundNames_1219.size <= 1, "expecting no more than 1 matching name in exports");
		  return foundNames_1219.get(0);
		}
		function removeNames_1208(impTerm_1226, names_1227) {
		  let namedImports_1228 = impTerm_1226.namedImports.filter(specifier_1229 => !names_1227.contains(specifier_1229.binding.name));
		  return impTerm_1226.extend({ namedImports: namedImports_1228 });
		}
		class TokenExpander extends _astDispatcher2.default {
		  constructor(context_1230) {
		    super("expand", false);
		    this.context = context_1230;
		  }
		  expand(stxl_1231) {
		    let result_1232 = [];
		    if (stxl_1231.size === 0) {
		      return (0, _immutable.List)(result_1232);
		    }
		    let prev_1233 = (0, _immutable.List)();
		    let enf_1234 = new _enforester.Enforester(stxl_1231, prev_1233, this.context);
		    while (!enf_1234.done) {
		      result_1232.push(this.dispatch(enf_1234.enforest()));
		    }
		    return (0, _immutable.List)(result_1232);
		  }
		  expandVariableDeclarationStatement(term_1235) {
		    return term_1235.extend({ declaration: this.registerVariableDeclaration(term_1235.declaration) });
		  }
		  expandFunctionDeclaration(term_1236) {
		    let registeredTerm_1237 = this.registerFunctionOrClass(term_1236);
		    let stx_1238 = registeredTerm_1237.name.name;
		    this.context.env.set(stx_1238.resolve(this.context.phase), new _transforms.VarBindingTransform(stx_1238));
		    return registeredTerm_1237;
		  }
		  expandImport(term_1239) {
		    let path_1240 = term_1239.moduleSpecifier.val();
		    let mod_1241;
		    if (term_1239.forSyntax) {
		      mod_1241 = this.context.modules.getAtPhase(path_1240, this.context.phase + 1, this.context.cwd);
		      this.context.store = this.context.modules.visit(mod_1241, this.context.phase + 1, this.context.store);
		      this.context.store = this.context.modules.invoke(mod_1241, this.context.phase + 1, this.context.store);
		    } else {
		      mod_1241 = this.context.modules.getAtPhase(path_1240, this.context.phase, this.context.cwd);
		      this.context.store = this.context.modules.visit(mod_1241, this.context.phase, this.context.store);
		    }
		    let boundNames_1242 = bindImports_1206(term_1239, mod_1241, this.context);
		    return removeNames_1208(term_1239, boundNames_1242);
		  }
		  expandExport(term_1243) {
		    if ((0, _terms.isFunctionDeclaration)(term_1243.declaration) || (0, _terms.isClassDeclaration)(term_1243.declaration)) {
		      return term_1243.extend({ declaration: this.registerFunctionOrClass(term_1243.declaration) });
		    } else if ((0, _terms.isVariableDeclaration)(term_1243.declaration)) {
		      return term_1243.extend({ declaration: this.registerVariableDeclaration(term_1243.declaration) });
		    }
		    return term_1243;
		  }
		  registerFunctionOrClass(term_1244) {
		    let name_1245 = term_1244.name.removeScope(this.context.useScope, this.context.phase);
		    (0, _hygieneUtils.collectBindings)(term_1244.name).forEach(stx_1246 => {
		      let newBinding_1247 = (0, _symbol.gensym)(stx_1246.val());
		      this.context.bindings.add(stx_1246, { binding: newBinding_1247, phase: this.context.phase, skipDup: false });
		      this.context.env.set(newBinding_1247.toString(), new _transforms.VarBindingTransform(stx_1246));
		    });
		    return term_1244.extend({ name: name_1245 });
		  }
		  registerVariableDeclaration(term_1248) {
		    if ((0, _terms.isSyntaxDeclaration)(term_1248) || (0, _terms.isSyntaxrecDeclaration)(term_1248)) {
		      return this.registerSyntaxDeclaration(term_1248);
		    }
		    return term_1248.extend({ declarators: term_1248.declarators.map(decl_1249 => {
		        let binding_1250 = decl_1249.binding.removeScope(this.context.useScope, this.context.phase);
		        (0, _hygieneUtils.collectBindings)(binding_1250).forEach(stx_1251 => {
		          let newBinding_1252 = (0, _symbol.gensym)(stx_1251.val());
		          this.context.bindings.add(stx_1251, { binding: newBinding_1252, phase: this.context.phase, skipDup: term_1248.kind === "var" });
		          this.context.env.set(newBinding_1252.toString(), new _transforms.VarBindingTransform(stx_1251));
		        });
		        return decl_1249.extend({ binding: binding_1250 });
		      }) });
		  }
		  registerSyntaxDeclaration(term_1253) {
		    if ((0, _terms.isSyntaxDeclaration)(term_1253)) {
		      let scope = (0, _scope.freshScope)("nonrec");
		      term_1253 = term_1253.extend({ declarators: term_1253.declarators.map(decl_1254 => {
		          let name_1255 = decl_1254.binding.name;
		          let nameAdded_1256 = name_1255.addScope(scope, this.context.bindings, _syntax.ALL_PHASES);
		          let nameRemoved_1257 = name_1255.removeScope(this.context.currentScope[this.context.currentScope.length - 1], this.context.phase);
		          let newBinding_1258 = (0, _symbol.gensym)(name_1255.val());
		          this.context.bindings.addForward(nameAdded_1256, nameRemoved_1257, newBinding_1258, this.context.phase);
		          return decl_1254.extend({ init: decl_1254.init.addScope(scope, this.context.bindings, _syntax.ALL_PHASES) });
		        }) });
		    }
		    return term_1253.extend({ declarators: term_1253.declarators.map(decl_1259 => {
		        let binding_1260 = decl_1259.binding.removeScope(this.context.useScope, this.context.phase);
		        let syntaxExpander_1261 = new _termExpander2.default(_.merge(this.context, { phase: this.context.phase + 1, env: new _env2.default(), store: this.context.store }));
		        let init_1262 = syntaxExpander_1261.expand(decl_1259.init);
		        let val_1263 = (0, _loadSyntax.evalCompiletimeValue)(init_1262.gen(), _.merge(this.context, { phase: this.context.phase + 1 }));
		        (0, _hygieneUtils.collectBindings)(binding_1260).forEach(stx_1264 => {
		          let newBinding_1265 = (0, _symbol.gensym)(stx_1264.val());
		          this.context.bindings.add(stx_1264, { binding: newBinding_1265, phase: this.context.phase, skipDup: false });
		          let resolvedName_1266 = stx_1264.resolve(this.context.phase);
		          this.context.env.set(resolvedName_1266, new _transforms.CompiletimeTransform(val_1263));
		        });
		        return decl_1259.extend({ binding: binding_1260, init: init_1262 });
		      }) });
		  }
		}
		exports.default = TokenExpander;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Rva2VuLWV4cGFuZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0lBQWEsQzs7Ozs7O0FBQ2IsU0FBUyxnQkFBVCxDQUEwQixZQUExQixFQUF3QyxhQUF4QyxFQUF1RCxZQUF2RCxFQUFxRTtBQUNuRSxNQUFJLGFBQWEsRUFBakI7QUFDQSxNQUFJLGFBQWEsYUFBYSxTQUFiLEdBQXlCLGFBQWEsS0FBYixHQUFxQixDQUE5QyxHQUFrRCxhQUFhLEtBQWhGO0FBQ0EsZUFBYSxZQUFiLENBQTBCLE9BQTFCLENBQWtDLGtCQUFrQjtBQUNsRCxRQUFJLFlBQVksZUFBZSxPQUFmLENBQXVCLElBQXZDO0FBQ0EsUUFBSSxrQkFBa0IsdUJBQXVCLFNBQXZCLEVBQWtDLGNBQWMsYUFBaEQsQ0FBdEI7QUFDQSxRQUFJLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQixVQUFJLGFBQWEsb0JBQU8sVUFBVSxHQUFWLEVBQVAsQ0FBakI7QUFDQSxtQkFBYSxLQUFiLENBQW1CLEdBQW5CLENBQXVCLFdBQVcsUUFBWCxFQUF2QixFQUE4QyxvQ0FBd0IsU0FBeEIsQ0FBOUM7QUFDQSxtQkFBYSxRQUFiLENBQXNCLFVBQXRCLENBQWlDLFNBQWpDLEVBQTRDLGVBQTVDLEVBQTZELFVBQTdELEVBQXlFLFVBQXpFO0FBQ0EsaUJBQVcsSUFBWCxDQUFnQixTQUFoQjtBQUNEO0FBQ0YsR0FURDtBQVVBLFNBQU8scUJBQUssVUFBTCxDQUFQO0FBQ0Q7QUFDRCxTQUFTLHNCQUFULENBQWdDLFNBQWhDLEVBQTJDLFFBQTNDLEVBQXFEO0FBQ25ELE1BQUksa0JBQWtCLFNBQVMsTUFBVCxDQUFnQixDQUFDLFFBQUQsRUFBVyxNQUFYLEtBQXNCO0FBQzFELFFBQUks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QUFJLGtCQUFrQixvQkFBTyxTQUFTLEdBQVQsRUFBUCxDQUF0QjtBQUNBLGVBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsR0FBdEIsQ0FBMEIsUUFBMUIsRUFBb0MsRUFBQyxTQUFTLGVBQVYsRUFBMkIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUEvQyxFQUFzRCxTQUFTLEtBQS9ELEVBQXBDO0FBQ0EsY0FBSSxvQkFBb0IsU0FBUyxPQUFULENBQWlCLEtBQUssT0FBTCxDQUFhLEtBQTlCLENBQXhCO0FBQ0EsZUFBSyxPQUFMLENBQWEsR0FBYixDQUFpQixHQUFqQixDQUFxQixpQkFBckIsRUFBd0MscUNBQXlCLFFBQXpCLENBQXhDO0FBQ0QsU0FMRDtBQU1BLGVBQU8sVUFBVSxNQUFWLENBQWlCLEVBQUMsU0FBUyxZQUFWLEVBQXdCLE1BQU0sU0FBOUIsRUFBakIsQ0FBUDtBQUNELE9BWnFDLENBQWQsRUFBakIsQ0FBUDtBQWFEO0FBaEdzRDtrQkFBcEMsYSIsImZpbGUiOiJ0b2tlbi1leHBhbmRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IHtlbmZvcmVzdEV4cHIsIEVuZm9yZXN0ZXJ9IGZyb20gXCIuL2VuZm9yZXN0ZXJcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSBcIi4vYmluZGluZy1tYXAuanNcIjtcbmltcG9ydCBFbnYgZnJvbSBcIi4vZW52XCI7XG5pbXBvcnQgUmVhZGVyIGZyb20gXCIuL3NoaWZ0LXJlYWRlclwiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSwgaXNCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyLCBpc09iamVjdEJpbmRpbmcsIGlzQXJyYXlCaW5kaW5nLCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24sIGlzRnVuY3Rpb25FeHByZXNzaW9uLCBpc0Z1bmN0aW9uVGVybSwgaXNGdW5jdGlvbldpdGhOYW1lLCBpc1N5bnRheERlY2xhcmF0aW9uLCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCwgaXNJbXBvcnQsIGlzRXhwb3J0LCBpc0V4cG9ydEZyb20sIGlzUHJhZ21hLCBpc0V4cG9ydFN5bnRheCwgaXNDbGFzc0RlY2xhcmF0aW9ufSBmcm9tIFwiLi90ZXJtc1wiO1xuaW1wb3J0IHtnZW5zeW19IGZyb20gXCIuL3N5bWJvbFwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQge2V2YWxDb21waWxldGltZVZhbHVlfSBmcm9tIFwiLi9sb2FkLXN5bnRheFwiO1xuaW1wb3J0IHtTY29wZSwgZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCBBU1REaXNwYXRjaGVyIGZyb20gXCIuL2FzdC1kaXNwYXRjaGVyXCI7XG5pbXBvcnQge2NvbGxlY3RCaW5kaW5nc30gZnJvbSBcIi4vaHlnaWVuZS11dGlsc1wiO1xuaW1wb3J0ICAqIGFzIF8gZnJvbSBcInJhbWRhXCI7XG5mdW5jdGlvbiBiaW5kSW1wb3J0c18xMjA2KGltcFRlcm1fMTIwOSwgZXhNb2R1bGVfMTIxMCwgY29udGV4dF8xMjExKSB7XG4gIGxldCBuYW1lc18xMjEyID0gW107XG4gIGxldCBwaGFzZV8xMjEzID0gaW1wVGVybV8xMjA5LmZvclN5bnRheCA/IGNvbnRleHRfMTIxMS5waGFzZSArIDEgOiBjb250ZXh0XzEyMTEucGhhc2U7XG4gIGltcFRlcm1fMTIwOS5uYW1lZEltcG9ydHMuZm9yRWFjaChzcGVjaWZpZXJfMTIxNCA9PiB7XG4gICAgbGV0IG5hbWVfMTIxNSA9IHNwZWNpZmllcl8xMjE0LmJpbmRpbmcubmFtZTtcbiAgICBsZXQgZXhwb3J0TmFtZV8xMjE2ID0gZmluZE5hbWVJbkV4cG9ydHNfMTIwNyhuYW1lXzEyMTUsIGV4TW9kdWxlXzEyMTAuZXhwb3J0RW50cmllcyk7XG4gICAgaWYgKGV4cG9ydE5hbWVfMTIxNiAhPSBudWxsKSB7XG4gICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuYW1lXzEyMTUudmFsKCkpO1xuICAgICAgY29udGV4dF8xMjExLnN0b3JlLnNldChuZXdCaW5kaW5nLnRvU3RyaW5nKCksIG5ldyBWYXJCaW5kaW5nVHJhbnNmb3JtKG5hbWVfMTIxNSkpO1xuICAgICAgY29udGV4dF8xMjExLmJpbmRpbmdzLmFkZEZvcndhcmQobmFtZV8xMjE1LCBleHBvcnROYW1lXzEyMTYsIG5ld0JpbmRpbmcsIHBoYXNlXzEyMTMpO1xuICAgICAgbmFtZXNfMTIxMi5wdXNoKG5hbWVfMTIxNSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIExpc3QobmFtZXNfMTIxMik7XG59XG5mdW5jdGlvbiBmaW5kTmFtZUluRXhwb3J0c18xMjA3KG5hbWVfMTIxNywgZXhwXzEyMTgpIHtcbiAgbGV0IGZvdW5kTmFtZXNfMTIxOSA9IGV4cF8xMjE4LnJlZHVjZSgoYWNjXzEyMjAsIGVfMTIyMSkgPT4ge1xuICAgIGlmIChpc0V4cG9ydEZyb20oZV8xMjIxKSkge1xuICAgICAgcmV0dXJuIGFjY18xMjIwLmNvbmNhdChlXzEyMjEubmFtZWRFeHBvcnRzLnJlZHVjZSgoYWNjXzEyMjIsIHNwZWNpZmllcl8xMjIzKSA9PiB7XG4gICAgICAgIGlmIChzcGVjaWZpZXJfMTIyMy5leHBvcnRlZE5hbWUudmFsKCkgPT09IG5hbWVfMTIxNy52YWwoKSkge1xuICAgICAgICAgIHJldHVybiBhY2NfMTIyMi5jb25jYXQoc3BlY2lmaWVyXzEyMjMuZXhwb3J0ZWROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjXzEyMjI7XG4gICAgICB9LCBMaXN0KCkpKTtcbiAgICB9IGVsc2UgaWYgKGlzRXhwb3J0KGVfMTIyMSkpIHtcbiAgICAgIHJldHVybiBhY2NfMTIyMC5jb25jYXQoZV8xMjIxLmRlY2xhcmF0aW9uLmRlY2xhcmF0b3JzLnJlZHVjZSgoYWNjXzEyMjQsIGRlY2xfMTIyNSkgPT4ge1xuICAgICAgICBpZiAoZGVjbF8xMjI1LmJpbmRpbmcubmFtZS52YWwoKSA9PT0gbmFtZV8xMjE3LnZhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY18xMjI0LmNvbmNhdChkZWNsXzEyMjUuYmluZGluZy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjXzEyMjQ7XG4gICAgICB9LCBMaXN0KCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY18xMjIwO1xuICB9LCBMaXN0KCkpO1xuICBhc3NlcnQoZm91bmROYW1lc18xMjE5LnNpemUgPD0gMSwgXCJleHBlY3Rpbmcgbm8gbW9yZSB0aGFuIDEgbWF0Y2hpbmcgbmFtZSBpbiBleHBvcnRzXCIpO1xuICByZXR1cm4gZm91bmROYW1lc18xMjE5LmdldCgwKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5hbWVzXzEyMDgoaW1wVGVybV8xMjI2LCBuYW1lc18xMjI3KSB7XG4gIGxldCBuYW1lZEltcG9ydHNfMTIyOCA9IGltcFRlcm1fMTIyNi5uYW1lZEltcG9ydHMuZmlsdGVyKHNwZWNpZmllcl8xMjI5ID0+ICFuYW1lc18xMjI3LmNvbnRhaW5zKHNwZWNpZmllcl8xMjI5LmJpbmRpbmcubmFtZSkpO1xuICByZXR1cm4gaW1wVGVybV8xMjI2LmV4dGVuZCh7bmFtZWRJbXBvcnRzOiBuYW1lZEltcG9ydHNfMTIyOH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9rZW5FeHBhbmRlciBleHRlbmRzIEFTVERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0XzEyMzApIHtcbiAgICBzdXBlcihcImV4cGFuZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF8xMjMwO1xuICB9XG4gIGV4cGFuZChzdHhsXzEyMzEpIHtcbiAgICBsZXQgcmVzdWx0XzEyMzIgPSBbXTtcbiAgICBpZiAoc3R4bF8xMjMxLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBMaXN0KHJlc3VsdF8xMjMyKTtcbiAgICB9XG4gICAgbGV0IHByZXZfMTIzMyA9IExpc3QoKTtcbiAgICBsZXQgZW5mXzEyMzQgPSBuZXcgRW5mb3Jlc3RlcihzdHhsXzEyMzEsIHByZXZfMTIzMywgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoIWVuZl8xMjM0LmRvbmUpIHtcbiAgICAgIHJlc3VsdF8xMjMyLnB1c2godGhpcy5kaXNwYXRjaChlbmZfMTIzNC5lbmZvcmVzdCgpKSk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF8xMjMyKTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm1fMTIzNSkge1xuICAgIHJldHVybiB0ZXJtXzEyMzUuZXh0ZW5kKHtkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjM1LmRlY2xhcmF0aW9uKX0pO1xuICB9XG4gIGV4cGFuZEZ1bmN0aW9uRGVjbGFyYXRpb24odGVybV8xMjM2KSB7XG4gICAgbGV0IHJlZ2lzdGVyZWRUZXJtXzEyMzcgPSB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzKHRlcm1fMTIzNik7XG4gICAgbGV0IHN0eF8xMjM4ID0gcmVnaXN0ZXJlZFRlcm1fMTIzNy5uYW1lLm5hbWU7XG4gICAgdGhpcy5jb250ZXh0LmVudi5zZXQoc3R4XzEyMzgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfMTIzOCkpO1xuICAgIHJldHVybiByZWdpc3RlcmVkVGVybV8xMjM3O1xuICB9XG4gIGV4cGFuZEltcG9ydCh0ZXJtXzEyMzkpIHtcbiAgICBsZXQgcGF0aF8xMjQwID0gdGVybV8xMjM5Lm1vZHVsZVNwZWNpZmllci52YWwoKTtcbiAgICBsZXQgbW9kXzEyNDE7XG4gICAgaWYgKHRlcm1fMTIzOS5mb3JTeW50YXgpIHtcbiAgICAgIG1vZF8xMjQxID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMuZ2V0QXRQaGFzZShwYXRoXzEyNDAsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5jd2QpO1xuICAgICAgdGhpcy5jb250ZXh0LnN0b3JlID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMudmlzaXQobW9kXzEyNDEsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB0aGlzLmNvbnRleHQubW9kdWxlcy5pbnZva2UobW9kXzEyNDEsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZF8xMjQxID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMuZ2V0QXRQaGFzZShwYXRoXzEyNDAsIHRoaXMuY29udGV4dC5waGFzZSwgdGhpcy5jb250ZXh0LmN3ZCk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB0aGlzLmNvbnRleHQubW9kdWxlcy52aXNpdChtb2RfMTI0MSwgdGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuc3RvcmUpO1xuICAgIH1cbiAgICBsZXQgYm91bmROYW1lc18xMjQyID0gYmluZEltcG9ydHNfMTIwNih0ZXJtXzEyMzksIG1vZF8xMjQxLCB0aGlzLmNvbnRleHQpO1xuICAgIHJldHVybiByZW1vdmVOYW1lc18xMjA4KHRlcm1fMTIzOSwgYm91bmROYW1lc18xMjQyKTtcbiAgfVxuICBleHBhbmRFeHBvcnQodGVybV8xMjQzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb25EZWNsYXJhdGlvbih0ZXJtXzEyNDMuZGVjbGFyYXRpb24pIHx8IGlzQ2xhc3NEZWNsYXJhdGlvbih0ZXJtXzEyNDMuZGVjbGFyYXRpb24pKSB7XG4gICAgICByZXR1cm4gdGVybV8xMjQzLmV4dGVuZCh7ZGVjbGFyYXRpb246IHRoaXMucmVnaXN0ZXJGdW5jdGlvbk9yQ2xhc3ModGVybV8xMjQzLmRlY2xhcmF0aW9uKX0pO1xuICAgIH0gZWxzZSBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMTI0My5kZWNsYXJhdGlvbikpIHtcbiAgICAgIHJldHVybiB0ZXJtXzEyNDMuZXh0ZW5kKHtkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjQzLmRlY2xhcmF0aW9uKX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVybV8xMjQzO1xuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzKHRlcm1fMTI0NCkge1xuICAgIGxldCBuYW1lXzEyNDUgPSB0ZXJtXzEyNDQubmFtZS5yZW1vdmVTY29wZSh0aGlzLmNvbnRleHQudXNlU2NvcGUsIHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgY29sbGVjdEJpbmRpbmdzKHRlcm1fMTI0NC5uYW1lKS5mb3JFYWNoKHN0eF8xMjQ2ID0+IHtcbiAgICAgIGxldCBuZXdCaW5kaW5nXzEyNDcgPSBnZW5zeW0oc3R4XzEyNDYudmFsKCkpO1xuICAgICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChzdHhfMTI0Niwge2JpbmRpbmc6IG5ld0JpbmRpbmdfMTI0NywgcGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSwgc2tpcER1cDogZmFsc2V9KTtcbiAgICAgIHRoaXMuY29udGV4dC5lbnYuc2V0KG5ld0JpbmRpbmdfMTI0Ny50b1N0cmluZygpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHhfMTI0NikpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXJtXzEyNDQuZXh0ZW5kKHtuYW1lOiBuYW1lXzEyNDV9KTtcbiAgfVxuICByZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24odGVybV8xMjQ4KSB7XG4gICAgaWYgKGlzU3ludGF4RGVjbGFyYXRpb24odGVybV8xMjQ4KSB8fCBpc1N5bnRheHJlY0RlY2xhcmF0aW9uKHRlcm1fMTI0OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24odGVybV8xMjQ4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm1fMTI0OC5leHRlbmQoe2RlY2xhcmF0b3JzOiB0ZXJtXzEyNDguZGVjbGFyYXRvcnMubWFwKGRlY2xfMTI0OSA9PiB7XG4gICAgICBsZXQgYmluZGluZ18xMjUwID0gZGVjbF8xMjQ5LmJpbmRpbmcucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LnVzZVNjb3BlLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgY29sbGVjdEJpbmRpbmdzKGJpbmRpbmdfMTI1MCkuZm9yRWFjaChzdHhfMTI1MSA9PiB7XG4gICAgICAgIGxldCBuZXdCaW5kaW5nXzEyNTIgPSBnZW5zeW0oc3R4XzEyNTEudmFsKCkpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MuYWRkKHN0eF8xMjUxLCB7YmluZGluZzogbmV3QmluZGluZ18xMjUyLCBwaGFzZTogdGhpcy5jb250ZXh0LnBoYXNlLCBza2lwRHVwOiB0ZXJtXzEyNDgua2luZCA9PT0gXCJ2YXJcIn0pO1xuICAgICAgICB0aGlzLmNvbnRleHQuZW52LnNldChuZXdCaW5kaW5nXzEyNTIudG9TdHJpbmcoKSwgbmV3IFZhckJpbmRpbmdUcmFuc2Zvcm0oc3R4XzEyNTEpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlY2xfMTI0OS5leHRlbmQoe2JpbmRpbmc6IGJpbmRpbmdfMTI1MH0pO1xuICAgIH0pfSk7XG4gIH1cbiAgcmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbih0ZXJtXzEyNTMpIHtcbiAgICBpZiAoaXNTeW50YXhEZWNsYXJhdGlvbih0ZXJtXzEyNTMpKSB7XG4gICAgICBsZXQgc2NvcGUgPSBmcmVzaFNjb3BlKFwibm9ucmVjXCIpO1xuICAgICAgdGVybV8xMjUzID0gdGVybV8xMjUzLmV4dGVuZCh7ZGVjbGFyYXRvcnM6IHRlcm1fMTI1My5kZWNsYXJhdG9ycy5tYXAoZGVjbF8xMjU0ID0+IHtcbiAgICAgICAgbGV0IG5hbWVfMTI1NSA9IGRlY2xfMTI1NC5iaW5kaW5nLm5hbWU7XG4gICAgICAgIGxldCBuYW1lQWRkZWRfMTI1NiA9IG5hbWVfMTI1NS5hZGRTY29wZShzY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKTtcbiAgICAgICAgbGV0IG5hbWVSZW1vdmVkXzEyNTcgPSBuYW1lXzEyNTUucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZVt0aGlzLmNvbnRleHQuY3VycmVudFNjb3BlLmxlbmd0aCAtIDFdLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgICBsZXQgbmV3QmluZGluZ18xMjU4ID0gZ2Vuc3ltKG5hbWVfMTI1NS52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGRGb3J3YXJkKG5hbWVBZGRlZF8xMjU2LCBuYW1lUmVtb3ZlZF8xMjU3LCBuZXdCaW5kaW5nXzEyNTgsIHRoaXMuY29udGV4dC5waGFzZSk7XG4gICAgICAgIHJldHVybiBkZWNsXzEyNTQuZXh0ZW5kKHtpbml0OiBkZWNsXzEyNTQuaW5pdC5hZGRTY29wZShzY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKX0pO1xuICAgICAgfSl9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm1fMTI1My5leHRlbmQoe2RlY2xhcmF0b3JzOiB0ZXJtXzEyNTMuZGVjbGFyYXRvcnMubWFwKGRlY2xfMTI1OSA9PiB7XG4gICAgICBsZXQgYmluZGluZ18xMjYwID0gZGVjbF8xMjU5LmJpbmRpbmcucmVtb3ZlU2NvcGUodGhpcy5jb250ZXh0LnVzZVNjb3BlLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgbGV0IHN5bnRheEV4cGFuZGVyXzEyNjEgPSBuZXcgVGVybUV4cGFuZGVyKF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSArIDEsIGVudjogbmV3IEVudiwgc3RvcmU6IHRoaXMuY29udGV4dC5zdG9yZX0pKTtcbiAgICAgIGxldCBpbml0XzEyNjIgPSBzeW50YXhFeHBhbmRlcl8xMjYxLmV4cGFuZChkZWNsXzEyNTkuaW5pdCk7XG4gICAgICBsZXQgdmFsXzEyNjMgPSBldmFsQ29tcGlsZXRpbWVWYWx1ZShpbml0XzEyNjIuZ2VuKCksIF8ubWVyZ2UodGhpcy5jb250ZXh0LCB7cGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSArIDF9KSk7XG4gICAgICBjb2xsZWN0QmluZGluZ3MoYmluZGluZ18xMjYwKS5mb3JFYWNoKHN0eF8xMjY0ID0+IHtcbiAgICAgICAgbGV0IG5ld0JpbmRpbmdfMTI2NSA9IGdlbnN5bShzdHhfMTI2NC52YWwoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4XzEyNjQsIHtiaW5kaW5nOiBuZXdCaW5kaW5nXzEyNjUsIHBoYXNlOiB0aGlzLmNvbnRleHQucGhhc2UsIHNraXBEdXA6IGZhbHNlfSk7XG4gICAgICAgIGxldCByZXNvbHZlZE5hbWVfMTI2NiA9IHN0eF8xMjY0LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVudi5zZXQocmVzb2x2ZWROYW1lXzEyNjYsIG5ldyBDb21waWxldGltZVRyYW5zZm9ybSh2YWxfMTI2MykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVjbF8xMjU5LmV4dGVuZCh7YmluZGluZzogYmluZGluZ18xMjYwLCBpbml0OiBpbml0XzEyNjJ9KTtcbiAgICB9KX0pO1xuICB9XG59XG4iXX0=

	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Enforester = undefined;

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _transforms = __webpack_require__(29);

		var _immutable = __webpack_require__(9);

		var _errors = __webpack_require__(11);

		var _operators = __webpack_require__(49);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _scope = __webpack_require__(41);

		var _loadSyntax = __webpack_require__(50);

		var _macroContext = __webpack_require__(62);

		var _macroContext2 = _interopRequireDefault(_macroContext);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const EXPR_LOOP_OPERATOR_41 = {};
		const EXPR_LOOP_NO_CHANGE_42 = {};
		const EXPR_LOOP_EXPANSION_43 = {};
		class Enforester_44 {
		  constructor(stxl_45, prev_46, context_47) {
		    this.done = false;
		    (0, _errors.assert)(_immutable.List.isList(stxl_45), "expecting a list of terms to enforest");
		    (0, _errors.assert)(_immutable.List.isList(prev_46), "expecting a list of terms to enforest");
		    (0, _errors.assert)(context_47, "expecting a context to enforest");
		    this.term = null;
		    this.rest = stxl_45;
		    this.prev = prev_46;
		    this.context = context_47;
		  }
		  peek() {
		    let n_48 = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

		    return this.rest.get(n_48);
		  }
		  advance() {
		    let ret_49 = this.rest.first();
		    this.rest = this.rest.rest();
		    return ret_49;
		  }
		  enforest() {
		    let type_50 = arguments.length <= 0 || arguments[0] === undefined ? "Module" : arguments[0];

		    this.term = null;
		    if (this.rest.size === 0) {
		      this.done = true;
		      return this.term;
		    }
		    if (this.isEOF(this.peek())) {
		      this.term = new _terms2.default("EOF", {});
		      this.advance();
		      return this.term;
		    }
		    let result_51;
		    if (type_50 === "expression") {
		      result_51 = this.enforestExpressionLoop();
		    } else {
		      result_51 = this.enforestModule();
		    }
		    if (this.rest.size === 0) {
		      this.done = true;
		    }
		    return result_51;
		  }
		  enforestModule() {
		    return this.enforestBody();
		  }
		  enforestBody() {
		    return this.enforestModuleItem();
		  }
		  enforestModuleItem() {
		    let lookahead_52 = this.peek();
		    if (this.isKeyword(lookahead_52, "import")) {
		      this.advance();
		      return this.enforestImportDeclaration();
		    } else if (this.isKeyword(lookahead_52, "export")) {
		      this.advance();
		      return this.enforestExportDeclaration();
		    } else if (this.isIdentifier(lookahead_52, "#")) {
		      return this.enforestLanguagePragma();
		    }
		    return this.enforestStatement();
		  }
		  enforestLanguagePragma() {
		    this.matchIdentifier("#");
		    this.matchIdentifier("lang");
		    let path_53 = this.matchStringLiteral();
		    this.consumeSemicolon();
		    return new _terms2.default("Pragma", { kind: "lang", items: _immutable.List.of(path_53) });
		  }
		  enforestExportDeclaration() {
		    let lookahead_54 = this.peek();
		    if (this.isPunctuator(lookahead_54, "*")) {
		      this.advance();
		      let moduleSpecifier = this.enforestFromClause();
		      return new _terms2.default("ExportAllFrom", { moduleSpecifier: moduleSpecifier });
		    } else if (this.isBraces(lookahead_54)) {
		      let namedExports = this.enforestExportClause();
		      let moduleSpecifier = null;
		      if (this.isIdentifier(this.peek(), "from")) {
		        moduleSpecifier = this.enforestFromClause();
		      }
		      return new _terms2.default("ExportFrom", { namedExports: namedExports, moduleSpecifier: moduleSpecifier });
		    } else if (this.isKeyword(lookahead_54, "class")) {
		      return new _terms2.default("Export", { declaration: this.enforestClass({ isExpr: false }) });
		    } else if (this.isFnDeclTransform(lookahead_54)) {
		      return new _terms2.default("Export", { declaration: this.enforestFunction({ isExpr: false, inDefault: false }) });
		    } else if (this.isKeyword(lookahead_54, "default")) {
		      this.advance();
		      if (this.isFnDeclTransform(this.peek())) {
		        return new _terms2.default("ExportDefault", { body: this.enforestFunction({ isExpr: false, inDefault: true }) });
		      } else if (this.isKeyword(this.peek(), "class")) {
		        return new _terms2.default("ExportDefault", { body: this.enforestClass({ isExpr: false, inDefault: true }) });
		      } else {
		        let body = this.enforestExpressionLoop();
		        this.consumeSemicolon();
		        return new _terms2.default("ExportDefault", { body: body });
		      }
		    } else if (this.isVarDeclTransform(lookahead_54) || this.isLetDeclTransform(lookahead_54) || this.isConstDeclTransform(lookahead_54) || this.isSyntaxrecDeclTransform(lookahead_54) || this.isSyntaxDeclTransform(lookahead_54)) {
		      return new _terms2.default("Export", { declaration: this.enforestVariableDeclaration() });
		    }
		    throw this.createError(lookahead_54, "unexpected syntax");
		  }
		  enforestExportClause() {
		    let enf_55 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
		    let result_56 = [];
		    while (enf_55.rest.size !== 0) {
		      result_56.push(enf_55.enforestExportSpecifier());
		      enf_55.consumeComma();
		    }
		    return (0, _immutable.List)(result_56);
		  }
		  enforestExportSpecifier() {
		    let name_57 = this.enforestIdentifier();
		    if (this.isIdentifier(this.peek(), "as")) {
		      this.advance();
		      let exportedName = this.enforestIdentifier();
		      return new _terms2.default("ExportSpecifier", { name: name_57, exportedName: exportedName });
		    }
		    return new _terms2.default("ExportSpecifier", { name: null, exportedName: name_57 });
		  }
		  enforestImportDeclaration() {
		    let lookahead_58 = this.peek();
		    let defaultBinding_59 = null;
		    let namedImports_60 = (0, _immutable.List)();
		    let forSyntax_61 = false;
		    if (this.isStringLiteral(lookahead_58)) {
		      let moduleSpecifier = this.advance();
		      this.consumeSemicolon();
		      return new _terms2.default("Import", { defaultBinding: defaultBinding_59, namedImports: namedImports_60, moduleSpecifier: moduleSpecifier });
		    }
		    if (this.isIdentifier(lookahead_58) || this.isKeyword(lookahead_58)) {
		      defaultBinding_59 = this.enforestBindingIdentifier();
		      if (!this.isPunctuator(this.peek(), ",")) {
		        let moduleSpecifier = this.enforestFromClause();
		        if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
		          this.advance();
		          this.advance();
		          forSyntax_61 = true;
		        }
		        return new _terms2.default("Import", { defaultBinding: defaultBinding_59, moduleSpecifier: moduleSpecifier, namedImports: (0, _immutable.List)(), forSyntax: forSyntax_61 });
		      }
		    }
		    this.consumeComma();
		    lookahead_58 = this.peek();
		    if (this.isBraces(lookahead_58)) {
		      let imports = this.enforestNamedImports();
		      let fromClause = this.enforestFromClause();
		      if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
		        this.advance();
		        this.advance();
		        forSyntax_61 = true;
		      }
		      return new _terms2.default("Import", { defaultBinding: defaultBinding_59, forSyntax: forSyntax_61, namedImports: imports, moduleSpecifier: fromClause });
		    } else if (this.isPunctuator(lookahead_58, "*")) {
		      let namespaceBinding = this.enforestNamespaceBinding();
		      let moduleSpecifier = this.enforestFromClause();
		      if (this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax")) {
		        this.advance();
		        this.advance();
		        forSyntax_61 = true;
		      }
		      return new _terms2.default("ImportNamespace", { defaultBinding: defaultBinding_59, forSyntax: forSyntax_61, namespaceBinding: namespaceBinding, moduleSpecifier: moduleSpecifier });
		    }
		    throw this.createError(lookahead_58, "unexpected syntax");
		  }
		  enforestNamespaceBinding() {
		    this.matchPunctuator("*");
		    this.matchIdentifier("as");
		    return this.enforestBindingIdentifier();
		  }
		  enforestNamedImports() {
		    let enf_62 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
		    let result_63 = [];
		    while (enf_62.rest.size !== 0) {
		      result_63.push(enf_62.enforestImportSpecifiers());
		      enf_62.consumeComma();
		    }
		    return (0, _immutable.List)(result_63);
		  }
		  enforestImportSpecifiers() {
		    let lookahead_64 = this.peek();
		    let name_65;
		    if (this.isIdentifier(lookahead_64) || this.isKeyword(lookahead_64)) {
		      name_65 = this.advance();
		      if (!this.isIdentifier(this.peek(), "as")) {
		        return new _terms2.default("ImportSpecifier", { name: null, binding: new _terms2.default("BindingIdentifier", { name: name_65 }) });
		      } else {
		        this.matchIdentifier("as");
		      }
		    } else {
		      throw this.createError(lookahead_64, "unexpected token in import specifier");
		    }
		    return new _terms2.default("ImportSpecifier", { name: name_65, binding: this.enforestBindingIdentifier() });
		  }
		  enforestFromClause() {
		    this.matchIdentifier("from");
		    let lookahead_66 = this.matchStringLiteral();
		    this.consumeSemicolon();
		    return lookahead_66;
		  }
		  enforestStatementListItem() {
		    let lookahead_67 = this.peek();
		    if (this.isFnDeclTransform(lookahead_67)) {
		      return this.enforestFunctionDeclaration({ isExpr: false });
		    } else if (this.isKeyword(lookahead_67, "class")) {
		      return this.enforestClass({ isExpr: false });
		    } else {
		      return this.enforestStatement();
		    }
		  }
		  enforestStatement() {
		    let lookahead_68 = this.peek();
		    if (this.term === null && this.isCompiletimeTransform(lookahead_68)) {
		      this.rest = this.expandMacro().concat(this.rest);
		      lookahead_68 = this.peek();
		      this.term = null;
		    }
		    if (this.term === null && this.isBraces(lookahead_68)) {
		      return this.enforestBlockStatement();
		    }
		    if (this.term === null && this.isWhileTransform(lookahead_68)) {
		      return this.enforestWhileStatement();
		    }
		    if (this.term === null && this.isIfTransform(lookahead_68)) {
		      return this.enforestIfStatement();
		    }
		    if (this.term === null && this.isForTransform(lookahead_68)) {
		      return this.enforestForStatement();
		    }
		    if (this.term === null && this.isSwitchTransform(lookahead_68)) {
		      return this.enforestSwitchStatement();
		    }
		    if (this.term === null && this.isBreakTransform(lookahead_68)) {
		      return this.enforestBreakStatement();
		    }
		    if (this.term === null && this.isContinueTransform(lookahead_68)) {
		      return this.enforestContinueStatement();
		    }
		    if (this.term === null && this.isDoTransform(lookahead_68)) {
		      return this.enforestDoStatement();
		    }
		    if (this.term === null && this.isDebuggerTransform(lookahead_68)) {
		      return this.enforestDebuggerStatement();
		    }
		    if (this.term === null && this.isWithTransform(lookahead_68)) {
		      return this.enforestWithStatement();
		    }
		    if (this.term === null && this.isTryTransform(lookahead_68)) {
		      return this.enforestTryStatement();
		    }
		    if (this.term === null && this.isThrowTransform(lookahead_68)) {
		      return this.enforestThrowStatement();
		    }
		    if (this.term === null && this.isKeyword(lookahead_68, "class")) {
		      return this.enforestClass({ isExpr: false });
		    }
		    if (this.term === null && this.isFnDeclTransform(lookahead_68)) {
		      return this.enforestFunctionDeclaration();
		    }
		    if (this.term === null && this.isIdentifier(lookahead_68) && this.isPunctuator(this.peek(1), ":")) {
		      return this.enforestLabeledStatement();
		    }
		    if (this.term === null && (this.isVarDeclTransform(lookahead_68) || this.isLetDeclTransform(lookahead_68) || this.isConstDeclTransform(lookahead_68) || this.isSyntaxrecDeclTransform(lookahead_68) || this.isSyntaxDeclTransform(lookahead_68))) {
		      let stmt = new _terms2.default("VariableDeclarationStatement", { declaration: this.enforestVariableDeclaration() });
		      this.consumeSemicolon();
		      return stmt;
		    }
		    if (this.term === null && this.isReturnStmtTransform(lookahead_68)) {
		      return this.enforestReturnStatement();
		    }
		    if (this.term === null && this.isPunctuator(lookahead_68, ";")) {
		      this.advance();
		      return new _terms2.default("EmptyStatement", {});
		    }
		    return this.enforestExpressionStatement();
		  }
		  enforestLabeledStatement() {
		    let label_69 = this.matchIdentifier();
		    let punc_70 = this.matchPunctuator(":");
		    let stmt_71 = this.enforestStatement();
		    return new _terms2.default("LabeledStatement", { label: label_69, body: stmt_71 });
		  }
		  enforestBreakStatement() {
		    this.matchKeyword("break");
		    let lookahead_72 = this.peek();
		    let label_73 = null;
		    if (this.rest.size === 0 || this.isPunctuator(lookahead_72, ";")) {
		      this.consumeSemicolon();
		      return new _terms2.default("BreakStatement", { label: label_73 });
		    }
		    if (this.isIdentifier(lookahead_72) || this.isKeyword(lookahead_72, "yield") || this.isKeyword(lookahead_72, "let")) {
		      label_73 = this.enforestIdentifier();
		    }
		    this.consumeSemicolon();
		    return new _terms2.default("BreakStatement", { label: label_73 });
		  }
		  enforestTryStatement() {
		    this.matchKeyword("try");
		    let body_74 = this.enforestBlock();
		    if (this.isKeyword(this.peek(), "catch")) {
		      let catchClause = this.enforestCatchClause();
		      if (this.isKeyword(this.peek(), "finally")) {
		        this.advance();
		        let finalizer = this.enforestBlock();
		        return new _terms2.default("TryFinallyStatement", { body: body_74, catchClause: catchClause, finalizer: finalizer });
		      }
		      return new _terms2.default("TryCatchStatement", { body: body_74, catchClause: catchClause });
		    }
		    if (this.isKeyword(this.peek(), "finally")) {
		      this.advance();
		      let finalizer = this.enforestBlock();
		      return new _terms2.default("TryFinallyStatement", { body: body_74, catchClause: null, finalizer: finalizer });
		    }
		    throw this.createError(this.peek(), "try with no catch or finally");
		  }
		  enforestCatchClause() {
		    this.matchKeyword("catch");
		    let bindingParens_75 = this.matchParens();
		    let enf_76 = new Enforester_44(bindingParens_75, (0, _immutable.List)(), this.context);
		    let binding_77 = enf_76.enforestBindingTarget();
		    let body_78 = this.enforestBlock();
		    return new _terms2.default("CatchClause", { binding: binding_77, body: body_78 });
		  }
		  enforestThrowStatement() {
		    this.matchKeyword("throw");
		    let expression_79 = this.enforestExpression();
		    this.consumeSemicolon();
		    return new _terms2.default("ThrowStatement", { expression: expression_79 });
		  }
		  enforestWithStatement() {
		    this.matchKeyword("with");
		    let objParens_80 = this.matchParens();
		    let enf_81 = new Enforester_44(objParens_80, (0, _immutable.List)(), this.context);
		    let object_82 = enf_81.enforestExpression();
		    let body_83 = this.enforestStatement();
		    return new _terms2.default("WithStatement", { object: object_82, body: body_83 });
		  }
		  enforestDebuggerStatement() {
		    this.matchKeyword("debugger");
		    return new _terms2.default("DebuggerStatement", {});
		  }
		  enforestDoStatement() {
		    this.matchKeyword("do");
		    let body_84 = this.enforestStatement();
		    this.matchKeyword("while");
		    let testBody_85 = this.matchParens();
		    let enf_86 = new Enforester_44(testBody_85, (0, _immutable.List)(), this.context);
		    let test_87 = enf_86.enforestExpression();
		    this.consumeSemicolon();
		    return new _terms2.default("DoWhileStatement", { body: body_84, test: test_87 });
		  }
		  enforestContinueStatement() {
		    let kwd_88 = this.matchKeyword("continue");
		    let lookahead_89 = this.peek();
		    let label_90 = null;
		    if (this.rest.size === 0 || this.isPunctuator(lookahead_89, ";")) {
		      this.consumeSemicolon();
		      return new _terms2.default("ContinueStatement", { label: label_90 });
		    }
		    if (this.lineNumberEq(kwd_88, lookahead_89) && (this.isIdentifier(lookahead_89) || this.isKeyword(lookahead_89, "yield") || this.isKeyword(lookahead_89, "let"))) {
		      label_90 = this.enforestIdentifier();
		    }
		    this.consumeSemicolon();
		    return new _terms2.default("ContinueStatement", { label: label_90 });
		  }
		  enforestSwitchStatement() {
		    this.matchKeyword("switch");
		    let cond_91 = this.matchParens();
		    let enf_92 = new Enforester_44(cond_91, (0, _immutable.List)(), this.context);
		    let discriminant_93 = enf_92.enforestExpression();
		    let body_94 = this.matchCurlies();
		    if (body_94.size === 0) {
		      return new _terms2.default("SwitchStatement", { discriminant: discriminant_93, cases: (0, _immutable.List)() });
		    }
		    enf_92 = new Enforester_44(body_94, (0, _immutable.List)(), this.context);
		    let cases_95 = enf_92.enforestSwitchCases();
		    let lookahead_96 = enf_92.peek();
		    if (enf_92.isKeyword(lookahead_96, "default")) {
		      let defaultCase = enf_92.enforestSwitchDefault();
		      let postDefaultCases = enf_92.enforestSwitchCases();
		      return new _terms2.default("SwitchStatementWithDefault", { discriminant: discriminant_93, preDefaultCases: cases_95, defaultCase: defaultCase, postDefaultCases: postDefaultCases });
		    }
		    return new _terms2.default("SwitchStatement", { discriminant: discriminant_93, cases: cases_95 });
		  }
		  enforestSwitchCases() {
		    let cases_97 = [];
		    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), "default"))) {
		      cases_97.push(this.enforestSwitchCase());
		    }
		    return (0, _immutable.List)(cases_97);
		  }
		  enforestSwitchCase() {
		    this.matchKeyword("case");
		    return new _terms2.default("SwitchCase", { test: this.enforestExpression(), consequent: this.enforestSwitchCaseBody() });
		  }
		  enforestSwitchCaseBody() {
		    this.matchPunctuator(":");
		    return this.enforestStatementListInSwitchCaseBody();
		  }
		  enforestStatementListInSwitchCaseBody() {
		    let result_98 = [];
		    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), "default") || this.isKeyword(this.peek(), "case"))) {
		      result_98.push(this.enforestStatementListItem());
		    }
		    return (0, _immutable.List)(result_98);
		  }
		  enforestSwitchDefault() {
		    this.matchKeyword("default");
		    return new _terms2.default("SwitchDefault", { consequent: this.enforestSwitchCaseBody() });
		  }
		  enforestForStatement() {
		    this.matchKeyword("for");
		    let cond_99 = this.matchParens();
		    let enf_100 = new Enforester_44(cond_99, (0, _immutable.List)(), this.context);
		    let lookahead_101, test_102, init_103, right_104, type_105, left_106, update_107;
		    if (enf_100.isPunctuator(enf_100.peek(), ";")) {
		      enf_100.advance();
		      if (!enf_100.isPunctuator(enf_100.peek(), ";")) {
		        test_102 = enf_100.enforestExpression();
		      }
		      enf_100.matchPunctuator(";");
		      if (enf_100.rest.size !== 0) {
		        right_104 = enf_100.enforestExpression();
		      }
		      return new _terms2.default("ForStatement", { init: null, test: test_102, update: right_104, body: this.enforestStatement() });
		    } else {
		      lookahead_101 = enf_100.peek();
		      if (enf_100.isVarDeclTransform(lookahead_101) || enf_100.isLetDeclTransform(lookahead_101) || enf_100.isConstDeclTransform(lookahead_101)) {
		        init_103 = enf_100.enforestVariableDeclaration();
		        lookahead_101 = enf_100.peek();
		        if (this.isKeyword(lookahead_101, "in") || this.isIdentifier(lookahead_101, "of")) {
		          if (this.isKeyword(lookahead_101, "in")) {
		            enf_100.advance();
		            right_104 = enf_100.enforestExpression();
		            type_105 = "ForInStatement";
		          } else if (this.isIdentifier(lookahead_101, "of")) {
		            enf_100.advance();
		            right_104 = enf_100.enforestExpression();
		            type_105 = "ForOfStatement";
		          }
		          return new _terms2.default(type_105, { left: init_103, right: right_104, body: this.enforestStatement() });
		        }
		        enf_100.matchPunctuator(";");
		        if (enf_100.isPunctuator(enf_100.peek(), ";")) {
		          enf_100.advance();
		          test_102 = null;
		        } else {
		          test_102 = enf_100.enforestExpression();
		          enf_100.matchPunctuator(";");
		        }
		        update_107 = enf_100.enforestExpression();
		      } else {
		        if (this.isKeyword(enf_100.peek(1), "in") || this.isIdentifier(enf_100.peek(1), "of")) {
		          left_106 = enf_100.enforestBindingIdentifier();
		          let kind = enf_100.advance();
		          if (this.isKeyword(kind, "in")) {
		            type_105 = "ForInStatement";
		          } else {
		            type_105 = "ForOfStatement";
		          }
		          right_104 = enf_100.enforestExpression();
		          return new _terms2.default(type_105, { left: left_106, right: right_104, body: this.enforestStatement() });
		        }
		        init_103 = enf_100.enforestExpression();
		        enf_100.matchPunctuator(";");
		        if (enf_100.isPunctuator(enf_100.peek(), ";")) {
		          enf_100.advance();
		          test_102 = null;
		        } else {
		          test_102 = enf_100.enforestExpression();
		          enf_100.matchPunctuator(";");
		        }
		        update_107 = enf_100.enforestExpression();
		      }
		      return new _terms2.default("ForStatement", { init: init_103, test: test_102, update: update_107, body: this.enforestStatement() });
		    }
		  }
		  enforestIfStatement() {
		    this.matchKeyword("if");
		    let cond_108 = this.matchParens();
		    let enf_109 = new Enforester_44(cond_108, (0, _immutable.List)(), this.context);
		    let lookahead_110 = enf_109.peek();
		    let test_111 = enf_109.enforestExpression();
		    if (test_111 === null) {
		      throw enf_109.createError(lookahead_110, "expecting an expression");
		    }
		    let consequent_112 = this.enforestStatement();
		    let alternate_113 = null;
		    if (this.isKeyword(this.peek(), "else")) {
		      this.advance();
		      alternate_113 = this.enforestStatement();
		    }
		    return new _terms2.default("IfStatement", { test: test_111, consequent: consequent_112, alternate: alternate_113 });
		  }
		  enforestWhileStatement() {
		    this.matchKeyword("while");
		    let cond_114 = this.matchParens();
		    let enf_115 = new Enforester_44(cond_114, (0, _immutable.List)(), this.context);
		    let lookahead_116 = enf_115.peek();
		    let test_117 = enf_115.enforestExpression();
		    if (test_117 === null) {
		      throw enf_115.createError(lookahead_116, "expecting an expression");
		    }
		    let body_118 = this.enforestStatement();
		    return new _terms2.default("WhileStatement", { test: test_117, body: body_118 });
		  }
		  enforestBlockStatement() {
		    return new _terms2.default("BlockStatement", { block: this.enforestBlock() });
		  }
		  enforestBlock() {
		    let b_119 = this.matchCurlies();
		    let body_120 = [];
		    let enf_121 = new Enforester_44(b_119, (0, _immutable.List)(), this.context);
		    while (enf_121.rest.size !== 0) {
		      let lookahead = enf_121.peek();
		      let stmt = enf_121.enforestStatement();
		      if (stmt == null) {
		        throw enf_121.createError(lookahead, "not a statement");
		      }
		      body_120.push(stmt);
		    }
		    return new _terms2.default("Block", { statements: (0, _immutable.List)(body_120) });
		  }
		  enforestClass(_ref) {
		    let isExpr = _ref.isExpr;
		    let inDefault = _ref.inDefault;

		    let kw_122 = this.advance();
		    let name_123 = null,
		        supr_124 = null;
		    let type_125 = isExpr ? "ClassExpression" : "ClassDeclaration";
		    if (this.isIdentifier(this.peek())) {
		      name_123 = this.enforestBindingIdentifier();
		    } else if (!isExpr) {
		      if (inDefault) {
		        name_123 = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("_default", kw_122) });
		      } else {
		        throw this.createError(this.peek(), "unexpected syntax");
		      }
		    }
		    if (this.isKeyword(this.peek(), "extends")) {
		      this.advance();
		      supr_124 = this.enforestExpressionLoop();
		    }
		    let elements_126 = [];
		    let enf_127 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
		    while (enf_127.rest.size !== 0) {
		      if (enf_127.isPunctuator(enf_127.peek(), ";")) {
		        enf_127.advance();
		        continue;
		      }
		      let isStatic = false;

		      var _enf_127$enforestMeth = enf_127.enforestMethodDefinition();

		      let methodOrKey = _enf_127$enforestMeth.methodOrKey;
		      let kind = _enf_127$enforestMeth.kind;

		      if (kind === "identifier" && methodOrKey.value.val() === "static") {
		        isStatic = true;

		        var _enf_127$enforestMeth2 = enf_127.enforestMethodDefinition();

		        methodOrKey = _enf_127$enforestMeth2.methodOrKey;
		        kind = _enf_127$enforestMeth2.kind;
		      }
		      if (kind === "method") {
		        elements_126.push(new _terms2.default("ClassElement", { isStatic: isStatic, method: methodOrKey }));
		      } else {
		        throw this.createError(enf_127.peek(), "Only methods are allowed in classes");
		      }
		    }
		    return new _terms2.default(type_125, { name: name_123, super: supr_124, elements: (0, _immutable.List)(elements_126) });
		  }
		  enforestBindingTarget() {
		    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		    let allowPunctuator = _ref2.allowPunctuator;

		    let lookahead_128 = this.peek();
		    if (this.isIdentifier(lookahead_128) || this.isKeyword(lookahead_128) || allowPunctuator && this.isPunctuator(lookahead_128)) {
		      return this.enforestBindingIdentifier({ allowPunctuator: allowPunctuator });
		    } else if (this.isBrackets(lookahead_128)) {
		      return this.enforestArrayBinding();
		    } else if (this.isBraces(lookahead_128)) {
		      return this.enforestObjectBinding();
		    }
		    (0, _errors.assert)(false, "not implemented yet");
		  }
		  enforestObjectBinding() {
		    let enf_129 = new Enforester_44(this.matchCurlies(), (0, _immutable.List)(), this.context);
		    let properties_130 = [];
		    while (enf_129.rest.size !== 0) {
		      properties_130.push(enf_129.enforestBindingProperty());
		      enf_129.consumeComma();
		    }
		    return new _terms2.default("ObjectBinding", { properties: (0, _immutable.List)(properties_130) });
		  }
		  enforestBindingProperty() {
		    let lookahead_131 = this.peek();

		    var _enforestPropertyName = this.enforestPropertyName();

		    let name = _enforestPropertyName.name;
		    let binding = _enforestPropertyName.binding;

		    if (this.isIdentifier(lookahead_131) || this.isKeyword(lookahead_131, "let") || this.isKeyword(lookahead_131, "yield")) {
		      if (!this.isPunctuator(this.peek(), ":")) {
		        let defaultValue = null;
		        if (this.isAssign(this.peek())) {
		          this.advance();
		          let expr = this.enforestExpressionLoop();
		          defaultValue = expr;
		        }
		        return new _terms2.default("BindingPropertyIdentifier", { binding: binding, init: defaultValue });
		      }
		    }
		    this.matchPunctuator(":");
		    binding = this.enforestBindingElement();
		    return new _terms2.default("BindingPropertyProperty", { name: name, binding: binding });
		  }
		  enforestArrayBinding() {
		    let bracket_132 = this.matchSquares();
		    let enf_133 = new Enforester_44(bracket_132, (0, _immutable.List)(), this.context);
		    let elements_134 = [],
		        restElement_135 = null;
		    while (enf_133.rest.size !== 0) {
		      let el;
		      if (enf_133.isPunctuator(enf_133.peek(), ",")) {
		        enf_133.consumeComma();
		        el = null;
		      } else {
		        if (enf_133.isPunctuator(enf_133.peek(), "...")) {
		          enf_133.advance();
		          restElement_135 = enf_133.enforestBindingTarget();
		          break;
		        } else {
		          el = enf_133.enforestBindingElement();
		        }
		        enf_133.consumeComma();
		      }
		      elements_134.push(el);
		    }
		    return new _terms2.default("ArrayBinding", { elements: (0, _immutable.List)(elements_134), restElement: restElement_135 });
		  }
		  enforestBindingElement() {
		    let binding_136 = this.enforestBindingTarget();
		    if (this.isAssign(this.peek())) {
		      this.advance();
		      let init = this.enforestExpressionLoop();
		      binding_136 = new _terms2.default("BindingWithDefault", { binding: binding_136, init: init });
		    }
		    return binding_136;
		  }
		  enforestBindingIdentifier() {
		    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		    let allowPunctuator = _ref3.allowPunctuator;

		    let name_137;
		    if (allowPunctuator && this.isPunctuator(this.peek())) {
		      name_137 = this.enforestPunctuator();
		    } else {
		      name_137 = this.enforestIdentifier();
		    }
		    return new _terms2.default("BindingIdentifier", { name: name_137 });
		  }
		  enforestPunctuator() {
		    let lookahead_138 = this.peek();
		    if (this.isPunctuator(lookahead_138)) {
		      return this.advance();
		    }
		    throw this.createError(lookahead_138, "expecting a punctuator");
		  }
		  enforestIdentifier() {
		    let lookahead_139 = this.peek();
		    if (this.isIdentifier(lookahead_139) || this.isKeyword(lookahead_139)) {
		      return this.advance();
		    }
		    throw this.createError(lookahead_139, "expecting an identifier");
		  }
		  enforestReturnStatement() {
		    let kw_140 = this.advance();
		    let lookahead_141 = this.peek();
		    if (this.rest.size === 0 || lookahead_141 && !this.lineNumberEq(kw_140, lookahead_141)) {
		      return new _terms2.default("ReturnStatement", { expression: null });
		    }
		    let term_142 = null;
		    if (!this.isPunctuator(lookahead_141, ";")) {
		      term_142 = this.enforestExpression();
		      (0, _errors.expect)(term_142 != null, "Expecting an expression to follow return keyword", lookahead_141, this.rest);
		    }
		    this.consumeSemicolon();
		    return new _terms2.default("ReturnStatement", { expression: term_142 });
		  }
		  enforestVariableDeclaration() {
		    let kind_143;
		    let lookahead_144 = this.advance();
		    let kindSyn_145 = lookahead_144;
		    let phase_146 = this.context.phase;
		    if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.VariableDeclTransform) {
		      kind_143 = "var";
		    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.LetDeclTransform) {
		      kind_143 = "let";
		    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.ConstDeclTransform) {
		      kind_143 = "const";
		    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.SyntaxDeclTransform) {
		      kind_143 = "syntax";
		    } else if (kindSyn_145 && this.context.env.get(kindSyn_145.resolve(phase_146)) === _transforms.SyntaxrecDeclTransform) {
		      kind_143 = "syntaxrec";
		    }
		    let decls_147 = (0, _immutable.List)();
		    while (true) {
		      let term = this.enforestVariableDeclarator({ isSyntax: kind_143 === "syntax" || kind_143 === "syntaxrec" });
		      let lookahead_144 = this.peek();
		      decls_147 = decls_147.concat(term);
		      if (this.isPunctuator(lookahead_144, ",")) {
		        this.advance();
		      } else {
		        break;
		      }
		    }
		    return new _terms2.default("VariableDeclaration", { kind: kind_143, declarators: decls_147 });
		  }
		  enforestVariableDeclarator(_ref4) {
		    let isSyntax = _ref4.isSyntax;

		    let id_148 = this.enforestBindingTarget({ allowPunctuator: isSyntax });
		    let lookahead_149 = this.peek();
		    let init_150, rest_151;
		    if (this.isPunctuator(lookahead_149, "=")) {
		      this.advance();
		      let enf = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
		      init_150 = enf.enforest("expression");
		      this.rest = enf.rest;
		    } else {
		      init_150 = null;
		    }
		    return new _terms2.default("VariableDeclarator", { binding: id_148, init: init_150 });
		  }
		  enforestExpressionStatement() {
		    let start_152 = this.rest.get(0);
		    let expr_153 = this.enforestExpression();
		    if (expr_153 === null) {
		      throw this.createError(start_152, "not a valid expression");
		    }
		    this.consumeSemicolon();
		    return new _terms2.default("ExpressionStatement", { expression: expr_153 });
		  }
		  enforestExpression() {
		    let left_154 = this.enforestExpressionLoop();
		    let lookahead_155 = this.peek();
		    if (this.isPunctuator(lookahead_155, ",")) {
		      while (this.rest.size !== 0) {
		        if (!this.isPunctuator(this.peek(), ",")) {
		          break;
		        }
		        let operator = this.advance();
		        let right = this.enforestExpressionLoop();
		        left_154 = new _terms2.default("BinaryExpression", { left: left_154, operator: operator, right: right });
		      }
		    }
		    this.term = null;
		    return left_154;
		  }
		  enforestExpressionLoop() {
		    this.term = null;
		    this.opCtx = { prec: 0, combine: x_156 => x_156, stack: (0, _immutable.List)() };
		    do {
		      let term = this.enforestAssignmentExpression();
		      if (term === EXPR_LOOP_NO_CHANGE_42 && this.opCtx.stack.size > 0) {
		        this.term = this.opCtx.combine(this.term);

		        var _opCtx$stack$last = this.opCtx.stack.last();

		        let prec = _opCtx$stack$last.prec;
		        let combine = _opCtx$stack$last.combine;

		        this.opCtx.prec = prec;
		        this.opCtx.combine = combine;
		        this.opCtx.stack = this.opCtx.stack.pop();
		      } else if (term === EXPR_LOOP_NO_CHANGE_42) {
		        break;
		      } else if (term === EXPR_LOOP_OPERATOR_41 || term === EXPR_LOOP_EXPANSION_43) {
		        this.term = null;
		      } else {
		        this.term = term;
		      }
		    } while (true);
		    return this.term;
		  }
		  enforestAssignmentExpression() {
		    let lookahead_157 = this.peek();
		    if (this.term === null && this.isTerm(lookahead_157)) {
		      return this.advance();
		    }
		    if (this.term === null && this.isCompiletimeTransform(lookahead_157)) {
		      let result = this.expandMacro();
		      this.rest = result.concat(this.rest);
		      return EXPR_LOOP_EXPANSION_43;
		    }
		    if (this.term === null && this.isKeyword(lookahead_157, "yield")) {
		      return this.enforestYieldExpression();
		    }
		    if (this.term === null && this.isKeyword(lookahead_157, "class")) {
		      return this.enforestClass({ isExpr: true });
		    }
		    if (this.term === null && this.isKeyword(lookahead_157, "super")) {
		      this.advance();
		      return new _terms2.default("Super", {});
		    }
		    if (this.term === null && (this.isIdentifier(lookahead_157) || this.isParens(lookahead_157)) && this.isPunctuator(this.peek(1), "=>") && this.lineNumberEq(lookahead_157, this.peek(1))) {
		      return this.enforestArrowExpression();
		    }
		    if (this.term === null && this.isSyntaxTemplate(lookahead_157)) {
		      return this.enforestSyntaxTemplate();
		    }
		    if (this.term === null && this.isSyntaxQuoteTransform(lookahead_157)) {
		      return this.enforestSyntaxQuote();
		    }
		    if (this.term === null && this.isNewTransform(lookahead_157)) {
		      return this.enforestNewExpression();
		    }
		    if (this.term === null && this.isKeyword(lookahead_157, "this")) {
		      return new _terms2.default("ThisExpression", { stx: this.advance() });
		    }
		    if (this.term === null && (this.isIdentifier(lookahead_157) || this.isKeyword(lookahead_157, "let") || this.isKeyword(lookahead_157, "yield"))) {
		      return new _terms2.default("IdentifierExpression", { name: this.advance() });
		    }
		    if (this.term === null && this.isNumericLiteral(lookahead_157)) {
		      let num = this.advance();
		      if (num.val() === 1 / 0) {
		        return new _terms2.default("LiteralInfinityExpression", {});
		      }
		      return new _terms2.default("LiteralNumericExpression", { value: num });
		    }
		    if (this.term === null && this.isStringLiteral(lookahead_157)) {
		      return new _terms2.default("LiteralStringExpression", { value: this.advance() });
		    }
		    if (this.term === null && this.isTemplate(lookahead_157)) {
		      return new _terms2.default("TemplateExpression", { tag: null, elements: this.enforestTemplateElements() });
		    }
		    if (this.term === null && this.isBooleanLiteral(lookahead_157)) {
		      return new _terms2.default("LiteralBooleanExpression", { value: this.advance() });
		    }
		    if (this.term === null && this.isNullLiteral(lookahead_157)) {
		      this.advance();
		      return new _terms2.default("LiteralNullExpression", {});
		    }
		    if (this.term === null && this.isRegularExpression(lookahead_157)) {
		      let reStx = this.advance();
		      let lastSlash = reStx.token.value.lastIndexOf("/");
		      let pattern = reStx.token.value.slice(1, lastSlash);
		      let flags = reStx.token.value.slice(lastSlash + 1);
		      return new _terms2.default("LiteralRegExpExpression", { pattern: pattern, flags: flags });
		    }
		    if (this.term === null && this.isParens(lookahead_157)) {
		      return new _terms2.default("ParenthesizedExpression", { inner: this.advance().inner() });
		    }
		    if (this.term === null && this.isFnDeclTransform(lookahead_157)) {
		      return this.enforestFunctionExpression();
		    }
		    if (this.term === null && this.isBraces(lookahead_157)) {
		      return this.enforestObjectExpression();
		    }
		    if (this.term === null && this.isBrackets(lookahead_157)) {
		      return this.enforestArrayExpression();
		    }
		    if (this.term === null && this.isOperator(lookahead_157)) {
		      return this.enforestUnaryExpression();
		    }
		    if (this.term === null && this.isVarBindingTransform(lookahead_157)) {
		      let id = this.getFromCompiletimeEnvironment(lookahead_157).id;
		      if (id !== lookahead_157) {
		        this.advance();
		        this.rest = _immutable.List.of(id).concat(this.rest);
		        return EXPR_LOOP_EXPANSION_43;
		      }
		    }
		    if (this.term && this.isUpdateOperator(lookahead_157)) {
		      return this.enforestUpdateExpression();
		    }
		    if (this.term && this.isOperator(lookahead_157)) {
		      return this.enforestBinaryExpression();
		    }
		    if (this.term && this.isPunctuator(lookahead_157, ".") && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) {
		      return this.enforestStaticMemberExpression();
		    }
		    if (this.term && this.isBrackets(lookahead_157)) {
		      return this.enforestComputedMemberExpression();
		    }
		    if (this.term && this.isParens(lookahead_157)) {
		      let paren = this.advance();
		      return new _terms2.default("CallExpression", { callee: this.term, arguments: paren.inner() });
		    }
		    if (this.term && this.isTemplate(lookahead_157)) {
		      return new _terms2.default("TemplateExpression", { tag: this.term, elements: this.enforestTemplateElements() });
		    }
		    if (this.term && this.isAssign(lookahead_157)) {
		      let binding = this.transformDestructuring(this.term);
		      let op = this.advance();
		      let enf = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
		      let init = enf.enforest("expression");
		      this.rest = enf.rest;
		      if (op.val() === "=") {
		        return new _terms2.default("AssignmentExpression", { binding: binding, expression: init });
		      } else {
		        return new _terms2.default("CompoundAssignmentExpression", { binding: binding, operator: op.val(), expression: init });
		      }
		    }
		    if (this.term && this.isPunctuator(lookahead_157, "?")) {
		      return this.enforestConditionalExpression();
		    }
		    return EXPR_LOOP_NO_CHANGE_42;
		  }
		  enforestArgumentList() {
		    let result_158 = [];
		    while (this.rest.size > 0) {
		      let arg;
		      if (this.isPunctuator(this.peek(), "...")) {
		        this.advance();
		        arg = new _terms2.default("SpreadElement", { expression: this.enforestExpressionLoop() });
		      } else {
		        arg = this.enforestExpressionLoop();
		      }
		      if (this.rest.size > 0) {
		        this.matchPunctuator(",");
		      }
		      result_158.push(arg);
		    }
		    return (0, _immutable.List)(result_158);
		  }
		  enforestNewExpression() {
		    this.matchKeyword("new");
		    let callee_159;
		    if (this.isKeyword(this.peek(), "new")) {
		      callee_159 = this.enforestNewExpression();
		    } else if (this.isKeyword(this.peek(), "super")) {
		      callee_159 = this.enforestExpressionLoop();
		    } else if (this.isPunctuator(this.peek(), ".") && this.isIdentifier(this.peek(1), "target")) {
		      this.advance();
		      this.advance();
		      return new _terms2.default("NewTargetExpression", {});
		    } else {
		      callee_159 = new _terms2.default("IdentifierExpression", { name: this.enforestIdentifier() });
		    }
		    let args_160;
		    if (this.isParens(this.peek())) {
		      args_160 = this.matchParens();
		    } else {
		      args_160 = (0, _immutable.List)();
		    }
		    return new _terms2.default("NewExpression", { callee: callee_159, arguments: args_160 });
		  }
		  enforestComputedMemberExpression() {
		    let enf_161 = new Enforester_44(this.matchSquares(), (0, _immutable.List)(), this.context);
		    return new _terms2.default("ComputedMemberExpression", { object: this.term, expression: enf_161.enforestExpression() });
		  }
		  transformDestructuring(term_162) {
		    switch (term_162.type) {
		      case "IdentifierExpression":
		        return new _terms2.default("BindingIdentifier", { name: term_162.name });
		      case "ParenthesizedExpression":
		        if (term_162.inner.size === 1 && this.isIdentifier(term_162.inner.get(0))) {
		          return new _terms2.default("BindingIdentifier", { name: term_162.inner.get(0) });
		        }
		      case "DataProperty":
		        return new _terms2.default("BindingPropertyProperty", { name: term_162.name, binding: this.transformDestructuringWithDefault(term_162.expression) });
		      case "ShorthandProperty":
		        return new _terms2.default("BindingPropertyIdentifier", { binding: new _terms2.default("BindingIdentifier", { name: term_162.name }), init: null });
		      case "ObjectExpression":
		        return new _terms2.default("ObjectBinding", { properties: term_162.properties.map(t_163 => this.transformDestructuring(t_163)) });
		      case "ArrayExpression":
		        let last = term_162.elements.last();
		        if (last != null && last.type === "SpreadElement") {
		          return new _terms2.default("ArrayBinding", { elements: term_162.elements.slice(0, -1).map(t_164 => t_164 && this.transformDestructuringWithDefault(t_164)), restElement: this.transformDestructuringWithDefault(last.expression) });
		        } else {
		          return new _terms2.default("ArrayBinding", { elements: term_162.elements.map(t_165 => t_165 && this.transformDestructuringWithDefault(t_165)), restElement: null });
		        }
		        return new _terms2.default("ArrayBinding", { elements: term_162.elements.map(t_166 => t_166 && this.transformDestructuring(t_166)), restElement: null });
		      case "StaticPropertyName":
		        return new _terms2.default("BindingIdentifier", { name: term_162.value });
		      case "ComputedMemberExpression":
		      case "StaticMemberExpression":
		      case "ArrayBinding":
		      case "BindingIdentifier":
		      case "BindingPropertyIdentifier":
		      case "BindingPropertyProperty":
		      case "BindingWithDefault":
		      case "ObjectBinding":
		        return term_162;
		    }
		    (0, _errors.assert)(false, "not implemented yet for " + term_162.type);
		  }
		  transformDestructuringWithDefault(term_167) {
		    switch (term_167.type) {
		      case "AssignmentExpression":
		        return new _terms2.default("BindingWithDefault", { binding: this.transformDestructuring(term_167.binding), init: term_167.expression });
		    }
		    return this.transformDestructuring(term_167);
		  }
		  enforestArrowExpression() {
		    let enf_168;
		    if (this.isIdentifier(this.peek())) {
		      enf_168 = new Enforester_44(_immutable.List.of(this.advance()), (0, _immutable.List)(), this.context);
		    } else {
		      let p = this.matchParens();
		      enf_168 = new Enforester_44(p, (0, _immutable.List)(), this.context);
		    }
		    let params_169 = enf_168.enforestFormalParameters();
		    this.matchPunctuator("=>");
		    let body_170;
		    if (this.isBraces(this.peek())) {
		      body_170 = this.matchCurlies();
		    } else {
		      enf_168 = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
		      body_170 = enf_168.enforestExpressionLoop();
		      this.rest = enf_168.rest;
		    }
		    return new _terms2.default("ArrowExpression", { params: params_169, body: body_170 });
		  }
		  enforestYieldExpression() {
		    let kwd_171 = this.matchKeyword("yield");
		    let lookahead_172 = this.peek();
		    if (this.rest.size === 0 || lookahead_172 && !this.lineNumberEq(kwd_171, lookahead_172)) {
		      return new _terms2.default("YieldExpression", { expression: null });
		    } else {
		      let isGenerator = false;
		      if (this.isPunctuator(this.peek(), "*")) {
		        isGenerator = true;
		        this.advance();
		      }
		      let expr = this.enforestExpression();
		      let type = isGenerator ? "YieldGeneratorExpression" : "YieldExpression";
		      return new _terms2.default(type, { expression: expr });
		    }
		  }
		  enforestSyntaxTemplate() {
		    return new _terms2.default("SyntaxTemplate", { template: this.advance() });
		  }
		  enforestSyntaxQuote() {
		    let name_173 = this.advance();
		    return new _terms2.default("SyntaxQuote", { name: name_173, template: new _terms2.default("TemplateExpression", { tag: new _terms2.default("IdentifierExpression", { name: name_173 }), elements: this.enforestTemplateElements() }) });
		  }
		  enforestStaticMemberExpression() {
		    let object_174 = this.term;
		    let dot_175 = this.advance();
		    let property_176 = this.advance();
		    return new _terms2.default("StaticMemberExpression", { object: object_174, property: property_176 });
		  }
		  enforestArrayExpression() {
		    let arr_177 = this.advance();
		    let elements_178 = [];
		    let enf_179 = new Enforester_44(arr_177.inner(), (0, _immutable.List)(), this.context);
		    while (enf_179.rest.size > 0) {
		      let lookahead = enf_179.peek();
		      if (enf_179.isPunctuator(lookahead, ",")) {
		        enf_179.advance();
		        elements_178.push(null);
		      } else if (enf_179.isPunctuator(lookahead, "...")) {
		        enf_179.advance();
		        let expression = enf_179.enforestExpressionLoop();
		        if (expression == null) {
		          throw enf_179.createError(lookahead, "expecting expression");
		        }
		        elements_178.push(new _terms2.default("SpreadElement", { expression: expression }));
		      } else {
		        let term = enf_179.enforestExpressionLoop();
		        if (term == null) {
		          throw enf_179.createError(lookahead, "expected expression");
		        }
		        elements_178.push(term);
		        enf_179.consumeComma();
		      }
		    }
		    return new _terms2.default("ArrayExpression", { elements: (0, _immutable.List)(elements_178) });
		  }
		  enforestObjectExpression() {
		    let obj_180 = this.advance();
		    let properties_181 = (0, _immutable.List)();
		    let enf_182 = new Enforester_44(obj_180.inner(), (0, _immutable.List)(), this.context);
		    let lastProp_183 = null;
		    while (enf_182.rest.size > 0) {
		      let prop = enf_182.enforestPropertyDefinition();
		      enf_182.consumeComma();
		      properties_181 = properties_181.concat(prop);
		      if (lastProp_183 === prop) {
		        throw enf_182.createError(prop, "invalid syntax in object");
		      }
		      lastProp_183 = prop;
		    }
		    return new _terms2.default("ObjectExpression", { properties: properties_181 });
		  }
		  enforestPropertyDefinition() {
		    var _enforestMethodDefini = this.enforestMethodDefinition();

		    let methodOrKey = _enforestMethodDefini.methodOrKey;
		    let kind = _enforestMethodDefini.kind;

		    switch (kind) {
		      case "method":
		        return methodOrKey;
		      case "identifier":
		        if (this.isAssign(this.peek())) {
		          this.advance();
		          let init = this.enforestExpressionLoop();
		          return new _terms2.default("BindingPropertyIdentifier", { init: init, binding: this.transformDestructuring(methodOrKey) });
		        } else if (!this.isPunctuator(this.peek(), ":")) {
		          return new _terms2.default("ShorthandProperty", { name: methodOrKey.value });
		        }
		    }
		    this.matchPunctuator(":");
		    let expr_184 = this.enforestExpressionLoop();
		    return new _terms2.default("DataProperty", { name: methodOrKey, expression: expr_184 });
		  }
		  enforestMethodDefinition() {
		    let lookahead_185 = this.peek();
		    let isGenerator_186 = false;
		    if (this.isPunctuator(lookahead_185, "*")) {
		      isGenerator_186 = true;
		      this.advance();
		    }
		    if (this.isIdentifier(lookahead_185, "get") && this.isPropertyName(this.peek(1))) {
		      this.advance();

		      var _enforestPropertyName2 = this.enforestPropertyName();

		      let name = _enforestPropertyName2.name;

		      this.matchParens();
		      let body = this.matchCurlies();
		      return { methodOrKey: new _terms2.default("Getter", { name: name, body: body }), kind: "method" };
		    } else if (this.isIdentifier(lookahead_185, "set") && this.isPropertyName(this.peek(1))) {
		      this.advance();

		      var _enforestPropertyName3 = this.enforestPropertyName();

		      let name = _enforestPropertyName3.name;

		      let enf = new Enforester_44(this.matchParens(), (0, _immutable.List)(), this.context);
		      let param = enf.enforestBindingElement();
		      let body = this.matchCurlies();
		      return { methodOrKey: new _terms2.default("Setter", { name: name, param: param, body: body }), kind: "method" };
		    }

		    var _enforestPropertyName4 = this.enforestPropertyName();

		    let name = _enforestPropertyName4.name;

		    if (this.isParens(this.peek())) {
		      let params = this.matchParens();
		      let enf = new Enforester_44(params, (0, _immutable.List)(), this.context);
		      let formalParams = enf.enforestFormalParameters();
		      let body = this.matchCurlies();
		      return { methodOrKey: new _terms2.default("Method", { isGenerator: isGenerator_186, name: name, params: formalParams, body: body }), kind: "method" };
		    }
		    return { methodOrKey: name, kind: this.isIdentifier(lookahead_185) || this.isKeyword(lookahead_185) ? "identifier" : "property" };
		  }
		  enforestPropertyName() {
		    let lookahead_187 = this.peek();
		    if (this.isStringLiteral(lookahead_187) || this.isNumericLiteral(lookahead_187)) {
		      return { name: new _terms2.default("StaticPropertyName", { value: this.advance() }), binding: null };
		    } else if (this.isBrackets(lookahead_187)) {
		      let enf = new Enforester_44(this.matchSquares(), (0, _immutable.List)(), this.context);
		      let expr = enf.enforestExpressionLoop();
		      return { name: new _terms2.default("ComputedPropertyName", { expression: expr }), binding: null };
		    }
		    let name_188 = this.advance();
		    return { name: new _terms2.default("StaticPropertyName", { value: name_188 }), binding: new _terms2.default("BindingIdentifier", { name: name_188 }) };
		  }
		  enforestFunction(_ref5) {
		    let isExpr = _ref5.isExpr;
		    let inDefault = _ref5.inDefault;
		    let allowGenerator = _ref5.allowGenerator;

		    let name_189 = null,
		        params_190,
		        body_191,
		        rest_192;
		    let isGenerator_193 = false;
		    let fnKeyword_194 = this.advance();
		    let lookahead_195 = this.peek();
		    let type_196 = isExpr ? "FunctionExpression" : "FunctionDeclaration";
		    if (this.isPunctuator(lookahead_195, "*")) {
		      isGenerator_193 = true;
		      this.advance();
		      lookahead_195 = this.peek();
		    }
		    if (!this.isParens(lookahead_195)) {
		      name_189 = this.enforestBindingIdentifier();
		    } else if (inDefault) {
		      name_189 = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("*default*", fnKeyword_194) });
		    }
		    params_190 = this.matchParens();
		    body_191 = this.matchCurlies();
		    let enf_197 = new Enforester_44(params_190, (0, _immutable.List)(), this.context);
		    let formalParams_198 = enf_197.enforestFormalParameters();
		    return new _terms2.default(type_196, { name: name_189, isGenerator: isGenerator_193, params: formalParams_198, body: body_191 });
		  }
		  enforestFunctionExpression() {
		    let name_199 = null,
		        params_200,
		        body_201,
		        rest_202;
		    let isGenerator_203 = false;
		    this.advance();
		    let lookahead_204 = this.peek();
		    if (this.isPunctuator(lookahead_204, "*")) {
		      isGenerator_203 = true;
		      this.advance();
		      lookahead_204 = this.peek();
		    }
		    if (!this.isParens(lookahead_204)) {
		      name_199 = this.enforestBindingIdentifier();
		    }
		    params_200 = this.matchParens();
		    body_201 = this.matchCurlies();
		    let enf_205 = new Enforester_44(params_200, (0, _immutable.List)(), this.context);
		    let formalParams_206 = enf_205.enforestFormalParameters();
		    return new _terms2.default("FunctionExpression", { name: name_199, isGenerator: isGenerator_203, params: formalParams_206, body: body_201 });
		  }
		  enforestFunctionDeclaration() {
		    let name_207, params_208, body_209, rest_210;
		    let isGenerator_211 = false;
		    this.advance();
		    let lookahead_212 = this.peek();
		    if (this.isPunctuator(lookahead_212, "*")) {
		      isGenerator_211 = true;
		      this.advance();
		    }
		    name_207 = this.enforestBindingIdentifier();
		    params_208 = this.matchParens();
		    body_209 = this.matchCurlies();
		    let enf_213 = new Enforester_44(params_208, (0, _immutable.List)(), this.context);
		    let formalParams_214 = enf_213.enforestFormalParameters();
		    return new _terms2.default("FunctionDeclaration", { name: name_207, isGenerator: isGenerator_211, params: formalParams_214, body: body_209 });
		  }
		  enforestFormalParameters() {
		    let items_215 = [];
		    let rest_216 = null;
		    while (this.rest.size !== 0) {
		      let lookahead = this.peek();
		      if (this.isPunctuator(lookahead, "...")) {
		        this.matchPunctuator("...");
		        rest_216 = this.enforestBindingIdentifier();
		        break;
		      }
		      items_215.push(this.enforestParam());
		      this.consumeComma();
		    }
		    return new _terms2.default("FormalParameters", { items: (0, _immutable.List)(items_215), rest: rest_216 });
		  }
		  enforestParam() {
		    return this.enforestBindingElement();
		  }
		  enforestUpdateExpression() {
		    let operator_217 = this.matchUnaryOperator();
		    return new _terms2.default("UpdateExpression", { isPrefix: false, operator: operator_217.val(), operand: this.transformDestructuring(this.term) });
		  }
		  enforestUnaryExpression() {
		    let operator_218 = this.matchUnaryOperator();
		    this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine });
		    this.opCtx.prec = 14;
		    this.opCtx.combine = rightTerm_219 => {
		      let type_220, term_221, isPrefix_222;
		      if (operator_218.val() === "++" || operator_218.val() === "--") {
		        type_220 = "UpdateExpression";
		        term_221 = this.transformDestructuring(rightTerm_219);
		        isPrefix_222 = true;
		      } else {
		        type_220 = "UnaryExpression";
		        isPrefix_222 = undefined;
		        term_221 = rightTerm_219;
		      }
		      return new _terms2.default(type_220, { operator: operator_218.val(), operand: term_221, isPrefix: isPrefix_222 });
		    };
		    return EXPR_LOOP_OPERATOR_41;
		  }
		  enforestConditionalExpression() {
		    let test_223 = this.opCtx.combine(this.term);
		    if (this.opCtx.stack.size > 0) {
		      var _opCtx$stack$last2 = this.opCtx.stack.last();

		      let prec = _opCtx$stack$last2.prec;
		      let combine = _opCtx$stack$last2.combine;

		      this.opCtx.stack = this.opCtx.stack.pop();
		      this.opCtx.prec = prec;
		      this.opCtx.combine = combine;
		    }
		    this.matchPunctuator("?");
		    let enf_224 = new Enforester_44(this.rest, (0, _immutable.List)(), this.context);
		    let consequent_225 = enf_224.enforestExpressionLoop();
		    enf_224.matchPunctuator(":");
		    enf_224 = new Enforester_44(enf_224.rest, (0, _immutable.List)(), this.context);
		    let alternate_226 = enf_224.enforestExpressionLoop();
		    this.rest = enf_224.rest;
		    return new _terms2.default("ConditionalExpression", { test: test_223, consequent: consequent_225, alternate: alternate_226 });
		  }
		  enforestBinaryExpression() {
		    let leftTerm_227 = this.term;
		    let opStx_228 = this.peek();
		    let op_229 = opStx_228.val();
		    let opPrec_230 = (0, _operators.getOperatorPrec)(op_229);
		    let opAssoc_231 = (0, _operators.getOperatorAssoc)(op_229);
		    if ((0, _operators.operatorLt)(this.opCtx.prec, opPrec_230, opAssoc_231)) {
		      this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine });
		      this.opCtx.prec = opPrec_230;
		      this.opCtx.combine = rightTerm_232 => {
		        return new _terms2.default("BinaryExpression", { left: leftTerm_227, operator: opStx_228, right: rightTerm_232 });
		      };
		      this.advance();
		      return EXPR_LOOP_OPERATOR_41;
		    } else {
		      let term = this.opCtx.combine(leftTerm_227);

		      var _opCtx$stack$last3 = this.opCtx.stack.last();

		      let prec = _opCtx$stack$last3.prec;
		      let combine = _opCtx$stack$last3.combine;

		      this.opCtx.stack = this.opCtx.stack.pop();
		      this.opCtx.prec = prec;
		      this.opCtx.combine = combine;
		      return term;
		    }
		  }
		  enforestTemplateElements() {
		    let lookahead_233 = this.matchTemplate();
		    let elements_234 = lookahead_233.token.items.map(it_235 => {
		      if (it_235 instanceof _syntax2.default && it_235.isDelimiter()) {
		        let enf = new Enforester_44(it_235.inner(), (0, _immutable.List)(), this.context);
		        return enf.enforest("expression");
		      }
		      return new _terms2.default("TemplateElement", { rawValue: it_235.slice.text });
		    });
		    return elements_234;
		  }
		  expandMacro(enforestType_236) {
		    let name_237 = this.advance();
		    let syntaxTransform_238 = this.getFromCompiletimeEnvironment(name_237);
		    if (syntaxTransform_238 == null || typeof syntaxTransform_238.value !== "function") {
		      throw this.createError(name_237, "the macro name was not bound to a value that could be invoked");
		    }
		    let useSiteScope_239 = (0, _scope.freshScope)("u");
		    let introducedScope_240 = (0, _scope.freshScope)("i");
		    this.context.useScope = useSiteScope_239;
		    let ctx_241 = new _macroContext2.default(this, name_237, this.context, useSiteScope_239, introducedScope_240);
		    let result_242 = (0, _loadSyntax.sanitizeReplacementValues)(syntaxTransform_238.value.call(null, ctx_241));
		    if (!_immutable.List.isList(result_242)) {
		      throw this.createError(name_237, "macro must return a list but got: " + result_242);
		    }
		    result_242 = result_242.map(stx_243 => {
		      if (!(stx_243 && typeof stx_243.addScope === "function")) {
		        throw this.createError(name_237, "macro must return syntax objects or terms but got: " + stx_243);
		      }
		      return stx_243.addScope(introducedScope_240, this.context.bindings, _syntax.ALL_PHASES, { flip: true });
		    });
		    return result_242;
		  }
		  consumeSemicolon() {
		    let lookahead_244 = this.peek();
		    if (lookahead_244 && this.isPunctuator(lookahead_244, ";")) {
		      this.advance();
		    }
		  }
		  consumeComma() {
		    let lookahead_245 = this.peek();
		    if (lookahead_245 && this.isPunctuator(lookahead_245, ",")) {
		      this.advance();
		    }
		  }
		  isTerm(term_246) {
		    return term_246 && term_246 instanceof _terms2.default;
		  }
		  isEOF(term_247) {
		    return term_247 && term_247 instanceof _syntax2.default && term_247.isEOF();
		  }
		  isIdentifier(term_248) {
		    let val_249 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		    return term_248 && term_248 instanceof _syntax2.default && term_248.isIdentifier() && (val_249 === null || term_248.val() === val_249);
		  }
		  isPropertyName(term_250) {
		    return this.isIdentifier(term_250) || this.isKeyword(term_250) || this.isNumericLiteral(term_250) || this.isStringLiteral(term_250) || this.isBrackets(term_250);
		  }
		  isNumericLiteral(term_251) {
		    return term_251 && term_251 instanceof _syntax2.default && term_251.isNumericLiteral();
		  }
		  isStringLiteral(term_252) {
		    return term_252 && term_252 instanceof _syntax2.default && term_252.isStringLiteral();
		  }
		  isTemplate(term_253) {
		    return term_253 && term_253 instanceof _syntax2.default && term_253.isTemplate();
		  }
		  isBooleanLiteral(term_254) {
		    return term_254 && term_254 instanceof _syntax2.default && term_254.isBooleanLiteral();
		  }
		  isNullLiteral(term_255) {
		    return term_255 && term_255 instanceof _syntax2.default && term_255.isNullLiteral();
		  }
		  isRegularExpression(term_256) {
		    return term_256 && term_256 instanceof _syntax2.default && term_256.isRegularExpression();
		  }
		  isParens(term_257) {
		    return term_257 && term_257 instanceof _syntax2.default && term_257.isParens();
		  }
		  isBraces(term_258) {
		    return term_258 && term_258 instanceof _syntax2.default && term_258.isBraces();
		  }
		  isBrackets(term_259) {
		    return term_259 && term_259 instanceof _syntax2.default && term_259.isBrackets();
		  }
		  isAssign(term_260) {
		    if (this.isPunctuator(term_260)) {
		      switch (term_260.val()) {
		        case "=":
		        case "|=":
		        case "^=":
		        case "&=":
		        case "<<=":
		        case ">>=":
		        case ">>>=":
		        case "+=":
		        case "-=":
		        case "*=":
		        case "/=":
		        case "%=":
		          return true;
		        default:
		          return false;
		      }
		    }
		    return false;
		  }
		  isKeyword(term_261) {
		    let val_262 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		    return term_261 && term_261 instanceof _syntax2.default && term_261.isKeyword() && (val_262 === null || term_261.val() === val_262);
		  }
		  isPunctuator(term_263) {
		    let val_264 = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		    return term_263 && term_263 instanceof _syntax2.default && term_263.isPunctuator() && (val_264 === null || term_263.val() === val_264);
		  }
		  isOperator(term_265) {
		    return term_265 && term_265 instanceof _syntax2.default && (0, _operators.isOperator)(term_265);
		  }
		  isUpdateOperator(term_266) {
		    return term_266 && term_266 instanceof _syntax2.default && term_266.isPunctuator() && (term_266.val() === "++" || term_266.val() === "--");
		  }
		  isFnDeclTransform(term_267) {
		    return term_267 && term_267 instanceof _syntax2.default && this.context.env.get(term_267.resolve(this.context.phase)) === _transforms.FunctionDeclTransform;
		  }
		  isVarDeclTransform(term_268) {
		    return term_268 && term_268 instanceof _syntax2.default && this.context.env.get(term_268.resolve(this.context.phase)) === _transforms.VariableDeclTransform;
		  }
		  isLetDeclTransform(term_269) {
		    return term_269 && term_269 instanceof _syntax2.default && this.context.env.get(term_269.resolve(this.context.phase)) === _transforms.LetDeclTransform;
		  }
		  isConstDeclTransform(term_270) {
		    return term_270 && term_270 instanceof _syntax2.default && this.context.env.get(term_270.resolve(this.context.phase)) === _transforms.ConstDeclTransform;
		  }
		  isSyntaxDeclTransform(term_271) {
		    return term_271 && term_271 instanceof _syntax2.default && this.context.env.get(term_271.resolve(this.context.phase)) === _transforms.SyntaxDeclTransform;
		  }
		  isSyntaxrecDeclTransform(term_272) {
		    return term_272 && term_272 instanceof _syntax2.default && this.context.env.get(term_272.resolve(this.context.phase)) === _transforms.SyntaxrecDeclTransform;
		  }
		  isSyntaxTemplate(term_273) {
		    return term_273 && term_273 instanceof _syntax2.default && term_273.isSyntaxTemplate();
		  }
		  isSyntaxQuoteTransform(term_274) {
		    return term_274 && term_274 instanceof _syntax2.default && this.context.env.get(term_274.resolve(this.context.phase)) === _transforms.SyntaxQuoteTransform;
		  }
		  isReturnStmtTransform(term_275) {
		    return term_275 && term_275 instanceof _syntax2.default && this.context.env.get(term_275.resolve(this.context.phase)) === _transforms.ReturnStatementTransform;
		  }
		  isWhileTransform(term_276) {
		    return term_276 && term_276 instanceof _syntax2.default && this.context.env.get(term_276.resolve(this.context.phase)) === _transforms.WhileTransform;
		  }
		  isForTransform(term_277) {
		    return term_277 && term_277 instanceof _syntax2.default && this.context.env.get(term_277.resolve(this.context.phase)) === _transforms.ForTransform;
		  }
		  isSwitchTransform(term_278) {
		    return term_278 && term_278 instanceof _syntax2.default && this.context.env.get(term_278.resolve(this.context.phase)) === _transforms.SwitchTransform;
		  }
		  isBreakTransform(term_279) {
		    return term_279 && term_279 instanceof _syntax2.default && this.context.env.get(term_279.resolve(this.context.phase)) === _transforms.BreakTransform;
		  }
		  isContinueTransform(term_280) {
		    return term_280 && term_280 instanceof _syntax2.default && this.context.env.get(term_280.resolve(this.context.phase)) === _transforms.ContinueTransform;
		  }
		  isDoTransform(term_281) {
		    return term_281 && term_281 instanceof _syntax2.default && this.context.env.get(term_281.resolve(this.context.phase)) === _transforms.DoTransform;
		  }
		  isDebuggerTransform(term_282) {
		    return term_282 && term_282 instanceof _syntax2.default && this.context.env.get(term_282.resolve(this.context.phase)) === _transforms.DebuggerTransform;
		  }
		  isWithTransform(term_283) {
		    return term_283 && term_283 instanceof _syntax2.default && this.context.env.get(term_283.resolve(this.context.phase)) === _transforms.WithTransform;
		  }
		  isTryTransform(term_284) {
		    return term_284 && term_284 instanceof _syntax2.default && this.context.env.get(term_284.resolve(this.context.phase)) === _transforms.TryTransform;
		  }
		  isThrowTransform(term_285) {
		    return term_285 && term_285 instanceof _syntax2.default && this.context.env.get(term_285.resolve(this.context.phase)) === _transforms.ThrowTransform;
		  }
		  isIfTransform(term_286) {
		    return term_286 && term_286 instanceof _syntax2.default && this.context.env.get(term_286.resolve(this.context.phase)) === _transforms.IfTransform;
		  }
		  isNewTransform(term_287) {
		    return term_287 && term_287 instanceof _syntax2.default && this.context.env.get(term_287.resolve(this.context.phase)) === _transforms.NewTransform;
		  }
		  isCompiletimeTransform(term_288) {
		    return term_288 && term_288 instanceof _syntax2.default && (this.context.env.get(term_288.resolve(this.context.phase)) instanceof _transforms.CompiletimeTransform || this.context.store.get(term_288.resolve(this.context.phase)) instanceof _transforms.CompiletimeTransform);
		  }
		  isVarBindingTransform(term_289) {
		    return term_289 && term_289 instanceof _syntax2.default && (this.context.env.get(term_289.resolve(this.context.phase)) instanceof _transforms.VarBindingTransform || this.context.store.get(term_289.resolve(this.context.phase)) instanceof _transforms.VarBindingTransform);
		  }
		  getFromCompiletimeEnvironment(term_290) {
		    if (this.context.env.has(term_290.resolve(this.context.phase))) {
		      return this.context.env.get(term_290.resolve(this.context.phase));
		    }
		    return this.context.store.get(term_290.resolve(this.context.phase));
		  }
		  lineNumberEq(a_291, b_292) {
		    if (!(a_291 && b_292)) {
		      return false;
		    }
		    return a_291.lineNumber() === b_292.lineNumber();
		  }
		  matchIdentifier(val_293) {
		    let lookahead_294 = this.advance();
		    if (this.isIdentifier(lookahead_294)) {
		      return lookahead_294;
		    }
		    throw this.createError(lookahead_294, "expecting an identifier");
		  }
		  matchKeyword(val_295) {
		    let lookahead_296 = this.advance();
		    if (this.isKeyword(lookahead_296, val_295)) {
		      return lookahead_296;
		    }
		    throw this.createError(lookahead_296, "expecting " + val_295);
		  }
		  matchLiteral() {
		    let lookahead_297 = this.advance();
		    if (this.isNumericLiteral(lookahead_297) || this.isStringLiteral(lookahead_297) || this.isBooleanLiteral(lookahead_297) || this.isNullLiteral(lookahead_297) || this.isTemplate(lookahead_297) || this.isRegularExpression(lookahead_297)) {
		      return lookahead_297;
		    }
		    throw this.createError(lookahead_297, "expecting a literal");
		  }
		  matchStringLiteral() {
		    let lookahead_298 = this.advance();
		    if (this.isStringLiteral(lookahead_298)) {
		      return lookahead_298;
		    }
		    throw this.createError(lookahead_298, "expecting a string literal");
		  }
		  matchTemplate() {
		    let lookahead_299 = this.advance();
		    if (this.isTemplate(lookahead_299)) {
		      return lookahead_299;
		    }
		    throw this.createError(lookahead_299, "expecting a template literal");
		  }
		  matchParens() {
		    let lookahead_300 = this.advance();
		    if (this.isParens(lookahead_300)) {
		      return lookahead_300.inner();
		    }
		    throw this.createError(lookahead_300, "expecting parens");
		  }
		  matchCurlies() {
		    let lookahead_301 = this.advance();
		    if (this.isBraces(lookahead_301)) {
		      return lookahead_301.inner();
		    }
		    throw this.createError(lookahead_301, "expecting curly braces");
		  }
		  matchSquares() {
		    let lookahead_302 = this.advance();
		    if (this.isBrackets(lookahead_302)) {
		      return lookahead_302.inner();
		    }
		    throw this.createError(lookahead_302, "expecting sqaure braces");
		  }
		  matchUnaryOperator() {
		    let lookahead_303 = this.advance();
		    if ((0, _operators.isUnaryOperator)(lookahead_303)) {
		      return lookahead_303;
		    }
		    throw this.createError(lookahead_303, "expecting a unary operator");
		  }
		  matchPunctuator(val_304) {
		    let lookahead_305 = this.advance();
		    if (this.isPunctuator(lookahead_305)) {
		      if (typeof val_304 !== "undefined") {
		        if (lookahead_305.val() === val_304) {
		          return lookahead_305;
		        } else {
		          throw this.createError(lookahead_305, "expecting a " + val_304 + " punctuator");
		        }
		      }
		      return lookahead_305;
		    }
		    throw this.createError(lookahead_305, "expecting a punctuator");
		  }
		  createError(stx_306, message_307) {
		    let ctx_308 = "";
		    let offending_309 = stx_306;
		    if (this.rest.size > 0) {
		      ctx_308 = this.rest.slice(0, 20).map(term_310 => {
		        if (term_310.isDelimiter()) {
		          return term_310.inner();
		        }
		        return _immutable.List.of(term_310);
		      }).flatten().map(s_311 => {
		        if (s_311 === offending_309) {
		          return "__" + s_311.val() + "__";
		        }
		        return s_311.val();
		      }).join(" ");
		    } else {
		      ctx_308 = offending_309.toString();
		    }
		    return new Error(message_307 + "\n" + ctx_308);
		  }
		}
		exports.Enforester = Enforester_44;
		//# sourceMappingURL=data:application/json;base64,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TyxPQUFPLE1BQU0sR0FBTixFQUFQLEdBQXFCLElBQTVCO0FBQ0Q7QUFDRCxlQUFPLE1BQU0sR0FBTixFQUFQO0FBQ0QsT0FWUyxFQVVQLElBVk8sQ0FVRixHQVZFLENBQVY7QUFXRCxLQVpELE1BWU87QUFDTCxnQkFBVSxjQUFjLFFBQWQsRUFBVjtBQUNEO0FBQ0QsV0FBTyxJQUFJLEtBQUosQ0FBVSxjQUFjLElBQWQsR0FBcUIsT0FBL0IsQ0FBUDtBQUNEO0FBL2dEaUI7UUFpaERLLFUsR0FBakIsYSIsImZpbGUiOiJlbmZvcmVzdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRlcm0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7RnVuY3Rpb25EZWNsVHJhbnNmb3JtLCBWYXJpYWJsZURlY2xUcmFuc2Zvcm0sIE5ld1RyYW5zZm9ybSwgTGV0RGVjbFRyYW5zZm9ybSwgQ29uc3REZWNsVHJhbnNmb3JtLCBTeW50YXhEZWNsVHJhbnNmb3JtLCBTeW50YXhyZWNEZWNsVHJhbnNmb3JtLCBTeW50YXhRdW90ZVRyYW5zZm9ybSwgUmV0dXJuU3RhdGVtZW50VHJhbnNmb3JtLCBXaGlsZVRyYW5zZm9ybSwgSWZUcmFuc2Zvcm0sIEZvclRyYW5zZm9ybSwgU3dpdGNoVHJhbnNmb3JtLCBCcmVha1RyYW5zZm9ybSwgQ29udGludWVUcmFuc2Zvcm0sIERvVHJhbnNmb3JtLCBEZWJ1Z2dlclRyYW5zZm9ybSwgV2l0aFRyYW5zZm9ybSwgVHJ5VHJhbnNmb3JtLCBUaHJvd1RyYW5zZm9ybSwgQ29tcGlsZXRpbWVUcmFuc2Zvcm0sIFZhckJpbmRpbmdUcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybXNcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQge2lzT3BlcmF0b3IsIGlzVW5hcnlPcGVyYXRvciwgZ2V0T3BlcmF0b3JBc3NvYywgZ2V0T3BlcmF0b3JQcmVjLCBvcGVyYXRvckx0fSBmcm9tIFwiLi9vcGVyYXRvcnNcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7ZnJlc2hTY29wZX0gZnJvbSBcIi4vc2NvcGVcIjtcbmltcG9ydCB7c2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc30gZnJvbSBcIi4vbG9hZC1zeW50YXhcIjtcbmltcG9ydCBNYWNyb0NvbnRleHQgZnJvbSBcIi4vbWFjcm8tY29udGV4dFwiO1xuY29uc3QgRVhQUl9MT09QX09QRVJBVE9SXzQxID0ge307XG5jb25zdCBFWFBSX0xPT1BfTk9fQ0hBTkdFXzQyID0ge307XG5jb25zdCBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzID0ge307XG5jbGFzcyBFbmZvcmVzdGVyXzQ0IHtcbiAgY29uc3RydWN0b3Ioc3R4bF80NSwgcHJldl80NiwgY29udGV4dF80Nykge1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIGFzc2VydChMaXN0LmlzTGlzdChzdHhsXzQ1KSwgXCJleHBlY3RpbmcgYSBsaXN0IG9mIHRlcm1zIHRvIGVuZm9yZXN0XCIpO1xuICAgIGFzc2VydChMaXN0LmlzTGlzdChwcmV2XzQ2KSwgXCJleHBlY3RpbmcgYSBsaXN0IG9mIHRlcm1zIHRvIGVuZm9yZXN0XCIpO1xuICAgIGFzc2VydChjb250ZXh0XzQ3LCBcImV4cGVjdGluZyBhIGNvbnRleHQgdG8gZW5mb3Jlc3RcIik7XG4gICAgdGhpcy50ZXJtID0gbnVsbDtcbiAgICB0aGlzLnJlc3QgPSBzdHhsXzQ1O1xuICAgIHRoaXMucHJldiA9IHByZXZfNDY7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dF80NztcbiAgfVxuICBwZWVrKG5fNDggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5nZXQobl80OCk7XG4gIH1cbiAgYWR2YW5jZSgpIHtcbiAgICBsZXQgcmV0XzQ5ID0gdGhpcy5yZXN0LmZpcnN0KCk7XG4gICAgdGhpcy5yZXN0ID0gdGhpcy5yZXN0LnJlc3QoKTtcbiAgICByZXR1cm4gcmV0XzQ5O1xuICB9XG4gIGVuZm9yZXN0KHR5cGVfNTAgPSBcIk1vZHVsZVwiKSB7XG4gICAgdGhpcy50ZXJtID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy50ZXJtO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VPRih0aGlzLnBlZWsoKSkpIHtcbiAgICAgIHRoaXMudGVybSA9IG5ldyBUZXJtKFwiRU9GXCIsIHt9KTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudGVybTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdF81MTtcbiAgICBpZiAodHlwZV81MCA9PT0gXCJleHByZXNzaW9uXCIpIHtcbiAgICAgIHJlc3VsdF81MSA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRfNTEgPSB0aGlzLmVuZm9yZXN0TW9kdWxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdF81MTtcbiAgfVxuICBlbmZvcmVzdE1vZHVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJvZHkoKTtcbiAgfVxuICBlbmZvcmVzdEJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RNb2R1bGVJdGVtKCk7XG4gIH1cbiAgZW5mb3Jlc3RNb2R1bGVJdGVtKCkge1xuICAgIGxldCBsb29rYWhlYWRfNTIgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzUyLCBcImltcG9ydFwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNTIsIFwiZXhwb3J0XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF81MiwgXCIjXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdExhbmd1YWdlUHJhZ21hKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RMYW5ndWFnZVByYWdtYSgpIHtcbiAgICB0aGlzLm1hdGNoSWRlbnRpZmllcihcIiNcIik7XG4gICAgdGhpcy5tYXRjaElkZW50aWZpZXIoXCJsYW5nXCIpO1xuICAgIGxldCBwYXRoXzUzID0gdGhpcy5tYXRjaFN0cmluZ0xpdGVyYWwoKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJQcmFnbWFcIiwge2tpbmQ6IFwibGFuZ1wiLCBpdGVtczogTGlzdC5vZihwYXRoXzUzKX0pO1xuICB9XG4gIGVuZm9yZXN0RXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZF81NCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNTQsIFwiKlwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydEFsbEZyb21cIiwge21vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF81NCkpIHtcbiAgICAgIGxldCBuYW1lZEV4cG9ydHMgPSB0aGlzLmVuZm9yZXN0RXhwb3J0Q2xhdXNlKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgXCJmcm9tXCIpKSB7XG4gICAgICAgIG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRGcm9tXCIsIHtuYW1lZEV4cG9ydHM6IG5hbWVkRXhwb3J0cywgbW9kdWxlU3BlY2lmaWVyOiBtb2R1bGVTcGVjaWZpZXJ9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81NCwgXCJjbGFzc1wiKSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdENsYXNzKHtpc0V4cHI6IGZhbHNlfSl9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNGbkRlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzU0KSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdEZ1bmN0aW9uKHtpc0V4cHI6IGZhbHNlLCBpbkRlZmF1bHQ6IGZhbHNlfSl9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81NCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKHRoaXMucGVlaygpKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnREZWZhdWx0XCIsIHtib2R5OiB0aGlzLmVuZm9yZXN0RnVuY3Rpb24oe2lzRXhwcjogZmFsc2UsIGluRGVmYXVsdDogdHJ1ZX0pfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImNsYXNzXCIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydERlZmF1bHRcIiwge2JvZHk6IHRoaXMuZW5mb3Jlc3RDbGFzcyh7aXNFeHByOiBmYWxzZSwgaW5EZWZhdWx0OiB0cnVlfSl9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBib2R5ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnREZWZhdWx0XCIsIHtib2R5OiBib2R5fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmFyRGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNTQpIHx8IHRoaXMuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF81NCkgfHwgdGhpcy5pc0NvbnN0RGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNTQpIHx8IHRoaXMuaXNTeW50YXhyZWNEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF81NCkgfHwgdGhpcy5pc1N5bnRheERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzU0KSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwb3J0XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRpb24oKX0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF81NCwgXCJ1bmV4cGVjdGVkIHN5bnRheFwiKTtcbiAgfVxuICBlbmZvcmVzdEV4cG9ydENsYXVzZSgpIHtcbiAgICBsZXQgZW5mXzU1ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCByZXN1bHRfNTYgPSBbXTtcbiAgICB3aGlsZSAoZW5mXzU1LnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcmVzdWx0XzU2LnB1c2goZW5mXzU1LmVuZm9yZXN0RXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgZW5mXzU1LmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHRfNTYpO1xuICB9XG4gIGVuZm9yZXN0RXhwb3J0U3BlY2lmaWVyKCkge1xuICAgIGxldCBuYW1lXzU3ID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCksIFwiYXNcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IGV4cG9ydGVkTmFtZSA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNTcsIGV4cG9ydGVkTmFtZTogZXhwb3J0ZWROYW1lfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydFNwZWNpZmllclwiLCB7bmFtZTogbnVsbCwgZXhwb3J0ZWROYW1lOiBuYW1lXzU3fSk7XG4gIH1cbiAgZW5mb3Jlc3RJbXBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzU4ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IGRlZmF1bHRCaW5kaW5nXzU5ID0gbnVsbDtcbiAgICBsZXQgbmFtZWRJbXBvcnRzXzYwID0gTGlzdCgpO1xuICAgIGxldCBmb3JTeW50YXhfNjEgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1N0cmluZ0xpdGVyYWwobG9va2FoZWFkXzU4KSkge1xuICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRcIiwge2RlZmF1bHRCaW5kaW5nOiBkZWZhdWx0QmluZGluZ181OSwgbmFtZWRJbXBvcnRzOiBuYW1lZEltcG9ydHNfNjAsIG1vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfNTgpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF81OCkpIHtcbiAgICAgIGRlZmF1bHRCaW5kaW5nXzU5ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgICBpZiAoIXRoaXMuaXNQdW5jdHVhdG9yKHRoaXMucGVlaygpLCBcIixcIikpIHtcbiAgICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmb3JcIikgJiYgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpLCBcInN5bnRheFwiKSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIGZvclN5bnRheF82MSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0XCIsIHtkZWZhdWx0QmluZGluZzogZGVmYXVsdEJpbmRpbmdfNTksIG1vZHVsZVNwZWNpZmllcjogbW9kdWxlU3BlY2lmaWVyLCBuYW1lZEltcG9ydHM6IExpc3QoKSwgZm9yU3ludGF4OiBmb3JTeW50YXhfNjF9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdW1lQ29tbWEoKTtcbiAgICBsb29rYWhlYWRfNTggPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNlcyhsb29rYWhlYWRfNTgpKSB7XG4gICAgICBsZXQgaW1wb3J0cyA9IHRoaXMuZW5mb3Jlc3ROYW1lZEltcG9ydHMoKTtcbiAgICAgIGxldCBmcm9tQ2xhdXNlID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmb3JcIikgJiYgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpLCBcInN5bnRheFwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGZvclN5bnRheF82MSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRcIiwge2RlZmF1bHRCaW5kaW5nOiBkZWZhdWx0QmluZGluZ181OSwgZm9yU3ludGF4OiBmb3JTeW50YXhfNjEsIG5hbWVkSW1wb3J0czogaW1wb3J0cywgbW9kdWxlU3BlY2lmaWVyOiBmcm9tQ2xhdXNlfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNTgsIFwiKlwiKSkge1xuICAgICAgbGV0IG5hbWVzcGFjZUJpbmRpbmcgPSB0aGlzLmVuZm9yZXN0TmFtZXNwYWNlQmluZGluZygpO1xuICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuZW5mb3Jlc3RGcm9tQ2xhdXNlKCk7XG4gICAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZm9yXCIpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgXCJzeW50YXhcIikpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBmb3JTeW50YXhfNjEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiSW1wb3J0TmFtZXNwYWNlXCIsIHtkZWZhdWx0QmluZGluZzogZGVmYXVsdEJpbmRpbmdfNTksIGZvclN5bnRheDogZm9yU3ludGF4XzYxLCBuYW1lc3BhY2VCaW5kaW5nOiBuYW1lc3BhY2VCaW5kaW5nLCBtb2R1bGVTcGVjaWZpZXI6IG1vZHVsZVNwZWNpZmllcn0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF81OCwgXCJ1bmV4cGVjdGVkIHN5bnRheFwiKTtcbiAgfVxuICBlbmZvcmVzdE5hbWVzcGFjZUJpbmRpbmcoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCIqXCIpO1xuICAgIHRoaXMubWF0Y2hJZGVudGlmaWVyKFwiYXNcIik7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICB9XG4gIGVuZm9yZXN0TmFtZWRJbXBvcnRzKCkge1xuICAgIGxldCBlbmZfNjIgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLm1hdGNoQ3VybGllcygpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IHJlc3VsdF82MyA9IFtdO1xuICAgIHdoaWxlIChlbmZfNjIucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICByZXN1bHRfNjMucHVzaChlbmZfNjIuZW5mb3Jlc3RJbXBvcnRTcGVjaWZpZXJzKCkpO1xuICAgICAgZW5mXzYyLmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHRfNjMpO1xuICB9XG4gIGVuZm9yZXN0SW1wb3J0U3BlY2lmaWVycygpIHtcbiAgICBsZXQgbG9va2FoZWFkXzY0ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IG5hbWVfNjU7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF82NCkgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzY0KSkge1xuICAgICAgbmFtZV82NSA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgXCJhc1wiKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG51bGwsIGJpbmRpbmc6IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfNjV9KX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRjaElkZW50aWZpZXIoXCJhc1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihsb29rYWhlYWRfNjQsIFwidW5leHBlY3RlZCB0b2tlbiBpbiBpbXBvcnQgc3BlY2lmaWVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJbXBvcnRTcGVjaWZpZXJcIiwge25hbWU6IG5hbWVfNjUsIGJpbmRpbmc6IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpfSk7XG4gIH1cbiAgZW5mb3Jlc3RGcm9tQ2xhdXNlKCkge1xuICAgIHRoaXMubWF0Y2hJZGVudGlmaWVyKFwiZnJvbVwiKTtcbiAgICBsZXQgbG9va2FoZWFkXzY2ID0gdGhpcy5tYXRjaFN0cmluZ0xpdGVyYWwoKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbG9va2FoZWFkXzY2O1xuICB9XG4gIGVuZm9yZXN0U3RhdGVtZW50TGlzdEl0ZW0oKSB7XG4gICAgbGV0IGxvb2thaGVhZF82NyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb25EZWNsYXJhdGlvbih7aXNFeHByOiBmYWxzZX0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzY3LCBcImNsYXNzXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdENsYXNzKHtpc0V4cHI6IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgfVxuICB9XG4gIGVuZm9yZXN0U3RhdGVtZW50KCkge1xuICAgIGxldCBsb29rYWhlYWRfNjggPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNDb21waWxldGltZVRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICB0aGlzLnJlc3QgPSB0aGlzLmV4cGFuZE1hY3JvKCkuY29uY2F0KHRoaXMucmVzdCk7XG4gICAgICBsb29rYWhlYWRfNjggPSB0aGlzLnBlZWsoKTtcbiAgICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyYWNlcyhsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJsb2NrU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1doaWxlVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0V2hpbGVTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzSWZUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RJZlN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNGb3JUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RGb3JTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3dpdGNoVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3dpdGNoU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyZWFrVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QnJlYWtTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQ29udGludWVUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb250aW51ZVN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNEb1RyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdERvU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0RlYnVnZ2VyVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzV2l0aFRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFdpdGhTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVHJ5VHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VHJ5U3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1Rocm93VHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VGhyb3dTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNjgsIFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogZmFsc2V9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF82OCkgJiYgdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKDEpLCBcIjpcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TGFiZWxlZFN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmICh0aGlzLmlzVmFyRGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNjgpIHx8IHRoaXMuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkgfHwgdGhpcy5pc0NvbnN0RGVjbFRyYW5zZm9ybShsb29rYWhlYWRfNjgpIHx8IHRoaXMuaXNTeW50YXhyZWNEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF82OCkgfHwgdGhpcy5pc1N5bnRheERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzY4KSkpIHtcbiAgICAgIGxldCBzdG10ID0gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRpb24oKX0pO1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzUmV0dXJuU3RtdFRyYW5zZm9ybShsb29rYWhlYWRfNjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFJldHVyblN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF82OCwgXCI7XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkVtcHR5U3RhdGVtZW50XCIsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uU3RhdGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RMYWJlbGVkU3RhdGVtZW50KCkge1xuICAgIGxldCBsYWJlbF82OSA9IHRoaXMubWF0Y2hJZGVudGlmaWVyKCk7XG4gICAgbGV0IHB1bmNfNzAgPSB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgbGV0IHN0bXRfNzEgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiTGFiZWxlZFN0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzY5LCBib2R5OiBzdG10XzcxfSk7XG4gIH1cbiAgZW5mb3Jlc3RCcmVha1N0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcImJyZWFrXCIpO1xuICAgIGxldCBsb29rYWhlYWRfNzIgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgbGFiZWxfNzMgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfNzIsIFwiO1wiKSkge1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJCcmVha1N0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzczfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfNzIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF83MiwgXCJ5aWVsZFwiKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfNzIsIFwibGV0XCIpKSB7XG4gICAgICBsYWJlbF83MyA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJyZWFrU3RhdGVtZW50XCIsIHtsYWJlbDogbGFiZWxfNzN9KTtcbiAgfVxuICBlbmZvcmVzdFRyeVN0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcInRyeVwiKTtcbiAgICBsZXQgYm9keV83NCA9IHRoaXMuZW5mb3Jlc3RCbG9jaygpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJjYXRjaFwiKSkge1xuICAgICAgbGV0IGNhdGNoQ2xhdXNlID0gdGhpcy5lbmZvcmVzdENhdGNoQ2xhdXNlKCk7XG4gICAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZmluYWxseVwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGZpbmFsaXplciA9IHRoaXMuZW5mb3Jlc3RCbG9jaygpO1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlGaW5hbGx5U3RhdGVtZW50XCIsIHtib2R5OiBib2R5Xzc0LCBjYXRjaENsYXVzZTogY2F0Y2hDbGF1c2UsIGZpbmFsaXplcjogZmluYWxpemVyfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlDYXRjaFN0YXRlbWVudFwiLCB7Ym9keTogYm9keV83NCwgY2F0Y2hDbGF1c2U6IGNhdGNoQ2xhdXNlfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJmaW5hbGx5XCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBmaW5hbGl6ZXIgPSB0aGlzLmVuZm9yZXN0QmxvY2soKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIiwge2JvZHk6IGJvZHlfNzQsIGNhdGNoQ2xhdXNlOiBudWxsLCBmaW5hbGl6ZXI6IGZpbmFsaXplcn0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKHRoaXMucGVlaygpLCBcInRyeSB3aXRoIG5vIGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gIH1cbiAgZW5mb3Jlc3RDYXRjaENsYXVzZSgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcImNhdGNoXCIpO1xuICAgIGxldCBiaW5kaW5nUGFyZW5zXzc1ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfNzYgPSBuZXcgRW5mb3Jlc3Rlcl80NChiaW5kaW5nUGFyZW5zXzc1LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGJpbmRpbmdfNzcgPSBlbmZfNzYuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgbGV0IGJvZHlfNzggPSB0aGlzLmVuZm9yZXN0QmxvY2soKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDYXRjaENsYXVzZVwiLCB7YmluZGluZzogYmluZGluZ183NywgYm9keTogYm9keV83OH0pO1xuICB9XG4gIGVuZm9yZXN0VGhyb3dTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJ0aHJvd1wiKTtcbiAgICBsZXQgZXhwcmVzc2lvbl83OSA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVGhyb3dTdGF0ZW1lbnRcIiwge2V4cHJlc3Npb246IGV4cHJlc3Npb25fNzl9KTtcbiAgfVxuICBlbmZvcmVzdFdpdGhTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJ3aXRoXCIpO1xuICAgIGxldCBvYmpQYXJlbnNfODAgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl84MSA9IG5ldyBFbmZvcmVzdGVyXzQ0KG9ialBhcmVuc184MCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBvYmplY3RfODIgPSBlbmZfODEuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgbGV0IGJvZHlfODMgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiV2l0aFN0YXRlbWVudFwiLCB7b2JqZWN0OiBvYmplY3RfODIsIGJvZHk6IGJvZHlfODN9KTtcbiAgfVxuICBlbmZvcmVzdERlYnVnZ2VyU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZGVidWdnZXJcIik7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwge30pO1xuICB9XG4gIGVuZm9yZXN0RG9TdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJkb1wiKTtcbiAgICBsZXQgYm9keV84NCA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcIndoaWxlXCIpO1xuICAgIGxldCB0ZXN0Qm9keV84NSA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICBsZXQgZW5mXzg2ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGVzdEJvZHlfODUsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgdGVzdF84NyA9IGVuZl84Ni5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJEb1doaWxlU3RhdGVtZW50XCIsIHtib2R5OiBib2R5Xzg0LCB0ZXN0OiB0ZXN0Xzg3fSk7XG4gIH1cbiAgZW5mb3Jlc3RDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICBsZXQga3dkXzg4ID0gdGhpcy5tYXRjaEtleXdvcmQoXCJjb250aW51ZVwiKTtcbiAgICBsZXQgbG9va2FoZWFkXzg5ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IGxhYmVsXzkwID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDAgfHwgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzg5LCBcIjtcIikpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29udGludWVTdGF0ZW1lbnRcIiwge2xhYmVsOiBsYWJlbF85MH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5saW5lTnVtYmVyRXEoa3dkXzg4LCBsb29rYWhlYWRfODkpICYmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfODkpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF84OSwgXCJ5aWVsZFwiKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfODksIFwibGV0XCIpKSkge1xuICAgICAgbGFiZWxfOTAgPSB0aGlzLmVuZm9yZXN0SWRlbnRpZmllcigpO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb250aW51ZVN0YXRlbWVudFwiLCB7bGFiZWw6IGxhYmVsXzkwfSk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJzd2l0Y2hcIik7XG4gICAgbGV0IGNvbmRfOTEgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl85MiA9IG5ldyBFbmZvcmVzdGVyXzQ0KGNvbmRfOTEsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgZGlzY3JpbWluYW50XzkzID0gZW5mXzkyLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgIGxldCBib2R5Xzk0ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICBpZiAoYm9keV85NC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge2Rpc2NyaW1pbmFudDogZGlzY3JpbWluYW50XzkzLCBjYXNlczogTGlzdCgpfSk7XG4gICAgfVxuICAgIGVuZl85MiA9IG5ldyBFbmZvcmVzdGVyXzQ0KGJvZHlfOTQsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgY2FzZXNfOTUgPSBlbmZfOTIuZW5mb3Jlc3RTd2l0Y2hDYXNlcygpO1xuICAgIGxldCBsb29rYWhlYWRfOTYgPSBlbmZfOTIucGVlaygpO1xuICAgIGlmIChlbmZfOTIuaXNLZXl3b3JkKGxvb2thaGVhZF85NiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICBsZXQgZGVmYXVsdENhc2UgPSBlbmZfOTIuZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0KCk7XG4gICAgICBsZXQgcG9zdERlZmF1bHRDYXNlcyA9IGVuZl85Mi5lbmZvcmVzdFN3aXRjaENhc2VzKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwiLCB7ZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnRfOTMsIHByZURlZmF1bHRDYXNlczogY2FzZXNfOTUsIGRlZmF1bHRDYXNlOiBkZWZhdWx0Q2FzZSwgcG9zdERlZmF1bHRDYXNlczogcG9zdERlZmF1bHRDYXNlc30pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge2Rpc2NyaW1pbmFudDogZGlzY3JpbWluYW50XzkzLCBjYXNlczogY2FzZXNfOTV9KTtcbiAgfVxuICBlbmZvcmVzdFN3aXRjaENhc2VzKCkge1xuICAgIGxldCBjYXNlc185NyA9IFtdO1xuICAgIHdoaWxlICghKHRoaXMucmVzdC5zaXplID09PSAwIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImRlZmF1bHRcIikpKSB7XG4gICAgICBjYXNlc185Ny5wdXNoKHRoaXMuZW5mb3Jlc3RTd2l0Y2hDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChjYXNlc185Nyk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hDYXNlKCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiY2FzZVwiKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hDYXNlXCIsIHt0ZXN0OiB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbigpLCBjb25zZXF1ZW50OiB0aGlzLmVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKX0pO1xuICB9XG4gIGVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCI6XCIpO1xuICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50TGlzdEluU3dpdGNoQ2FzZUJvZHkoKTtcbiAgfVxuICBlbmZvcmVzdFN0YXRlbWVudExpc3RJblN3aXRjaENhc2VCb2R5KCkge1xuICAgIGxldCByZXN1bHRfOTggPSBbXTtcbiAgICB3aGlsZSAoISh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJkZWZhdWx0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcImNhc2VcIikpKSB7XG4gICAgICByZXN1bHRfOTgucHVzaCh0aGlzLmVuZm9yZXN0U3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF85OCk7XG4gIH1cbiAgZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZGVmYXVsdFwiKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hEZWZhdWx0XCIsIHtjb25zZXF1ZW50OiB0aGlzLmVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKX0pO1xuICB9XG4gIGVuZm9yZXN0Rm9yU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwiZm9yXCIpO1xuICAgIGxldCBjb25kXzk5ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfMTAwID0gbmV3IEVuZm9yZXN0ZXJfNDQoY29uZF85OSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTAxLCB0ZXN0XzEwMiwgaW5pdF8xMDMsIHJpZ2h0XzEwNCwgdHlwZV8xMDUsIGxlZnRfMTA2LCB1cGRhdGVfMTA3O1xuICAgIGlmIChlbmZfMTAwLmlzUHVuY3R1YXRvcihlbmZfMTAwLnBlZWsoKSwgXCI7XCIpKSB7XG4gICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgIGlmICghZW5mXzEwMC5pc1B1bmN0dWF0b3IoZW5mXzEwMC5wZWVrKCksIFwiO1wiKSkge1xuICAgICAgICB0ZXN0XzEwMiA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgICBlbmZfMTAwLm1hdGNoUHVuY3R1YXRvcihcIjtcIik7XG4gICAgICBpZiAoZW5mXzEwMC5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgcmlnaHRfMTA0ID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybShcIkZvclN0YXRlbWVudFwiLCB7aW5pdDogbnVsbCwgdGVzdDogdGVzdF8xMDIsIHVwZGF0ZTogcmlnaHRfMTA0LCBib2R5OiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9va2FoZWFkXzEwMSA9IGVuZl8xMDAucGVlaygpO1xuICAgICAgaWYgKGVuZl8xMDAuaXNWYXJEZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xMDEpIHx8IGVuZl8xMDAuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZF8xMDEpIHx8IGVuZl8xMDAuaXNDb25zdERlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzEwMSkpIHtcbiAgICAgICAgaW5pdF8xMDMgPSBlbmZfMTAwLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICBsb29rYWhlYWRfMTAxID0gZW5mXzEwMC5wZWVrKCk7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTAxLCBcImluXCIpIHx8IHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xMDEsIFwib2ZcIikpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkXzEwMSwgXCJpblwiKSkge1xuICAgICAgICAgICAgZW5mXzEwMC5hZHZhbmNlKCk7XG4gICAgICAgICAgICByaWdodF8xMDQgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgdHlwZV8xMDUgPSBcIkZvckluU3RhdGVtZW50XCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTAxLCBcIm9mXCIpKSB7XG4gICAgICAgICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJpZ2h0XzEwNCA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB0eXBlXzEwNSA9IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA1LCB7bGVmdDogaW5pdF8xMDMsIHJpZ2h0OiByaWdodF8xMDQsIGJvZHk6IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKX0pO1xuICAgICAgICB9XG4gICAgICAgIGVuZl8xMDAubWF0Y2hQdW5jdHVhdG9yKFwiO1wiKTtcbiAgICAgICAgaWYgKGVuZl8xMDAuaXNQdW5jdHVhdG9yKGVuZl8xMDAucGVlaygpLCBcIjtcIikpIHtcbiAgICAgICAgICBlbmZfMTAwLmFkdmFuY2UoKTtcbiAgICAgICAgICB0ZXN0XzEwMiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVzdF8xMDIgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgIGVuZl8xMDAubWF0Y2hQdW5jdHVhdG9yKFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVfMTA3ID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChlbmZfMTAwLnBlZWsoMSksIFwiaW5cIikgfHwgdGhpcy5pc0lkZW50aWZpZXIoZW5mXzEwMC5wZWVrKDEpLCBcIm9mXCIpKSB7XG4gICAgICAgICAgbGVmdF8xMDYgPSBlbmZfMTAwLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoKTtcbiAgICAgICAgICBsZXQga2luZCA9IGVuZl8xMDAuYWR2YW5jZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmlzS2V5d29yZChraW5kLCBcImluXCIpKSB7XG4gICAgICAgICAgICB0eXBlXzEwNSA9IFwiRm9ySW5TdGF0ZW1lbnRcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZV8xMDUgPSBcIkZvck9mU3RhdGVtZW50XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0XzEwNCA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA1LCB7bGVmdDogbGVmdF8xMDYsIHJpZ2h0OiByaWdodF8xMDQsIGJvZHk6IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKX0pO1xuICAgICAgICB9XG4gICAgICAgIGluaXRfMTAzID0gZW5mXzEwMC5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgICAgZW5mXzEwMC5tYXRjaFB1bmN0dWF0b3IoXCI7XCIpO1xuICAgICAgICBpZiAoZW5mXzEwMC5pc1B1bmN0dWF0b3IoZW5mXzEwMC5wZWVrKCksIFwiO1wiKSkge1xuICAgICAgICAgIGVuZl8xMDAuYWR2YW5jZSgpO1xuICAgICAgICAgIHRlc3RfMTAyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXN0XzEwMiA9IGVuZl8xMDAuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZW5mXzEwMC5tYXRjaFB1bmN0dWF0b3IoXCI7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZV8xMDcgPSBlbmZfMTAwLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yU3RhdGVtZW50XCIsIHtpbml0OiBpbml0XzEwMywgdGVzdDogdGVzdF8xMDIsIHVwZGF0ZTogdXBkYXRlXzEwNywgYm9keTogdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpfSk7XG4gICAgfVxuICB9XG4gIGVuZm9yZXN0SWZTdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoXCJpZlwiKTtcbiAgICBsZXQgY29uZF8xMDggPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZl8xMDkgPSBuZXcgRW5mb3Jlc3Rlcl80NChjb25kXzEwOCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTEwID0gZW5mXzEwOS5wZWVrKCk7XG4gICAgbGV0IHRlc3RfMTExID0gZW5mXzEwOS5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICBpZiAodGVzdF8xMTEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVuZl8xMDkuY3JlYXRlRXJyb3IobG9va2FoZWFkXzExMCwgXCJleHBlY3RpbmcgYW4gZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgbGV0IGNvbnNlcXVlbnRfMTEyID0gdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgIGxldCBhbHRlcm5hdGVfMTEzID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwiZWxzZVwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBhbHRlcm5hdGVfMTEzID0gdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJJZlN0YXRlbWVudFwiLCB7dGVzdDogdGVzdF8xMTEsIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnRfMTEyLCBhbHRlcm5hdGU6IGFsdGVybmF0ZV8xMTN9KTtcbiAgfVxuICBlbmZvcmVzdFdoaWxlU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKFwid2hpbGVcIik7XG4gICAgbGV0IGNvbmRfMTE0ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmZfMTE1ID0gbmV3IEVuZm9yZXN0ZXJfNDQoY29uZF8xMTQsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgbG9va2FoZWFkXzExNiA9IGVuZl8xMTUucGVlaygpO1xuICAgIGxldCB0ZXN0XzExNyA9IGVuZl8xMTUuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRlc3RfMTE3ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBlbmZfMTE1LmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMTYsIFwiZXhwZWN0aW5nIGFuIGV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIGxldCBib2R5XzExOCA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaGlsZVN0YXRlbWVudFwiLCB7dGVzdDogdGVzdF8xMTcsIGJvZHk6IGJvZHlfMTE4fSk7XG4gIH1cbiAgZW5mb3Jlc3RCbG9ja1N0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCbG9ja1N0YXRlbWVudFwiLCB7YmxvY2s6IHRoaXMuZW5mb3Jlc3RCbG9jaygpfSk7XG4gIH1cbiAgZW5mb3Jlc3RCbG9jaygpIHtcbiAgICBsZXQgYl8xMTkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBib2R5XzEyMCA9IFtdO1xuICAgIGxldCBlbmZfMTIxID0gbmV3IEVuZm9yZXN0ZXJfNDQoYl8xMTksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoZW5mXzEyMS5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGxldCBsb29rYWhlYWQgPSBlbmZfMTIxLnBlZWsoKTtcbiAgICAgIGxldCBzdG10ID0gZW5mXzEyMS5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgICAgaWYgKHN0bXQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlbmZfMTIxLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgXCJub3QgYSBzdGF0ZW1lbnRcIik7XG4gICAgICB9XG4gICAgICBib2R5XzEyMC5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCbG9ja1wiLCB7c3RhdGVtZW50czogTGlzdChib2R5XzEyMCl9KTtcbiAgfVxuICBlbmZvcmVzdENsYXNzKHtpc0V4cHIsIGluRGVmYXVsdH0pIHtcbiAgICBsZXQga3dfMTIyID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IG5hbWVfMTIzID0gbnVsbCwgc3Vwcl8xMjQgPSBudWxsO1xuICAgIGxldCB0eXBlXzEyNSA9IGlzRXhwciA/IFwiQ2xhc3NFeHByZXNzaW9uXCIgOiBcIkNsYXNzRGVjbGFyYXRpb25cIjtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCkpKSB7XG4gICAgICBuYW1lXzEyMyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgIH0gZWxzZSBpZiAoIWlzRXhwcikge1xuICAgICAgaWYgKGluRGVmYXVsdCkge1xuICAgICAgICBuYW1lXzEyMyA9IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IFN5bnRheC5mcm9tSWRlbnRpZmllcihcIl9kZWZhdWx0XCIsIGt3XzEyMil9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IodGhpcy5wZWVrKCksIFwidW5leHBlY3RlZCBzeW50YXhcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgXCJleHRlbmRzXCIpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHN1cHJfMTI0ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgfVxuICAgIGxldCBlbGVtZW50c18xMjYgPSBbXTtcbiAgICBsZXQgZW5mXzEyNyA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hDdXJsaWVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoZW5mXzEyNy5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGlmIChlbmZfMTI3LmlzUHVuY3R1YXRvcihlbmZfMTI3LnBlZWsoKSwgXCI7XCIpKSB7XG4gICAgICAgIGVuZl8xMjcuYWR2YW5jZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgbGV0IHttZXRob2RPcktleSwga2luZH0gPSBlbmZfMTI3LmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaWRlbnRpZmllclwiICYmIG1ldGhvZE9yS2V5LnZhbHVlLnZhbCgpID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgKHttZXRob2RPcktleSwga2luZH0gPSBlbmZfMTI3LmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBcIm1ldGhvZFwiKSB7XG4gICAgICAgIGVsZW1lbnRzXzEyNi5wdXNoKG5ldyBUZXJtKFwiQ2xhc3NFbGVtZW50XCIsIHtpc1N0YXRpYzogaXNTdGF0aWMsIG1ldGhvZDogbWV0aG9kT3JLZXl9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGVuZl8xMjcucGVlaygpLCBcIk9ubHkgbWV0aG9kcyBhcmUgYWxsb3dlZCBpbiBjbGFzc2VzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8xMjUsIHtuYW1lOiBuYW1lXzEyMywgc3VwZXI6IHN1cHJfMTI0LCBlbGVtZW50czogTGlzdChlbGVtZW50c18xMjYpfSk7XG4gIH1cbiAgZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KHthbGxvd1B1bmN0dWF0b3J9ID0ge30pIHtcbiAgICBsZXQgbG9va2FoZWFkXzEyOCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTI4KSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTI4KSB8fCBhbGxvd1B1bmN0dWF0b3IgJiYgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzEyOCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoe2FsbG93UHVuY3R1YXRvcjogYWxsb3dQdW5jdHVhdG9yfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2tldHMobG9va2FoZWFkXzEyOCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QXJyYXlCaW5kaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF8xMjgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE9iamVjdEJpbmRpbmcoKTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIH1cbiAgZW5mb3Jlc3RPYmplY3RCaW5kaW5nKCkge1xuICAgIGxldCBlbmZfMTI5ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBwcm9wZXJ0aWVzXzEzMCA9IFtdO1xuICAgIHdoaWxlIChlbmZfMTI5LnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcHJvcGVydGllc18xMzAucHVzaChlbmZfMTI5LmVuZm9yZXN0QmluZGluZ1Byb3BlcnR5KCkpO1xuICAgICAgZW5mXzEyOS5jb25zdW1lQ29tbWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiT2JqZWN0QmluZGluZ1wiLCB7cHJvcGVydGllczogTGlzdChwcm9wZXJ0aWVzXzEzMCl9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmRpbmdQcm9wZXJ0eSgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzEzMSA9IHRoaXMucGVlaygpO1xuICAgIGxldCB7bmFtZSwgYmluZGluZ30gPSB0aGlzLmVuZm9yZXN0UHJvcGVydHlOYW1lKCk7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xMzEpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xMzEsIFwibGV0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xMzEsIFwieWllbGRcIikpIHtcbiAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiOlwiKSkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3NpZ24odGhpcy5wZWVrKCkpKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgbGV0IGV4cHIgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBleHByO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJcIiwge2JpbmRpbmc6IGJpbmRpbmcsIGluaXQ6IGRlZmF1bHRWYWx1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgYmluZGluZyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5XCIsIHtuYW1lOiBuYW1lLCBiaW5kaW5nOiBiaW5kaW5nfSk7XG4gIH1cbiAgZW5mb3Jlc3RBcnJheUJpbmRpbmcoKSB7XG4gICAgbGV0IGJyYWNrZXRfMTMyID0gdGhpcy5tYXRjaFNxdWFyZXMoKTtcbiAgICBsZXQgZW5mXzEzMyA9IG5ldyBFbmZvcmVzdGVyXzQ0KGJyYWNrZXRfMTMyLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGVsZW1lbnRzXzEzNCA9IFtdLCByZXN0RWxlbWVudF8xMzUgPSBudWxsO1xuICAgIHdoaWxlIChlbmZfMTMzLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgbGV0IGVsO1xuICAgICAgaWYgKGVuZl8xMzMuaXNQdW5jdHVhdG9yKGVuZl8xMzMucGVlaygpLCBcIixcIikpIHtcbiAgICAgICAgZW5mXzEzMy5jb25zdW1lQ29tbWEoKTtcbiAgICAgICAgZWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVuZl8xMzMuaXNQdW5jdHVhdG9yKGVuZl8xMzMucGVlaygpLCBcIi4uLlwiKSkge1xuICAgICAgICAgIGVuZl8xMzMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJlc3RFbGVtZW50XzEzNSA9IGVuZl8xMzMuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwgPSBlbmZfMTMzLmVuZm9yZXN0QmluZGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbmZfMTMzLmNvbnN1bWVDb21tYSgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudHNfMTM0LnB1c2goZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiBMaXN0KGVsZW1lbnRzXzEzNCksIHJlc3RFbGVtZW50OiByZXN0RWxlbWVudF8xMzV9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmRpbmdFbGVtZW50KCkge1xuICAgIGxldCBiaW5kaW5nXzEzNiA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgaWYgKHRoaXMuaXNBc3NpZ24odGhpcy5wZWVrKCkpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBpbml0ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICBiaW5kaW5nXzEzNiA9IG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiBiaW5kaW5nXzEzNiwgaW5pdDogaW5pdH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ18xMzY7XG4gIH1cbiAgZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcih7YWxsb3dQdW5jdHVhdG9yfSA9IHt9KSB7XG4gICAgbGV0IG5hbWVfMTM3O1xuICAgIGlmIChhbGxvd1B1bmN0dWF0b3IgJiYgdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCkpKSB7XG4gICAgICBuYW1lXzEzNyA9IHRoaXMuZW5mb3Jlc3RQdW5jdHVhdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVfMTM3ID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfMTM3fSk7XG4gIH1cbiAgZW5mb3Jlc3RQdW5jdHVhdG9yKCkge1xuICAgIGxldCBsb29rYWhlYWRfMTM4ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xMzgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzEzOCwgXCJleHBlY3RpbmcgYSBwdW5jdHVhdG9yXCIpO1xuICB9XG4gIGVuZm9yZXN0SWRlbnRpZmllcigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzEzOSA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTM5KSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTM5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMzksIFwiZXhwZWN0aW5nIGFuIGlkZW50aWZpZXJcIik7XG4gIH1cbiAgZW5mb3Jlc3RSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgbGV0IGt3XzE0MCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGxldCBsb29rYWhlYWRfMTQxID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMucmVzdC5zaXplID09PSAwIHx8IGxvb2thaGVhZF8xNDEgJiYgIXRoaXMubGluZU51bWJlckVxKGt3XzE0MCwgbG9va2FoZWFkXzE0MSkpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlJldHVyblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogbnVsbH0pO1xuICAgIH1cbiAgICBsZXQgdGVybV8xNDIgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE0MSwgXCI7XCIpKSB7XG4gICAgICB0ZXJtXzE0MiA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QodGVybV8xNDIgIT0gbnVsbCwgXCJFeHBlY3RpbmcgYW4gZXhwcmVzc2lvbiB0byBmb2xsb3cgcmV0dXJuIGtleXdvcmRcIiwgbG9va2FoZWFkXzE0MSwgdGhpcy5yZXN0KTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiB0ZXJtXzE0Mn0pO1xuICB9XG4gIGVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQga2luZF8xNDM7XG4gICAgbGV0IGxvb2thaGVhZF8xNDQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBsZXQga2luZFN5bl8xNDUgPSBsb29rYWhlYWRfMTQ0O1xuICAgIGxldCBwaGFzZV8xNDYgPSB0aGlzLmNvbnRleHQucGhhc2U7XG4gICAgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFZhcmlhYmxlRGVjbFRyYW5zZm9ybSkge1xuICAgICAga2luZF8xNDMgPSBcInZhclwiO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5bl8xNDUgJiYgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bl8xNDUucmVzb2x2ZShwaGFzZV8xNDYpKSA9PT0gTGV0RGVjbFRyYW5zZm9ybSkge1xuICAgICAga2luZF8xNDMgPSBcImxldFwiO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5bl8xNDUgJiYgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bl8xNDUucmVzb2x2ZShwaGFzZV8xNDYpKSA9PT0gQ29uc3REZWNsVHJhbnNmb3JtKSB7XG4gICAgICBraW5kXzE0MyA9IFwiY29uc3RcIjtcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFN5bnRheERlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmRfMTQzID0gXCJzeW50YXhcIjtcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW5fMTQ1ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW5fMTQ1LnJlc29sdmUocGhhc2VfMTQ2KSkgPT09IFN5bnRheHJlY0RlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmRfMTQzID0gXCJzeW50YXhyZWNcIjtcbiAgICB9XG4gICAgbGV0IGRlY2xzXzE0NyA9IExpc3QoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdG9yKHtpc1N5bnRheDoga2luZF8xNDMgPT09IFwic3ludGF4XCIgfHwga2luZF8xNDMgPT09IFwic3ludGF4cmVjXCJ9KTtcbiAgICAgIGxldCBsb29rYWhlYWRfMTQ0ID0gdGhpcy5wZWVrKCk7XG4gICAgICBkZWNsc18xNDcgPSBkZWNsc18xNDcuY29uY2F0KHRlcm0pO1xuICAgICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNDQsIFwiLFwiKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtraW5kOiBraW5kXzE0MywgZGVjbGFyYXRvcnM6IGRlY2xzXzE0N30pO1xuICB9XG4gIGVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdG9yKHtpc1N5bnRheH0pIHtcbiAgICBsZXQgaWRfMTQ4ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdUYXJnZXQoe2FsbG93UHVuY3R1YXRvcjogaXNTeW50YXh9KTtcbiAgICBsZXQgbG9va2FoZWFkXzE0OSA9IHRoaXMucGVlaygpO1xuICAgIGxldCBpbml0XzE1MCwgcmVzdF8xNTE7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNDksIFwiPVwiKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5yZXN0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBpbml0XzE1MCA9IGVuZi5lbmZvcmVzdChcImV4cHJlc3Npb25cIik7XG4gICAgICB0aGlzLnJlc3QgPSBlbmYucmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdF8xNTAgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwge2JpbmRpbmc6IGlkXzE0OCwgaW5pdDogaW5pdF8xNTB9KTtcbiAgfVxuICBlbmZvcmVzdEV4cHJlc3Npb25TdGF0ZW1lbnQoKSB7XG4gICAgbGV0IHN0YXJ0XzE1MiA9IHRoaXMucmVzdC5nZXQoMCk7XG4gICAgbGV0IGV4cHJfMTUzID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICBpZiAoZXhwcl8xNTMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3Ioc3RhcnRfMTUyLCBcIm5vdCBhIHZhbGlkIGV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwge2V4cHJlc3Npb246IGV4cHJfMTUzfSk7XG4gIH1cbiAgZW5mb3Jlc3RFeHByZXNzaW9uKCkge1xuICAgIGxldCBsZWZ0XzE1NCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIGxldCBsb29rYWhlYWRfMTU1ID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xNTUsIFwiLFwiKSkge1xuICAgICAgd2hpbGUgKHRoaXMucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiLFwiKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVyYXRvciA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgbGVmdF8xNTQgPSBuZXcgVGVybShcIkJpbmFyeUV4cHJlc3Npb25cIiwge2xlZnQ6IGxlZnRfMTU0LCBvcGVyYXRvcjogb3BlcmF0b3IsIHJpZ2h0OiByaWdodH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRlcm0gPSBudWxsO1xuICAgIHJldHVybiBsZWZ0XzE1NDtcbiAgfVxuICBlbmZvcmVzdEV4cHJlc3Npb25Mb29wKCkge1xuICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgdGhpcy5vcEN0eCA9IHtwcmVjOiAwLCBjb21iaW5lOiB4XzE1NiA9PiB4XzE1Niwgc3RhY2s6IExpc3QoKX07XG4gICAgZG8ge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLmVuZm9yZXN0QXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0ZXJtID09PSBFWFBSX0xPT1BfTk9fQ0hBTkdFXzQyICYmIHRoaXMub3BDdHguc3RhY2suc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5vcEN0eC5jb21iaW5lKHRoaXMudGVybSk7XG4gICAgICAgIGxldCB7cHJlYywgY29tYmluZX0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgICAgdGhpcy5vcEN0eC5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5vcEN0eC5zdGFjayA9IHRoaXMub3BDdHguc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9OT19DSEFOR0VfNDIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9PUEVSQVRPUl80MSB8fCB0ZXJtID09PSBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzKSB7XG4gICAgICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cbiAgZW5mb3Jlc3RBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE1NyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1Rlcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQ29tcGlsZXRpbWVUcmFuc2Zvcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmV4cGFuZE1hY3JvKCk7XG4gICAgICB0aGlzLnJlc3QgPSByZXN1bHQuY29uY2F0KHRoaXMucmVzdCk7XG4gICAgICByZXR1cm4gRVhQUl9MT09QX0VYUEFOU0lPTl80MztcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTU3LCBcInlpZWxkXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFlpZWxkRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogdHJ1ZX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwic3VwZXJcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiU3VwZXJcIiwge30pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTU3KSB8fCB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZF8xNTcpKSAmJiB0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoMSksIFwiPT5cIikgJiYgdGhpcy5saW5lTnVtYmVyRXEobG9va2FoZWFkXzE1NywgdGhpcy5wZWVrKDEpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3ludGF4VGVtcGxhdGUobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3ludGF4VGVtcGxhdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3ludGF4UXVvdGVUcmFuc2Zvcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3ludGF4UXVvdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzTmV3VHJhbnNmb3JtKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE5ld0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTU3LCBcInRoaXNcIikpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRoaXNFeHByZXNzaW9uXCIsIHtzdHg6IHRoaXMuYWR2YW5jZSgpfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZF8xNTcpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwibGV0XCIpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZF8xNTcsIFwieWllbGRcIikpKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJJZGVudGlmaWVyRXhwcmVzc2lvblwiLCB7bmFtZTogdGhpcy5hZHZhbmNlKCl9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzTnVtZXJpY0xpdGVyYWwobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIGxldCBudW0gPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGlmIChudW0udmFsKCkgPT09IDEgLyAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxJbmZpbml0eUV4cHJlc3Npb25cIiwge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uXCIsIHt2YWx1ZTogbnVtfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1N0cmluZ0xpdGVyYWwobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkxpdGVyYWxTdHJpbmdFeHByZXNzaW9uXCIsIHt2YWx1ZTogdGhpcy5hZHZhbmNlKCl9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVGVtcGxhdGUobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiBudWxsLCBlbGVtZW50czogdGhpcy5lbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNCb29sZWFuTGl0ZXJhbChsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uXCIsIHt2YWx1ZTogdGhpcy5hZHZhbmNlKCl9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzTnVsbExpdGVyYWwobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbE51bGxFeHByZXNzaW9uXCIsIHt9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzUmVndWxhckV4cHJlc3Npb24obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIGxldCByZVN0eCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IGxhc3RTbGFzaCA9IHJlU3R4LnRva2VuLnZhbHVlLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgIGxldCBwYXR0ZXJuID0gcmVTdHgudG9rZW4udmFsdWUuc2xpY2UoMSwgbGFzdFNsYXNoKTtcbiAgICAgIGxldCBmbGFncyA9IHJlU3R4LnRva2VuLnZhbHVlLnNsaWNlKGxhc3RTbGFzaCArIDEpO1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25cIiwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFnc30pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNQYXJlbnMobG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIHtpbm5lcjogdGhpcy5hZHZhbmNlKCkuaW5uZXIoKX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNGbkRlY2xUcmFuc2Zvcm0obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb25FeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyYWNlcyhsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RPYmplY3RFeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEFycmF5RXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNPcGVyYXRvcihsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RVbmFyeUV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVmFyQmluZGluZ1RyYW5zZm9ybShsb29rYWhlYWRfMTU3KSkge1xuICAgICAgbGV0IGlkID0gdGhpcy5nZXRGcm9tQ29tcGlsZXRpbWVFbnZpcm9ubWVudChsb29rYWhlYWRfMTU3KS5pZDtcbiAgICAgIGlmIChpZCAhPT0gbG9va2FoZWFkXzE1Nykge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5yZXN0ID0gTGlzdC5vZihpZCkuY29uY2F0KHRoaXMucmVzdCk7XG4gICAgICAgIHJldHVybiBFWFBSX0xPT1BfRVhQQU5TSU9OXzQzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNVcGRhdGVPcGVyYXRvcihsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc09wZXJhdG9yKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmFyeUV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMTU3LCBcIi5cIikgJiYgKHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSkgfHwgdGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKDEpKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGljTWVtYmVyRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWRfMTU3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb21wdXRlZE1lbWJlckV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICBsZXQgcGFyZW4gPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIkNhbGxFeHByZXNzaW9uXCIsIHtjYWxsZWU6IHRoaXMudGVybSwgYXJndW1lbnRzOiBwYXJlbi5pbm5lcigpfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZF8xNTcpKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJUZW1wbGF0ZUV4cHJlc3Npb25cIiwge3RhZzogdGhpcy50ZXJtLCBlbGVtZW50czogdGhpcy5lbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKX0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNBc3NpZ24obG9va2FoZWFkXzE1NykpIHtcbiAgICAgIGxldCBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRoaXMudGVybSk7XG4gICAgICBsZXQgb3AgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBpbml0ID0gZW5mLmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzdCA9IGVuZi5yZXN0O1xuICAgICAgaWYgKG9wLnZhbCgpID09PSBcIj1cIikge1xuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogYmluZGluZywgZXhwcmVzc2lvbjogaW5pdH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogYmluZGluZywgb3BlcmF0b3I6IG9wLnZhbCgpLCBleHByZXNzaW9uOiBpbml0fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE1NywgXCI/XCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdENvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gRVhQUl9MT09QX05PX0NIQU5HRV80MjtcbiAgfVxuICBlbmZvcmVzdEFyZ3VtZW50TGlzdCgpIHtcbiAgICBsZXQgcmVzdWx0XzE1OCA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgIGxldCBhcmc7XG4gICAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiLi4uXCIpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBhcmcgPSBuZXcgVGVybShcIlNwcmVhZEVsZW1lbnRcIiwge2V4cHJlc3Npb246IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmcgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoXCIsXCIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0XzE1OC5wdXNoKGFyZyk7XG4gICAgfVxuICAgIHJldHVybiBMaXN0KHJlc3VsdF8xNTgpO1xuICB9XG4gIGVuZm9yZXN0TmV3RXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZChcIm5ld1wiKTtcbiAgICBsZXQgY2FsbGVlXzE1OTtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksIFwibmV3XCIpKSB7XG4gICAgICBjYWxsZWVfMTU5ID0gdGhpcy5lbmZvcmVzdE5ld0V4cHJlc3Npb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCBcInN1cGVyXCIpKSB7XG4gICAgICBjYWxsZWVfMTU5ID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoKSwgXCIuXCIpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgXCJ0YXJnZXRcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oXCJOZXdUYXJnZXRFeHByZXNzaW9uXCIsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVlXzE1OSA9IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCl9KTtcbiAgICB9XG4gICAgbGV0IGFyZ3NfMTYwO1xuICAgIGlmICh0aGlzLmlzUGFyZW5zKHRoaXMucGVlaygpKSkge1xuICAgICAgYXJnc18xNjAgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NfMTYwID0gTGlzdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJOZXdFeHByZXNzaW9uXCIsIHtjYWxsZWU6IGNhbGxlZV8xNTksIGFyZ3VtZW50czogYXJnc18xNjB9KTtcbiAgfVxuICBlbmZvcmVzdENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgZW5mXzE2MSA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIiwge29iamVjdDogdGhpcy50ZXJtLCBleHByZXNzaW9uOiBlbmZfMTYxLmVuZm9yZXN0RXhwcmVzc2lvbigpfSk7XG4gIH1cbiAgdHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0ZXJtXzE2Mikge1xuICAgIHN3aXRjaCAodGVybV8xNjIudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2Mi5uYW1lfSk7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHRlcm1fMTYyLmlubmVyLnNpemUgPT09IDEgJiYgdGhpcy5pc0lkZW50aWZpZXIodGVybV8xNjIuaW5uZXIuZ2V0KDApKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2Mi5pbm5lci5nZXQoMCl9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkRhdGFQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGVybV8xNjIubmFtZSwgYmluZGluZzogdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nV2l0aERlZmF1bHQodGVybV8xNjIuZXhwcmVzc2lvbil9KTtcbiAgICAgIGNhc2UgXCJTaG9ydGhhbmRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCIsIHtiaW5kaW5nOiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiB0ZXJtXzE2Mi5uYW1lfSksIGluaXQ6IG51bGx9KTtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEJpbmRpbmdcIiwge3Byb3BlcnRpZXM6IHRlcm1fMTYyLnByb3BlcnRpZXMubWFwKHRfMTYzID0+IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0XzE2MykpfSk7XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIGxldCBsYXN0ID0gdGVybV8xNjIuZWxlbWVudHMubGFzdCgpO1xuICAgICAgICBpZiAobGFzdCAhPSBudWxsICYmIGxhc3QudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiB0ZXJtXzE2Mi5lbGVtZW50cy5zbGljZSgwLCAtMSkubWFwKHRfMTY0ID0+IHRfMTY0ICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRfMTY0KSksIHJlc3RFbGVtZW50OiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmdXaXRoRGVmYXVsdChsYXN0LmV4cHJlc3Npb24pfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV8xNjIuZWxlbWVudHMubWFwKHRfMTY1ID0+IHRfMTY1ICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRfMTY1KSksIHJlc3RFbGVtZW50OiBudWxsfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV8xNjIuZWxlbWVudHMubWFwKHRfMTY2ID0+IHRfMTY2ICYmIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0XzE2NikpLCByZXN0RWxlbWVudDogbnVsbH0pO1xuICAgICAgY2FzZSBcIlN0YXRpY1Byb3BlcnR5TmFtZVwiOlxuICAgICAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogdGVybV8xNjIudmFsdWV9KTtcbiAgICAgIGNhc2UgXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQXJyYXlCaW5kaW5nXCI6XG4gICAgICBjYXNlIFwiQmluZGluZ0lkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiQmluZGluZ1Byb3BlcnR5UHJvcGVydHlcIjpcbiAgICAgIGNhc2UgXCJCaW5kaW5nV2l0aERlZmF1bHRcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RCaW5kaW5nXCI6XG4gICAgICAgIHJldHVybiB0ZXJtXzE2MjtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXQgZm9yIFwiICsgdGVybV8xNjIudHlwZSk7XG4gIH1cbiAgdHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRlcm1fMTY3KSB7XG4gICAgc3dpdGNoICh0ZXJtXzE2Ny50eXBlKSB7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmcodGVybV8xNjcuYmluZGluZyksIGluaXQ6IHRlcm1fMTY3LmV4cHJlc3Npb259KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0ZXJtXzE2Nyk7XG4gIH1cbiAgZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKSB7XG4gICAgbGV0IGVuZl8xNjg7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygpKSkge1xuICAgICAgZW5mXzE2OCA9IG5ldyBFbmZvcmVzdGVyXzQ0KExpc3Qub2YodGhpcy5hZHZhbmNlKCkpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgICAgZW5mXzE2OCA9IG5ldyBFbmZvcmVzdGVyXzQ0KHAsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgbGV0IHBhcmFtc18xNjkgPSBlbmZfMTY4LmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiPT5cIik7XG4gICAgbGV0IGJvZHlfMTcwO1xuICAgIGlmICh0aGlzLmlzQnJhY2VzKHRoaXMucGVlaygpKSkge1xuICAgICAgYm9keV8xNzAgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmZfMTY4ID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5yZXN0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBib2R5XzE3MCA9IGVuZl8xNjguZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgdGhpcy5yZXN0ID0gZW5mXzE2OC5yZXN0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJvd0V4cHJlc3Npb25cIiwge3BhcmFtczogcGFyYW1zXzE2OSwgYm9keTogYm9keV8xNzB9KTtcbiAgfVxuICBlbmZvcmVzdFlpZWxkRXhwcmVzc2lvbigpIHtcbiAgICBsZXQga3dkXzE3MSA9IHRoaXMubWF0Y2hLZXl3b3JkKFwieWllbGRcIik7XG4gICAgbGV0IGxvb2thaGVhZF8xNzIgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDAgfHwgbG9va2FoZWFkXzE3MiAmJiAhdGhpcy5saW5lTnVtYmVyRXEoa3dkXzE3MSwgbG9va2FoZWFkXzE3MikpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIllpZWxkRXhwcmVzc2lvblwiLCB7ZXhwcmVzc2lvbjogbnVsbH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaXNHZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoKSwgXCIqXCIpKSB7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBsZXQgZXhwciA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICBsZXQgdHlwZSA9IGlzR2VuZXJhdG9yID8gXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIiA6IFwiWWllbGRFeHByZXNzaW9uXCI7XG4gICAgICByZXR1cm4gbmV3IFRlcm0odHlwZSwge2V4cHJlc3Npb246IGV4cHJ9KTtcbiAgICB9XG4gIH1cbiAgZW5mb3Jlc3RTeW50YXhUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTeW50YXhUZW1wbGF0ZVwiLCB7dGVtcGxhdGU6IHRoaXMuYWR2YW5jZSgpfSk7XG4gIH1cbiAgZW5mb3Jlc3RTeW50YXhRdW90ZSgpIHtcbiAgICBsZXQgbmFtZV8xNzMgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTeW50YXhRdW90ZVwiLCB7bmFtZTogbmFtZV8xNzMsIHRlbXBsYXRlOiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiBuYW1lXzE3M30pLCBlbGVtZW50czogdGhpcy5lbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKX0pfSk7XG4gIH1cbiAgZW5mb3Jlc3RTdGF0aWNNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgIGxldCBvYmplY3RfMTc0ID0gdGhpcy50ZXJtO1xuICAgIGxldCBkb3RfMTc1ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IHByb3BlcnR5XzE3NiA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlN0YXRpY01lbWJlckV4cHJlc3Npb25cIiwge29iamVjdDogb2JqZWN0XzE3NCwgcHJvcGVydHk6IHByb3BlcnR5XzE3Nn0pO1xuICB9XG4gIGVuZm9yZXN0QXJyYXlFeHByZXNzaW9uKCkge1xuICAgIGxldCBhcnJfMTc3ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGVsZW1lbnRzXzE3OCA9IFtdO1xuICAgIGxldCBlbmZfMTc5ID0gbmV3IEVuZm9yZXN0ZXJfNDQoYXJyXzE3Ny5pbm5lcigpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgd2hpbGUgKGVuZl8xNzkucmVzdC5zaXplID4gMCkge1xuICAgICAgbGV0IGxvb2thaGVhZCA9IGVuZl8xNzkucGVlaygpO1xuICAgICAgaWYgKGVuZl8xNzkuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgXCIsXCIpKSB7XG4gICAgICAgIGVuZl8xNzkuYWR2YW5jZSgpO1xuICAgICAgICBlbGVtZW50c18xNzgucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoZW5mXzE3OS5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCBcIi4uLlwiKSkge1xuICAgICAgICBlbmZfMTc5LmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSBlbmZfMTc5LmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVuZl8xNzkuY3JlYXRlRXJyb3IobG9va2FoZWFkLCBcImV4cGVjdGluZyBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzXzE3OC5wdXNoKG5ldyBUZXJtKFwiU3ByZWFkRWxlbWVudFwiLCB7ZXhwcmVzc2lvbjogZXhwcmVzc2lvbn0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0ZXJtID0gZW5mXzE3OS5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGlmICh0ZXJtID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlbmZfMTc5LmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgXCJleHBlY3RlZCBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzXzE3OC5wdXNoKHRlcm0pO1xuICAgICAgICBlbmZfMTc5LmNvbnN1bWVDb21tYSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUV4cHJlc3Npb25cIiwge2VsZW1lbnRzOiBMaXN0KGVsZW1lbnRzXzE3OCl9KTtcbiAgfVxuICBlbmZvcmVzdE9iamVjdEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9ial8xODAgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBsZXQgcHJvcGVydGllc18xODEgPSBMaXN0KCk7XG4gICAgbGV0IGVuZl8xODIgPSBuZXcgRW5mb3Jlc3Rlcl80NChvYmpfMTgwLmlubmVyKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgbGFzdFByb3BfMTgzID0gbnVsbDtcbiAgICB3aGlsZSAoZW5mXzE4Mi5yZXN0LnNpemUgPiAwKSB7XG4gICAgICBsZXQgcHJvcCA9IGVuZl8xODIuZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKTtcbiAgICAgIGVuZl8xODIuY29uc3VtZUNvbW1hKCk7XG4gICAgICBwcm9wZXJ0aWVzXzE4MSA9IHByb3BlcnRpZXNfMTgxLmNvbmNhdChwcm9wKTtcbiAgICAgIGlmIChsYXN0UHJvcF8xODMgPT09IHByb3ApIHtcbiAgICAgICAgdGhyb3cgZW5mXzE4Mi5jcmVhdGVFcnJvcihwcm9wLCBcImludmFsaWQgc3ludGF4IGluIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGxhc3RQcm9wXzE4MyA9IHByb3A7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEV4cHJlc3Npb25cIiwge3Byb3BlcnRpZXM6IHByb3BlcnRpZXNfMTgxfSk7XG4gIH1cbiAgZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKSB7XG4gICAgbGV0IHttZXRob2RPcktleSwga2luZH0gPSB0aGlzLmVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBcIm1ldGhvZFwiOlxuICAgICAgICByZXR1cm4gbWV0aG9kT3JLZXk7XG4gICAgICBjYXNlIFwiaWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pc0Fzc2lnbih0aGlzLnBlZWsoKSkpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICBsZXQgaW5pdCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJcIiwge2luaXQ6IGluaXQsIGJpbmRpbmc6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyhtZXRob2RPcktleSl9KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksIFwiOlwiKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGVybShcIlNob3J0aGFuZFByb3BlcnR5XCIsIHtuYW1lOiBtZXRob2RPcktleS52YWx1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiOlwiKTtcbiAgICBsZXQgZXhwcl8xODQgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJEYXRhUHJvcGVydHlcIiwge25hbWU6IG1ldGhvZE9yS2V5LCBleHByZXNzaW9uOiBleHByXzE4NH0pO1xuICB9XG4gIGVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE4NSA9IHRoaXMucGVlaygpO1xuICAgIGxldCBpc0dlbmVyYXRvcl8xODYgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzE4NSwgXCIqXCIpKSB7XG4gICAgICBpc0dlbmVyYXRvcl8xODYgPSB0cnVlO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTg1LCBcImdldFwiKSAmJiB0aGlzLmlzUHJvcGVydHlOYW1lKHRoaXMucGVlaygxKSkpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IHtuYW1lfSA9IHRoaXMuZW5mb3Jlc3RQcm9wZXJ0eU5hbWUoKTtcbiAgICAgIHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICAgIGxldCBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICAgIHJldHVybiB7bWV0aG9kT3JLZXk6IG5ldyBUZXJtKFwiR2V0dGVyXCIsIHtuYW1lOiBuYW1lLCBib2R5OiBib2R5fSksIGtpbmQ6IFwibWV0aG9kXCJ9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkXzE4NSwgXCJzZXRcIikgJiYgdGhpcy5pc1Byb3BlcnR5TmFtZSh0aGlzLnBlZWsoMSkpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCB7bmFtZX0gPSB0aGlzLmVuZm9yZXN0UHJvcGVydHlOYW1lKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQodGhpcy5tYXRjaFBhcmVucygpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBsZXQgcGFyYW0gPSBlbmYuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICAgICAgbGV0IGJvZHkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgICAgcmV0dXJuIHttZXRob2RPcktleTogbmV3IFRlcm0oXCJTZXR0ZXJcIiwge25hbWU6IG5hbWUsIHBhcmFtOiBwYXJhbSwgYm9keTogYm9keX0pLCBraW5kOiBcIm1ldGhvZFwifTtcbiAgICB9XG4gICAgbGV0IHtuYW1lfSA9IHRoaXMuZW5mb3Jlc3RQcm9wZXJ0eU5hbWUoKTtcbiAgICBpZiAodGhpcy5pc1BhcmVucyh0aGlzLnBlZWsoKSkpIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICBsZXQgZm9ybWFsUGFyYW1zID0gZW5mLmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgICAgbGV0IGJvZHkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgICAgcmV0dXJuIHttZXRob2RPcktleTogbmV3IFRlcm0oXCJNZXRob2RcIiwge2lzR2VuZXJhdG9yOiBpc0dlbmVyYXRvcl8xODYsIG5hbWU6IG5hbWUsIHBhcmFtczogZm9ybWFsUGFyYW1zLCBib2R5OiBib2R5fSksIGtpbmQ6IFwibWV0aG9kXCJ9O1xuICAgIH1cbiAgICByZXR1cm4ge21ldGhvZE9yS2V5OiBuYW1lLCBraW5kOiB0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWRfMTg1KSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMTg1KSA/IFwiaWRlbnRpZmllclwiIDogXCJwcm9wZXJ0eVwifTtcbiAgfVxuICBlbmZvcmVzdFByb3BlcnR5TmFtZSgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzE4NyA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWRfMTg3KSB8fCB0aGlzLmlzTnVtZXJpY0xpdGVyYWwobG9va2FoZWFkXzE4NykpIHtcbiAgICAgIHJldHVybiB7bmFtZTogbmV3IFRlcm0oXCJTdGF0aWNQcm9wZXJ0eU5hbWVcIiwge3ZhbHVlOiB0aGlzLmFkdmFuY2UoKX0pLCBiaW5kaW5nOiBudWxsfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWRfMTg3KSkge1xuICAgICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyXzQ0KHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBleHByID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgIHJldHVybiB7bmFtZTogbmV3IFRlcm0oXCJDb21wdXRlZFByb3BlcnR5TmFtZVwiLCB7ZXhwcmVzc2lvbjogZXhwcn0pLCBiaW5kaW5nOiBudWxsfTtcbiAgICB9XG4gICAgbGV0IG5hbWVfMTg4ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHtuYW1lOiBuZXcgVGVybShcIlN0YXRpY1Byb3BlcnR5TmFtZVwiLCB7dmFsdWU6IG5hbWVfMTg4fSksIGJpbmRpbmc6IG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfMTg4fSl9O1xuICB9XG4gIGVuZm9yZXN0RnVuY3Rpb24oe2lzRXhwciwgaW5EZWZhdWx0LCBhbGxvd0dlbmVyYXRvcn0pIHtcbiAgICBsZXQgbmFtZV8xODkgPSBudWxsLCBwYXJhbXNfMTkwLCBib2R5XzE5MSwgcmVzdF8xOTI7XG4gICAgbGV0IGlzR2VuZXJhdG9yXzE5MyA9IGZhbHNlO1xuICAgIGxldCBmbktleXdvcmRfMTk0ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGxvb2thaGVhZF8xOTUgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgdHlwZV8xOTYgPSBpc0V4cHIgPyBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIDogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8xOTUsIFwiKlwiKSkge1xuICAgICAgaXNHZW5lcmF0b3JfMTkzID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbG9va2FoZWFkXzE5NSA9IHRoaXMucGVlaygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNQYXJlbnMobG9va2FoZWFkXzE5NSkpIHtcbiAgICAgIG5hbWVfMTg5ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmIChpbkRlZmF1bHQpIHtcbiAgICAgIG5hbWVfMTg5ID0gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogU3ludGF4LmZyb21JZGVudGlmaWVyKFwiKmRlZmF1bHQqXCIsIGZuS2V5d29yZF8xOTQpfSk7XG4gICAgfVxuICAgIHBhcmFtc18xOTAgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgYm9keV8xOTEgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBlbmZfMTk3ID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zXzE5MCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBmb3JtYWxQYXJhbXNfMTk4ID0gZW5mXzE5Ny5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8xOTYsIHtuYW1lOiBuYW1lXzE4OSwgaXNHZW5lcmF0b3I6IGlzR2VuZXJhdG9yXzE5MywgcGFyYW1zOiBmb3JtYWxQYXJhbXNfMTk4LCBib2R5OiBib2R5XzE5MX0pO1xuICB9XG4gIGVuZm9yZXN0RnVuY3Rpb25FeHByZXNzaW9uKCkge1xuICAgIGxldCBuYW1lXzE5OSA9IG51bGwsIHBhcmFtc18yMDAsIGJvZHlfMjAxLCByZXN0XzIwMjtcbiAgICBsZXQgaXNHZW5lcmF0b3JfMjAzID0gZmFsc2U7XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IGxvb2thaGVhZF8yMDQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkXzIwNCwgXCIqXCIpKSB7XG4gICAgICBpc0dlbmVyYXRvcl8yMDMgPSB0cnVlO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsb29rYWhlYWRfMjA0ID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1BhcmVucyhsb29rYWhlYWRfMjA0KSkge1xuICAgICAgbmFtZV8xOTkgPSB0aGlzLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgcGFyYW1zXzIwMCA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICBib2R5XzIwMSA9IHRoaXMubWF0Y2hDdXJsaWVzKCk7XG4gICAgbGV0IGVuZl8yMDUgPSBuZXcgRW5mb3Jlc3Rlcl80NChwYXJhbXNfMjAwLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGZvcm1hbFBhcmFtc18yMDYgPSBlbmZfMjA1LmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7bmFtZTogbmFtZV8xOTksIGlzR2VuZXJhdG9yOiBpc0dlbmVyYXRvcl8yMDMsIHBhcmFtczogZm9ybWFsUGFyYW1zXzIwNiwgYm9keTogYm9keV8yMDF9KTtcbiAgfVxuICBlbmZvcmVzdEZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IG5hbWVfMjA3LCBwYXJhbXNfMjA4LCBib2R5XzIwOSwgcmVzdF8yMTA7XG4gICAgbGV0IGlzR2VuZXJhdG9yXzIxMSA9IGZhbHNlO1xuICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIGxldCBsb29rYWhlYWRfMjEyID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8yMTIsIFwiKlwiKSkge1xuICAgICAgaXNHZW5lcmF0b3JfMjExID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICBuYW1lXzIwNyA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgIHBhcmFtc18yMDggPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgYm9keV8yMDkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgIGxldCBlbmZfMjEzID0gbmV3IEVuZm9yZXN0ZXJfNDQocGFyYW1zXzIwOCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBmb3JtYWxQYXJhbXNfMjE0ID0gZW5mXzIxMy5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIHtuYW1lOiBuYW1lXzIwNywgaXNHZW5lcmF0b3I6IGlzR2VuZXJhdG9yXzIxMSwgcGFyYW1zOiBmb3JtYWxQYXJhbXNfMjE0LCBib2R5OiBib2R5XzIwOX0pO1xuICB9XG4gIGVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpIHtcbiAgICBsZXQgaXRlbXNfMjE1ID0gW107XG4gICAgbGV0IHJlc3RfMjE2ID0gbnVsbDtcbiAgICB3aGlsZSAodGhpcy5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsIFwiLi4uXCIpKSB7XG4gICAgICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKFwiLi4uXCIpO1xuICAgICAgICByZXN0XzIxNiA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGl0ZW1zXzIxNS5wdXNoKHRoaXMuZW5mb3Jlc3RQYXJhbSgpKTtcbiAgICAgIHRoaXMuY29uc3VtZUNvbW1hKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiBMaXN0KGl0ZW1zXzIxNSksIHJlc3Q6IHJlc3RfMjE2fSk7XG4gIH1cbiAgZW5mb3Jlc3RQYXJhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmRpbmdFbGVtZW50KCk7XG4gIH1cbiAgZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCkge1xuICAgIGxldCBvcGVyYXRvcl8yMTcgPSB0aGlzLm1hdGNoVW5hcnlPcGVyYXRvcigpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge2lzUHJlZml4OiBmYWxzZSwgb3BlcmF0b3I6IG9wZXJhdG9yXzIxNy52YWwoKSwgb3BlcmFuZDogdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRoaXMudGVybSl9KTtcbiAgfVxuICBlbmZvcmVzdFVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgb3BlcmF0b3JfMjE4ID0gdGhpcy5tYXRjaFVuYXJ5T3BlcmF0b3IoKTtcbiAgICB0aGlzLm9wQ3R4LnN0YWNrID0gdGhpcy5vcEN0eC5zdGFjay5wdXNoKHtwcmVjOiB0aGlzLm9wQ3R4LnByZWMsIGNvbWJpbmU6IHRoaXMub3BDdHguY29tYmluZX0pO1xuICAgIHRoaXMub3BDdHgucHJlYyA9IDE0O1xuICAgIHRoaXMub3BDdHguY29tYmluZSA9IHJpZ2h0VGVybV8yMTkgPT4ge1xuICAgICAgbGV0IHR5cGVfMjIwLCB0ZXJtXzIyMSwgaXNQcmVmaXhfMjIyO1xuICAgICAgaWYgKG9wZXJhdG9yXzIxOC52YWwoKSA9PT0gXCIrK1wiIHx8IG9wZXJhdG9yXzIxOC52YWwoKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIHR5cGVfMjIwID0gXCJVcGRhdGVFeHByZXNzaW9uXCI7XG4gICAgICAgIHRlcm1fMjIxID0gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHJpZ2h0VGVybV8yMTkpO1xuICAgICAgICBpc1ByZWZpeF8yMjIgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZV8yMjAgPSBcIlVuYXJ5RXhwcmVzc2lvblwiO1xuICAgICAgICBpc1ByZWZpeF8yMjIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRlcm1fMjIxID0gcmlnaHRUZXJtXzIxOTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybSh0eXBlXzIyMCwge29wZXJhdG9yOiBvcGVyYXRvcl8yMTgudmFsKCksIG9wZXJhbmQ6IHRlcm1fMjIxLCBpc1ByZWZpeDogaXNQcmVmaXhfMjIyfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRVhQUl9MT09QX09QRVJBVE9SXzQxO1xuICB9XG4gIGVuZm9yZXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgIGxldCB0ZXN0XzIyMyA9IHRoaXMub3BDdHguY29tYmluZSh0aGlzLnRlcm0pO1xuICAgIGlmICh0aGlzLm9wQ3R4LnN0YWNrLnNpemUgPiAwKSB7XG4gICAgICBsZXQge3ByZWMsIGNvbWJpbmV9ID0gdGhpcy5vcEN0eC5zdGFjay5sYXN0KCk7XG4gICAgICB0aGlzLm9wQ3R4LnN0YWNrID0gdGhpcy5vcEN0eC5zdGFjay5wb3AoKTtcbiAgICAgIHRoaXMub3BDdHgucHJlYyA9IHByZWM7XG4gICAgICB0aGlzLm9wQ3R4LmNvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cbiAgICB0aGlzLm1hdGNoUHVuY3R1YXRvcihcIj9cIik7XG4gICAgbGV0IGVuZl8yMjQgPSBuZXcgRW5mb3Jlc3Rlcl80NCh0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgY29uc2VxdWVudF8yMjUgPSBlbmZfMjI0LmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICBlbmZfMjI0Lm1hdGNoUHVuY3R1YXRvcihcIjpcIik7XG4gICAgZW5mXzIyNCA9IG5ldyBFbmZvcmVzdGVyXzQ0KGVuZl8yMjQucmVzdCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhbHRlcm5hdGVfMjI2ID0gZW5mXzIyNC5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgdGhpcy5yZXN0ID0gZW5mXzIyNC5yZXN0O1xuICAgIHJldHVybiBuZXcgVGVybShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7dGVzdDogdGVzdF8yMjMsIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnRfMjI1LCBhbHRlcm5hdGU6IGFsdGVybmF0ZV8yMjZ9KTtcbiAgfVxuICBlbmZvcmVzdEJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnRUZXJtXzIyNyA9IHRoaXMudGVybTtcbiAgICBsZXQgb3BTdHhfMjI4ID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IG9wXzIyOSA9IG9wU3R4XzIyOC52YWwoKTtcbiAgICBsZXQgb3BQcmVjXzIzMCA9IGdldE9wZXJhdG9yUHJlYyhvcF8yMjkpO1xuICAgIGxldCBvcEFzc29jXzIzMSA9IGdldE9wZXJhdG9yQXNzb2Mob3BfMjI5KTtcbiAgICBpZiAob3BlcmF0b3JMdCh0aGlzLm9wQ3R4LnByZWMsIG9wUHJlY18yMzAsIG9wQXNzb2NfMjMxKSkge1xuICAgICAgdGhpcy5vcEN0eC5zdGFjayA9IHRoaXMub3BDdHguc3RhY2sucHVzaCh7cHJlYzogdGhpcy5vcEN0eC5wcmVjLCBjb21iaW5lOiB0aGlzLm9wQ3R4LmNvbWJpbmV9KTtcbiAgICAgIHRoaXMub3BDdHgucHJlYyA9IG9wUHJlY18yMzA7XG4gICAgICB0aGlzLm9wQ3R4LmNvbWJpbmUgPSByaWdodFRlcm1fMjMyID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7bGVmdDogbGVmdFRlcm1fMjI3LCBvcGVyYXRvcjogb3BTdHhfMjI4LCByaWdodDogcmlnaHRUZXJtXzIzMn0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIEVYUFJfTE9PUF9PUEVSQVRPUl80MTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRlcm0gPSB0aGlzLm9wQ3R4LmNvbWJpbmUobGVmdFRlcm1fMjI3KTtcbiAgICAgIGxldCB7cHJlYywgY29tYmluZX0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgIHRoaXMub3BDdHguc3RhY2sgPSB0aGlzLm9wQ3R4LnN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgIHRoaXMub3BDdHguY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gIH1cbiAgZW5mb3Jlc3RUZW1wbGF0ZUVsZW1lbnRzKCkge1xuICAgIGxldCBsb29rYWhlYWRfMjMzID0gdGhpcy5tYXRjaFRlbXBsYXRlKCk7XG4gICAgbGV0IGVsZW1lbnRzXzIzNCA9IGxvb2thaGVhZF8yMzMudG9rZW4uaXRlbXMubWFwKGl0XzIzNSA9PiB7XG4gICAgICBpZiAoaXRfMjM1IGluc3RhbmNlb2YgU3ludGF4ICYmIGl0XzIzNS5pc0RlbGltaXRlcigpKSB7XG4gICAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcl80NChpdF8yMzUuaW5uZXIoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZW5mLmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRWxlbWVudFwiLCB7cmF3VmFsdWU6IGl0XzIzNS5zbGljZS50ZXh0fSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnRzXzIzNDtcbiAgfVxuICBleHBhbmRNYWNybyhlbmZvcmVzdFR5cGVfMjM2KSB7XG4gICAgbGV0IG5hbWVfMjM3ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IHN5bnRheFRyYW5zZm9ybV8yMzggPSB0aGlzLmdldEZyb21Db21waWxldGltZUVudmlyb25tZW50KG5hbWVfMjM3KTtcbiAgICBpZiAoc3ludGF4VHJhbnNmb3JtXzIzOCA9PSBudWxsIHx8IHR5cGVvZiBzeW50YXhUcmFuc2Zvcm1fMjM4LnZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZV8yMzcsIFwidGhlIG1hY3JvIG5hbWUgd2FzIG5vdCBib3VuZCB0byBhIHZhbHVlIHRoYXQgY291bGQgYmUgaW52b2tlZFwiKTtcbiAgICB9XG4gICAgbGV0IHVzZVNpdGVTY29wZV8yMzkgPSBmcmVzaFNjb3BlKFwidVwiKTtcbiAgICBsZXQgaW50cm9kdWNlZFNjb3BlXzI0MCA9IGZyZXNoU2NvcGUoXCJpXCIpO1xuICAgIHRoaXMuY29udGV4dC51c2VTY29wZSA9IHVzZVNpdGVTY29wZV8yMzk7XG4gICAgbGV0IGN0eF8yNDEgPSBuZXcgTWFjcm9Db250ZXh0KHRoaXMsIG5hbWVfMjM3LCB0aGlzLmNvbnRleHQsIHVzZVNpdGVTY29wZV8yMzksIGludHJvZHVjZWRTY29wZV8yNDApO1xuICAgIGxldCByZXN1bHRfMjQyID0gc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlcyhzeW50YXhUcmFuc2Zvcm1fMjM4LnZhbHVlLmNhbGwobnVsbCwgY3R4XzI0MSkpO1xuICAgIGlmICghTGlzdC5pc0xpc3QocmVzdWx0XzI0MikpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZV8yMzcsIFwibWFjcm8gbXVzdCByZXR1cm4gYSBsaXN0IGJ1dCBnb3Q6IFwiICsgcmVzdWx0XzI0Mik7XG4gICAgfVxuICAgIHJlc3VsdF8yNDIgPSByZXN1bHRfMjQyLm1hcChzdHhfMjQzID0+IHtcbiAgICAgIGlmICghKHN0eF8yNDMgJiYgdHlwZW9mIHN0eF8yNDMuYWRkU2NvcGUgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihuYW1lXzIzNywgXCJtYWNybyBtdXN0IHJldHVybiBzeW50YXggb2JqZWN0cyBvciB0ZXJtcyBidXQgZ290OiBcIiArIHN0eF8yNDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eF8yNDMuYWRkU2NvcGUoaW50cm9kdWNlZFNjb3BlXzI0MCwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTLCB7ZmxpcDogdHJ1ZX0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRfMjQyO1xuICB9XG4gIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yNDQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAobG9va2FoZWFkXzI0NCAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMjQ0LCBcIjtcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdW1lQ29tbWEoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yNDUgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAobG9va2FoZWFkXzI0NSAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWRfMjQ1LCBcIixcIikpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuICBpc1Rlcm0odGVybV8yNDYpIHtcbiAgICByZXR1cm4gdGVybV8yNDYgJiYgdGVybV8yNDYgaW5zdGFuY2VvZiBUZXJtO1xuICB9XG4gIGlzRU9GKHRlcm1fMjQ3KSB7XG4gICAgcmV0dXJuIHRlcm1fMjQ3ICYmIHRlcm1fMjQ3IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjQ3LmlzRU9GKCk7XG4gIH1cbiAgaXNJZGVudGlmaWVyKHRlcm1fMjQ4LCB2YWxfMjQ5ID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI0OCAmJiB0ZXJtXzI0OCBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI0OC5pc0lkZW50aWZpZXIoKSAmJiAodmFsXzI0OSA9PT0gbnVsbCB8fCB0ZXJtXzI0OC52YWwoKSA9PT0gdmFsXzI0OSk7XG4gIH1cbiAgaXNQcm9wZXJ0eU5hbWUodGVybV8yNTApIHtcbiAgICByZXR1cm4gdGhpcy5pc0lkZW50aWZpZXIodGVybV8yNTApIHx8IHRoaXMuaXNLZXl3b3JkKHRlcm1fMjUwKSB8fCB0aGlzLmlzTnVtZXJpY0xpdGVyYWwodGVybV8yNTApIHx8IHRoaXMuaXNTdHJpbmdMaXRlcmFsKHRlcm1fMjUwKSB8fCB0aGlzLmlzQnJhY2tldHModGVybV8yNTApO1xuICB9XG4gIGlzTnVtZXJpY0xpdGVyYWwodGVybV8yNTEpIHtcbiAgICByZXR1cm4gdGVybV8yNTEgJiYgdGVybV8yNTEgaW5zdGFuY2VvZiBTeW50YXggJiYgdGVybV8yNTEuaXNOdW1lcmljTGl0ZXJhbCgpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh0ZXJtXzI1Mikge1xuICAgIHJldHVybiB0ZXJtXzI1MiAmJiB0ZXJtXzI1MiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1Mi5pc1N0cmluZ0xpdGVyYWwoKTtcbiAgfVxuICBpc1RlbXBsYXRlKHRlcm1fMjUzKSB7XG4gICAgcmV0dXJuIHRlcm1fMjUzICYmIHRlcm1fMjUzIGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjUzLmlzVGVtcGxhdGUoKTtcbiAgfVxuICBpc0Jvb2xlYW5MaXRlcmFsKHRlcm1fMjU0KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU0ICYmIHRlcm1fMjU0IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU0LmlzQm9vbGVhbkxpdGVyYWwoKTtcbiAgfVxuICBpc051bGxMaXRlcmFsKHRlcm1fMjU1KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU1ICYmIHRlcm1fMjU1IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU1LmlzTnVsbExpdGVyYWwoKTtcbiAgfVxuICBpc1JlZ3VsYXJFeHByZXNzaW9uKHRlcm1fMjU2KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU2ICYmIHRlcm1fMjU2IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU2LmlzUmVndWxhckV4cHJlc3Npb24oKTtcbiAgfVxuICBpc1BhcmVucyh0ZXJtXzI1Nykge1xuICAgIHJldHVybiB0ZXJtXzI1NyAmJiB0ZXJtXzI1NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1Ny5pc1BhcmVucygpO1xuICB9XG4gIGlzQnJhY2VzKHRlcm1fMjU4KSB7XG4gICAgcmV0dXJuIHRlcm1fMjU4ICYmIHRlcm1fMjU4IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjU4LmlzQnJhY2VzKCk7XG4gIH1cbiAgaXNCcmFja2V0cyh0ZXJtXzI1OSkge1xuICAgIHJldHVybiB0ZXJtXzI1OSAmJiB0ZXJtXzI1OSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI1OS5pc0JyYWNrZXRzKCk7XG4gIH1cbiAgaXNBc3NpZ24odGVybV8yNjApIHtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGVybV8yNjApKSB7XG4gICAgICBzd2l0Y2ggKHRlcm1fMjYwLnZhbCgpKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgIGNhc2UgXCJ8PVwiOlxuICAgICAgICBjYXNlIFwiXj1cIjpcbiAgICAgICAgY2FzZSBcIiY9XCI6XG4gICAgICAgIGNhc2UgXCI8PD1cIjpcbiAgICAgICAgY2FzZSBcIj4+PVwiOlxuICAgICAgICBjYXNlIFwiPj4+PVwiOlxuICAgICAgICBjYXNlIFwiKz1cIjpcbiAgICAgICAgY2FzZSBcIi09XCI6XG4gICAgICAgIGNhc2UgXCIqPVwiOlxuICAgICAgICBjYXNlIFwiLz1cIjpcbiAgICAgICAgY2FzZSBcIiU9XCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNLZXl3b3JkKHRlcm1fMjYxLCB2YWxfMjYyID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI2MSAmJiB0ZXJtXzI2MSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI2MS5pc0tleXdvcmQoKSAmJiAodmFsXzI2MiA9PT0gbnVsbCB8fCB0ZXJtXzI2MS52YWwoKSA9PT0gdmFsXzI2Mik7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHRlcm1fMjYzLCB2YWxfMjY0ID0gbnVsbCkge1xuICAgIHJldHVybiB0ZXJtXzI2MyAmJiB0ZXJtXzI2MyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0ZXJtXzI2My5pc1B1bmN0dWF0b3IoKSAmJiAodmFsXzI2NCA9PT0gbnVsbCB8fCB0ZXJtXzI2My52YWwoKSA9PT0gdmFsXzI2NCk7XG4gIH1cbiAgaXNPcGVyYXRvcih0ZXJtXzI2NSkge1xuICAgIHJldHVybiB0ZXJtXzI2NSAmJiB0ZXJtXzI2NSBpbnN0YW5jZW9mIFN5bnRheCAmJiBpc09wZXJhdG9yKHRlcm1fMjY1KTtcbiAgfVxuICBpc1VwZGF0ZU9wZXJhdG9yKHRlcm1fMjY2KSB7XG4gICAgcmV0dXJuIHRlcm1fMjY2ICYmIHRlcm1fMjY2IGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjY2LmlzUHVuY3R1YXRvcigpICYmICh0ZXJtXzI2Ni52YWwoKSA9PT0gXCIrK1wiIHx8IHRlcm1fMjY2LnZhbCgpID09PSBcIi0tXCIpO1xuICB9XG4gIGlzRm5EZWNsVHJhbnNmb3JtKHRlcm1fMjY3KSB7XG4gICAgcmV0dXJuIHRlcm1fMjY3ICYmIHRlcm1fMjY3IGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjY3LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IEZ1bmN0aW9uRGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1ZhckRlY2xUcmFuc2Zvcm0odGVybV8yNjgpIHtcbiAgICByZXR1cm4gdGVybV8yNjggJiYgdGVybV8yNjggaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNjgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVmFyaWFibGVEZWNsVHJhbnNmb3JtO1xuICB9XG4gIGlzTGV0RGVjbFRyYW5zZm9ybSh0ZXJtXzI2OSkge1xuICAgIHJldHVybiB0ZXJtXzI2OSAmJiB0ZXJtXzI2OSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI2OS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBMZXREZWNsVHJhbnNmb3JtO1xuICB9XG4gIGlzQ29uc3REZWNsVHJhbnNmb3JtKHRlcm1fMjcwKSB7XG4gICAgcmV0dXJuIHRlcm1fMjcwICYmIHRlcm1fMjcwIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjcwLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IENvbnN0RGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheERlY2xUcmFuc2Zvcm0odGVybV8yNzEpIHtcbiAgICByZXR1cm4gdGVybV8yNzEgJiYgdGVybV8yNzEgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzEucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3ludGF4RGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheHJlY0RlY2xUcmFuc2Zvcm0odGVybV8yNzIpIHtcbiAgICByZXR1cm4gdGVybV8yNzIgJiYgdGVybV8yNzIgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzIucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3ludGF4cmVjRGVjbFRyYW5zZm9ybTtcbiAgfVxuICBpc1N5bnRheFRlbXBsYXRlKHRlcm1fMjczKSB7XG4gICAgcmV0dXJuIHRlcm1fMjczICYmIHRlcm1fMjczIGluc3RhbmNlb2YgU3ludGF4ICYmIHRlcm1fMjczLmlzU3ludGF4VGVtcGxhdGUoKTtcbiAgfVxuICBpc1N5bnRheFF1b3RlVHJhbnNmb3JtKHRlcm1fMjc0KSB7XG4gICAgcmV0dXJuIHRlcm1fMjc0ICYmIHRlcm1fMjc0IGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjc0LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IFN5bnRheFF1b3RlVHJhbnNmb3JtO1xuICB9XG4gIGlzUmV0dXJuU3RtdFRyYW5zZm9ybSh0ZXJtXzI3NSkge1xuICAgIHJldHVybiB0ZXJtXzI3NSAmJiB0ZXJtXzI3NSBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3NS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBSZXR1cm5TdGF0ZW1lbnRUcmFuc2Zvcm07XG4gIH1cbiAgaXNXaGlsZVRyYW5zZm9ybSh0ZXJtXzI3Nikge1xuICAgIHJldHVybiB0ZXJtXzI3NiAmJiB0ZXJtXzI3NiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3Ni5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBXaGlsZVRyYW5zZm9ybTtcbiAgfVxuICBpc0ZvclRyYW5zZm9ybSh0ZXJtXzI3Nykge1xuICAgIHJldHVybiB0ZXJtXzI3NyAmJiB0ZXJtXzI3NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI3Ny5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBGb3JUcmFuc2Zvcm07XG4gIH1cbiAgaXNTd2l0Y2hUcmFuc2Zvcm0odGVybV8yNzgpIHtcbiAgICByZXR1cm4gdGVybV8yNzggJiYgdGVybV8yNzggaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gU3dpdGNoVHJhbnNmb3JtO1xuICB9XG4gIGlzQnJlYWtUcmFuc2Zvcm0odGVybV8yNzkpIHtcbiAgICByZXR1cm4gdGVybV8yNzkgJiYgdGVybV8yNzkgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yNzkucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gQnJlYWtUcmFuc2Zvcm07XG4gIH1cbiAgaXNDb250aW51ZVRyYW5zZm9ybSh0ZXJtXzI4MCkge1xuICAgIHJldHVybiB0ZXJtXzI4MCAmJiB0ZXJtXzI4MCBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBDb250aW51ZVRyYW5zZm9ybTtcbiAgfVxuICBpc0RvVHJhbnNmb3JtKHRlcm1fMjgxKSB7XG4gICAgcmV0dXJuIHRlcm1fMjgxICYmIHRlcm1fMjgxIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjgxLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IERvVHJhbnNmb3JtO1xuICB9XG4gIGlzRGVidWdnZXJUcmFuc2Zvcm0odGVybV8yODIpIHtcbiAgICByZXR1cm4gdGVybV8yODIgJiYgdGVybV8yODIgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODIucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gRGVidWdnZXJUcmFuc2Zvcm07XG4gIH1cbiAgaXNXaXRoVHJhbnNmb3JtKHRlcm1fMjgzKSB7XG4gICAgcmV0dXJuIHRlcm1fMjgzICYmIHRlcm1fMjgzIGluc3RhbmNlb2YgU3ludGF4ICYmIHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjgzLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgPT09IFdpdGhUcmFuc2Zvcm07XG4gIH1cbiAgaXNUcnlUcmFuc2Zvcm0odGVybV8yODQpIHtcbiAgICByZXR1cm4gdGVybV8yODQgJiYgdGVybV8yODQgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODQucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVHJ5VHJhbnNmb3JtO1xuICB9XG4gIGlzVGhyb3dUcmFuc2Zvcm0odGVybV8yODUpIHtcbiAgICByZXR1cm4gdGVybV8yODUgJiYgdGVybV8yODUgaW5zdGFuY2VvZiBTeW50YXggJiYgdGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSA9PT0gVGhyb3dUcmFuc2Zvcm07XG4gIH1cbiAgaXNJZlRyYW5zZm9ybSh0ZXJtXzI4Nikge1xuICAgIHJldHVybiB0ZXJtXzI4NiAmJiB0ZXJtXzI4NiBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4Ni5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBJZlRyYW5zZm9ybTtcbiAgfVxuICBpc05ld1RyYW5zZm9ybSh0ZXJtXzI4Nykge1xuICAgIHJldHVybiB0ZXJtXzI4NyAmJiB0ZXJtXzI4NyBpbnN0YW5jZW9mIFN5bnRheCAmJiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI4Ny5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpID09PSBOZXdUcmFuc2Zvcm07XG4gIH1cbiAgaXNDb21waWxldGltZVRyYW5zZm9ybSh0ZXJtXzI4OCkge1xuICAgIHJldHVybiB0ZXJtXzI4OCAmJiB0ZXJtXzI4OCBpbnN0YW5jZW9mIFN5bnRheCAmJiAodGhpcy5jb250ZXh0LmVudi5nZXQodGVybV8yODgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIENvbXBpbGV0aW1lVHJhbnNmb3JtIHx8IHRoaXMuY29udGV4dC5zdG9yZS5nZXQodGVybV8yODgucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIENvbXBpbGV0aW1lVHJhbnNmb3JtKTtcbiAgfVxuICBpc1ZhckJpbmRpbmdUcmFuc2Zvcm0odGVybV8yODkpIHtcbiAgICByZXR1cm4gdGVybV8yODkgJiYgdGVybV8yODkgaW5zdGFuY2VvZiBTeW50YXggJiYgKHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMjg5LnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkgaW5zdGFuY2VvZiBWYXJCaW5kaW5nVHJhbnNmb3JtIHx8IHRoaXMuY29udGV4dC5zdG9yZS5nZXQodGVybV8yODkucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKSBpbnN0YW5jZW9mIFZhckJpbmRpbmdUcmFuc2Zvcm0pO1xuICB9XG4gIGdldEZyb21Db21waWxldGltZUVudmlyb25tZW50KHRlcm1fMjkwKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5lbnYuaGFzKHRlcm1fMjkwLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtXzI5MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN0b3JlLmdldCh0ZXJtXzI5MC5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSkpO1xuICB9XG4gIGxpbmVOdW1iZXJFcShhXzI5MSwgYl8yOTIpIHtcbiAgICBpZiAoIShhXzI5MSAmJiBiXzI5MikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFfMjkxLmxpbmVOdW1iZXIoKSA9PT0gYl8yOTIubGluZU51bWJlcigpO1xuICB9XG4gIG1hdGNoSWRlbnRpZmllcih2YWxfMjkzKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yOTQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkXzI5NCkpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWRfMjk0O1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8yOTQsIFwiZXhwZWN0aW5nIGFuIGlkZW50aWZpZXJcIik7XG4gIH1cbiAgbWF0Y2hLZXl3b3JkKHZhbF8yOTUpIHtcbiAgICBsZXQgbG9va2FoZWFkXzI5NiA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWRfMjk2LCB2YWxfMjk1KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTY7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5NiwgXCJleHBlY3RpbmcgXCIgKyB2YWxfMjk1KTtcbiAgfVxuICBtYXRjaExpdGVyYWwoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8yOTcgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc051bWVyaWNMaXRlcmFsKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNTdHJpbmdMaXRlcmFsKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNCb29sZWFuTGl0ZXJhbChsb29rYWhlYWRfMjk3KSB8fCB0aGlzLmlzTnVsbExpdGVyYWwobG9va2FoZWFkXzI5NykgfHwgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZF8yOTcpIHx8IHRoaXMuaXNSZWd1bGFyRXhwcmVzc2lvbihsb29rYWhlYWRfMjk3KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTc7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5NywgXCJleHBlY3RpbmcgYSBsaXRlcmFsXCIpO1xuICB9XG4gIG1hdGNoU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgbG9va2FoZWFkXzI5OCA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWRfMjk4KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTg7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5OCwgXCJleHBlY3RpbmcgYSBzdHJpbmcgbGl0ZXJhbFwiKTtcbiAgfVxuICBtYXRjaFRlbXBsYXRlKCkge1xuICAgIGxldCBsb29rYWhlYWRfMjk5ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNUZW1wbGF0ZShsb29rYWhlYWRfMjk5KSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8yOTk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzI5OSwgXCJleHBlY3RpbmcgYSB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICB9XG4gIG1hdGNoUGFyZW5zKCkge1xuICAgIGxldCBsb29rYWhlYWRfMzAwID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNQYXJlbnMobG9va2FoZWFkXzMwMCkpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWRfMzAwLmlubmVyKCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwMCwgXCJleHBlY3RpbmcgcGFyZW5zXCIpO1xuICB9XG4gIG1hdGNoQ3VybGllcygpIHtcbiAgICBsZXQgbG9va2FoZWFkXzMwMSA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZF8zMDEpKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkXzMwMS5pbm5lcigpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDEsIFwiZXhwZWN0aW5nIGN1cmx5IGJyYWNlc1wiKTtcbiAgfVxuICBtYXRjaFNxdWFyZXMoKSB7XG4gICAgbGV0IGxvb2thaGVhZF8zMDIgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZF8zMDIpKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkXzMwMi5pbm5lcigpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDIsIFwiZXhwZWN0aW5nIHNxYXVyZSBicmFjZXNcIik7XG4gIH1cbiAgbWF0Y2hVbmFyeU9wZXJhdG9yKCkge1xuICAgIGxldCBsb29rYWhlYWRfMzAzID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKGlzVW5hcnlPcGVyYXRvcihsb29rYWhlYWRfMzAzKSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZF8zMDM7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwMywgXCJleHBlY3RpbmcgYSB1bmFyeSBvcGVyYXRvclwiKTtcbiAgfVxuICBtYXRjaFB1bmN0dWF0b3IodmFsXzMwNCkge1xuICAgIGxldCBsb29rYWhlYWRfMzA1ID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZF8zMDUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbF8zMDQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZF8zMDUudmFsKCkgPT09IHZhbF8zMDQpIHtcbiAgICAgICAgICByZXR1cm4gbG9va2FoZWFkXzMwNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8zMDUsIFwiZXhwZWN0aW5nIGEgXCIgKyB2YWxfMzA0ICsgXCIgcHVuY3R1YXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxvb2thaGVhZF8zMDU7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkXzMwNSwgXCJleHBlY3RpbmcgYSBwdW5jdHVhdG9yXCIpO1xuICB9XG4gIGNyZWF0ZUVycm9yKHN0eF8zMDYsIG1lc3NhZ2VfMzA3KSB7XG4gICAgbGV0IGN0eF8zMDggPSBcIlwiO1xuICAgIGxldCBvZmZlbmRpbmdfMzA5ID0gc3R4XzMwNjtcbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPiAwKSB7XG4gICAgICBjdHhfMzA4ID0gdGhpcy5yZXN0LnNsaWNlKDAsIDIwKS5tYXAodGVybV8zMTAgPT4ge1xuICAgICAgICBpZiAodGVybV8zMTAuaXNEZWxpbWl0ZXIoKSkge1xuICAgICAgICAgIHJldHVybiB0ZXJtXzMxMC5pbm5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMaXN0Lm9mKHRlcm1fMzEwKTtcbiAgICAgIH0pLmZsYXR0ZW4oKS5tYXAoc18zMTEgPT4ge1xuICAgICAgICBpZiAoc18zMTEgPT09IG9mZmVuZGluZ18zMDkpIHtcbiAgICAgICAgICByZXR1cm4gXCJfX1wiICsgc18zMTEudmFsKCkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNfMzExLnZhbCgpO1xuICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eF8zMDggPSBvZmZlbmRpbmdfMzA5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZV8zMDcgKyBcIlxcblwiICsgY3R4XzMwOCk7XG4gIH1cbn1cbmV4cG9ydCB7RW5mb3Jlc3Rlcl80NCBhcyBFbmZvcmVzdGVyfSJdfQ==

	/***/ },
	/* 49 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		const unaryOperators_512 = { "+": true, "-": true, "!": true, "~": true, "++": true, "--": true, typeof: true, void: true, delete: true };
		const binaryOperatorPrecedence_513 = { "*": 13, "/": 13, "%": 13, "+": 12, "-": 12, ">>": 11, "<<": 11, ">>>": 11, "<": 10, "<=": 10, ">": 10, ">=": 10, in: 10, instanceof: 10, "==": 9, "!=": 9, "===": 9, "!==": 9, "&": 8, "^": 7, "|": 6, "&&": 5, "||": 4 };
		var operatorAssoc_514 = { "*": "left", "/": "left", "%": "left", "+": "left", "-": "left", ">>": "left", "<<": "left", ">>>": "left", "<": "left", "<=": "left", ">": "left", ">=": "left", in: "left", instanceof: "left", "==": "left", "!=": "left", "===": "left", "!==": "left", "&": "left", "^": "left", "|": "left", "&&": "left", "||": "left" };
		function operatorLt_515(left_520, right_521, assoc_522) {
		  if (assoc_522 === "left") {
		    return left_520 < right_521;
		  } else {
		    return left_520 <= right_521;
		  }
		}
		function getOperatorPrec_516(op_523) {
		  return binaryOperatorPrecedence_513[op_523];
		}
		function getOperatorAssoc_517(op_524) {
		  return operatorAssoc_514[op_524];
		}
		function isUnaryOperator_518(op_525) {
		  return (op_525.match("punctuator") || op_525.match("identifier") || op_525.match("keyword")) && unaryOperators_512.hasOwnProperty(op_525.val());
		}
		function isOperator_519(op_526) {
		  if (op_526.match("punctuator") || op_526.match("identifier") || op_526.match("keyword")) {
		    return binaryOperatorPrecedence_513.hasOwnProperty(op_526) || unaryOperators_512.hasOwnProperty(op_526.val());
		  }
		  return false;
		}
		exports.operatorLt = operatorLt_515;
		exports.getOperatorPrec = getOperatorPrec_516;
		exports.getOperatorAssoc = getOperatorAssoc_517;
		exports.isUnaryOperator = isUnaryOperator_518;
		exports.isOperator = isOperator_519;
		//# sourceMappingURL=data:application/json;base64,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QixjO1FBQ3VCLGUsR0FBdkIsbUI7UUFDd0IsZ0IsR0FBeEIsb0I7UUFDdUIsZSxHQUF2QixtQjtRQUNrQixVLEdBQWxCLGMiLCJmaWxlIjoib3BlcmF0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdW5hcnlPcGVyYXRvcnNfNTEyID0ge1wiK1wiOiB0cnVlLCBcIi1cIjogdHJ1ZSwgXCIhXCI6IHRydWUsIFwiflwiOiB0cnVlLCBcIisrXCI6IHRydWUsIFwiLS1cIjogdHJ1ZSwgdHlwZW9mOiB0cnVlLCB2b2lkOiB0cnVlLCBkZWxldGU6IHRydWV9O1xuY29uc3QgYmluYXJ5T3BlcmF0b3JQcmVjZWRlbmNlXzUxMyA9IHtcIipcIjogMTMsIFwiL1wiOiAxMywgXCIlXCI6IDEzLCBcIitcIjogMTIsIFwiLVwiOiAxMiwgXCI+PlwiOiAxMSwgXCI8PFwiOiAxMSwgXCI+Pj5cIjogMTEsIFwiPFwiOiAxMCwgXCI8PVwiOiAxMCwgXCI+XCI6IDEwLCBcIj49XCI6IDEwLCBpbjogMTAsIGluc3RhbmNlb2Y6IDEwLCBcIj09XCI6IDksIFwiIT1cIjogOSwgXCI9PT1cIjogOSwgXCIhPT1cIjogOSwgXCImXCI6IDgsIFwiXlwiOiA3LCBcInxcIjogNiwgXCImJlwiOiA1LCBcInx8XCI6IDR9O1xudmFyIG9wZXJhdG9yQXNzb2NfNTE0ID0ge1wiKlwiOiBcImxlZnRcIiwgXCIvXCI6IFwibGVmdFwiLCBcIiVcIjogXCJsZWZ0XCIsIFwiK1wiOiBcImxlZnRcIiwgXCItXCI6IFwibGVmdFwiLCBcIj4+XCI6IFwibGVmdFwiLCBcIjw8XCI6IFwibGVmdFwiLCBcIj4+PlwiOiBcImxlZnRcIiwgXCI8XCI6IFwibGVmdFwiLCBcIjw9XCI6IFwibGVmdFwiLCBcIj5cIjogXCJsZWZ0XCIsIFwiPj1cIjogXCJsZWZ0XCIsIGluOiBcImxlZnRcIiwgaW5zdGFuY2VvZjogXCJsZWZ0XCIsIFwiPT1cIjogXCJsZWZ0XCIsIFwiIT1cIjogXCJsZWZ0XCIsIFwiPT09XCI6IFwibGVmdFwiLCBcIiE9PVwiOiBcImxlZnRcIiwgXCImXCI6IFwibGVmdFwiLCBcIl5cIjogXCJsZWZ0XCIsIFwifFwiOiBcImxlZnRcIiwgXCImJlwiOiBcImxlZnRcIiwgXCJ8fFwiOiBcImxlZnRcIn07XG5mdW5jdGlvbiBvcGVyYXRvckx0XzUxNShsZWZ0XzUyMCwgcmlnaHRfNTIxLCBhc3NvY181MjIpIHtcbiAgaWYgKGFzc29jXzUyMiA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gbGVmdF81MjAgPCByaWdodF81MjE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlZnRfNTIwIDw9IHJpZ2h0XzUyMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3BlcmF0b3JQcmVjXzUxNihvcF81MjMpIHtcbiAgcmV0dXJuIGJpbmFyeU9wZXJhdG9yUHJlY2VkZW5jZV81MTNbb3BfNTIzXTtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdG9yQXNzb2NfNTE3KG9wXzUyNCkge1xuICByZXR1cm4gb3BlcmF0b3JBc3NvY181MTRbb3BfNTI0XTtcbn1cbmZ1bmN0aW9uIGlzVW5hcnlPcGVyYXRvcl81MTgob3BfNTI1KSB7XG4gIHJldHVybiAob3BfNTI1Lm1hdGNoKFwicHVuY3R1YXRvclwiKSB8fCBvcF81MjUubWF0Y2goXCJpZGVudGlmaWVyXCIpIHx8IG9wXzUyNS5tYXRjaChcImtleXdvcmRcIikpICYmIHVuYXJ5T3BlcmF0b3JzXzUxMi5oYXNPd25Qcm9wZXJ0eShvcF81MjUudmFsKCkpO1xufVxuZnVuY3Rpb24gaXNPcGVyYXRvcl81MTkob3BfNTI2KSB7XG4gIGlmIChvcF81MjYubWF0Y2goXCJwdW5jdHVhdG9yXCIpIHx8IG9wXzUyNi5tYXRjaChcImlkZW50aWZpZXJcIikgfHwgb3BfNTI2Lm1hdGNoKFwia2V5d29yZFwiKSkge1xuICAgIHJldHVybiBiaW5hcnlPcGVyYXRvclByZWNlZGVuY2VfNTEzLmhhc093blByb3BlcnR5KG9wXzUyNikgfHwgdW5hcnlPcGVyYXRvcnNfNTEyLmhhc093blByb3BlcnR5KG9wXzUyNi52YWwoKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IHtvcGVyYXRvckx0XzUxNSBhcyBvcGVyYXRvckx0fTtcbmV4cG9ydCB7Z2V0T3BlcmF0b3JQcmVjXzUxNiBhcyBnZXRPcGVyYXRvclByZWN9O1xuZXhwb3J0IHtnZXRPcGVyYXRvckFzc29jXzUxNyBhcyBnZXRPcGVyYXRvckFzc29jfTtcbmV4cG9ydCB7aXNVbmFyeU9wZXJhdG9yXzUxOCBhcyBpc1VuYXJ5T3BlcmF0b3J9O1xuZXhwb3J0IHtpc09wZXJhdG9yXzUxOSBhcyBpc09wZXJhdG9yfSJdfQ==

	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.evalCompiletimeValue = exports.evalRuntimeValues = exports.sanitizeReplacementValues = undefined;

		var _termExpander = __webpack_require__(51);

		var _termExpander2 = _interopRequireDefault(_termExpander);

		var _immutable = __webpack_require__(9);

		var _parseReducer = __webpack_require__(34);

		var _parseReducer2 = _interopRequireDefault(_parseReducer);

		var _shiftReducer = __webpack_require__(30);

		var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

		var _serializer = __webpack_require__(54);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _shiftCodegen = __webpack_require__(35);

		var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

		var _transforms = __webpack_require__(29);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _shiftReader = __webpack_require__(1);

		var _shiftReader2 = _interopRequireDefault(_shiftReader);

		var _macroContext = __webpack_require__(62);

		var _templateProcessor = __webpack_require__(60);

		var _vm = __webpack_require__(45);

		var _vm2 = _interopRequireDefault(_vm);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		let geval_340 = eval;
		function sanitizeReplacementValues_341(values_344) {
		  if (Array.isArray(values_344)) {
		    return sanitizeReplacementValues_341((0, _immutable.List)(values_344));
		  } else if (_immutable.List.isList(values_344)) {
		    return values_344.map(sanitizeReplacementValues_341);
		  } else if (values_344 == null) {
		    throw new Error("replacement values for syntax template must not be null or undefined");
		  } else if (typeof values_344.next === "function") {
		    return sanitizeReplacementValues_341((0, _immutable.List)(values_344));
		  }
		  return (0, _macroContext.unwrap)(values_344);
		}
		function evalRuntimeValues_342(terms_345, context_346) {
		  let prepped_347 = terms_345.reduce((acc_353, term_354) => {
		    let result_355 = (0, _immutable.List)();
		    if ((0, _terms.isExport)(term_354)) {
		      if ((0, _terms.isVariableDeclaration)(term_354.declaration)) {
		        return acc_353.concat(new _terms2.default("VariableDeclarationStatement", { declaration: term_354.declaration })).concat(term_354.declaration.declarators.map(decl_356 => {
		          return new _terms2.default("ExpressionStatement", { expression: new _terms2.default("AssignmentExpression", { binding: new _terms2.default("StaticMemberExpression", { object: new _terms2.default("IdentifierExpression", { name: _syntax2.default.fromIdentifier("exports") }), property: decl_356.binding.name }), expression: new _terms2.default("IdentifierExpression", { name: decl_356.binding.name }) }) });
		        }));
		      }
		    } else if ((0, _terms.isImport)(term_354)) {
		      return acc_353;
		    }
		    return acc_353.concat(term_354);
		  }, (0, _immutable.List)());
		  let parsed_348 = (0, _shiftReducer2.default)(new _parseReducer2.default(context_346, false), new _terms2.default("Module", { directives: (0, _immutable.List)(), items: prepped_347 }).gen({ includeImports: false }));
		  let gen_349 = (0, _shiftCodegen2.default)(parsed_348, new _shiftCodegen.FormattedCodeGen());
		  let result_350 = context_346.transform(gen_349, { babelrc: true, filename: context_346.filename });
		  let exportsObj_351 = {};
		  context_346.store.set("exports", exportsObj_351);
		  let val_352 = _vm2.default.runInContext(result_350.code, context_346.store.getNodeContext());
		  return exportsObj_351;
		}
		function evalCompiletimeValue_343(expr_357, context_358) {
		  let deserializer_359 = (0, _serializer.makeDeserializer)(context_358.bindings);
		  let sandbox_360 = { syntaxQuote: function syntaxQuote(strings_368) {
		      for (var _len = arguments.length, values_367 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		        values_367[_key - 1] = arguments[_key];
		      }

		      let ctx_369 = deserializer_359.read(_.last(values_367));
		      let reader_370 = new _shiftReader2.default(strings_368, ctx_369, _.take(values_367.length - 1, values_367));
		      return reader_370.read();
		    }, syntaxTemplate: function syntaxTemplate(str_372) {
		      for (var _len2 = arguments.length, values_371 = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
		        values_371[_key2 - 1] = arguments[_key2];
		      }

		      return (0, _templateProcessor.replaceTemplate)(deserializer_359.read(str_372), sanitizeReplacementValues_341(values_371));
		    } };
		  let sandboxKeys_361 = (0, _immutable.List)(Object.keys(sandbox_360));
		  let sandboxVals_362 = sandboxKeys_361.map(k_373 => sandbox_360[k_373]).toArray();
		  let parsed_363 = (0, _shiftReducer2.default)(new _parseReducer2.default(context_358), new _terms2.default("Module", { directives: (0, _immutable.List)(), items: _immutable.List.of(new _terms2.default("ExpressionStatement", { expression: new _terms2.default("FunctionExpression", { isGenerator: false, name: null, params: new _terms2.default("FormalParameters", { items: sandboxKeys_361.map(param_374 => {
		            return new _terms2.default("BindingIdentifier", { name: _syntax2.default.from("identifier", param_374) });
		          }), rest: null }), body: new _terms2.default("FunctionBody", { directives: _immutable.List.of(new _terms2.default("Directive", { rawValue: "use strict" })), statements: _immutable.List.of(new _terms2.default("ReturnStatement", { expression: expr_357 })) }) }) })) }));
		  let gen_364 = (0, _shiftCodegen2.default)(parsed_363, new _shiftCodegen.FormattedCodeGen());
		  let result_365 = context_358.transform(gen_364, { babelrc: true, filename: context_358.filename });
		  let val_366 = _vm2.default.runInContext(result_365.code, context_358.store.getNodeContext());
		  return val_366.apply(undefined, sandboxVals_362);
		}
		exports.sanitizeReplacementValues = sanitizeReplacementValues_341;
		exports.evalRuntimeValues = evalRuntimeValues_342;
		exports.evalCompiletimeValue = evalCompiletimeValue_343;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2xvYWQtc3ludGF4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7O0lBQWEsQzs7Ozs7O0FBQ2IsSUFBSSxZQUFZLElBQWhCO0FBQ0EsU0FBUyw2QkFBVCxDQUF1QyxVQUF2QyxFQUFtRDtBQUNqRCxNQUFJLE1BQU0sT0FBTixDQUFjLFVBQWQsQ0FBSixFQUErQjtBQUM3QixXQUFPLDhCQUE4QixxQkFBSyxVQUFMLENBQTlCLENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSSxnQkFBSyxNQUFMLENBQVksVUFBWixDQUFKLEVBQTZCO0FBQ2xDLFdBQU8sV0FBVyxHQUFYLENBQWUsNkJBQWYsQ0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJLGNBQWMsSUFBbEIsRUFBd0I7QUFDN0IsVUFBTSxJQUFJLEtBQUosQ0FBVSxzRUFBVixDQUFOO0FBQ0QsR0FGTSxNQUVBLElBQUksT0FBTyxXQUFXLElBQWxCLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ2hELFdBQU8sOEJBQThCLHFCQUFLLFVBQUwsQ0FBOUIsQ0FBUDtBQUNEO0FBQ0QsU0FBTywwQkFBTyxVQUFQLENBQVA7QUFDRDtBQUNELFNBQVMscUJBQVQsQ0FBK0IsU0FBL0IsRUFBMEMsV0FBMUMsRUFBdUQ7QUFDckQsTUFBSSxjQUFjLFVBQVUsTUFBVixDQUFpQixDQUFDLE9BQUQsRUFBVSxRQUFWLEtBQXVCO0FBQ3hELFFBQUksYUFBYSxzQkFBakI7QUFDQSxRQUFJLHFCQUFTLFFBQVQsQ0FBSixFQUF3QjtBQUN0QixVQUFJLGtDQUFzQixTQUFTLFdBQS9CLENBQUosRUFBaUQ7QUFDL0MsZUFBTyxRQUFRLE1BQVIsQ0FBZSxvQkFBUyw4QkFBVCxFQUF5QyxFQUFDLGFBQWEsU0FBUyxXQUF2QixFQUF6QyxDQUFmLEVB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QixFQUFDLGFBQWEsS0FBZCxFQUFxQixNQUFNLElBQTNCLEVBQWlDLFFBQVEsb0JBQVMsa0JBQVQsRUFBNkIsRUFBQyxPQUFPLGdCQUFnQixHQUFoQixDQUFvQixhQUFhO0FBQ3hTLG1CQUFPLG9CQUFTLG1CQUFULEVBQThCLEVBQUMsTUFBTSxpQkFBTyxJQUFQLENBQVksWUFBWixFQUEwQixTQUExQixDQUFQLEVBQTlCLENBQVA7QUFDRCxXQUZ3USxDQUFSLEVBRTdQLE1BQU0sSUFGdVAsRUFBN0IsQ0FBekMsRUFFekssTUFBTSxvQkFBUyxjQUFULEVBQXlCLEVBQUMsWUFBWSxnQkFBSyxFQUFMLENBQVEsb0JBQVMsV0FBVCxFQUFzQixFQUFDLFVBQVUsWUFBWCxFQUF0QixDQUFSLENBQWIsRUFBdUUsWUFBWSxnQkFBSyxFQUFMLENBQVEsb0JBQVMsaUJBQVQsRUFBNEIsRUFBQyxZQUFZLFFBQWIsRUFBNUIsQ0FBUixDQUFuRixFQUF6QixDQUZtSyxFQUEvQixDQUFiLEVBQWhDLENBQVIsQ0FBNUIsRUFBbkIsQ0FBdkMsQ0FBakI7QUFHQSxNQUFJLFVBQVUsNEJBQVEsVUFBUixFQUFvQixvQ0FBcEIsQ0FBZDtBQUNBLE1BQUksYUFBYSxZQUFZLFNBQVosQ0FBc0IsT0FBdEIsRUFBK0IsRUFBQyxTQUFTLElBQVYsRUFBZ0IsVUFBVSxZQUFZLFFBQXRDLEVBQS9CLENBQWpCO0FBQ0EsTUFBSSxVQUFVLGFBQUcsWUFBSCxDQUFnQixXQUFXLElBQTNCLEVBQWlDLFlBQVksS0FBWixDQUFrQixjQUFsQixFQUFqQyxDQUFkO0FBQ0EsU0FBTyxRQUFRLEtBQVIsQ0FBYyxTQUFkLEVBQXlCLGVBQXpCLENBQVA7QUFDRDtRQUN3Qyx5QixHQUFqQyw2QjtRQUN5QixpQixHQUF6QixxQjtRQUM0QixvQixHQUE1Qix3QiIsImZpbGUiOiJsb2FkLXN5bnRheC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlclwiO1xuaW1wb3J0IHtMaXN0fSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQgUGFyc2VSZWR1Y2VyIGZyb20gXCIuL3BhcnNlLXJlZHVjZXIuanNcIjtcbmltcG9ydCByZWR1Y2VyLCB7TW9ub2lkYWxSZWR1Y2VyfSBmcm9tIFwic2hpZnQtcmVkdWNlclwiO1xuaW1wb3J0IHttYWtlRGVzZXJpYWxpemVyfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG5pbXBvcnQgU3ludGF4IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0IGNvZGVnZW4sIHtGb3JtYXR0ZWRDb2RlR2VufSBmcm9tIFwic2hpZnQtY29kZWdlblwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNGdW5jdGlvbkRlY2xhcmF0aW9uLCBpc0Z1bmN0aW9uRXhwcmVzc2lvbiwgaXNGdW5jdGlvblRlcm0sIGlzRnVuY3Rpb25XaXRoTmFtZSwgaXNTeW50YXhEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQsIGlzSW1wb3J0LCBpc0V4cG9ydH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCBSZWFkZXIgZnJvbSBcIi4vc2hpZnQtcmVhZGVyXCI7XG5pbXBvcnQge3Vud3JhcH0gZnJvbSBcIi4vbWFjcm8tY29udGV4dFwiO1xuaW1wb3J0IHtyZXBsYWNlVGVtcGxhdGV9IGZyb20gXCIuL3RlbXBsYXRlLXByb2Nlc3NvclwiO1xuaW1wb3J0IHZtIGZyb20gXCJ2bVwiO1xuaW1wb3J0ICAqIGFzIF8gZnJvbSBcInJhbWRhXCI7XG5sZXQgZ2V2YWxfMzQwID0gZXZhbDtcbmZ1bmN0aW9uIHNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXNfMzQxKHZhbHVlc18zNDQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzXzM0NCkpIHtcbiAgICByZXR1cm4gc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDEoTGlzdCh2YWx1ZXNfMzQ0KSk7XG4gIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodmFsdWVzXzM0NCkpIHtcbiAgICByZXR1cm4gdmFsdWVzXzM0NC5tYXAoc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDEpO1xuICB9IGVsc2UgaWYgKHZhbHVlc18zNDQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlcGxhY2VtZW50IHZhbHVlcyBmb3Igc3ludGF4IHRlbXBsYXRlIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXNfMzQ0Lm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzXzM0MShMaXN0KHZhbHVlc18zNDQpKTtcbiAgfVxuICByZXR1cm4gdW53cmFwKHZhbHVlc18zNDQpO1xufVxuZnVuY3Rpb24gZXZhbFJ1bnRpbWVWYWx1ZXNfMzQyKHRlcm1zXzM0NSwgY29udGV4dF8zNDYpIHtcbiAgbGV0IHByZXBwZWRfMzQ3ID0gdGVybXNfMzQ1LnJlZHVjZSgoYWNjXzM1MywgdGVybV8zNTQpID0+IHtcbiAgICBsZXQgcmVzdWx0XzM1NSA9IExpc3QoKTtcbiAgICBpZiAoaXNFeHBvcnQodGVybV8zNTQpKSB7XG4gICAgICBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMzU0LmRlY2xhcmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gYWNjXzM1My5jb25jYXQobmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGVybV8zNTQuZGVjbGFyYXRpb259KSkuY29uY2F0KHRlcm1fMzU0LmRlY2xhcmF0aW9uLmRlY2xhcmF0b3JzLm1hcChkZWNsXzM1NiA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXJtKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogbmV3IFRlcm0oXCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uXCIsIHtvYmplY3Q6IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IFN5bnRheC5mcm9tSWRlbnRpZmllcihcImV4cG9ydHNcIil9KSwgcHJvcGVydHk6IGRlY2xfMzU2LmJpbmRpbmcubmFtZX0pLCBleHByZXNzaW9uOiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiBkZWNsXzM1Ni5iaW5kaW5nLm5hbWV9KX0pfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSW1wb3J0KHRlcm1fMzU0KSkge1xuICAgICAgcmV0dXJuIGFjY18zNTM7XG4gICAgfVxuICAgIHJldHVybiBhY2NfMzUzLmNvbmNhdCh0ZXJtXzM1NCk7XG4gIH0sIExpc3QoKSk7XG4gIGxldCBwYXJzZWRfMzQ4ID0gcmVkdWNlcihuZXcgUGFyc2VSZWR1Y2VyKGNvbnRleHRfMzQ2LCBmYWxzZSksIG5ldyBUZXJtKFwiTW9kdWxlXCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIGl0ZW1zOiBwcmVwcGVkXzM0N30pLmdlbih7aW5jbHVkZUltcG9ydHM6IGZhbHNlfSkpO1xuICBsZXQgZ2VuXzM0OSA9IGNvZGVnZW4ocGFyc2VkXzM0OCwgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICBsZXQgcmVzdWx0XzM1MCA9IGNvbnRleHRfMzQ2LnRyYW5zZm9ybShnZW5fMzQ5LCB7YmFiZWxyYzogdHJ1ZSwgZmlsZW5hbWU6IGNvbnRleHRfMzQ2LmZpbGVuYW1lfSk7XG4gIGxldCBleHBvcnRzT2JqXzM1MSA9IHt9O1xuICBjb250ZXh0XzM0Ni5zdG9yZS5zZXQoXCJleHBvcnRzXCIsIGV4cG9ydHNPYmpfMzUxKTtcbiAgbGV0IHZhbF8zNTIgPSB2bS5ydW5JbkNvbnRleHQocmVzdWx0XzM1MC5jb2RlLCBjb250ZXh0XzM0Ni5zdG9yZS5nZXROb2RlQ29udGV4dCgpKTtcbiAgcmV0dXJuIGV4cG9ydHNPYmpfMzUxO1xufVxuZnVuY3Rpb24gZXZhbENvbXBpbGV0aW1lVmFsdWVfMzQzKGV4cHJfMzU3LCBjb250ZXh0XzM1OCkge1xuICBsZXQgZGVzZXJpYWxpemVyXzM1OSA9IG1ha2VEZXNlcmlhbGl6ZXIoY29udGV4dF8zNTguYmluZGluZ3MpO1xuICBsZXQgc2FuZGJveF8zNjAgPSB7c3ludGF4UXVvdGU6IGZ1bmN0aW9uIChzdHJpbmdzXzM2OCwgLi4udmFsdWVzXzM2Nykge1xuICAgIGxldCBjdHhfMzY5ID0gZGVzZXJpYWxpemVyXzM1OS5yZWFkKF8ubGFzdCh2YWx1ZXNfMzY3KSk7XG4gICAgbGV0IHJlYWRlcl8zNzAgPSBuZXcgUmVhZGVyKHN0cmluZ3NfMzY4LCBjdHhfMzY5LCBfLnRha2UodmFsdWVzXzM2Ny5sZW5ndGggLSAxLCB2YWx1ZXNfMzY3KSk7XG4gICAgcmV0dXJuIHJlYWRlcl8zNzAucmVhZCgpO1xuICB9LCBzeW50YXhUZW1wbGF0ZTogZnVuY3Rpb24gKHN0cl8zNzIsIC4uLnZhbHVlc18zNzEpIHtcbiAgICByZXR1cm4gcmVwbGFjZVRlbXBsYXRlKGRlc2VyaWFsaXplcl8zNTkucmVhZChzdHJfMzcyKSwgc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDEodmFsdWVzXzM3MSkpO1xuICB9fTtcbiAgbGV0IHNhbmRib3hLZXlzXzM2MSA9IExpc3QoT2JqZWN0LmtleXMoc2FuZGJveF8zNjApKTtcbiAgbGV0IHNhbmRib3hWYWxzXzM2MiA9IHNhbmRib3hLZXlzXzM2MS5tYXAoa18zNzMgPT4gc2FuZGJveF8zNjBba18zNzNdKS50b0FycmF5KCk7XG4gIGxldCBwYXJzZWRfMzYzID0gcmVkdWNlcihuZXcgUGFyc2VSZWR1Y2VyKGNvbnRleHRfMzU4KSwgbmV3IFRlcm0oXCJNb2R1bGVcIiwge2RpcmVjdGl2ZXM6IExpc3QoKSwgaXRlbXM6IExpc3Qub2YobmV3IFRlcm0oXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiBuZXcgVGVybShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7aXNHZW5lcmF0b3I6IGZhbHNlLCBuYW1lOiBudWxsLCBwYXJhbXM6IG5ldyBUZXJtKFwiRm9ybWFsUGFyYW1ldGVyc1wiLCB7aXRlbXM6IHNhbmRib3hLZXlzXzM2MS5tYXAocGFyYW1fMzc0ID0+IHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nSWRlbnRpZmllclwiLCB7bmFtZTogU3ludGF4LmZyb20oXCJpZGVudGlmaWVyXCIsIHBhcmFtXzM3NCl9KTtcbiAgfSksIHJlc3Q6IG51bGx9KSwgYm9keTogbmV3IFRlcm0oXCJGdW5jdGlvbkJvZHlcIiwge2RpcmVjdGl2ZXM6IExpc3Qub2YobmV3IFRlcm0oXCJEaXJlY3RpdmVcIiwge3Jhd1ZhbHVlOiBcInVzZSBzdHJpY3RcIn0pKSwgc3RhdGVtZW50czogTGlzdC5vZihuZXcgVGVybShcIlJldHVyblN0YXRlbWVudFwiLCB7ZXhwcmVzc2lvbjogZXhwcl8zNTd9KSl9KX0pfSkpfSkpO1xuICBsZXQgZ2VuXzM2NCA9IGNvZGVnZW4ocGFyc2VkXzM2MywgbmV3IEZvcm1hdHRlZENvZGVHZW4pO1xuICBsZXQgcmVzdWx0XzM2NSA9IGNvbnRleHRfMzU4LnRyYW5zZm9ybShnZW5fMzY0LCB7YmFiZWxyYzogdHJ1ZSwgZmlsZW5hbWU6IGNvbnRleHRfMzU4LmZpbGVuYW1lfSk7XG4gIGxldCB2YWxfMzY2ID0gdm0ucnVuSW5Db250ZXh0KHJlc3VsdF8zNjUuY29kZSwgY29udGV4dF8zNTguc3RvcmUuZ2V0Tm9kZUNvbnRleHQoKSk7XG4gIHJldHVybiB2YWxfMzY2LmFwcGx5KHVuZGVmaW5lZCwgc2FuZGJveFZhbHNfMzYyKTtcbn1cbmV4cG9ydCB7c2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc18zNDEgYXMgc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlc307XG5leHBvcnQge2V2YWxSdW50aW1lVmFsdWVzXzM0MiBhcyBldmFsUnVudGltZVZhbHVlc307XG5leHBvcnQge2V2YWxDb21waWxldGltZVZhbHVlXzM0MyBhcyBldmFsQ29tcGlsZXRpbWVWYWx1ZX0iXX0=

	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _immutable = __webpack_require__(9);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _scope = __webpack_require__(41);

		var _applyScopeInParamsReducer = __webpack_require__(52);

		var _applyScopeInParamsReducer2 = _interopRequireDefault(_applyScopeInParamsReducer);

		var _shiftReducer = __webpack_require__(30);

		var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

		var _compiler = __webpack_require__(53);

		var _compiler2 = _interopRequireDefault(_compiler);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _serializer = __webpack_require__(54);

		var _enforester = __webpack_require__(48);

		var _errors = __webpack_require__(11);

		var _templateProcessor = __webpack_require__(60);

		var _astDispatcher = __webpack_require__(61);

		var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class TermExpander extends _astDispatcher2.default {
		  constructor(context_937) {
		    super("expand", true);
		    this.context = context_937;
		  }
		  expand(term_938) {
		    return this.dispatch(term_938);
		  }
		  expandPragma(term_939) {
		    return term_939;
		  }
		  expandTemplateExpression(term_940) {
		    return new _terms2.default("TemplateExpression", { tag: term_940.tag == null ? null : this.expand(term_940.tag), elements: term_940.elements.toArray() });
		  }
		  expandBreakStatement(term_941) {
		    return new _terms2.default("BreakStatement", { label: term_941.label ? term_941.label.val() : null });
		  }
		  expandDoWhileStatement(term_942) {
		    return new _terms2.default("DoWhileStatement", { body: this.expand(term_942.body), test: this.expand(term_942.test) });
		  }
		  expandWithStatement(term_943) {
		    return new _terms2.default("WithStatement", { body: this.expand(term_943.body), object: this.expand(term_943.object) });
		  }
		  expandDebuggerStatement(term_944) {
		    return term_944;
		  }
		  expandContinueStatement(term_945) {
		    return new _terms2.default("ContinueStatement", { label: term_945.label ? term_945.label.val() : null });
		  }
		  expandSwitchStatementWithDefault(term_946) {
		    return new _terms2.default("SwitchStatementWithDefault", { discriminant: this.expand(term_946.discriminant), preDefaultCases: term_946.preDefaultCases.map(c_947 => this.expand(c_947)).toArray(), defaultCase: this.expand(term_946.defaultCase), postDefaultCases: term_946.postDefaultCases.map(c_948 => this.expand(c_948)).toArray() });
		  }
		  expandComputedMemberExpression(term_949) {
		    return new _terms2.default("ComputedMemberExpression", { object: this.expand(term_949.object), expression: this.expand(term_949.expression) });
		  }
		  expandSwitchStatement(term_950) {
		    return new _terms2.default("SwitchStatement", { discriminant: this.expand(term_950.discriminant), cases: term_950.cases.map(c_951 => this.expand(c_951)).toArray() });
		  }
		  expandFormalParameters(term_952) {
		    let rest_953 = term_952.rest == null ? null : this.expand(term_952.rest);
		    return new _terms2.default("FormalParameters", { items: term_952.items.map(i_954 => this.expand(i_954)), rest: rest_953 });
		  }
		  expandArrowExpression(term_955) {
		    return this.doFunctionExpansion(term_955, "ArrowExpression");
		  }
		  expandSwitchDefault(term_956) {
		    return new _terms2.default("SwitchDefault", { consequent: term_956.consequent.map(c_957 => this.expand(c_957)).toArray() });
		  }
		  expandSwitchCase(term_958) {
		    return new _terms2.default("SwitchCase", { test: this.expand(term_958.test), consequent: term_958.consequent.map(c_959 => this.expand(c_959)).toArray() });
		  }
		  expandForInStatement(term_960) {
		    return new _terms2.default("ForInStatement", { left: this.expand(term_960.left), right: this.expand(term_960.right), body: this.expand(term_960.body) });
		  }
		  expandTryCatchStatement(term_961) {
		    return new _terms2.default("TryCatchStatement", { body: this.expand(term_961.body), catchClause: this.expand(term_961.catchClause) });
		  }
		  expandTryFinallyStatement(term_962) {
		    let catchClause_963 = term_962.catchClause == null ? null : this.expand(term_962.catchClause);
		    return new _terms2.default("TryFinallyStatement", { body: this.expand(term_962.body), catchClause: catchClause_963, finalizer: this.expand(term_962.finalizer) });
		  }
		  expandCatchClause(term_964) {
		    return new _terms2.default("CatchClause", { binding: this.expand(term_964.binding), body: this.expand(term_964.body) });
		  }
		  expandThrowStatement(term_965) {
		    return new _terms2.default("ThrowStatement", { expression: this.expand(term_965.expression) });
		  }
		  expandForOfStatement(term_966) {
		    return new _terms2.default("ForOfStatement", { left: this.expand(term_966.left), right: this.expand(term_966.right), body: this.expand(term_966.body) });
		  }
		  expandBindingIdentifier(term_967) {
		    return term_967;
		  }
		  expandBindingPropertyIdentifier(term_968) {
		    return term_968;
		  }
		  expandBindingPropertyProperty(term_969) {
		    return new _terms2.default("BindingPropertyProperty", { name: this.expand(term_969.name), binding: this.expand(term_969.binding) });
		  }
		  expandComputedPropertyName(term_970) {
		    return new _terms2.default("ComputedPropertyName", { expression: this.expand(term_970.expression) });
		  }
		  expandObjectBinding(term_971) {
		    return new _terms2.default("ObjectBinding", { properties: term_971.properties.map(t_972 => this.expand(t_972)).toArray() });
		  }
		  expandArrayBinding(term_973) {
		    let restElement_974 = term_973.restElement == null ? null : this.expand(term_973.restElement);
		    return new _terms2.default("ArrayBinding", { elements: term_973.elements.map(t_975 => t_975 == null ? null : this.expand(t_975)).toArray(), restElement: restElement_974 });
		  }
		  expandBindingWithDefault(term_976) {
		    return new _terms2.default("BindingWithDefault", { binding: this.expand(term_976.binding), init: this.expand(term_976.init) });
		  }
		  expandShorthandProperty(term_977) {
		    return new _terms2.default("DataProperty", { name: new _terms2.default("StaticPropertyName", { value: term_977.name }), expression: new _terms2.default("IdentifierExpression", { name: term_977.name }) });
		  }
		  expandForStatement(term_978) {
		    let init_979 = term_978.init == null ? null : this.expand(term_978.init);
		    let test_980 = term_978.test == null ? null : this.expand(term_978.test);
		    let update_981 = term_978.update == null ? null : this.expand(term_978.update);
		    let body_982 = this.expand(term_978.body);
		    return new _terms2.default("ForStatement", { init: init_979, test: test_980, update: update_981, body: body_982 });
		  }
		  expandYieldExpression(term_983) {
		    let expr_984 = term_983.expression == null ? null : this.expand(term_983.expression);
		    return new _terms2.default("YieldExpression", { expression: expr_984 });
		  }
		  expandYieldGeneratorExpression(term_985) {
		    let expr_986 = term_985.expression == null ? null : this.expand(term_985.expression);
		    return new _terms2.default("YieldGeneratorExpression", { expression: expr_986 });
		  }
		  expandWhileStatement(term_987) {
		    return new _terms2.default("WhileStatement", { test: this.expand(term_987.test), body: this.expand(term_987.body) });
		  }
		  expandIfStatement(term_988) {
		    let consequent_989 = term_988.consequent == null ? null : this.expand(term_988.consequent);
		    let alternate_990 = term_988.alternate == null ? null : this.expand(term_988.alternate);
		    return new _terms2.default("IfStatement", { test: this.expand(term_988.test), consequent: consequent_989, alternate: alternate_990 });
		  }
		  expandBlockStatement(term_991) {
		    return new _terms2.default("BlockStatement", { block: this.expand(term_991.block) });
		  }
		  expandBlock(term_992) {
		    return new _terms2.default("Block", { statements: term_992.statements.map(s_993 => this.expand(s_993)).toArray() });
		  }
		  expandVariableDeclarationStatement(term_994) {
		    return new _terms2.default("VariableDeclarationStatement", { declaration: this.expand(term_994.declaration) });
		  }
		  expandReturnStatement(term_995) {
		    if (term_995.expression == null) {
		      return term_995;
		    }
		    return new _terms2.default("ReturnStatement", { expression: this.expand(term_995.expression) });
		  }
		  expandClassDeclaration(term_996) {
		    return new _terms2.default("ClassDeclaration", { name: term_996.name == null ? null : this.expand(term_996.name), super: term_996.super == null ? null : this.expand(term_996.super), elements: term_996.elements.map(el_997 => this.expand(el_997)).toArray() });
		  }
		  expandClassExpression(term_998) {
		    return new _terms2.default("ClassExpression", { name: term_998.name == null ? null : this.expand(term_998.name), super: term_998.super == null ? null : this.expand(term_998.super), elements: term_998.elements.map(el_999 => this.expand(el_999)).toArray() });
		  }
		  expandClassElement(term_1000) {
		    return new _terms2.default("ClassElement", { isStatic: term_1000.isStatic, method: this.expand(term_1000.method) });
		  }
		  expandThisExpression(term_1001) {
		    return term_1001;
		  }
		  expandSyntaxTemplate(term_1002) {
		    let r_1003 = (0, _templateProcessor.processTemplate)(term_1002.template.inner());
		    let str_1004 = _syntax2.default.from("string", _serializer.serializer.write(r_1003.template));
		    let callee_1005 = new _terms2.default("IdentifierExpression", { name: _syntax2.default.from("identifier", "syntaxTemplate") });
		    let expandedInterps_1006 = r_1003.interp.map(i_1008 => {
		      let enf_1009 = new _enforester.Enforester(i_1008, (0, _immutable.List)(), this.context);
		      return this.expand(enf_1009.enforest("expression"));
		    });
		    let args_1007 = _immutable.List.of(new _terms2.default("LiteralStringExpression", { value: str_1004 })).concat(expandedInterps_1006);
		    return new _terms2.default("CallExpression", { callee: callee_1005, arguments: args_1007 });
		  }
		  expandSyntaxQuote(term_1010) {
		    let str_1011 = new _terms2.default("LiteralStringExpression", { value: _syntax2.default.from("string", _serializer.serializer.write(term_1010.name)) });
		    return new _terms2.default("TemplateExpression", { tag: term_1010.template.tag, elements: term_1010.template.elements.push(str_1011).push(new _terms2.default("TemplateElement", { rawValue: "" })).toArray() });
		  }
		  expandStaticMemberExpression(term_1012) {
		    return new _terms2.default("StaticMemberExpression", { object: this.expand(term_1012.object), property: term_1012.property });
		  }
		  expandArrayExpression(term_1013) {
		    return new _terms2.default("ArrayExpression", { elements: term_1013.elements.map(t_1014 => t_1014 == null ? t_1014 : this.expand(t_1014)) });
		  }
		  expandImport(term_1015) {
		    return term_1015;
		  }
		  expandImportNamespace(term_1016) {
		    return term_1016;
		  }
		  expandExport(term_1017) {
		    return new _terms2.default("Export", { declaration: this.expand(term_1017.declaration) });
		  }
		  expandExportDefault(term_1018) {
		    return new _terms2.default("ExportDefault", { body: this.expand(term_1018.body) });
		  }
		  expandExportFrom(term_1019) {
		    return term_1019;
		  }
		  expandExportAllFrom(term_1020) {
		    return term_1020;
		  }
		  expandExportSpecifier(term_1021) {
		    return term_1021;
		  }
		  expandStaticPropertyName(term_1022) {
		    return term_1022;
		  }
		  expandDataProperty(term_1023) {
		    return new _terms2.default("DataProperty", { name: this.expand(term_1023.name), expression: this.expand(term_1023.expression) });
		  }
		  expandObjectExpression(term_1024) {
		    return new _terms2.default("ObjectExpression", { properties: term_1024.properties.map(t_1025 => this.expand(t_1025)) });
		  }
		  expandVariableDeclarator(term_1026) {
		    let init_1027 = term_1026.init == null ? null : this.expand(term_1026.init);
		    return new _terms2.default("VariableDeclarator", { binding: this.expand(term_1026.binding), init: init_1027 });
		  }
		  expandVariableDeclaration(term_1028) {
		    if (term_1028.kind === "syntax" || term_1028.kind === "syntaxrec") {
		      return term_1028;
		    }
		    return new _terms2.default("VariableDeclaration", { kind: term_1028.kind, declarators: term_1028.declarators.map(d_1029 => this.expand(d_1029)) });
		  }
		  expandParenthesizedExpression(term_1030) {
		    if (term_1030.inner.size === 0) {
		      throw new Error("unexpected end of input");
		    }
		    let enf_1031 = new _enforester.Enforester(term_1030.inner, (0, _immutable.List)(), this.context);
		    let lookahead_1032 = enf_1031.peek();
		    let t_1033 = enf_1031.enforestExpression();
		    if (t_1033 == null || enf_1031.rest.size > 0) {
		      throw enf_1031.createError(lookahead_1032, "unexpected syntax");
		    }
		    return this.expand(t_1033);
		  }
		  expandUnaryExpression(term_1034) {
		    return new _terms2.default("UnaryExpression", { operator: term_1034.operator, operand: this.expand(term_1034.operand) });
		  }
		  expandUpdateExpression(term_1035) {
		    return new _terms2.default("UpdateExpression", { isPrefix: term_1035.isPrefix, operator: term_1035.operator, operand: this.expand(term_1035.operand) });
		  }
		  expandBinaryExpression(term_1036) {
		    let left_1037 = this.expand(term_1036.left);
		    let right_1038 = this.expand(term_1036.right);
		    return new _terms2.default("BinaryExpression", { left: left_1037, operator: term_1036.operator, right: right_1038 });
		  }
		  expandConditionalExpression(term_1039) {
		    return new _terms2.default("ConditionalExpression", { test: this.expand(term_1039.test), consequent: this.expand(term_1039.consequent), alternate: this.expand(term_1039.alternate) });
		  }
		  expandNewTargetExpression(term_1040) {
		    return term_1040;
		  }
		  expandNewExpression(term_1041) {
		    let callee_1042 = this.expand(term_1041.callee);
		    let enf_1043 = new _enforester.Enforester(term_1041.arguments, (0, _immutable.List)(), this.context);
		    let args_1044 = enf_1043.enforestArgumentList().map(arg_1045 => this.expand(arg_1045));
		    return new _terms2.default("NewExpression", { callee: callee_1042, arguments: args_1044.toArray() });
		  }
		  expandSuper(term_1046) {
		    return term_1046;
		  }
		  expandCallExpression(term_1047) {
		    let callee_1048 = this.expand(term_1047.callee);
		    let enf_1049 = new _enforester.Enforester(term_1047.arguments, (0, _immutable.List)(), this.context);
		    let args_1050 = enf_1049.enforestArgumentList().map(arg_1051 => this.expand(arg_1051));
		    return new _terms2.default("CallExpression", { callee: callee_1048, arguments: args_1050 });
		  }
		  expandSpreadElement(term_1052) {
		    return new _terms2.default("SpreadElement", { expression: this.expand(term_1052.expression) });
		  }
		  expandExpressionStatement(term_1053) {
		    let child_1054 = this.expand(term_1053.expression);
		    return new _terms2.default("ExpressionStatement", { expression: child_1054 });
		  }
		  expandLabeledStatement(term_1055) {
		    return new _terms2.default("LabeledStatement", { label: term_1055.label.val(), body: this.expand(term_1055.body) });
		  }
		  doFunctionExpansion(term_1056, type_1057) {
		    let scope_1058 = (0, _scope.freshScope)("fun");
		    let red_1059 = new _applyScopeInParamsReducer2.default(scope_1058, this.context);
		    let params_1060;
		    if (type_1057 !== "Getter" && type_1057 !== "Setter") {
		      params_1060 = red_1059.transform(term_1056.params);
		      params_1060 = this.expand(params_1060);
		    }
		    this.context.currentScope.push(scope_1058);
		    let compiler_1061 = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);
		    let markedBody_1062, bodyTerm_1063;
		    if (term_1056.body instanceof _terms2.default) {
		      bodyTerm_1063 = this.expand(term_1056.body.addScope(scope_1058, this.context.bindings, _syntax.ALL_PHASES));
		    } else {
		      markedBody_1062 = term_1056.body.map(b_1064 => b_1064.addScope(scope_1058, this.context.bindings, _syntax.ALL_PHASES));
		      bodyTerm_1063 = new _terms2.default("FunctionBody", { directives: (0, _immutable.List)(), statements: compiler_1061.compile(markedBody_1062) });
		    }
		    this.context.currentScope.pop();
		    if (type_1057 === "Getter") {
		      return new _terms2.default(type_1057, { name: this.expand(term_1056.name), body: bodyTerm_1063 });
		    } else if (type_1057 === "Setter") {
		      return new _terms2.default(type_1057, { name: this.expand(term_1056.name), param: term_1056.param, body: bodyTerm_1063 });
		    }
		    return new _terms2.default(type_1057, { name: term_1056.name, isGenerator: term_1056.isGenerator, params: params_1060, body: bodyTerm_1063 });
		  }
		  expandMethod(term_1065) {
		    return this.doFunctionExpansion(term_1065, "Method");
		  }
		  expandSetter(term_1066) {
		    return this.doFunctionExpansion(term_1066, "Setter");
		  }
		  expandGetter(term_1067) {
		    return this.doFunctionExpansion(term_1067, "Getter");
		  }
		  expandFunctionDeclaration(term_1068) {
		    return this.doFunctionExpansion(term_1068, "FunctionDeclaration");
		  }
		  expandFunctionExpression(term_1069) {
		    return this.doFunctionExpansion(term_1069, "FunctionExpression");
		  }
		  expandCompoundAssignmentExpression(term_1070) {
		    return new _terms2.default("CompoundAssignmentExpression", { binding: this.expand(term_1070.binding), operator: term_1070.operator, expression: this.expand(term_1070.expression) });
		  }
		  expandAssignmentExpression(term_1071) {
		    return new _terms2.default("AssignmentExpression", { binding: this.expand(term_1071.binding), expression: this.expand(term_1071.expression) });
		  }
		  expandEmptyStatement(term_1072) {
		    return term_1072;
		  }
		  expandLiteralBooleanExpression(term_1073) {
		    return term_1073;
		  }
		  expandLiteralNumericExpression(term_1074) {
		    return term_1074;
		  }
		  expandLiteralInfinityExpression(term_1075) {
		    return term_1075;
		  }
		  expandIdentifierExpression(term_1076) {
		    let trans_1077 = this.context.env.get(term_1076.name.resolve(this.context.phase));
		    if (trans_1077) {
		      return new _terms2.default("IdentifierExpression", { name: trans_1077.id });
		    }
		    return term_1076;
		  }
		  expandLiteralNullExpression(term_1078) {
		    return term_1078;
		  }
		  expandLiteralStringExpression(term_1079) {
		    return term_1079;
		  }
		  expandLiteralRegExpExpression(term_1080) {
		    return term_1080;
		  }
		}
		exports.default = TermExpander;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3Rlcm0tZXhwYW5kZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFDZSxNQUFNLFlBQU4saUNBQXlDO0FBQ3RELGNBQVksV0FBWixFQUF5QjtBQUN2QixVQUFNLFFBQU4sRUFBZ0IsSUFBaEI7QUFDQSxTQUFLLE9BQUwsR0FBZSxXQUFmO0FBQ0Q7QUFDRCxTQUFPLFFBQVAsRUFBaUI7QUFDZixXQUFPLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBUDtBQUNEO0FBQ0QsZUFBYSxRQUFiLEVBQXVCO0FBQ3JCLFdBQU8sUUFBUDtBQUNEO0FBQ0QsMkJBQXlCLFFBQXpCLEVBQW1DO0FBQ2pDLFdBQU8sb0JBQVMsb0JBQVQsRUFBK0IsRUFBQyxLQUFLLFNBQVMsR0FBVCxJQUFnQixJQUFoQixHQUF1QixJQUF2QixHQUE4QixLQUFLLE1BQUwsQ0FBWSxTQUFTLEdBQXJCLENBQXBDLEVBQStELFVBQVUsU0FBUyxRQUFULENBQWtCLE9BQWxCLEVBQXpFLEVBQS9CLENBQVA7QUFDRDtBQUNELHVCQUFxQixRQUFyQixFQUErQjtBQUM3QixXQUFPLG9CQUFTLGdCQUFULEVBQTJCLEVBQUMsT0FBTyxTQUFTLEtBQVQsR0FBaUIsU0FBUyxLQUFULENBQWUsR0FBZixFQUFqQixHQUF3QyxJQUFoRCxFQUEzQixDQUFQO0FBQ0Q7QUFDRCx5QkFBdUIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBTyxvQkFBUyxrQkFBVCxFQUE2QixFQUFDLE1BQU0sS0FBSyxNQUFMLENBQVksU0FBUyxJQUFyQixDQUFQLEVBQW1DLE1BQU0sS0FBSyxNQUFMLENBQVksU0FBUyxJQUFyQixDQUF6QyxFQUE3QixDQUFQO0FBQ0Q7QUFDRCxzQkFBb0IsUUFBcEIsRUFBOEI7QUFDNUIsV0FBTyxvQkFBUyxlQUFULEVBQTBC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UyxzQkFBVCxFQUFpQyxFQUFDLE1BQU0sV0FBVyxFQUFsQixFQUFqQyxDQUFQO0FBQ0Q7QUFDRCxXQUFPLFNBQVA7QUFDRDtBQUNELDhCQUE0QixTQUE1QixFQUF1QztBQUNyQyxXQUFPLFNBQVA7QUFDRDtBQUNELGdDQUE4QixTQUE5QixFQUF5QztBQUN2QyxXQUFPLFNBQVA7QUFDRDtBQUNELGdDQUE4QixTQUE5QixFQUF5QztBQUN2QyxXQUFPLFNBQVA7QUFDRDtBQTdVcUQ7a0JBQW5DLFkiLCJmaWxlIjoidGVybS1leHBhbmRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IFRlcm0sIHtpc0VPRiwgaXNCaW5kaW5nSWRlbnRpZmllciwgaXNGdW5jdGlvbkRlY2xhcmF0aW9uLCBpc0Z1bmN0aW9uRXhwcmVzc2lvbiwgaXNGdW5jdGlvblRlcm0sIGlzRnVuY3Rpb25XaXRoTmFtZSwgaXNTeW50YXhEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQsIGlzSW1wb3J0LCBpc0V4cG9ydH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7U2NvcGUsIGZyZXNoU2NvcGV9IGZyb20gXCIuL3Njb3BlXCI7XG5pbXBvcnQgQXBwbHlTY29wZUluUGFyYW1zUmVkdWNlciBmcm9tIFwiLi9hcHBseS1zY29wZS1pbi1wYXJhbXMtcmVkdWNlclwiO1xuaW1wb3J0IHJlZHVjZXIsIHtNb25vaWRhbFJlZHVjZXJ9IGZyb20gXCJzaGlmdC1yZWR1Y2VyXCI7XG5pbXBvcnQgQ29tcGlsZXIgZnJvbSBcIi4vY29tcGlsZXJcIjtcbmltcG9ydCBTeW50YXgsIHtBTExfUEhBU0VTfSBmcm9tIFwiLi9zeW50YXhcIjtcbmltcG9ydCB7c2VyaWFsaXplciwgbWFrZURlc2VyaWFsaXplcn0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuaW1wb3J0IHtlbmZvcmVzdEV4cHIsIEVuZm9yZXN0ZXJ9IGZyb20gXCIuL2VuZm9yZXN0ZXJcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7cHJvY2Vzc1RlbXBsYXRlfSBmcm9tIFwiLi90ZW1wbGF0ZS1wcm9jZXNzb3IuanNcIjtcbmltcG9ydCBBU1REaXNwYXRjaGVyIGZyb20gXCIuL2FzdC1kaXNwYXRjaGVyXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtRXhwYW5kZXIgZXh0ZW5kcyBBU1REaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dF85MzcpIHtcbiAgICBzdXBlcihcImV4cGFuZFwiLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XzkzNztcbiAgfVxuICBleHBhbmQodGVybV85MzgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0ZXJtXzkzOCk7XG4gIH1cbiAgZXhwYW5kUHJhZ21hKHRlcm1fOTM5KSB7XG4gICAgcmV0dXJuIHRlcm1fOTM5O1xuICB9XG4gIGV4cGFuZFRlbXBsYXRlRXhwcmVzc2lvbih0ZXJtXzk0MCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiB0ZXJtXzk0MC50YWcgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk0MC50YWcpLCBlbGVtZW50czogdGVybV85NDAuZWxlbWVudHMudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kQnJlYWtTdGF0ZW1lbnQodGVybV85NDEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCcmVha1N0YXRlbWVudFwiLCB7bGFiZWw6IHRlcm1fOTQxLmxhYmVsID8gdGVybV85NDEubGFiZWwudmFsKCkgOiBudWxsfSk7XG4gIH1cbiAgZXhwYW5kRG9XaGlsZVN0YXRlbWVudCh0ZXJtXzk0Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTQyLmJvZHkpLCB0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk0Mi50ZXN0KX0pO1xuICB9XG4gIGV4cGFuZFdpdGhTdGF0ZW1lbnQodGVybV85NDMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaXRoU3RhdGVtZW50XCIsIHtib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzk0My5ib2R5KSwgb2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk0My5vYmplY3QpfSk7XG4gIH1cbiAgZXhwYW5kRGVidWdnZXJTdGF0ZW1lbnQodGVybV85NDQpIHtcbiAgICByZXR1cm4gdGVybV85NDQ7XG4gIH1cbiAgZXhwYW5kQ29udGludWVTdGF0ZW1lbnQodGVybV85NDUpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb250aW51ZVN0YXRlbWVudFwiLCB7bGFiZWw6IHRlcm1fOTQ1LmxhYmVsID8gdGVybV85NDUubGFiZWwudmFsKCkgOiBudWxsfSk7XG4gIH1cbiAgZXhwYW5kU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQodGVybV85NDYpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdFwiLCB7ZGlzY3JpbWluYW50OiB0aGlzLmV4cGFuZCh0ZXJtXzk0Ni5kaXNjcmltaW5hbnQpLCBwcmVEZWZhdWx0Q2FzZXM6IHRlcm1fOTQ2LnByZURlZmF1bHRDYXNlcy5tYXAoY185NDcgPT4gdGhpcy5leHBhbmQoY185NDcpKS50b0FycmF5KCksIGRlZmF1bHRDYXNlOiB0aGlzLmV4cGFuZCh0ZXJtXzk0Ni5kZWZhdWx0Q2FzZSksIHBvc3REZWZhdWx0Q2FzZXM6IHRlcm1fOTQ2LnBvc3REZWZhdWx0Q2FzZXMubWFwKGNfOTQ4ID0+IHRoaXMuZXhwYW5kKGNfOTQ4KSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKHRlcm1fOTQ5KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uXCIsIHtvYmplY3Q6IHRoaXMuZXhwYW5kKHRlcm1fOTQ5Lm9iamVjdCksIGV4cHJlc3Npb246IHRoaXMuZXhwYW5kKHRlcm1fOTQ5LmV4cHJlc3Npb24pfSk7XG4gIH1cbiAgZXhwYW5kU3dpdGNoU3RhdGVtZW50KHRlcm1fOTUwKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoU3RhdGVtZW50XCIsIHtkaXNjcmltaW5hbnQ6IHRoaXMuZXhwYW5kKHRlcm1fOTUwLmRpc2NyaW1pbmFudCksIGNhc2VzOiB0ZXJtXzk1MC5jYXNlcy5tYXAoY185NTEgPT4gdGhpcy5leHBhbmQoY185NTEpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRGb3JtYWxQYXJhbWV0ZXJzKHRlcm1fOTUyKSB7XG4gICAgbGV0IHJlc3RfOTUzID0gdGVybV85NTIucmVzdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTUyLnJlc3QpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiB0ZXJtXzk1Mi5pdGVtcy5tYXAoaV85NTQgPT4gdGhpcy5leHBhbmQoaV85NTQpKSwgcmVzdDogcmVzdF85NTN9KTtcbiAgfVxuICBleHBhbmRBcnJvd0V4cHJlc3Npb24odGVybV85NTUpIHtcbiAgICByZXR1cm4gdGhpcy5kb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fOTU1LCBcIkFycm93RXhwcmVzc2lvblwiKTtcbiAgfVxuICBleHBhbmRTd2l0Y2hEZWZhdWx0KHRlcm1fOTU2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoRGVmYXVsdFwiLCB7Y29uc2VxdWVudDogdGVybV85NTYuY29uc2VxdWVudC5tYXAoY185NTcgPT4gdGhpcy5leHBhbmQoY185NTcpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRTd2l0Y2hDYXNlKHRlcm1fOTU4KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3dpdGNoQ2FzZVwiLCB7dGVzdDogdGhpcy5leHBhbmQodGVybV85NTgudGVzdCksIGNvbnNlcXVlbnQ6IHRlcm1fOTU4LmNvbnNlcXVlbnQubWFwKGNfOTU5ID0+IHRoaXMuZXhwYW5kKGNfOTU5KSkudG9BcnJheSgpfSk7XG4gIH1cbiAgZXhwYW5kRm9ySW5TdGF0ZW1lbnQodGVybV85NjApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJGb3JJblN0YXRlbWVudFwiLCB7bGVmdDogdGhpcy5leHBhbmQodGVybV85NjAubGVmdCksIHJpZ2h0OiB0aGlzLmV4cGFuZCh0ZXJtXzk2MC5yaWdodCksIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTYwLmJvZHkpfSk7XG4gIH1cbiAgZXhwYW5kVHJ5Q2F0Y2hTdGF0ZW1lbnQodGVybV85NjEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJUcnlDYXRjaFN0YXRlbWVudFwiLCB7Ym9keTogdGhpcy5leHBhbmQodGVybV85NjEuYm9keSksIGNhdGNoQ2xhdXNlOiB0aGlzLmV4cGFuZCh0ZXJtXzk2MS5jYXRjaENsYXVzZSl9KTtcbiAgfVxuICBleHBhbmRUcnlGaW5hbGx5U3RhdGVtZW50KHRlcm1fOTYyKSB7XG4gICAgbGV0IGNhdGNoQ2xhdXNlXzk2MyA9IHRlcm1fOTYyLmNhdGNoQ2xhdXNlID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85NjIuY2F0Y2hDbGF1c2UpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTYyLmJvZHkpLCBjYXRjaENsYXVzZTogY2F0Y2hDbGF1c2VfOTYzLCBmaW5hbGl6ZXI6IHRoaXMuZXhwYW5kKHRlcm1fOTYyLmZpbmFsaXplcil9KTtcbiAgfVxuICBleHBhbmRDYXRjaENsYXVzZSh0ZXJtXzk2NCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNhdGNoQ2xhdXNlXCIsIHtiaW5kaW5nOiB0aGlzLmV4cGFuZCh0ZXJtXzk2NC5iaW5kaW5nKSwgYm9keTogdGhpcy5leHBhbmQodGVybV85NjQuYm9keSl9KTtcbiAgfVxuICBleHBhbmRUaHJvd1N0YXRlbWVudCh0ZXJtXzk2NSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIlRocm93U3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzk2NS5leHByZXNzaW9uKX0pO1xuICB9XG4gIGV4cGFuZEZvck9mU3RhdGVtZW50KHRlcm1fOTY2KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yT2ZTdGF0ZW1lbnRcIiwge2xlZnQ6IHRoaXMuZXhwYW5kKHRlcm1fOTY2LmxlZnQpLCByaWdodDogdGhpcy5leHBhbmQodGVybV85NjYucmlnaHQpLCBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzk2Ni5ib2R5KX0pO1xuICB9XG4gIGV4cGFuZEJpbmRpbmdJZGVudGlmaWVyKHRlcm1fOTY3KSB7XG4gICAgcmV0dXJuIHRlcm1fOTY3O1xuICB9XG4gIGV4cGFuZEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIodGVybV85NjgpIHtcbiAgICByZXR1cm4gdGVybV85Njg7XG4gIH1cbiAgZXhwYW5kQmluZGluZ1Byb3BlcnR5UHJvcGVydHkodGVybV85NjkpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGhpcy5leHBhbmQodGVybV85NjkubmFtZSksIGJpbmRpbmc6IHRoaXMuZXhwYW5kKHRlcm1fOTY5LmJpbmRpbmcpfSk7XG4gIH1cbiAgZXhwYW5kQ29tcHV0ZWRQcm9wZXJ0eU5hbWUodGVybV85NzApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb21wdXRlZFByb3BlcnR5TmFtZVwiLCB7ZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybV85NzAuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRPYmplY3RCaW5kaW5nKHRlcm1fOTcxKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiT2JqZWN0QmluZGluZ1wiLCB7cHJvcGVydGllczogdGVybV85NzEucHJvcGVydGllcy5tYXAodF85NzIgPT4gdGhpcy5leHBhbmQodF85NzIpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRBcnJheUJpbmRpbmcodGVybV85NzMpIHtcbiAgICBsZXQgcmVzdEVsZW1lbnRfOTc0ID0gdGVybV85NzMucmVzdEVsZW1lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk3My5yZXN0RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQXJyYXlCaW5kaW5nXCIsIHtlbGVtZW50czogdGVybV85NzMuZWxlbWVudHMubWFwKHRfOTc1ID0+IHRfOTc1ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodF85NzUpKS50b0FycmF5KCksIHJlc3RFbGVtZW50OiByZXN0RWxlbWVudF85NzR9KTtcbiAgfVxuICBleHBhbmRCaW5kaW5nV2l0aERlZmF1bHQodGVybV85NzYpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nV2l0aERlZmF1bHRcIiwge2JpbmRpbmc6IHRoaXMuZXhwYW5kKHRlcm1fOTc2LmJpbmRpbmcpLCBpbml0OiB0aGlzLmV4cGFuZCh0ZXJtXzk3Ni5pbml0KX0pO1xuICB9XG4gIGV4cGFuZFNob3J0aGFuZFByb3BlcnR5KHRlcm1fOTc3KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRGF0YVByb3BlcnR5XCIsIHtuYW1lOiBuZXcgVGVybShcIlN0YXRpY1Byb3BlcnR5TmFtZVwiLCB7dmFsdWU6IHRlcm1fOTc3Lm5hbWV9KSwgZXhwcmVzc2lvbjogbmV3IFRlcm0oXCJJZGVudGlmaWVyRXhwcmVzc2lvblwiLCB7bmFtZTogdGVybV85NzcubmFtZX0pfSk7XG4gIH1cbiAgZXhwYW5kRm9yU3RhdGVtZW50KHRlcm1fOTc4KSB7XG4gICAgbGV0IGluaXRfOTc5ID0gdGVybV85NzguaW5pdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTc4LmluaXQpO1xuICAgIGxldCB0ZXN0Xzk4MCA9IHRlcm1fOTc4LnRlc3QgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk3OC50ZXN0KTtcbiAgICBsZXQgdXBkYXRlXzk4MSA9IHRlcm1fOTc4LnVwZGF0ZSA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm1fOTc4LnVwZGF0ZSk7XG4gICAgbGV0IGJvZHlfOTgyID0gdGhpcy5leHBhbmQodGVybV85NzguYm9keSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiRm9yU3RhdGVtZW50XCIsIHtpbml0OiBpbml0Xzk3OSwgdGVzdDogdGVzdF85ODAsIHVwZGF0ZTogdXBkYXRlXzk4MSwgYm9keTogYm9keV85ODJ9KTtcbiAgfVxuICBleHBhbmRZaWVsZEV4cHJlc3Npb24odGVybV85ODMpIHtcbiAgICBsZXQgZXhwcl85ODQgPSB0ZXJtXzk4My5leHByZXNzaW9uID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85ODMuZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiWWllbGRFeHByZXNzaW9uXCIsIHtleHByZXNzaW9uOiBleHByXzk4NH0pO1xuICB9XG4gIGV4cGFuZFlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbih0ZXJtXzk4NSkge1xuICAgIGxldCBleHByXzk4NiA9IHRlcm1fOTg1LmV4cHJlc3Npb24gPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk4NS5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb25cIiwge2V4cHJlc3Npb246IGV4cHJfOTg2fSk7XG4gIH1cbiAgZXhwYW5kV2hpbGVTdGF0ZW1lbnQodGVybV85ODcpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJXaGlsZVN0YXRlbWVudFwiLCB7dGVzdDogdGhpcy5leHBhbmQodGVybV85ODcudGVzdCksIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm1fOTg3LmJvZHkpfSk7XG4gIH1cbiAgZXhwYW5kSWZTdGF0ZW1lbnQodGVybV85ODgpIHtcbiAgICBsZXQgY29uc2VxdWVudF85ODkgPSB0ZXJtXzk4OC5jb25zZXF1ZW50ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85ODguY29uc2VxdWVudCk7XG4gICAgbGV0IGFsdGVybmF0ZV85OTAgPSB0ZXJtXzk4OC5hbHRlcm5hdGUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk4OC5hbHRlcm5hdGUpO1xuICAgIHJldHVybiBuZXcgVGVybShcIklmU3RhdGVtZW50XCIsIHt0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtXzk4OC50ZXN0KSwgY29uc2VxdWVudDogY29uc2VxdWVudF85ODksIGFsdGVybmF0ZTogYWx0ZXJuYXRlXzk5MH0pO1xuICB9XG4gIGV4cGFuZEJsb2NrU3RhdGVtZW50KHRlcm1fOTkxKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmxvY2tTdGF0ZW1lbnRcIiwge2Jsb2NrOiB0aGlzLmV4cGFuZCh0ZXJtXzk5MS5ibG9jayl9KTtcbiAgfVxuICBleHBhbmRCbG9jayh0ZXJtXzk5Mikge1xuICAgIHJldHVybiBuZXcgVGVybShcIkJsb2NrXCIsIHtzdGF0ZW1lbnRzOiB0ZXJtXzk5Mi5zdGF0ZW1lbnRzLm1hcChzXzk5MyA9PiB0aGlzLmV4cGFuZChzXzk5MykpLnRvQXJyYXkoKX0pO1xuICB9XG4gIGV4cGFuZFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQodGVybV85OTQpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIHtkZWNsYXJhdGlvbjogdGhpcy5leHBhbmQodGVybV85OTQuZGVjbGFyYXRpb24pfSk7XG4gIH1cbiAgZXhwYW5kUmV0dXJuU3RhdGVtZW50KHRlcm1fOTk1KSB7XG4gICAgaWYgKHRlcm1fOTk1LmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRlcm1fOTk1O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlcm0oXCJSZXR1cm5TdGF0ZW1lbnRcIiwge2V4cHJlc3Npb246IHRoaXMuZXhwYW5kKHRlcm1fOTk1LmV4cHJlc3Npb24pfSk7XG4gIH1cbiAgZXhwYW5kQ2xhc3NEZWNsYXJhdGlvbih0ZXJtXzk5Nikge1xuICAgIHJldHVybiBuZXcgVGVybShcIkNsYXNzRGVjbGFyYXRpb25cIiwge25hbWU6IHRlcm1fOTk2Lm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk5Ni5uYW1lKSwgc3VwZXI6IHRlcm1fOTk2LnN1cGVyID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85OTYuc3VwZXIpLCBlbGVtZW50czogdGVybV85OTYuZWxlbWVudHMubWFwKGVsXzk5NyA9PiB0aGlzLmV4cGFuZChlbF85OTcpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRDbGFzc0V4cHJlc3Npb24odGVybV85OTgpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDbGFzc0V4cHJlc3Npb25cIiwge25hbWU6IHRlcm1fOTk4Lm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtXzk5OC5uYW1lKSwgc3VwZXI6IHRlcm1fOTk4LnN1cGVyID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV85OTguc3VwZXIpLCBlbGVtZW50czogdGVybV85OTguZWxlbWVudHMubWFwKGVsXzk5OSA9PiB0aGlzLmV4cGFuZChlbF85OTkpKS50b0FycmF5KCl9KTtcbiAgfVxuICBleHBhbmRDbGFzc0VsZW1lbnQodGVybV8xMDAwKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ2xhc3NFbGVtZW50XCIsIHtpc1N0YXRpYzogdGVybV8xMDAwLmlzU3RhdGljLCBtZXRob2Q6IHRoaXMuZXhwYW5kKHRlcm1fMTAwMC5tZXRob2QpfSk7XG4gIH1cbiAgZXhwYW5kVGhpc0V4cHJlc3Npb24odGVybV8xMDAxKSB7XG4gICAgcmV0dXJuIHRlcm1fMTAwMTtcbiAgfVxuICBleHBhbmRTeW50YXhUZW1wbGF0ZSh0ZXJtXzEwMDIpIHtcbiAgICBsZXQgcl8xMDAzID0gcHJvY2Vzc1RlbXBsYXRlKHRlcm1fMTAwMi50ZW1wbGF0ZS5pbm5lcigpKTtcbiAgICBsZXQgc3RyXzEwMDQgPSBTeW50YXguZnJvbShcInN0cmluZ1wiLCBzZXJpYWxpemVyLndyaXRlKHJfMTAwMy50ZW1wbGF0ZSkpO1xuICAgIGxldCBjYWxsZWVfMTAwNSA9IG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IFN5bnRheC5mcm9tKFwiaWRlbnRpZmllclwiLCBcInN5bnRheFRlbXBsYXRlXCIpfSk7XG4gICAgbGV0IGV4cGFuZGVkSW50ZXJwc18xMDA2ID0gcl8xMDAzLmludGVycC5tYXAoaV8xMDA4ID0+IHtcbiAgICAgIGxldCBlbmZfMTAwOSA9IG5ldyBFbmZvcmVzdGVyKGlfMTAwOCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kKGVuZl8xMDA5LmVuZm9yZXN0KFwiZXhwcmVzc2lvblwiKSk7XG4gICAgfSk7XG4gICAgbGV0IGFyZ3NfMTAwNyA9IExpc3Qub2YobmV3IFRlcm0oXCJMaXRlcmFsU3RyaW5nRXhwcmVzc2lvblwiLCB7dmFsdWU6IHN0cl8xMDA0fSkpLmNvbmNhdChleHBhbmRlZEludGVycHNfMTAwNik7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ2FsbEV4cHJlc3Npb25cIiwge2NhbGxlZTogY2FsbGVlXzEwMDUsIGFyZ3VtZW50czogYXJnc18xMDA3fSk7XG4gIH1cbiAgZXhwYW5kU3ludGF4UXVvdGUodGVybV8xMDEwKSB7XG4gICAgbGV0IHN0cl8xMDExID0gbmV3IFRlcm0oXCJMaXRlcmFsU3RyaW5nRXhwcmVzc2lvblwiLCB7dmFsdWU6IFN5bnRheC5mcm9tKFwic3RyaW5nXCIsIHNlcmlhbGl6ZXIud3JpdGUodGVybV8xMDEwLm5hbWUpKX0pO1xuICAgIHJldHVybiBuZXcgVGVybShcIlRlbXBsYXRlRXhwcmVzc2lvblwiLCB7dGFnOiB0ZXJtXzEwMTAudGVtcGxhdGUudGFnLCBlbGVtZW50czogdGVybV8xMDEwLnRlbXBsYXRlLmVsZW1lbnRzLnB1c2goc3RyXzEwMTEpLnB1c2gobmV3IFRlcm0oXCJUZW1wbGF0ZUVsZW1lbnRcIiwge3Jhd1ZhbHVlOiBcIlwifSkpLnRvQXJyYXkoKX0pO1xuICB9XG4gIGV4cGFuZFN0YXRpY01lbWJlckV4cHJlc3Npb24odGVybV8xMDEyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3RhdGljTWVtYmVyRXhwcmVzc2lvblwiLCB7b2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtXzEwMTIub2JqZWN0KSwgcHJvcGVydHk6IHRlcm1fMTAxMi5wcm9wZXJ0eX0pO1xuICB9XG4gIGV4cGFuZEFycmF5RXhwcmVzc2lvbih0ZXJtXzEwMTMpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUV4cHJlc3Npb25cIiwge2VsZW1lbnRzOiB0ZXJtXzEwMTMuZWxlbWVudHMubWFwKHRfMTAxNCA9PiB0XzEwMTQgPT0gbnVsbCA/IHRfMTAxNCA6IHRoaXMuZXhwYW5kKHRfMTAxNCkpfSk7XG4gIH1cbiAgZXhwYW5kSW1wb3J0KHRlcm1fMTAxNSkge1xuICAgIHJldHVybiB0ZXJtXzEwMTU7XG4gIH1cbiAgZXhwYW5kSW1wb3J0TmFtZXNwYWNlKHRlcm1fMTAxNikge1xuICAgIHJldHVybiB0ZXJtXzEwMTY7XG4gIH1cbiAgZXhwYW5kRXhwb3J0KHRlcm1fMTAxNykge1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydFwiLCB7ZGVjbGFyYXRpb246IHRoaXMuZXhwYW5kKHRlcm1fMTAxNy5kZWNsYXJhdGlvbil9KTtcbiAgfVxuICBleHBhbmRFeHBvcnREZWZhdWx0KHRlcm1fMTAxOCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIkV4cG9ydERlZmF1bHRcIiwge2JvZHk6IHRoaXMuZXhwYW5kKHRlcm1fMTAxOC5ib2R5KX0pO1xuICB9XG4gIGV4cGFuZEV4cG9ydEZyb20odGVybV8xMDE5KSB7XG4gICAgcmV0dXJuIHRlcm1fMTAxOTtcbiAgfVxuICBleHBhbmRFeHBvcnRBbGxGcm9tKHRlcm1fMTAyMCkge1xuICAgIHJldHVybiB0ZXJtXzEwMjA7XG4gIH1cbiAgZXhwYW5kRXhwb3J0U3BlY2lmaWVyKHRlcm1fMTAyMSkge1xuICAgIHJldHVybiB0ZXJtXzEwMjE7XG4gIH1cbiAgZXhwYW5kU3RhdGljUHJvcGVydHlOYW1lKHRlcm1fMTAyMikge1xuICAgIHJldHVybiB0ZXJtXzEwMjI7XG4gIH1cbiAgZXhwYW5kRGF0YVByb3BlcnR5KHRlcm1fMTAyMykge1xuICAgIHJldHVybiBuZXcgVGVybShcIkRhdGFQcm9wZXJ0eVwiLCB7bmFtZTogdGhpcy5leHBhbmQodGVybV8xMDIzLm5hbWUpLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMjMuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRPYmplY3RFeHByZXNzaW9uKHRlcm1fMTAyNCkge1xuICAgIHJldHVybiBuZXcgVGVybShcIk9iamVjdEV4cHJlc3Npb25cIiwge3Byb3BlcnRpZXM6IHRlcm1fMTAyNC5wcm9wZXJ0aWVzLm1hcCh0XzEwMjUgPT4gdGhpcy5leHBhbmQodF8xMDI1KSl9KTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0b3IodGVybV8xMDI2KSB7XG4gICAgbGV0IGluaXRfMTAyNyA9IHRlcm1fMTAyNi5pbml0ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybV8xMDI2LmluaXQpO1xuICAgIHJldHVybiBuZXcgVGVybShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDI2LmJpbmRpbmcpLCBpbml0OiBpbml0XzEwMjd9KTtcbiAgfVxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm1fMTAyOCkge1xuICAgIGlmICh0ZXJtXzEwMjgua2luZCA9PT0gXCJzeW50YXhcIiB8fCB0ZXJtXzEwMjgua2luZCA9PT0gXCJzeW50YXhyZWNcIikge1xuICAgICAgcmV0dXJuIHRlcm1fMTAyODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCB7a2luZDogdGVybV8xMDI4LmtpbmQsIGRlY2xhcmF0b3JzOiB0ZXJtXzEwMjguZGVjbGFyYXRvcnMubWFwKGRfMTAyOSA9PiB0aGlzLmV4cGFuZChkXzEwMjkpKX0pO1xuICB9XG4gIGV4cGFuZFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHRlcm1fMTAzMCkge1xuICAgIGlmICh0ZXJtXzEwMzAuaW5uZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIik7XG4gICAgfVxuICAgIGxldCBlbmZfMTAzMSA9IG5ldyBFbmZvcmVzdGVyKHRlcm1fMTAzMC5pbm5lciwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWRfMTAzMiA9IGVuZl8xMDMxLnBlZWsoKTtcbiAgICBsZXQgdF8xMDMzID0gZW5mXzEwMzEuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRfMTAzMyA9PSBudWxsIHx8IGVuZl8xMDMxLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgIHRocm93IGVuZl8xMDMxLmNyZWF0ZUVycm9yKGxvb2thaGVhZF8xMDMyLCBcInVuZXhwZWN0ZWQgc3ludGF4XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBhbmQodF8xMDMzKTtcbiAgfVxuICBleHBhbmRVbmFyeUV4cHJlc3Npb24odGVybV8xMDM0KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtvcGVyYXRvcjogdGVybV8xMDM0Lm9wZXJhdG9yLCBvcGVyYW5kOiB0aGlzLmV4cGFuZCh0ZXJtXzEwMzQub3BlcmFuZCl9KTtcbiAgfVxuICBleHBhbmRVcGRhdGVFeHByZXNzaW9uKHRlcm1fMTAzNSkge1xuICAgIHJldHVybiBuZXcgVGVybShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge2lzUHJlZml4OiB0ZXJtXzEwMzUuaXNQcmVmaXgsIG9wZXJhdG9yOiB0ZXJtXzEwMzUub3BlcmF0b3IsIG9wZXJhbmQ6IHRoaXMuZXhwYW5kKHRlcm1fMTAzNS5vcGVyYW5kKX0pO1xuICB9XG4gIGV4cGFuZEJpbmFyeUV4cHJlc3Npb24odGVybV8xMDM2KSB7XG4gICAgbGV0IGxlZnRfMTAzNyA9IHRoaXMuZXhwYW5kKHRlcm1fMTAzNi5sZWZ0KTtcbiAgICBsZXQgcmlnaHRfMTAzOCA9IHRoaXMuZXhwYW5kKHRlcm1fMTAzNi5yaWdodCk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7bGVmdDogbGVmdF8xMDM3LCBvcGVyYXRvcjogdGVybV8xMDM2Lm9wZXJhdG9yLCByaWdodDogcmlnaHRfMTAzOH0pO1xuICB9XG4gIGV4cGFuZENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXJtXzEwMzkpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwge3Rlc3Q6IHRoaXMuZXhwYW5kKHRlcm1fMTAzOS50ZXN0KSwgY29uc2VxdWVudDogdGhpcy5leHBhbmQodGVybV8xMDM5LmNvbnNlcXVlbnQpLCBhbHRlcm5hdGU6IHRoaXMuZXhwYW5kKHRlcm1fMTAzOS5hbHRlcm5hdGUpfSk7XG4gIH1cbiAgZXhwYW5kTmV3VGFyZ2V0RXhwcmVzc2lvbih0ZXJtXzEwNDApIHtcbiAgICByZXR1cm4gdGVybV8xMDQwO1xuICB9XG4gIGV4cGFuZE5ld0V4cHJlc3Npb24odGVybV8xMDQxKSB7XG4gICAgbGV0IGNhbGxlZV8xMDQyID0gdGhpcy5leHBhbmQodGVybV8xMDQxLmNhbGxlZSk7XG4gICAgbGV0IGVuZl8xMDQzID0gbmV3IEVuZm9yZXN0ZXIodGVybV8xMDQxLmFyZ3VtZW50cywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhcmdzXzEwNDQgPSBlbmZfMTA0My5lbmZvcmVzdEFyZ3VtZW50TGlzdCgpLm1hcChhcmdfMTA0NSA9PiB0aGlzLmV4cGFuZChhcmdfMTA0NSkpO1xuICAgIHJldHVybiBuZXcgVGVybShcIk5ld0V4cHJlc3Npb25cIiwge2NhbGxlZTogY2FsbGVlXzEwNDIsIGFyZ3VtZW50czogYXJnc18xMDQ0LnRvQXJyYXkoKX0pO1xuICB9XG4gIGV4cGFuZFN1cGVyKHRlcm1fMTA0Nikge1xuICAgIHJldHVybiB0ZXJtXzEwNDY7XG4gIH1cbiAgZXhwYW5kQ2FsbEV4cHJlc3Npb24odGVybV8xMDQ3KSB7XG4gICAgbGV0IGNhbGxlZV8xMDQ4ID0gdGhpcy5leHBhbmQodGVybV8xMDQ3LmNhbGxlZSk7XG4gICAgbGV0IGVuZl8xMDQ5ID0gbmV3IEVuZm9yZXN0ZXIodGVybV8xMDQ3LmFyZ3VtZW50cywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhcmdzXzEwNTAgPSBlbmZfMTA0OS5lbmZvcmVzdEFyZ3VtZW50TGlzdCgpLm1hcChhcmdfMTA1MSA9PiB0aGlzLmV4cGFuZChhcmdfMTA1MSkpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkNhbGxFeHByZXNzaW9uXCIsIHtjYWxsZWU6IGNhbGxlZV8xMDQ4LCBhcmd1bWVudHM6IGFyZ3NfMTA1MH0pO1xuICB9XG4gIGV4cGFuZFNwcmVhZEVsZW1lbnQodGVybV8xMDUyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiU3ByZWFkRWxlbWVudFwiLCB7ZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybV8xMDUyLmV4cHJlc3Npb24pfSk7XG4gIH1cbiAgZXhwYW5kRXhwcmVzc2lvblN0YXRlbWVudCh0ZXJtXzEwNTMpIHtcbiAgICBsZXQgY2hpbGRfMTA1NCA9IHRoaXMuZXhwYW5kKHRlcm1fMTA1My5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtleHByZXNzaW9uOiBjaGlsZF8xMDU0fSk7XG4gIH1cbiAgZXhwYW5kTGFiZWxlZFN0YXRlbWVudCh0ZXJtXzEwNTUpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJMYWJlbGVkU3RhdGVtZW50XCIsIHtsYWJlbDogdGVybV8xMDU1LmxhYmVsLnZhbCgpLCBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtXzEwNTUuYm9keSl9KTtcbiAgfVxuICBkb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fMTA1NiwgdHlwZV8xMDU3KSB7XG4gICAgbGV0IHNjb3BlXzEwNTggPSBmcmVzaFNjb3BlKFwiZnVuXCIpO1xuICAgIGxldCByZWRfMTA1OSA9IG5ldyBBcHBseVNjb3BlSW5QYXJhbXNSZWR1Y2VyKHNjb3BlXzEwNTgsIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IHBhcmFtc18xMDYwO1xuICAgIGlmICh0eXBlXzEwNTcgIT09IFwiR2V0dGVyXCIgJiYgdHlwZV8xMDU3ICE9PSBcIlNldHRlclwiKSB7XG4gICAgICBwYXJhbXNfMTA2MCA9IHJlZF8xMDU5LnRyYW5zZm9ybSh0ZXJtXzEwNTYucGFyYW1zKTtcbiAgICAgIHBhcmFtc18xMDYwID0gdGhpcy5leHBhbmQocGFyYW1zXzEwNjApO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuY3VycmVudFNjb3BlLnB1c2goc2NvcGVfMTA1OCk7XG4gICAgbGV0IGNvbXBpbGVyXzEwNjEgPSBuZXcgQ29tcGlsZXIodGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuZW52LCB0aGlzLmNvbnRleHQuc3RvcmUsIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IG1hcmtlZEJvZHlfMTA2MiwgYm9keVRlcm1fMTA2MztcbiAgICBpZiAodGVybV8xMDU2LmJvZHkgaW5zdGFuY2VvZiBUZXJtKSB7XG4gICAgICBib2R5VGVybV8xMDYzID0gdGhpcy5leHBhbmQodGVybV8xMDU2LmJvZHkuYWRkU2NvcGUoc2NvcGVfMTA1OCwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlZEJvZHlfMTA2MiA9IHRlcm1fMTA1Ni5ib2R5Lm1hcChiXzEwNjQgPT4gYl8xMDY0LmFkZFNjb3BlKHNjb3BlXzEwNTgsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUykpO1xuICAgICAgYm9keVRlcm1fMTA2MyA9IG5ldyBUZXJtKFwiRnVuY3Rpb25Cb2R5XCIsIHtkaXJlY3RpdmVzOiBMaXN0KCksIHN0YXRlbWVudHM6IGNvbXBpbGVyXzEwNjEuY29tcGlsZShtYXJrZWRCb2R5XzEwNjIpfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5jdXJyZW50U2NvcGUucG9wKCk7XG4gICAgaWYgKHR5cGVfMTA1NyA9PT0gXCJHZXR0ZXJcIikge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKHR5cGVfMTA1Nywge25hbWU6IHRoaXMuZXhwYW5kKHRlcm1fMTA1Ni5uYW1lKSwgYm9keTogYm9keVRlcm1fMTA2M30pO1xuICAgIH0gZWxzZSBpZiAodHlwZV8xMDU3ID09PSBcIlNldHRlclwiKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0odHlwZV8xMDU3LCB7bmFtZTogdGhpcy5leHBhbmQodGVybV8xMDU2Lm5hbWUpLCBwYXJhbTogdGVybV8xMDU2LnBhcmFtLCBib2R5OiBib2R5VGVybV8xMDYzfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVybSh0eXBlXzEwNTcsIHtuYW1lOiB0ZXJtXzEwNTYubmFtZSwgaXNHZW5lcmF0b3I6IHRlcm1fMTA1Ni5pc0dlbmVyYXRvciwgcGFyYW1zOiBwYXJhbXNfMTA2MCwgYm9keTogYm9keVRlcm1fMTA2M30pO1xuICB9XG4gIGV4cGFuZE1ldGhvZCh0ZXJtXzEwNjUpIHtcbiAgICByZXR1cm4gdGhpcy5kb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm1fMTA2NSwgXCJNZXRob2RcIik7XG4gIH1cbiAgZXhwYW5kU2V0dGVyKHRlcm1fMTA2Nikge1xuICAgIHJldHVybiB0aGlzLmRvRnVuY3Rpb25FeHBhbnNpb24odGVybV8xMDY2LCBcIlNldHRlclwiKTtcbiAgfVxuICBleHBhbmRHZXR0ZXIodGVybV8xMDY3KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNjcsIFwiR2V0dGVyXCIpO1xuICB9XG4gIGV4cGFuZEZ1bmN0aW9uRGVjbGFyYXRpb24odGVybV8xMDY4KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNjgsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiKTtcbiAgfVxuICBleHBhbmRGdW5jdGlvbkV4cHJlc3Npb24odGVybV8xMDY5KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtXzEwNjksIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG4gIGV4cGFuZENvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24odGVybV8xMDcwKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDcwLmJpbmRpbmcpLCBvcGVyYXRvcjogdGVybV8xMDcwLm9wZXJhdG9yLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwNzAuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRBc3NpZ25tZW50RXhwcmVzc2lvbih0ZXJtXzEwNzEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7YmluZGluZzogdGhpcy5leHBhbmQodGVybV8xMDcxLmJpbmRpbmcpLCBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtXzEwNzEuZXhwcmVzc2lvbil9KTtcbiAgfVxuICBleHBhbmRFbXB0eVN0YXRlbWVudCh0ZXJtXzEwNzIpIHtcbiAgICByZXR1cm4gdGVybV8xMDcyO1xuICB9XG4gIGV4cGFuZExpdGVyYWxCb29sZWFuRXhwcmVzc2lvbih0ZXJtXzEwNzMpIHtcbiAgICByZXR1cm4gdGVybV8xMDczO1xuICB9XG4gIGV4cGFuZExpdGVyYWxOdW1lcmljRXhwcmVzc2lvbih0ZXJtXzEwNzQpIHtcbiAgICByZXR1cm4gdGVybV8xMDc0O1xuICB9XG4gIGV4cGFuZExpdGVyYWxJbmZpbml0eUV4cHJlc3Npb24odGVybV8xMDc1KSB7XG4gICAgcmV0dXJuIHRlcm1fMTA3NTtcbiAgfVxuICBleHBhbmRJZGVudGlmaWVyRXhwcmVzc2lvbih0ZXJtXzEwNzYpIHtcbiAgICBsZXQgdHJhbnNfMTA3NyA9IHRoaXMuY29udGV4dC5lbnYuZ2V0KHRlcm1fMTA3Ni5uYW1lLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSk7XG4gICAgaWYgKHRyYW5zXzEwNzcpIHtcbiAgICAgIHJldHVybiBuZXcgVGVybShcIklkZW50aWZpZXJFeHByZXNzaW9uXCIsIHtuYW1lOiB0cmFuc18xMDc3LmlkfSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXJtXzEwNzY7XG4gIH1cbiAgZXhwYW5kTGl0ZXJhbE51bGxFeHByZXNzaW9uKHRlcm1fMTA3OCkge1xuICAgIHJldHVybiB0ZXJtXzEwNzg7XG4gIH1cbiAgZXhwYW5kTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24odGVybV8xMDc5KSB7XG4gICAgcmV0dXJuIHRlcm1fMTA3OTtcbiAgfVxuICBleHBhbmRMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbih0ZXJtXzEwODApIHtcbiAgICByZXR1cm4gdGVybV8xMDgwO1xuICB9XG59XG4iXX0=

	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _symbol = __webpack_require__(42);

		var _transforms = __webpack_require__(29);

		var _errors = __webpack_require__(11);

		var _syntax = __webpack_require__(10);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class ScopeApplyingReducer {
		  constructor(scope_0, context_1) {
		    this.context = context_1;
		    this.scope = scope_0;
		  }
		  transform(term_2) {
		    let field_3 = "transform" + term_2.type;
		    if (typeof this[field_3] === "function") {
		      return this[field_3](term_2);
		    }
		    (0, _errors.assert)(false, "transform not implemented yet for: " + term_2.type);
		  }
		  transformFormalParameters(term_4) {
		    let rest_5 = term_4.rest == null ? null : this.transform(term_4.rest);
		    return new _terms2.default("FormalParameters", { items: term_4.items.map(it_6 => this.transform(it_6)), rest: rest_5 });
		  }
		  transformBindingWithDefault(term_7) {
		    return new _terms2.default("BindingWithDefault", { binding: this.transform(term_7.binding), init: term_7.init });
		  }
		  transformObjectBinding(term_8) {
		    return term_8;
		  }
		  transformBindingPropertyIdentifier(term_9) {
		    return new _terms2.default("BindingPropertyIdentifier", { binding: this.transform(term_9.binding), init: term_9.init });
		  }
		  transformBindingPropertyProperty(term_10) {
		    return new _terms2.default("BindingPropertyProperty", { name: term_10.name, binding: this.transform(term_10.binding) });
		  }
		  transformArrayBinding(term_11) {
		    return new _terms2.default("ArrayBinding", { elements: term_11.elements.map(el_12 => this.transform(el_12)), restElement: term_11.restElement == null ? null : this.transform(term_11.restElement) });
		  }
		  transformBindingIdentifier(term_13) {
		    let name_14 = term_13.name.addScope(this.scope, this.context.bindings, _syntax.ALL_PHASES);
		    let newBinding_15 = (0, _symbol.gensym)(name_14.val());
		    this.context.env.set(newBinding_15.toString(), new _transforms.VarBindingTransform(name_14));
		    this.context.bindings.add(name_14, { binding: newBinding_15, phase: this.context.phase, skipDup: true });
		    return new _terms2.default("BindingIdentifier", { name: name_14 });
		  }
		}
		exports.default = ScopeApplyingReducer;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2FwcGx5LXNjb3BlLWluLXBhcmFtcy1yZWR1Y2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDZSxNQUFNLG9CQUFOLENBQTJCO0FBQ3hDLGNBQVksT0FBWixFQUFxQixTQUFyQixFQUFnQztBQUM5QixTQUFLLE9BQUwsR0FBZSxTQUFmO0FBQ0EsU0FBSyxLQUFMLEdBQWEsT0FBYjtBQUNEO0FBQ0QsWUFBVSxNQUFWLEVBQWtCO0FBQ2hCLFFBQUksVUFBVSxjQUFjLE9BQU8sSUFBbkM7QUFDQSxRQUFJLE9BQU8sS0FBSyxPQUFMLENBQVAsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkMsYUFBTyxLQUFLLE9BQUwsRUFBYyxNQUFkLENBQVA7QUFDRDtBQUNELHdCQUFPLEtBQVAsRUFBYyx3Q0FBd0MsT0FBTyxJQUE3RDtBQUNEO0FBQ0QsNEJBQTBCLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUksU0FBUyxPQUFPLElBQVAsSUFBZSxJQUFmLEdBQXNCLElBQXRCLEdBQTZCLEtBQUssU0FBTCxDQUFlLE9BQU8sSUFBdEIsQ0FBMUM7QUFDQSxXQUFPLG9CQUFTLGtCQUFULEVBQTZCLEVBQUMsT0FBTyxPQUFPLEtBQVAsQ0FBYSxHQUFiLENBQWlCLFFBQVEsS0FBSyxTQUFMLENBQWUsSUFBZixDQUF6QixDQUFSLEVBQXdELE1BQU0sTUFBOUQsRUFBN0IsQ0FBUDtBQUNEO0FBQ0QsOEJBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDLFdBQU8sb0JBQVMsb0JBQVQsRUFBK0IsRUFBQyxTQUFTLEtBQUssU0FBTCxDQUFlLE9BQU8sT0FBdEIsQ0FBVixFQUEwQyxNQUFNLE9BQU8sSUFBdkQsRUFBL0IsQ0FBUDtBQUNEO0FBQ0QseUJBQXVCLE1BQXZCLEVBQStCO0FBQzdCLFdBQU8sTUFBUDtBQUNEO0FBQ0QscUNBQW1DLE1BQW5DLEVBQTJDO0FBQ3pDLFdBQU8sb0JBQVMsMkJBQVQsRUFBc0MsRUFBQyxTQUFTLEtBQUssU0FBTCxDQUFlLE9BQU8sT0FBdEIsQ0FBVixFQUEwQyxNQUFNLE9BQU8sSUFBdkQsRUFBdEMsQ0FBUDtBQUNEO0FBQ0QsbUNBQWlDLE9BQWpDLEVBQTBDO0FBQ3hDLFdBQU8sb0JBQVMseUJBQVQsRUFBb0MsRUFBQyxNQUFNLFFBQVEsSUFBZixFQUFxQixTQUFTLEtBQUssU0FBTCxDQUFlLFFBQVEsT0FBdkIsQ0FBOUIsRUFBcEMsQ0FBUDtBQUNEO0FBQ0Qsd0JBQXNCLE9BQXRCLEVBQStCO0FBQzdCLFdBQU8sb0JBQVMsY0FBVCxFQUF5QixFQUFDLFVBQVUsUUFBUSxRQUFSLENBQWlCLEdBQWpCLENBQXFCLFNBQVMsS0FBSyxTQUFMLENBQWUsS0FBZixDQUE5QixDQUFYLEVBQWlFLGFBQWEsUUFBUSxXQUFSLElBQXVCLElBQXZCLEdBQThCLElBQTlCLEdBQXFDLEtBQUssU0FBTCxDQUFlLFFBQVEsV0FBdkIsQ0FBbkgsRUFBekIsQ0FBUDtBQUNEO0FBQ0QsNkJBQTJCLE9BQTNCLEVBQW9DO0FBQ2xDLFFBQUksVUFBVSxRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLEtBQUssS0FBM0IsRUFBa0MsS0FBSyxPQUFMLENBQWEsUUFBL0MscUJBQWQ7QUFDQSxRQUFJLGdCQUFnQixvQkFBTyxRQUFRLEdBQVIsRUFBUCxDQUFwQjtBQUNBLFNBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsR0FBakIsQ0FBcUIsY0FBYyxRQUFkLEVBQXJCLEVBQStDLG9DQUF3QixPQUF4QixDQUEvQztBQUNBLFNBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsR0FBdEIsQ0FBMEIsT0FBMUIsRUFBbUMsRUFBQyxTQUFTLGFBQVYsRUFBeUIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUE3QyxFQUFvRCxTQUFTLElBQTdELEVBQW5DO0FBQ0EsV0FBTyxvQkFBUyxtQkFBVCxFQUE4QixFQUFDLE1BQU0sT0FBUCxFQUE5QixDQUFQO0FBQ0Q7QUFyQ3VDO2tCQUFyQixvQiIsImZpbGUiOiJhcHBseS1zY29wZS1pbi1wYXJhbXMtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge2dlbnN5bX0gZnJvbSBcIi4vc3ltYm9sXCI7XG5pbXBvcnQge1ZhckJpbmRpbmdUcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybXNcIjtcbmltcG9ydCB7YXNzZXJ0fSBmcm9tIFwiLi9lcnJvcnNcIjtcbmltcG9ydCB7QUxMX1BIQVNFU30gZnJvbSBcIi4vc3ludGF4XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY29wZUFwcGx5aW5nUmVkdWNlciB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlXzAsIGNvbnRleHRfMSkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGVfMDtcbiAgfVxuICB0cmFuc2Zvcm0odGVybV8yKSB7XG4gICAgbGV0IGZpZWxkXzMgPSBcInRyYW5zZm9ybVwiICsgdGVybV8yLnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXzNdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpZWxkXzNdKHRlcm1fMik7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2Zvcm0gbm90IGltcGxlbWVudGVkIHlldCBmb3I6IFwiICsgdGVybV8yLnR5cGUpO1xuICB9XG4gIHRyYW5zZm9ybUZvcm1hbFBhcmFtZXRlcnModGVybV80KSB7XG4gICAgbGV0IHJlc3RfNSA9IHRlcm1fNC5yZXN0ID09IG51bGwgPyBudWxsIDogdGhpcy50cmFuc2Zvcm0odGVybV80LnJlc3QpO1xuICAgIHJldHVybiBuZXcgVGVybShcIkZvcm1hbFBhcmFtZXRlcnNcIiwge2l0ZW1zOiB0ZXJtXzQuaXRlbXMubWFwKGl0XzYgPT4gdGhpcy50cmFuc2Zvcm0oaXRfNikpLCByZXN0OiByZXN0XzV9KTtcbiAgfVxuICB0cmFuc2Zvcm1CaW5kaW5nV2l0aERlZmF1bHQodGVybV83KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1dpdGhEZWZhdWx0XCIsIHtiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybSh0ZXJtXzcuYmluZGluZyksIGluaXQ6IHRlcm1fNy5pbml0fSk7XG4gIH1cbiAgdHJhbnNmb3JtT2JqZWN0QmluZGluZyh0ZXJtXzgpIHtcbiAgICByZXR1cm4gdGVybV84O1xuICB9XG4gIHRyYW5zZm9ybUJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIodGVybV85KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllclwiLCB7YmluZGluZzogdGhpcy50cmFuc2Zvcm0odGVybV85LmJpbmRpbmcpLCBpbml0OiB0ZXJtXzkuaW5pdH0pO1xuICB9XG4gIHRyYW5zZm9ybUJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5KHRlcm1fMTApIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eVwiLCB7bmFtZTogdGVybV8xMC5uYW1lLCBiaW5kaW5nOiB0aGlzLnRyYW5zZm9ybSh0ZXJtXzEwLmJpbmRpbmcpfSk7XG4gIH1cbiAgdHJhbnNmb3JtQXJyYXlCaW5kaW5nKHRlcm1fMTEpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oXCJBcnJheUJpbmRpbmdcIiwge2VsZW1lbnRzOiB0ZXJtXzExLmVsZW1lbnRzLm1hcChlbF8xMiA9PiB0aGlzLnRyYW5zZm9ybShlbF8xMikpLCByZXN0RWxlbWVudDogdGVybV8xMS5yZXN0RWxlbWVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMudHJhbnNmb3JtKHRlcm1fMTEucmVzdEVsZW1lbnQpfSk7XG4gIH1cbiAgdHJhbnNmb3JtQmluZGluZ0lkZW50aWZpZXIodGVybV8xMykge1xuICAgIGxldCBuYW1lXzE0ID0gdGVybV8xMy5uYW1lLmFkZFNjb3BlKHRoaXMuc2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUyk7XG4gICAgbGV0IG5ld0JpbmRpbmdfMTUgPSBnZW5zeW0obmFtZV8xNC52YWwoKSk7XG4gICAgdGhpcy5jb250ZXh0LmVudi5zZXQobmV3QmluZGluZ18xNS50b1N0cmluZygpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShuYW1lXzE0KSk7XG4gICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChuYW1lXzE0LCB7YmluZGluZzogbmV3QmluZGluZ18xNSwgcGhhc2U6IHRoaXMuY29udGV4dC5waGFzZSwgc2tpcER1cDogdHJ1ZX0pO1xuICAgIHJldHVybiBuZXcgVGVybShcIkJpbmRpbmdJZGVudGlmaWVyXCIsIHtuYW1lOiBuYW1lXzE0fSk7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _immutable = __webpack_require__(9);

		var _termExpander = __webpack_require__(51);

		var _termExpander2 = _interopRequireDefault(_termExpander);

		var _tokenExpander = __webpack_require__(47);

		var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

		var _scope = __webpack_require__(41);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class Compiler {
		  constructor(phase_33, env_34, store_35, context_36) {
		    this.phase = phase_33;
		    this.env = env_34;
		    this.store = store_35;
		    this.context = context_36;
		  }
		  compile(stxl_37) {
		    let tokenExpander_38 = new _tokenExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store }));
		    let termExpander_39 = new _termExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store }));
		    return _.pipe(_.bind(tokenExpander_38.expand, tokenExpander_38), _.map(t_40 => termExpander_39.expand(t_40)))(stxl_37);
		  }
		}
		exports.default = Compiler;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDRSxNQUFNLFFBQU4sQ0FBZTtBQUM1QixjQUFZLFFBQVosRUFBc0IsTUFBdEIsRUFBOEIsUUFBOUIsRUFBd0MsVUFBeEMsRUFBb0Q7QUFDbEQsU0FBSyxLQUFMLEdBQWEsUUFBYjtBQUNBLFNBQUssR0FBTCxHQUFXLE1BQVg7QUFDQSxTQUFLLEtBQUwsR0FBYSxRQUFiO0FBQ0EsU0FBSyxPQUFMLEdBQWUsVUFBZjtBQUNEO0FBQ0QsVUFBUSxPQUFSLEVBQWlCO0FBQ2YsUUFBSSxtQkFBbUIsNEJBQWtCLEVBQUUsS0FBRixDQUFRLEtBQUssT0FBYixFQUFzQixFQUFDLE9BQU8sS0FBSyxLQUFiLEVBQW9CLEtBQUssS0FBSyxHQUE5QixFQUFtQyxPQUFPLEtBQUssS0FBL0MsRUFBdEIsQ0FBbEIsQ0FBdkI7QUFDQSxRQUFJLGtCQUFrQiwyQkFBaUIsRUFBRSxLQUFGLENBQVEsS0FBSyxPQUFiLEVBQXNCLEVBQUMsT0FBTyxLQUFLLEtBQWIsRUFBb0IsS0FBSyxLQUFLLEdBQTlCLEVBQW1DLE9BQU8sS0FBSyxLQUEvQyxFQUF0QixDQUFqQixDQUF0QjtBQUNBLFdBQU8sRUFBRSxJQUFGLENBQU8sRUFBRSxJQUFGLENBQU8saUJBQWlCLE1BQXhCLEVBQWdDLGdCQUFoQyxDQUFQLEVBQTBELEVBQUUsR0FBRixDQUFNLFFBQVEsZ0JBQWdCLE1BQWhCLENBQXVCLElBQXZCLENBQWQsQ0FBMUQsRUFBdUcsT0FBdkcsQ0FBUDtBQUNEO0FBWDJCO2tCQUFULFEiLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBUZXJtRXhwYW5kZXIgZnJvbSBcIi4vdGVybS1leHBhbmRlci5qc1wiO1xuaW1wb3J0IFRva2VuRXhwYW5kZXIgZnJvbSBcIi4vdG9rZW4tZXhwYW5kZXJcIjtcbmltcG9ydCB7U2NvcGUsIGZyZXNoU2NvcGV9IGZyb20gXCIuL3Njb3BlXCI7XG5pbXBvcnQgICogYXMgXyBmcm9tIFwicmFtZGFcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVyIHtcbiAgY29uc3RydWN0b3IocGhhc2VfMzMsIGVudl8zNCwgc3RvcmVfMzUsIGNvbnRleHRfMzYpIHtcbiAgICB0aGlzLnBoYXNlID0gcGhhc2VfMzM7XG4gICAgdGhpcy5lbnYgPSBlbnZfMzQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlXzM1O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMzY7XG4gIH1cbiAgY29tcGlsZShzdHhsXzM3KSB7XG4gICAgbGV0IHRva2VuRXhwYW5kZXJfMzggPSBuZXcgVG9rZW5FeHBhbmRlcihfLm1lcmdlKHRoaXMuY29udGV4dCwge3BoYXNlOiB0aGlzLnBoYXNlLCBlbnY6IHRoaXMuZW52LCBzdG9yZTogdGhpcy5zdG9yZX0pKTtcbiAgICBsZXQgdGVybUV4cGFuZGVyXzM5ID0gbmV3IFRlcm1FeHBhbmRlcihfLm1lcmdlKHRoaXMuY29udGV4dCwge3BoYXNlOiB0aGlzLnBoYXNlLCBlbnY6IHRoaXMuZW52LCBzdG9yZTogdGhpcy5zdG9yZX0pKTtcbiAgICByZXR1cm4gXy5waXBlKF8uYmluZCh0b2tlbkV4cGFuZGVyXzM4LmV4cGFuZCwgdG9rZW5FeHBhbmRlcl8zOCksIF8ubWFwKHRfNDAgPT4gdGVybUV4cGFuZGVyXzM5LmV4cGFuZCh0XzQwKSkpKHN0eGxfMzcpO1xuICB9XG59XG4iXX0=

	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.serializer = exports.makeDeserializer = undefined;

		var _transitJs = __webpack_require__(55);

		var _transitJs2 = _interopRequireDefault(_transitJs);

		var _immutable = __webpack_require__(9);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _symbol = __webpack_require__(42);

		var _tokenizer = __webpack_require__(2);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		let typeMap_584 = [_tokenizer.TokenType.STRING, _tokenizer.TokenType.EOS, _tokenizer.TokenType.LPAREN, _tokenizer.TokenType.RPAREN, _tokenizer.TokenType.LBRACK, _tokenizer.TokenType.RBRACK, _tokenizer.TokenType.LBRACE, _tokenizer.TokenType.RBRACE, _tokenizer.TokenType.COLON, _tokenizer.TokenType.SEMICOLON, _tokenizer.TokenType.PERIOD, _tokenizer.TokenType.ELLIPSIS, _tokenizer.TokenType.ARROW, _tokenizer.TokenType.CONDITIONAL, _tokenizer.TokenType.INC, _tokenizer.TokenType.DEC, _tokenizer.TokenType.ASSIGN, _tokenizer.TokenType.ASSIGN_BIT_OR, _tokenizer.TokenType.ASSIGN_BIT_XOR, _tokenizer.TokenType.ASSIGN_BIT_AND, _tokenizer.TokenType.ASSIGN_SHL, _tokenizer.TokenType.ASSIGN_SHR, _tokenizer.TokenType.ASSIGN_SHR_UNSIGNED, _tokenizer.TokenType.ASSIGN_ADD, _tokenizer.TokenType.ASSIGN_SUB, _tokenizer.TokenType.ASSIGN_MUL, _tokenizer.TokenType.ASSIGN_DIV, _tokenizer.TokenType.ASSIGN_MOD, _tokenizer.TokenType.COMMA, _tokenizer.TokenType.OR, _tokenizer.TokenType.AND, _tokenizer.TokenType.BIT_OR, _tokenizer.TokenType.BIT_XOR, _tokenizer.TokenType.BIT_AND, _tokenizer.TokenType.SHL, _tokenizer.TokenType.SHR, _tokenizer.TokenType.SHR_UNSIGNED, _tokenizer.TokenType.ADD, _tokenizer.TokenType.SUB, _tokenizer.TokenType.MUL, _tokenizer.TokenType.DIV, _tokenizer.TokenType.MOD, _tokenizer.TokenType.EQ, _tokenizer.TokenType.NE, _tokenizer.TokenType.EQ_STRICT, _tokenizer.TokenType.NE_STRICT, _tokenizer.TokenType.LT, _tokenizer.TokenType.GT, _tokenizer.TokenType.LTE, _tokenizer.TokenType.GTE, _tokenizer.TokenType.INSTANCEOF, _tokenizer.TokenType.IN, _tokenizer.TokenType.NOT, _tokenizer.TokenType.BIT_NOT, _tokenizer.TokenType.AWAIT, _tokenizer.TokenType.DELETE, _tokenizer.TokenType.TYPEOF, _tokenizer.TokenType.VOID, _tokenizer.TokenType.BREAK, _tokenizer.TokenType.CASE, _tokenizer.TokenType.CATCH, _tokenizer.TokenType.CLASS, _tokenizer.TokenType.CONTINUE, _tokenizer.TokenType.DEBUGGER, _tokenizer.TokenType.DEFAULT, _tokenizer.TokenType.DO, _tokenizer.TokenType.ELSE, _tokenizer.TokenType.EXPORT, _tokenizer.TokenType.EXTENDS, _tokenizer.TokenType.FINALLY, _tokenizer.TokenType.FOR, _tokenizer.TokenType.FUNCTION, _tokenizer.TokenType.IF, _tokenizer.TokenType.IMPORT, _tokenizer.TokenType.LET, _tokenizer.TokenType.NEW, _tokenizer.TokenType.RETURN, _tokenizer.TokenType.SUPER, _tokenizer.TokenType.SWITCH, _tokenizer.TokenType.THIS, _tokenizer.TokenType.THROW, _tokenizer.TokenType.TRY, _tokenizer.TokenType.VAR, _tokenizer.TokenType.WHILE, _tokenizer.TokenType.WITH, _tokenizer.TokenType.NULL, _tokenizer.TokenType.TRUE, _tokenizer.TokenType.FALSE, _tokenizer.TokenType.YIELD, _tokenizer.TokenType.NUMBER, _tokenizer.TokenType.STRING, _tokenizer.TokenType.REGEXP, _tokenizer.TokenType.IDENTIFIER, _tokenizer.TokenType.CONST, _tokenizer.TokenType.TEMPLATE, _tokenizer.TokenType.ILLEGAL];
		let ListHandler_585 = _transitJs2.default.makeWriteHandler({ tag: () => "array", rep: v_591 => v_591 });
		let MapHandler_586 = _transitJs2.default.makeWriteHandler({ tag: function tag(v_592) {
		    return "map";
		  }, rep: function rep(v_593) {
		    return v_593;
		  }, stringRep: function stringRep(v_594) {
		    return null;
		  } });
		let SyntaxHandler_587 = _transitJs2.default.makeWriteHandler({ tag: () => "stx", rep: v_595 => {
		    if (_immutable.List.isList(v_595.token)) {
		      return [v_595.token, v_595.scopesets];
		    } else {
		      let t = _transitJs2.default.objectToMap(v_595.token);
		      t.set("type", typeMap_584.indexOf(v_595.token.type));
		      return [t, v_595.scopesets];
		    }
		  } });
		let SymbolHandler_588 = _transitJs2.default.makeWriteHandler({ tag: () => "symb", rep: v_596 => [v_596.name] });
		let writer_589 = _transitJs2.default.writer("json", { handlers: _transitJs2.default.map([_immutable.List, ListHandler_585, _immutable.Map, MapHandler_586, _syntax2.default, SyntaxHandler_587, _symbol.SymbolClass, SymbolHandler_588]) });
		function makeReader_590(bindings_597) {
		  return _transitJs2.default.reader("json", { arrayBuilder: { init: node_598 => (0, _immutable.List)().asMutable(), add: (ret_599, val_600, node_601) => ret_599.push(val_600), finalize: (ret_602, node_603) => ret_602.asImmutable(), fromArray: (arr_604, node_605) => (0, _immutable.List)(arr_604) }, mapBuilder: { init: function init(node_606) {
		        return (0, _immutable.Map)().asMutable();
		      }, add: function add(ret_607, key_608, val_609, node_610) {
		        return ret_607.set(key_608, val_609);
		      }, finalize: function finalize(ret_611, node_612) {
		        return ret_611.asImmutable();
		      } }, handlers: { stx: rep_613 => {
		        let scopesets_614 = _transitJs2.default.mapToObject(rep_613[1]);
		        if (_immutable.List.isList(rep_613[0])) {
		          let token = rep_613[0];
		          return new _syntax2.default(token, { bindings: bindings_597, scopesets: scopesets_614 });
		        } else {
		          let token = _transitJs2.default.mapToObject(rep_613[0]);
		          token.type = typeMap_584[rep_613[0].get("type")];
		          token.slice = rep_613[0].has("slice") ? _transitJs2.default.mapToObject(rep_613[0].get("slice")) : undefined;
		          if (token.slice) {
		            token.slice.startLocation = _transitJs2.default.mapToObject(token.slice.startLocation);
		          }
		          return new _syntax2.default(token, { bindings: bindings_597, scopesets: scopesets_614 });
		        }
		      }, symb: rep_615 => {
		        return (0, _symbol.Symbol)(rep_615[0]);
		      } } });
		}
		exports.makeDeserializer = makeReader_590;
		exports.serializer = writer_589;
		//# sourceMappingURL=data:application/json;base64,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QUwsQ0FBWSxRQUFRLENBQVIsQ0FBWixDQUFKLEVBQTZCO0FBQzNCLGNBQUksUUFBUSxRQUFRLENBQVIsQ0FBWjtBQUNBLGlCQUFPLHFCQUFXLEtBQVgsRUFBa0IsRUFBQyxVQUFVLFlBQVgsRUFBeUIsV0FBVyxhQUFwQyxFQUFsQixDQUFQO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsY0FBSSxRQUFRLG9CQUFRLFdBQVIsQ0FBb0IsUUFBUSxDQUFSLENBQXBCLENBQVo7QUFDQSxnQkFBTSxJQUFOLEdBQWEsWUFBWSxRQUFRLENBQVIsRUFBVyxHQUFYLENBQWUsTUFBZixDQUFaLENBQWI7QUFDQSxnQkFBTSxLQUFOLEdBQWMsUUFBUSxDQUFSLEVBQVcsR0FBWCxDQUFlLE9BQWYsSUFBMEIsb0JBQVEsV0FBUixDQUFvQixRQUFRLENBQVIsRUFBVyxHQUFYLENBQWUsT0FBZixDQUFwQixDQUExQixHQUF5RSxTQUF2RjtBQUNBLGNBQUksTUFBTSxLQUFWLEVBQWlCO0FBQ2Ysa0JBQU0sS0FBTixDQUFZLGFBQVosR0FBNEIsb0JBQVEsV0FBUixDQUFvQixNQUFNLEtBQU4sQ0FBWSxhQUFoQyxDQUE1QjtBQUNEO0FBQ0QsaUJBQU8scUJBQVcsS0FBWCxFQUFrQixFQUFDLFVBQVUsWUFBWCxFQUF5QixXQUFXLGFBQXBDLEVBQWxCLENBQVA7QUFDRDtBQUNGLE9BZGEsRUFjWCxNQUFNLFdBQVc7QUFDbEIsZUFBTyxvQkFBTyxRQUFRLENBQVIsQ0FBUCxDQUFQO0FBQ0QsT0FoQmEsRUFOZ0IsRUFBdkIsQ0FBUDtBQXVCRDtRQUN5QixnQixHQUFsQixjO1FBQWtELFUsR0FBZCxVIiwiZmlsZSI6InNlcmlhbGl6ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHJhbnNpdCBmcm9tIFwidHJhbnNpdC1qc1wiO1xuaW1wb3J0IHtMaXN0LCBNYXB9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQge1N5bWJvbCwgZ2Vuc3ltLCBTeW1ib2xDbGFzc30gZnJvbSBcIi4vc3ltYm9sXCI7XG5pbXBvcnQge1Rva2VuQ2xhc3MsIFRva2VuVHlwZX0gZnJvbSBcInNoaWZ0LXBhcnNlci9kaXN0L3Rva2VuaXplclwiO1xubGV0IHR5cGVNYXBfNTg0ID0gW1Rva2VuVHlwZS5TVFJJTkcsIFRva2VuVHlwZS5FT1MsIFRva2VuVHlwZS5MUEFSRU4sIFRva2VuVHlwZS5SUEFSRU4sIFRva2VuVHlwZS5MQlJBQ0ssIFRva2VuVHlwZS5SQlJBQ0ssIFRva2VuVHlwZS5MQlJBQ0UsIFRva2VuVHlwZS5SQlJBQ0UsIFRva2VuVHlwZS5DT0xPTiwgVG9rZW5UeXBlLlNFTUlDT0xPTiwgVG9rZW5UeXBlLlBFUklPRCwgVG9rZW5UeXBlLkVMTElQU0lTLCBUb2tlblR5cGUuQVJST1csIFRva2VuVHlwZS5DT05ESVRJT05BTCwgVG9rZW5UeXBlLklOQywgVG9rZW5UeXBlLkRFQywgVG9rZW5UeXBlLkFTU0lHTiwgVG9rZW5UeXBlLkFTU0lHTl9CSVRfT1IsIFRva2VuVHlwZS5BU1NJR05fQklUX1hPUiwgVG9rZW5UeXBlLkFTU0lHTl9CSVRfQU5ELCBUb2tlblR5cGUuQVNTSUdOX1NITCwgVG9rZW5UeXBlLkFTU0lHTl9TSFIsIFRva2VuVHlwZS5BU1NJR05fU0hSX1VOU0lHTkVELCBUb2tlblR5cGUuQVNTSUdOX0FERCwgVG9rZW5UeXBlLkFTU0lHTl9TVUIsIFRva2VuVHlwZS5BU1NJR05fTVVMLCBUb2tlblR5cGUuQVNTSUdOX0RJViwgVG9rZW5UeXBlLkFTU0lHTl9NT0QsIFRva2VuVHlwZS5DT01NQSwgVG9rZW5UeXBlLk9SLCBUb2tlblR5cGUuQU5ELCBUb2tlblR5cGUuQklUX09SLCBUb2tlblR5cGUuQklUX1hPUiwgVG9rZW5UeXBlLkJJVF9BTkQsIFRva2VuVHlwZS5TSEwsIFRva2VuVHlwZS5TSFIsIFRva2VuVHlwZS5TSFJfVU5TSUdORUQsIFRva2VuVHlwZS5BREQsIFRva2VuVHlwZS5TVUIsIFRva2VuVHlwZS5NVUwsIFRva2VuVHlwZS5ESVYsIFRva2VuVHlwZS5NT0QsIFRva2VuVHlwZS5FUSwgVG9rZW5UeXBlLk5FLCBUb2tlblR5cGUuRVFfU1RSSUNULCBUb2tlblR5cGUuTkVfU1RSSUNULCBUb2tlblR5cGUuTFQsIFRva2VuVHlwZS5HVCwgVG9rZW5UeXBlLkxURSwgVG9rZW5UeXBlLkdURSwgVG9rZW5UeXBlLklOU1RBTkNFT0YsIFRva2VuVHlwZS5JTiwgVG9rZW5UeXBlLk5PVCwgVG9rZW5UeXBlLkJJVF9OT1QsIFRva2VuVHlwZS5BV0FJVCwgVG9rZW5UeXBlLkRFTEVURSwgVG9rZW5UeXBlLlRZUEVPRiwgVG9rZW5UeXBlLlZPSUQsIFRva2VuVHlwZS5CUkVBSywgVG9rZW5UeXBlLkNBU0UsIFRva2VuVHlwZS5DQVRDSCwgVG9rZW5UeXBlLkNMQVNTLCBUb2tlblR5cGUuQ09OVElOVUUsIFRva2VuVHlwZS5ERUJVR0dFUiwgVG9rZW5UeXBlLkRFRkFVTFQsIFRva2VuVHlwZS5ETywgVG9rZW5UeXBlLkVMU0UsIFRva2VuVHlwZS5FWFBPUlQsIFRva2VuVHlwZS5FWFRFTkRTLCBUb2tlblR5cGUuRklOQUxMWSwgVG9rZW5UeXBlLkZPUiwgVG9rZW5UeXBlLkZVTkNUSU9OLCBUb2tlblR5cGUuSUYsIFRva2VuVHlwZS5JTVBPUlQsIFRva2VuVHlwZS5MRVQsIFRva2VuVHlwZS5ORVcsIFRva2VuVHlwZS5SRVRVUk4sIFRva2VuVHlwZS5TVVBFUiwgVG9rZW5UeXBlLlNXSVRDSCwgVG9rZW5UeXBlLlRISVMsIFRva2VuVHlwZS5USFJPVywgVG9rZW5UeXBlLlRSWSwgVG9rZW5UeXBlLlZBUiwgVG9rZW5UeXBlLldISUxFLCBUb2tlblR5cGUuV0lUSCwgVG9rZW5UeXBlLk5VTEwsIFRva2VuVHlwZS5UUlVFLCBUb2tlblR5cGUuRkFMU0UsIFRva2VuVHlwZS5ZSUVMRCwgVG9rZW5UeXBlLk5VTUJFUiwgVG9rZW5UeXBlLlNUUklORywgVG9rZW5UeXBlLlJFR0VYUCwgVG9rZW5UeXBlLklERU5USUZJRVIsIFRva2VuVHlwZS5DT05TVCwgVG9rZW5UeXBlLlRFTVBMQVRFLCBUb2tlblR5cGUuSUxMRUdBTF07XG5sZXQgTGlzdEhhbmRsZXJfNTg1ID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6ICgpID0+IFwiYXJyYXlcIiwgcmVwOiB2XzU5MSA9PiB2XzU5MX0pO1xubGV0IE1hcEhhbmRsZXJfNTg2ID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6IGZ1bmN0aW9uICh2XzU5Mikge1xuICByZXR1cm4gXCJtYXBcIjtcbn0sIHJlcDogZnVuY3Rpb24gKHZfNTkzKSB7XG4gIHJldHVybiB2XzU5Mztcbn0sIHN0cmluZ1JlcDogZnVuY3Rpb24gKHZfNTk0KSB7XG4gIHJldHVybiBudWxsO1xufX0pO1xubGV0IFN5bnRheEhhbmRsZXJfNTg3ID0gdHJhbnNpdC5tYWtlV3JpdGVIYW5kbGVyKHt0YWc6ICgpID0+IFwic3R4XCIsIHJlcDogdl81OTUgPT4ge1xuICBpZiAoTGlzdC5pc0xpc3Qodl81OTUudG9rZW4pKSB7XG4gICAgcmV0dXJuIFt2XzU5NS50b2tlbiwgdl81OTUuc2NvcGVzZXRzXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdCA9IHRyYW5zaXQub2JqZWN0VG9NYXAodl81OTUudG9rZW4pO1xuICAgIHQuc2V0KFwidHlwZVwiLCB0eXBlTWFwXzU4NC5pbmRleE9mKHZfNTk1LnRva2VuLnR5cGUpKTtcbiAgICByZXR1cm4gW3QsIHZfNTk1LnNjb3Blc2V0c107XG4gIH1cbn19KTtcbmxldCBTeW1ib2xIYW5kbGVyXzU4OCA9IHRyYW5zaXQubWFrZVdyaXRlSGFuZGxlcih7dGFnOiAoKSA9PiBcInN5bWJcIiwgcmVwOiB2XzU5NiA9PiBbdl81OTYubmFtZV19KTtcbmxldCB3cml0ZXJfNTg5ID0gdHJhbnNpdC53cml0ZXIoXCJqc29uXCIsIHtoYW5kbGVyczogdHJhbnNpdC5tYXAoW0xpc3QsIExpc3RIYW5kbGVyXzU4NSwgTWFwLCBNYXBIYW5kbGVyXzU4NiwgU3ludGF4LCBTeW50YXhIYW5kbGVyXzU4NywgU3ltYm9sQ2xhc3MsIFN5bWJvbEhhbmRsZXJfNTg4XSl9KTtcbmZ1bmN0aW9uIG1ha2VSZWFkZXJfNTkwKGJpbmRpbmdzXzU5Nykge1xuICByZXR1cm4gdHJhbnNpdC5yZWFkZXIoXCJqc29uXCIsIHthcnJheUJ1aWxkZXI6IHtpbml0OiBub2RlXzU5OCA9PiBMaXN0KCkuYXNNdXRhYmxlKCksIGFkZDogKHJldF81OTksIHZhbF82MDAsIG5vZGVfNjAxKSA9PiByZXRfNTk5LnB1c2godmFsXzYwMCksIGZpbmFsaXplOiAocmV0XzYwMiwgbm9kZV82MDMpID0+IHJldF82MDIuYXNJbW11dGFibGUoKSwgZnJvbUFycmF5OiAoYXJyXzYwNCwgbm9kZV82MDUpID0+IExpc3QoYXJyXzYwNCl9LCBtYXBCdWlsZGVyOiB7aW5pdDogZnVuY3Rpb24gKG5vZGVfNjA2KSB7XG4gICAgcmV0dXJuIE1hcCgpLmFzTXV0YWJsZSgpO1xuICB9LCBhZGQ6IGZ1bmN0aW9uIChyZXRfNjA3LCBrZXlfNjA4LCB2YWxfNjA5LCBub2RlXzYxMCkge1xuICAgIHJldHVybiByZXRfNjA3LnNldChrZXlfNjA4LCB2YWxfNjA5KTtcbiAgfSwgZmluYWxpemU6IGZ1bmN0aW9uIChyZXRfNjExLCBub2RlXzYxMikge1xuICAgIHJldHVybiByZXRfNjExLmFzSW1tdXRhYmxlKCk7XG4gIH19LCBoYW5kbGVyczoge3N0eDogcmVwXzYxMyA9PiB7XG4gICAgbGV0IHNjb3Blc2V0c182MTQgPSB0cmFuc2l0Lm1hcFRvT2JqZWN0KHJlcF82MTNbMV0pO1xuICAgIGlmIChMaXN0LmlzTGlzdChyZXBfNjEzWzBdKSkge1xuICAgICAgbGV0IHRva2VuID0gcmVwXzYxM1swXTtcbiAgICAgIHJldHVybiBuZXcgU3ludGF4KHRva2VuLCB7YmluZGluZ3M6IGJpbmRpbmdzXzU5Nywgc2NvcGVzZXRzOiBzY29wZXNldHNfNjE0fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0b2tlbiA9IHRyYW5zaXQubWFwVG9PYmplY3QocmVwXzYxM1swXSk7XG4gICAgICB0b2tlbi50eXBlID0gdHlwZU1hcF81ODRbcmVwXzYxM1swXS5nZXQoXCJ0eXBlXCIpXTtcbiAgICAgIHRva2VuLnNsaWNlID0gcmVwXzYxM1swXS5oYXMoXCJzbGljZVwiKSA/IHRyYW5zaXQubWFwVG9PYmplY3QocmVwXzYxM1swXS5nZXQoXCJzbGljZVwiKSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodG9rZW4uc2xpY2UpIHtcbiAgICAgICAgdG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbiA9IHRyYW5zaXQubWFwVG9PYmplY3QodG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN5bnRheCh0b2tlbiwge2JpbmRpbmdzOiBiaW5kaW5nc181OTcsIHNjb3Blc2V0czogc2NvcGVzZXRzXzYxNH0pO1xuICAgIH1cbiAgfSwgc3ltYjogcmVwXzYxNSA9PiB7XG4gICAgcmV0dXJuIFN5bWJvbChyZXBfNjE1WzBdKTtcbiAgfX19KTtcbn1cbmV4cG9ydCB7bWFrZVJlYWRlcl81OTAgYXMgbWFrZURlc2VyaWFsaXplciwgd3JpdGVyXzU4OSBhcyBzZXJpYWxpemVyfTtcbiJdfQ==

	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.847
		// http://transit-format.org
		// 
		// Copyright 2014 Cognitect. All Rights Reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		//      http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS-IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License..
		var COMPILED = !0, goog = goog || {};
		goog.global = this;
		goog.isDef = function(a) {
		  return void 0 !== a;
		};
		goog.exportPath_ = function(a, b, c) {
		  a = a.split(".");
		  c = c || goog.global;
		  a[0] in c || !c.execScript || c.execScript("var " + a[0]);
		  for (var d;a.length && (d = a.shift());) {
		    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
		  }
		};
		goog.define = function(a, b) {
		  var c = b;
		  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
		  goog.exportPath_(a, c);
		};
		goog.DEBUG = !0;
		goog.LOCALE = "en";
		goog.TRUSTED_SITE = !0;
		goog.STRICT_MODE_COMPATIBLE = !1;
		goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
		goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
		goog.provide = function(a) {
		  if (!COMPILED && goog.isProvided_(a)) {
		    throw Error('Namespace "' + a + '" already declared.');
		  }
		  goog.constructNamespace_(a);
		};
		goog.constructNamespace_ = function(a, b) {
		  if (!COMPILED) {
		    delete goog.implicitNamespaces_[a];
		    for (var c = a;(c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
		      goog.implicitNamespaces_[c] = !0;
		    }
		  }
		  goog.exportPath_(a, b);
		};
		goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
		goog.module = function(a) {
		  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
		    throw Error("Invalid module identifier");
		  }
		  if (!goog.isInModuleLoader_()) {
		    throw Error("Module " + a + " has been loaded incorrectly.");
		  }
		  if (goog.moduleLoaderState_.moduleName) {
		    throw Error("goog.module may only be called once per module.");
		  }
		  goog.moduleLoaderState_.moduleName = a;
		  if (!COMPILED) {
		    if (goog.isProvided_(a)) {
		      throw Error('Namespace "' + a + '" already declared.');
		    }
		    delete goog.implicitNamespaces_[a];
		  }
		};
		goog.module.get = function(a) {
		  return goog.module.getInternal_(a);
		};
		goog.module.getInternal_ = function(a) {
		  if (!COMPILED) {
		    return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
		  }
		};
		goog.moduleLoaderState_ = null;
		goog.isInModuleLoader_ = function() {
		  return null != goog.moduleLoaderState_;
		};
		goog.module.declareTestMethods = function() {
		  if (!goog.isInModuleLoader_()) {
		    throw Error("goog.module.declareTestMethods must be called from within a goog.module");
		  }
		  goog.moduleLoaderState_.declareTestMethods = !0;
		};
		goog.module.declareLegacyNamespace = function() {
		  if (!COMPILED && !goog.isInModuleLoader_()) {
		    throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
		  }
		  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
		    throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
		  }
		  goog.moduleLoaderState_.declareLegacyNamespace = !0;
		};
		goog.setTestOnly = function(a) {
		  if (goog.DISALLOW_TEST_ONLY_CODE) {
		    throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
		  }
		};
		goog.forwardDeclare = function(a) {
		};
		COMPILED || (goog.isProvided_ = function(a) {
		  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
		}, goog.implicitNamespaces_ = {"goog.module":!0});
		goog.getObjectByName = function(a, b) {
		  for (var c = a.split("."), d = b || goog.global, e;e = c.shift();) {
		    if (goog.isDefAndNotNull(d[e])) {
		      d = d[e];
		    } else {
		      return null;
		    }
		  }
		  return d;
		};
		goog.globalize = function(a, b) {
		  var c = b || goog.global, d;
		  for (d in a) {
		    c[d] = a[d];
		  }
		};
		goog.addDependency = function(a, b, c, d) {
		  if (goog.DEPENDENCIES_ENABLED) {
		    var e;
		    a = a.replace(/\\/g, "/");
		    for (var f = goog.dependencies_, g = 0;e = b[g];g++) {
		      f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
		    }
		    for (d = 0;b = c[d];d++) {
		      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
		    }
		  }
		};
		goog.ENABLE_DEBUG_LOADER = !0;
		goog.logToConsole_ = function(a) {
		  goog.global.console && goog.global.console.error(a);
		};
		goog.require = function(a) {
		  if (!COMPILED) {
		    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
		    if (goog.isProvided_(a)) {
		      return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
		    }
		    if (goog.ENABLE_DEBUG_LOADER) {
		      var b = goog.getPathFromDeps_(a);
		      if (b) {
		        return goog.included_[b] = !0, goog.writeScripts_(), null;
		      }
		    }
		    a = "goog.require could not find: " + a;
		    goog.logToConsole_(a);
		    throw Error(a);
		  }
		};
		goog.basePath = "";
		goog.nullFunction = function() {
		};
		goog.abstractMethod = function() {
		  throw Error("unimplemented abstract method");
		};
		goog.addSingletonGetter = function(a) {
		  a.getInstance = function() {
		    if (a.instance_) {
		      return a.instance_;
		    }
		    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
		    return a.instance_ = new a;
		  };
		};
		goog.instantiatedSingletons_ = [];
		goog.LOAD_MODULE_USING_EVAL = !0;
		goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
		goog.loadedModules_ = {};
		goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
		goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {pathIsModule:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {
		  var a = goog.global.document;
		  return "undefined" != typeof a && "write" in a;
		}, goog.findBasePath_ = function() {
		  if (goog.global.CLOSURE_BASE_PATH) {
		    goog.basePath = goog.global.CLOSURE_BASE_PATH;
		  } else {
		    if (goog.inHtmlDocument_()) {
		      for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1;0 <= b;--b) {
		        var c = a[b].src, d = c.lastIndexOf("?"), d = -1 == d ? c.length : d;
		        if ("base.js" == c.substr(d - 7, 7)) {
		          goog.basePath = c.substr(0, d - 7);
		          break;
		        }
		      }
		    }
		  }
		}, goog.importScript_ = function(a, b) {
		  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
		}, goog.IS_OLD_IE_ = !goog.global.atob && goog.global.document && goog.global.document.all, goog.importModule_ = function(a) {
		  goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
		}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {
		  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
		}, goog.loadQueuedModules_ = function() {
		  var a = goog.queuedModules_.length;
		  if (0 < a) {
		    var b = goog.queuedModules_;
		    goog.queuedModules_ = [];
		    for (var c = 0;c < a;c++) {
		      goog.maybeProcessDeferredPath_(b[c]);
		    }
		  }
		}, goog.maybeProcessDeferredDep_ = function(a) {
		  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
		}, goog.isDeferredModule_ = function(a) {
		  return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
		}, goog.allDepsAreAvailable_ = function(a) {
		  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
		    for (var b in goog.dependencies_.requires[a]) {
		      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
		        return !1;
		      }
		    }
		  }
		  return !0;
		}, goog.maybeProcessDeferredPath_ = function(a) {
		  if (a in goog.dependencies_.deferred) {
		    var b = goog.dependencies_.deferred[a];
		    delete goog.dependencies_.deferred[a];
		    goog.globalEval(b);
		  }
		}, goog.loadModule = function(a) {
		  var b = goog.moduleLoaderState_;
		  try {
		    goog.moduleLoaderState_ = {moduleName:void 0, declareTestMethods:!1};
		    var c;
		    if (goog.isFunction(a)) {
		      c = a.call(goog.global, {});
		    } else {
		      if (goog.isString(a)) {
		        c = goog.loadModuleFromSource_.call(goog.global, a);
		      } else {
		        throw Error("Invalid module definition");
		      }
		    }
		    var d = goog.moduleLoaderState_.moduleName;
		    if (!goog.isString(d) || !d) {
		      throw Error('Invalid module name "' + d + '"');
		    }
		    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
		    goog.loadedModules_[d] = c;
		    if (goog.moduleLoaderState_.declareTestMethods) {
		      for (var e in c) {
		        if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
		          goog.global[e] = c[e];
		        }
		      }
		    }
		  } finally {
		    goog.moduleLoaderState_ = b;
		  }
		}, goog.loadModuleFromSource_ = function(a) {
		  eval(a);
		  return {};
		}, goog.writeScriptSrcNode_ = function(a) {
		  goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
		}, goog.appendScriptSrcNode_ = function(a) {
		  var b = goog.global.document, c = b.createElement("script");
		  c.type = "text/javascript";
		  c.src = a;
		  c.defer = !1;
		  c.async = !1;
		  b.head.appendChild(c);
		}, goog.writeScriptTag_ = function(a, b) {
		  if (goog.inHtmlDocument_()) {
		    var c = goog.global.document;
		    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
		      if (/\bdeps.js$/.test(a)) {
		        return !1;
		      }
		      throw Error('Cannot write "' + a + '" after document load');
		    }
		    var d = goog.IS_OLD_IE_;
		    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
		    return !0;
		  }
		  return !1;
		}, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {
		  "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
		  return !0;
		}, goog.writeScripts_ = function() {
		  function a(e) {
		    if (!(e in d.written)) {
		      if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
		        for (var f in d.requires[e]) {
		          if (!goog.isProvided_(f)) {
		            if (f in d.nameToPath) {
		              a(d.nameToPath[f]);
		            } else {
		              throw Error("Undefined nameToPath for " + f);
		            }
		          }
		        }
		      }
		      e in c || (c[e] = !0, b.push(e));
		    }
		  }
		  var b = [], c = {}, d = goog.dependencies_, e;
		  for (e in goog.included_) {
		    d.written[e] || a(e);
		  }
		  for (var f = 0;f < b.length;f++) {
		    e = b[f], goog.dependencies_.written[e] = !0;
		  }
		  var g = goog.moduleLoaderState_;
		  goog.moduleLoaderState_ = null;
		  for (f = 0;f < b.length;f++) {
		    if (e = b[f]) {
		      d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
		    } else {
		      throw goog.moduleLoaderState_ = g, Error("Undefined script input");
		    }
		  }
		  goog.moduleLoaderState_ = g;
		}, goog.getPathFromDeps_ = function(a) {
		  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
		}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
		goog.normalizePath_ = function(a) {
		  a = a.split("/");
		  for (var b = 0;b < a.length;) {
		    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
		  }
		  return a.join("/");
		};
		goog.loadFileSync_ = function(a) {
		  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
		    return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
		  }
		  var b = new goog.global.XMLHttpRequest;
		  b.open("get", a, !1);
		  b.send();
		  return b.responseText;
		};
		goog.retrieveAndExecModule_ = function(a) {
		  if (!COMPILED) {
		    var b = a;
		    a = goog.normalizePath_(a);
		    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, d = goog.loadFileSync_(a);
		    if (null != d) {
		      d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);
		    } else {
		      throw Error("load of " + a + "failed");
		    }
		  }
		};
		goog.typeOf = function(a) {
		  var b = typeof a;
		  if ("object" == b) {
		    if (a) {
		      if (a instanceof Array) {
		        return "array";
		      }
		      if (a instanceof Object) {
		        return b;
		      }
		      var c = Object.prototype.toString.call(a);
		      if ("[object Window]" == c) {
		        return "object";
		      }
		      if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
		        return "array";
		      }
		      if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
		        return "function";
		      }
		    } else {
		      return "null";
		    }
		  } else {
		    if ("function" == b && "undefined" == typeof a.call) {
		      return "object";
		    }
		  }
		  return b;
		};
		goog.isNull = function(a) {
		  return null === a;
		};
		goog.isDefAndNotNull = function(a) {
		  return null != a;
		};
		goog.isArray = function(a) {
		  return "array" == goog.typeOf(a);
		};
		goog.isArrayLike = function(a) {
		  var b = goog.typeOf(a);
		  return "array" == b || "object" == b && "number" == typeof a.length;
		};
		goog.isDateLike = function(a) {
		  return goog.isObject(a) && "function" == typeof a.getFullYear;
		};
		goog.isString = function(a) {
		  return "string" == typeof a;
		};
		goog.isBoolean = function(a) {
		  return "boolean" == typeof a;
		};
		goog.isNumber = function(a) {
		  return "number" == typeof a;
		};
		goog.isFunction = function(a) {
		  return "function" == goog.typeOf(a);
		};
		goog.isObject = function(a) {
		  var b = typeof a;
		  return "object" == b && null != a || "function" == b;
		};
		goog.getUid = function(a) {
		  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
		};
		goog.hasUid = function(a) {
		  return !!a[goog.UID_PROPERTY_];
		};
		goog.removeUid = function(a) {
		  "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
		  try {
		    delete a[goog.UID_PROPERTY_];
		  } catch (b) {
		  }
		};
		goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
		goog.uidCounter_ = 0;
		goog.getHashCode = goog.getUid;
		goog.removeHashCode = goog.removeUid;
		goog.cloneObject = function(a) {
		  var b = goog.typeOf(a);
		  if ("object" == b || "array" == b) {
		    if (a.clone) {
		      return a.clone();
		    }
		    var b = "array" == b ? [] : {}, c;
		    for (c in a) {
		      b[c] = goog.cloneObject(a[c]);
		    }
		    return b;
		  }
		  return a;
		};
		goog.bindNative_ = function(a, b, c) {
		  return a.call.apply(a.bind, arguments);
		};
		goog.bindJs_ = function(a, b, c) {
		  if (!a) {
		    throw Error();
		  }
		  if (2 < arguments.length) {
		    var d = Array.prototype.slice.call(arguments, 2);
		    return function() {
		      var c = Array.prototype.slice.call(arguments);
		      Array.prototype.unshift.apply(c, d);
		      return a.apply(b, c);
		    };
		  }
		  return function() {
		    return a.apply(b, arguments);
		  };
		};
		goog.bind = function(a, b, c) {
		  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
		  return goog.bind.apply(null, arguments);
		};
		goog.partial = function(a, b) {
		  var c = Array.prototype.slice.call(arguments, 1);
		  return function() {
		    var b = c.slice();
		    b.push.apply(b, arguments);
		    return a.apply(this, b);
		  };
		};
		goog.mixin = function(a, b) {
		  for (var c in b) {
		    a[c] = b[c];
		  }
		};
		goog.now = goog.TRUSTED_SITE && Date.now || function() {
		  return +new Date;
		};
		goog.globalEval = function(a) {
		  if (goog.global.execScript) {
		    goog.global.execScript(a, "JavaScript");
		  } else {
		    if (goog.global.eval) {
		      if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
		        goog.global.eval(a);
		      } else {
		        var b = goog.global.document, c = b.createElement("SCRIPT");
		        c.type = "text/javascript";
		        c.defer = !1;
		        c.appendChild(b.createTextNode(a));
		        b.body.appendChild(c);
		        b.body.removeChild(c);
		      }
		    } else {
		      throw Error("goog.globalEval not available");
		    }
		  }
		};
		goog.evalWorksForGlobals_ = null;
		goog.getCssName = function(a, b) {
		  var c = function(a) {
		    return goog.cssNameMapping_[a] || a;
		  }, d = function(a) {
		    a = a.split("-");
		    for (var b = [], d = 0;d < a.length;d++) {
		      b.push(c(a[d]));
		    }
		    return b.join("-");
		  }, d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function(a) {
		    return a;
		  };
		  return b ? a + "-" + d(b) : d(a);
		};
		goog.setCssNameMapping = function(a, b) {
		  goog.cssNameMapping_ = a;
		  goog.cssNameMappingStyle_ = b;
		};
		!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
		goog.getMsg = function(a, b) {
		  b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
		    return d in b ? b[d] : a;
		  }));
		  return a;
		};
		goog.getMsgWithFallback = function(a, b) {
		  return a;
		};
		goog.exportSymbol = function(a, b, c) {
		  goog.exportPath_(a, b, c);
		};
		goog.exportProperty = function(a, b, c) {
		  a[b] = c;
		};
		goog.inherits = function(a, b) {
		  function c() {
		  }
		  c.prototype = b.prototype;
		  a.superClass_ = b.prototype;
		  a.prototype = new c;
		  a.prototype.constructor = a;
		  a.base = function(a, c, f) {
		    for (var g = Array(arguments.length - 2), h = 2;h < arguments.length;h++) {
		      g[h - 2] = arguments[h];
		    }
		    return b.prototype[c].apply(a, g);
		  };
		};
		goog.base = function(a, b, c) {
		  var d = arguments.callee.caller;
		  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
		    throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
		  }
		  if (d.superClass_) {
		    for (var e = Array(arguments.length - 1), f = 1;f < arguments.length;f++) {
		      e[f - 1] = arguments[f];
		    }
		    return d.superClass_.constructor.apply(a, e);
		  }
		  e = Array(arguments.length - 2);
		  for (f = 2;f < arguments.length;f++) {
		    e[f - 2] = arguments[f];
		  }
		  for (var f = !1, g = a.constructor;g;g = g.superClass_ && g.superClass_.constructor) {
		    if (g.prototype[b] === d) {
		      f = !0;
		    } else {
		      if (f) {
		        return g.prototype[b].apply(a, e);
		      }
		    }
		  }
		  if (a[b] === d) {
		    return a.constructor.prototype[b].apply(a, e);
		  }
		  throw Error("goog.base called from a method of one name to a method of a different name");
		};
		goog.scope = function(a) {
		  a.call(goog.global);
		};
		COMPILED || (goog.global.COMPILED = COMPILED);
		goog.defineClass = function(a, b) {
		  var c = b.constructor, d = b.statics;
		  c && c != Object.prototype.constructor || (c = function() {
		    throw Error("cannot instantiate an interface (no constructor defined).");
		  });
		  c = goog.defineClass.createSealingConstructor_(c, a);
		  a && goog.inherits(c, a);
		  delete b.constructor;
		  delete b.statics;
		  goog.defineClass.applyProperties_(c.prototype, b);
		  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
		  return c;
		};
		goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
		goog.defineClass.createSealingConstructor_ = function(a, b) {
		  if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
		    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
		      return a;
		    }
		    var c = function() {
		      var b = a.apply(this, arguments) || this;
		      b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
		      this.constructor === c && Object.seal(b);
		      return b;
		    };
		    return c;
		  }
		  return a;
		};
		goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
		goog.defineClass.applyProperties_ = function(a, b) {
		  for (var c in b) {
		    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
		  }
		  for (var d = 0;d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++) {
		    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
		  }
		};
		goog.tagUnsealableClass = function(a) {
		  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
		};
		goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
		goog.math = {};
		goog.math.Long = function(a, b) {
		  this.low_ = a | 0;
		  this.high_ = b | 0;
		};
		goog.math.Long.IntCache_ = {};
		goog.math.Long.fromInt = function(a) {
		  if (-128 <= a && 128 > a) {
		    var b = goog.math.Long.IntCache_[a];
		    if (b) {
		      return b;
		    }
		  }
		  b = new goog.math.Long(a | 0, 0 > a ? -1 : 0);
		  -128 <= a && 128 > a && (goog.math.Long.IntCache_[a] = b);
		  return b;
		};
		goog.math.Long.fromNumber = function(a) {
		  return isNaN(a) || !isFinite(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);
		};
		goog.math.Long.fromBits = function(a, b) {
		  return new goog.math.Long(a, b);
		};
		goog.math.Long.fromString = function(a, b) {
		  if (0 == a.length) {
		    throw Error("number format error: empty string");
		  }
		  var c = b || 10;
		  if (2 > c || 36 < c) {
		    throw Error("radix out of range: " + c);
		  }
		  if ("-" == a.charAt(0)) {
		    return goog.math.Long.fromString(a.substring(1), c).negate();
		  }
		  if (0 <= a.indexOf("-")) {
		    throw Error('number format error: interior "-" character: ' + a);
		  }
		  for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0;f < a.length;f += 8) {
		    var g = Math.min(8, a.length - f), h = parseInt(a.substring(f, f + g), c);
		    8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));
		  }
		  return e;
		};
		goog.math.Long.TWO_PWR_16_DBL_ = 65536;
		goog.math.Long.getTwoPwr24DBL_ = 16777216;
		goog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
		goog.math.Long.TWO_PWR_31_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ / 2;
		goog.math.Long.TWO_PWR_48_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
		goog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;
		goog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;
		goog.math.Long.getZero = function() {
		  goog.math.Long.ZERO_ || (goog.math.Long.ZERO_ = goog.math.Long.fromInt(0));
		  return goog.math.Long.ZERO_;
		};
		goog.math.Long.getOne = function() {
		  goog.math.Long.ONE_ || (goog.math.Long.ONE_ = goog.math.Long.fromInt(1));
		  return goog.math.Long.ONE_;
		};
		goog.math.Long.getNegOne = function() {
		  goog.math.Long.NEG_ONE_ || (goog.math.Long.NEG_ONE_ = goog.math.Long.fromInt(-1));
		  return goog.math.Long.NEG_ONE_;
		};
		goog.math.Long.getMaxValue = function() {
		  goog.math.Long.MAX_VALUE_ || (goog.math.Long.MAX_VALUE_ = goog.math.Long.fromBits(-1, 2147483647));
		  return goog.math.Long.MAX_VALUE_;
		};
		goog.math.Long.getMinValue = function() {
		  goog.math.Long.MIN_VALUE_ || (goog.math.Long.MIN_VALUE_ = goog.math.Long.fromBits(0, -2147483648));
		  return goog.math.Long.MIN_VALUE_;
		};
		goog.math.Long.getTwoPwr24 = function() {
		  goog.math.Long.TWO_PWR_24_ || (goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(16777216));
		  return goog.math.Long.TWO_PWR_24_;
		};
		goog.math.Long.prototype.toInt = function() {
		  return this.low_;
		};
		goog.math.Long.prototype.toNumber = function() {
		  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
		};
		goog.math.Long.prototype.toString = function(a) {
		  a = a || 10;
		  if (2 > a || 36 < a) {
		    throw Error("radix out of range: " + a);
		  }
		  if (this.isZero()) {
		    return "0";
		  }
		  if (this.isNegative()) {
		    if (this.equals(goog.math.Long.getMinValue())) {
		      var b = goog.math.Long.fromNumber(a), c = this.div(b), b = c.multiply(b).subtract(this);
		      return c.toString(a) + b.toInt().toString(a);
		    }
		    return "-" + this.negate().toString(a);
		  }
		  for (var c = goog.math.Long.fromNumber(Math.pow(a, 6)), b = this, d = "";;) {
		    var e = b.div(c), f = b.subtract(e.multiply(c)).toInt().toString(a), b = e;
		    if (b.isZero()) {
		      return f + d;
		    }
		    for (;6 > f.length;) {
		      f = "0" + f;
		    }
		    d = "" + f + d;
		  }
		};
		goog.math.Long.prototype.getHighBits = function() {
		  return this.high_;
		};
		goog.math.Long.prototype.getLowBits = function() {
		  return this.low_;
		};
		goog.math.Long.prototype.getLowBitsUnsigned = function() {
		  return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
		};
		goog.math.Long.prototype.getNumBitsAbs = function() {
		  if (this.isNegative()) {
		    return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
		  }
		  for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31;0 < b && 0 == (a & 1 << b);b--) {
		  }
		  return 0 != this.high_ ? b + 33 : b + 1;
		};
		goog.math.Long.prototype.isZero = function() {
		  return 0 == this.high_ && 0 == this.low_;
		};
		goog.math.Long.prototype.isNegative = function() {
		  return 0 > this.high_;
		};
		goog.math.Long.prototype.isOdd = function() {
		  return 1 == (this.low_ & 1);
		};
		goog.math.Long.prototype.equals = function(a) {
		  return this.high_ == a.high_ && this.low_ == a.low_;
		};
		goog.math.Long.prototype.notEquals = function(a) {
		  return this.high_ != a.high_ || this.low_ != a.low_;
		};
		goog.math.Long.prototype.lessThan = function(a) {
		  return 0 > this.compare(a);
		};
		goog.math.Long.prototype.lessThanOrEqual = function(a) {
		  return 0 >= this.compare(a);
		};
		goog.math.Long.prototype.greaterThan = function(a) {
		  return 0 < this.compare(a);
		};
		goog.math.Long.prototype.greaterThanOrEqual = function(a) {
		  return 0 <= this.compare(a);
		};
		goog.math.Long.prototype.compare = function(a) {
		  if (this.equals(a)) {
		    return 0;
		  }
		  var b = this.isNegative(), c = a.isNegative();
		  return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;
		};
		goog.math.Long.prototype.negate = function() {
		  return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());
		};
		goog.math.Long.prototype.add = function(a) {
		  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = a.high_ >>> 16, f = a.high_ & 65535, g = a.low_ >>> 16, h;
		  h = 0 + ((this.low_ & 65535) + (a.low_ & 65535));
		  a = 0 + (h >>> 16);
		  a += d + g;
		  d = 0 + (a >>> 16);
		  d += c + f;
		  c = 0 + (d >>> 16);
		  c = c + (b + e) & 65535;
		  return goog.math.Long.fromBits((a & 65535) << 16 | h & 65535, c << 16 | d & 65535);
		};
		goog.math.Long.prototype.subtract = function(a) {
		  return this.add(a.negate());
		};
		goog.math.Long.prototype.multiply = function(a) {
		  if (this.isZero() || a.isZero()) {
		    return goog.math.Long.getZero();
		  }
		  if (this.equals(goog.math.Long.getMinValue())) {
		    return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
		  }
		  if (a.equals(goog.math.Long.getMinValue())) {
		    return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
		  }
		  if (this.isNegative()) {
		    return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
		  }
		  if (a.isNegative()) {
		    return this.multiply(a.negate()).negate();
		  }
		  if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {
		    return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());
		  }
		  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = this.low_ & 65535, f = a.high_ >>> 16, g = a.high_ & 65535, h = a.low_ >>> 16;
		  a = a.low_ & 65535;
		  var m, k, l, n;
		  n = 0 + e * a;
		  l = 0 + (n >>> 16);
		  l += d * a;
		  k = 0 + (l >>> 16);
		  l = (l & 65535) + e * h;
		  k += l >>> 16;
		  l &= 65535;
		  k += c * a;
		  m = 0 + (k >>> 16);
		  k = (k & 65535) + d * h;
		  m += k >>> 16;
		  k &= 65535;
		  k += e * g;
		  m += k >>> 16;
		  k &= 65535;
		  m = m + (b * a + c * h + d * g + e * f) & 65535;
		  return goog.math.Long.fromBits(l << 16 | n & 65535, m << 16 | k);
		};
		goog.math.Long.prototype.div = function(a) {
		  if (a.isZero()) {
		    throw Error("division by zero");
		  }
		  if (this.isZero()) {
		    return goog.math.Long.getZero();
		  }
		  if (this.equals(goog.math.Long.getMinValue())) {
		    if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {
		      return goog.math.Long.getMinValue();
		    }
		    if (a.equals(goog.math.Long.getMinValue())) {
		      return goog.math.Long.getOne();
		    }
		    var b = this.shiftRight(1).div(a).shiftLeft(1);
		    if (b.equals(goog.math.Long.getZero())) {
		      return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();
		    }
		    var c = this.subtract(a.multiply(b));
		    return b.add(c.div(a));
		  }
		  if (a.equals(goog.math.Long.getMinValue())) {
		    return goog.math.Long.getZero();
		  }
		  if (this.isNegative()) {
		    return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
		  }
		  if (a.isNegative()) {
		    return this.div(a.negate()).negate();
		  }
		  for (var d = goog.math.Long.getZero(), c = this;c.greaterThanOrEqual(a);) {
		    for (var b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())), e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a);g.isNegative() || g.greaterThan(c);) {
		      b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);
		    }
		    f.isZero() && (f = goog.math.Long.getOne());
		    d = d.add(f);
		    c = c.subtract(g);
		  }
		  return d;
		};
		goog.math.Long.prototype.modulo = function(a) {
		  return this.subtract(this.div(a).multiply(a));
		};
		goog.math.Long.prototype.not = function() {
		  return goog.math.Long.fromBits(~this.low_, ~this.high_);
		};
		goog.math.Long.prototype.and = function(a) {
		  return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);
		};
		goog.math.Long.prototype.or = function(a) {
		  return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);
		};
		goog.math.Long.prototype.xor = function(a) {
		  return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);
		};
		goog.math.Long.prototype.shiftLeft = function(a) {
		  a &= 63;
		  if (0 == a) {
		    return this;
		  }
		  var b = this.low_;
		  return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);
		};
		goog.math.Long.prototype.shiftRight = function(a) {
		  a &= 63;
		  if (0 == a) {
		    return this;
		  }
		  var b = this.high_;
		  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);
		};
		goog.math.Long.prototype.shiftRightUnsigned = function(a) {
		  a &= 63;
		  if (0 == a) {
		    return this;
		  }
		  var b = this.high_;
		  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);
		};
		goog.object = {};
		goog.object.forEach = function(a, b, c) {
		  for (var d in a) {
		    b.call(c, a[d], d, a);
		  }
		};
		goog.object.filter = function(a, b, c) {
		  var d = {}, e;
		  for (e in a) {
		    b.call(c, a[e], e, a) && (d[e] = a[e]);
		  }
		  return d;
		};
		goog.object.map = function(a, b, c) {
		  var d = {}, e;
		  for (e in a) {
		    d[e] = b.call(c, a[e], e, a);
		  }
		  return d;
		};
		goog.object.some = function(a, b, c) {
		  for (var d in a) {
		    if (b.call(c, a[d], d, a)) {
		      return !0;
		    }
		  }
		  return !1;
		};
		goog.object.every = function(a, b, c) {
		  for (var d in a) {
		    if (!b.call(c, a[d], d, a)) {
		      return !1;
		    }
		  }
		  return !0;
		};
		goog.object.getCount = function(a) {
		  var b = 0, c;
		  for (c in a) {
		    b++;
		  }
		  return b;
		};
		goog.object.getAnyKey = function(a) {
		  for (var b in a) {
		    return b;
		  }
		};
		goog.object.getAnyValue = function(a) {
		  for (var b in a) {
		    return a[b];
		  }
		};
		goog.object.contains = function(a, b) {
		  return goog.object.containsValue(a, b);
		};
		goog.object.getValues = function(a) {
		  var b = [], c = 0, d;
		  for (d in a) {
		    b[c++] = a[d];
		  }
		  return b;
		};
		goog.object.getKeys = function(a) {
		  var b = [], c = 0, d;
		  for (d in a) {
		    b[c++] = d;
		  }
		  return b;
		};
		goog.object.getValueByKeys = function(a, b) {
		  for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1;c < d.length && (a = a[d[c]], goog.isDef(a));c++) {
		  }
		  return a;
		};
		goog.object.containsKey = function(a, b) {
		  return b in a;
		};
		goog.object.containsValue = function(a, b) {
		  for (var c in a) {
		    if (a[c] == b) {
		      return !0;
		    }
		  }
		  return !1;
		};
		goog.object.findKey = function(a, b, c) {
		  for (var d in a) {
		    if (b.call(c, a[d], d, a)) {
		      return d;
		    }
		  }
		};
		goog.object.findValue = function(a, b, c) {
		  return (b = goog.object.findKey(a, b, c)) && a[b];
		};
		goog.object.isEmpty = function(a) {
		  for (var b in a) {
		    return !1;
		  }
		  return !0;
		};
		goog.object.clear = function(a) {
		  for (var b in a) {
		    delete a[b];
		  }
		};
		goog.object.remove = function(a, b) {
		  var c;
		  (c = b in a) && delete a[b];
		  return c;
		};
		goog.object.add = function(a, b, c) {
		  if (b in a) {
		    throw Error('The object already contains the key "' + b + '"');
		  }
		  goog.object.set(a, b, c);
		};
		goog.object.get = function(a, b, c) {
		  return b in a ? a[b] : c;
		};
		goog.object.set = function(a, b, c) {
		  a[b] = c;
		};
		goog.object.setIfUndefined = function(a, b, c) {
		  return b in a ? a[b] : a[b] = c;
		};
		goog.object.setWithReturnValueIfNotSet = function(a, b, c) {
		  if (b in a) {
		    return a[b];
		  }
		  c = c();
		  return a[b] = c;
		};
		goog.object.equals = function(a, b) {
		  for (var c in a) {
		    if (!(c in b) || a[c] !== b[c]) {
		      return !1;
		    }
		  }
		  for (c in b) {
		    if (!(c in a)) {
		      return !1;
		    }
		  }
		  return !0;
		};
		goog.object.clone = function(a) {
		  var b = {}, c;
		  for (c in a) {
		    b[c] = a[c];
		  }
		  return b;
		};
		goog.object.unsafeClone = function(a) {
		  var b = goog.typeOf(a);
		  if ("object" == b || "array" == b) {
		    if (a.clone) {
		      return a.clone();
		    }
		    var b = "array" == b ? [] : {}, c;
		    for (c in a) {
		      b[c] = goog.object.unsafeClone(a[c]);
		    }
		    return b;
		  }
		  return a;
		};
		goog.object.transpose = function(a) {
		  var b = {}, c;
		  for (c in a) {
		    b[a[c]] = c;
		  }
		  return b;
		};
		goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
		goog.object.extend = function(a, b) {
		  for (var c, d, e = 1;e < arguments.length;e++) {
		    d = arguments[e];
		    for (c in d) {
		      a[c] = d[c];
		    }
		    for (var f = 0;f < goog.object.PROTOTYPE_FIELDS_.length;f++) {
		      c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
		    }
		  }
		};
		goog.object.create = function(a) {
		  var b = arguments.length;
		  if (1 == b && goog.isArray(arguments[0])) {
		    return goog.object.create.apply(null, arguments[0]);
		  }
		  if (b % 2) {
		    throw Error("Uneven number of arguments");
		  }
		  for (var c = {}, d = 0;d < b;d += 2) {
		    c[arguments[d]] = arguments[d + 1];
		  }
		  return c;
		};
		goog.object.createSet = function(a) {
		  var b = arguments.length;
		  if (1 == b && goog.isArray(arguments[0])) {
		    return goog.object.createSet.apply(null, arguments[0]);
		  }
		  for (var c = {}, d = 0;d < b;d++) {
		    c[arguments[d]] = !0;
		  }
		  return c;
		};
		goog.object.createImmutableView = function(a) {
		  var b = a;
		  Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
		  return b;
		};
		goog.object.isImmutableView = function(a) {
		  return !!Object.isFrozen && Object.isFrozen(a);
		};
		var com = {cognitect:{}};
		com.cognitect.transit = {};
		com.cognitect.transit.delimiters = {};
		com.cognitect.transit.delimiters.ESC = "~";
		com.cognitect.transit.delimiters.TAG = "#";
		com.cognitect.transit.delimiters.SUB = "^";
		com.cognitect.transit.delimiters.RES = "`";
		com.cognitect.transit.delimiters.ESC_TAG = "~#";
		com.cognitect.transit.caching = {};
		com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
		com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
		com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
		com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
		com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
		com.cognitect.transit.caching.isCacheable = function(a, b) {
		  if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
		    if (b) {
		      return !0;
		    }
		    var c = a.charAt(0), d = a.charAt(1);
		    return c === com.cognitect.transit.delimiters.ESC ? ":" === d || "$" === d || "#" === d : !1;
		  }
		  return !1;
		};
		com.cognitect.transit.caching.idxToCode = function(a) {
		  var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
		  a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
		  return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;
		};
		com.cognitect.transit.caching.WriteCache = function() {
		  this.cacheSize = this.gen = this.idx = 0;
		  this.cache = {};
		};
		com.cognitect.transit.caching.WriteCache.prototype.write = function(a, b) {
		  if (com.cognitect.transit.caching.isCacheable(a, b)) {
		    this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();
		    var c = this.cache[a];
		    return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];
		  }
		  return a;
		};
		com.cognitect.transit.caching.WriteCache.prototype.clear = function() {
		  this.idx = 0;
		  this.gen++;
		};
		com.cognitect.transit.caching.writeCache = function() {
		  return new com.cognitect.transit.caching.WriteCache;
		};
		com.cognitect.transit.caching.isCacheCode = function(a) {
		  return a.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a.charAt(1);
		};
		com.cognitect.transit.caching.codeToIdx = function(a) {
		  if (2 === a.length) {
		    return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
		  }
		  var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
		  a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
		  return b + a;
		};
		com.cognitect.transit.caching.ReadCache = function() {
		  this.idx = 0;
		  this.cache = [];
		};
		com.cognitect.transit.caching.ReadCache.prototype.write = function(a, b) {
		  this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
		  this.cache[this.idx] = a;
		  this.idx++;
		  return a;
		};
		com.cognitect.transit.caching.ReadCache.prototype.read = function(a, b) {
		  return this.cache[com.cognitect.transit.caching.codeToIdx(a)];
		};
		com.cognitect.transit.caching.ReadCache.prototype.clear = function() {
		  this.idx = 0;
		};
		com.cognitect.transit.caching.readCache = function() {
		  return new com.cognitect.transit.caching.ReadCache;
		};
		com.cognitect.transit.util = {};
		com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function(a) {
		  return Object.keys(a);
		} : function(a) {
		  return goog.object.getKeys(a);
		};
		com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function(a) {
		  return Array.isArray(a);
		} : function(a) {
		  return "array" === goog.typeOf(a);
		};
		com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		com.cognitect.transit.util.randInt = function(a) {
		  return Math.round(Math.random() * a);
		};
		com.cognitect.transit.util.randHex = function() {
		  return com.cognitect.transit.util.randInt(15).toString(16);
		};
		com.cognitect.transit.util.randomUUID = function() {
		  var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
		  return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + 
		  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + 
		  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
		};
		com.cognitect.transit.util.btoa = function(a) {
		  if ("undefined" != typeof btoa) {
		    return btoa(a);
		  }
		  a = String(a);
		  for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = "";a.charAt(d | 0) || (e = "=", d % 1);f += e.charAt(63 & b >> 8 - d % 1 * 8)) {
		    c = a.charCodeAt(d += .75);
		    if (255 < c) {
		      throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
		    }
		    b = b << 8 | c;
		  }
		  return f;
		};
		com.cognitect.transit.util.atob = function(a) {
		  if ("undefined" != typeof atob) {
		    return atob(a);
		  }
		  a = String(a).replace(/=+$/, "");
		  if (1 == a.length % 4) {
		    throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
		  }
		  for (var b = 0, c, d, e = 0, f = "";d = a.charAt(e++);~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {
		    d = com.cognitect.transit.util.chars.indexOf(d);
		  }
		  return f;
		};
		com.cognitect.transit.util.Uint8ToBase64 = function(a) {
		  for (var b = 0, c = a.length, d = "", e = null;b < c;) {
		    e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;
		  }
		  return com.cognitect.transit.util.btoa(d);
		};
		com.cognitect.transit.util.Base64ToUint8 = function(a) {
		  a = com.cognitect.transit.util.atob(a);
		  for (var b = a.length, c = new Uint8Array(b), d = 0;d < b;d++) {
		    var e = a.charCodeAt(d);
		    c[d] = e;
		  }
		  return c;
		};
		com.cognitect.transit.eq = {};
		com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
		com.cognitect.transit.eq.hashCodeCounter = 1;
		com.cognitect.transit.eq.equals = function(a, b) {
		  if (null == a) {
		    return null == b;
		  }
		  if (a === b) {
		    return !0;
		  }
		  if ("object" === typeof a) {
		    if (com.cognitect.transit.util.isArray(a)) {
		      if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {
		        for (var c = 0;c < a.length;c++) {
		          if (!com.cognitect.transit.eq.equals(a[c], b[c])) {
		            return !1;
		          }
		        }
		        return !0;
		      }
		      return !1;
		    }
		    if (a.com$cognitect$transit$equals) {
		      return a.com$cognitect$transit$equals(b);
		    }
		    if (null != b && "object" === typeof b) {
		      if (b.com$cognitect$transit$equals) {
		        return b.com$cognitect$transit$equals(a);
		      }
		      var c = 0, d = com.cognitect.transit.util.objectKeys(b).length, e;
		      for (e in a) {
		        if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {
		          return !1;
		        }
		      }
		      return c === d;
		    }
		  }
		  return !1;
		};
		com.cognitect.transit.eq.hashCombine = function(a, b) {
		  return a ^ b + 2654435769 + (a << 6) + (a >> 2);
		};
		com.cognitect.transit.eq.stringCodeCache = {};
		com.cognitect.transit.eq.stringCodeCacheSize = 0;
		com.cognitect.transit.eq.STR_CACHE_MAX = 256;
		com.cognitect.transit.eq.hashString = function(a) {
		  var b = com.cognitect.transit.eq.stringCodeCache[a];
		  if (null != b) {
		    return b;
		  }
		  for (var c = b = 0;c < a.length;++c) {
		    b = 31 * b + a.charCodeAt(c), b %= 4294967296;
		  }
		  com.cognitect.transit.eq.stringCodeCacheSize++;
		  com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
		  return com.cognitect.transit.eq.stringCodeCache[a] = b;
		};
		com.cognitect.transit.eq.hashMapLike = function(a) {
		  var b = 0;
		  if (null != a.forEach) {
		    a.forEach(function(a, c, d) {
		      b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;
		    });
		  } else {
		    for (var c = com.cognitect.transit.util.objectKeys(a), d = 0;d < c.length;d++) {
		      var e = c[d], f = a[e], b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496
		    }
		  }
		  return b;
		};
		com.cognitect.transit.eq.hashArrayLike = function(a) {
		  var b = 0;
		  if (com.cognitect.transit.util.isArray(a)) {
		    for (var c = 0;c < a.length;c++) {
		      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));
		    }
		  } else {
		    a.forEach && a.forEach(function(a, c) {
		      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));
		    });
		  }
		  return b;
		};
		com.cognitect.transit.eq.hashCode = function(a) {
		  if (null == a) {
		    return 0;
		  }
		  switch(typeof a) {
		    case "number":
		      return a;
		    case "boolean":
		      return !0 === a ? 1 : 0;
		    case "string":
		      return com.cognitect.transit.eq.hashString(a);
		    case "function":
		      var b = a[com.cognitect.transit.eq.hashCodeProperty];
		      b || (b = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, {value:b, enumerable:!1}) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);
		      return b;
		    default:
		      return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);
		  }
		};
		com.cognitect.transit.eq.extendToEQ = function(a, b) {
		  a.com$cognitect$transit$hashCode = b.hashCode;
		  a.com$cognitect$transit$equals = b.equals;
		  return a;
		};
		com.cognitect.transit.types = {};
		com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
		com.cognitect.transit.types.TaggedValue = function(a, b) {
		  this.tag = a;
		  this.rep = b;
		  this.hashCode = -1;
		};
		com.cognitect.transit.types.TaggedValue.prototype.toString = function() {
		  return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
		};
		com.cognitect.transit.types.TaggedValue.prototype.equiv = function(a) {
		  return com.cognitect.transit.eq.equals(this, a);
		};
		com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
		com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;
		};
		com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
		  return this.hashCode;
		};
		com.cognitect.transit.types.taggedValue = function(a, b) {
		  return new com.cognitect.transit.types.TaggedValue(a, b);
		};
		com.cognitect.transit.types.isTaggedValue = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue;
		};
		com.cognitect.transit.types.nullValue = function() {
		  return null;
		};
		com.cognitect.transit.types.boolValue = function(a) {
		  return "t" === a;
		};
		com.cognitect.transit.types.MAX_INT = goog.math.Long.fromString("9007199254740991");
		com.cognitect.transit.types.MIN_INT = goog.math.Long.fromString("-9007199254740991");
		com.cognitect.transit.types.intValue = function(a) {
		  if ("number" === typeof a || a instanceof goog.math.Long) {
		    return a;
		  }
		  a = goog.math.Long.fromString(a, 10);
		  return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();
		};
		goog.math.Long.prototype.equiv = function(a) {
		  return com.cognitect.transit.eq.equals(this, a);
		};
		goog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;
		goog.math.Long.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof goog.math.Long && this.equals(a);
		};
		goog.math.Long.prototype.com$cognitect$transit$hashCode = function() {
		  return this.toInt();
		};
		com.cognitect.transit.types.isInteger = function(a) {
		  return a instanceof goog.math.Long ? !0 : "number" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);
		};
		com.cognitect.transit.types.floatValue = function(a) {
		  return parseFloat(a);
		};
		com.cognitect.transit.types.bigInteger = function(a) {
		  return com.cognitect.transit.types.taggedValue("n", a);
		};
		com.cognitect.transit.types.isBigInteger = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "n" === a.tag;
		};
		com.cognitect.transit.types.bigDecimalValue = function(a) {
		  return com.cognitect.transit.types.taggedValue("f", a);
		};
		com.cognitect.transit.types.isBigDecimal = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "f" === a.tag;
		};
		com.cognitect.transit.types.charValue = function(a) {
		  return a;
		};
		com.cognitect.transit.types.Keyword = function(a) {
		  this._name = a;
		  this.hashCode = -1;
		};
		com.cognitect.transit.types.Keyword.prototype.toString = function() {
		  return ":" + this._name;
		};
		com.cognitect.transit.types.Keyword.prototype.namespace = function() {
		  var a = this._name.indexOf("/");
		  return -1 != a ? this._name.substring(0, a) : null;
		};
		com.cognitect.transit.types.Keyword.prototype.name = function() {
		  var a = this._name.indexOf("/");
		  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
		};
		com.cognitect.transit.types.Keyword.prototype.equiv = function(a) {
		  return com.cognitect.transit.eq.equals(this, a);
		};
		com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
		com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;
		};
		com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
		  return this.hashCode;
		};
		com.cognitect.transit.types.keyword = function(a) {
		  return new com.cognitect.transit.types.Keyword(a);
		};
		com.cognitect.transit.types.isKeyword = function(a) {
		  return a instanceof com.cognitect.transit.types.Keyword;
		};
		com.cognitect.transit.types.Symbol = function(a) {
		  this._name = a;
		  this.hashCode = -1;
		};
		com.cognitect.transit.types.Symbol.prototype.namespace = function() {
		  var a = this._name.indexOf("/");
		  return -1 != a ? this._name.substring(0, a) : null;
		};
		com.cognitect.transit.types.Symbol.prototype.name = function() {
		  var a = this._name.indexOf("/");
		  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
		};
		com.cognitect.transit.types.Symbol.prototype.toString = function() {
		  return this._name;
		};
		com.cognitect.transit.types.Symbol.prototype.equiv = function(a) {
		  return com.cognitect.transit.eq.equals(this, a);
		};
		com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
		com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;
		};
		com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
		  return this.hashCode;
		};
		com.cognitect.transit.types.symbol = function(a) {
		  return new com.cognitect.transit.types.Symbol(a);
		};
		com.cognitect.transit.types.isSymbol = function(a) {
		  return a instanceof com.cognitect.transit.types.Symbol;
		};
		com.cognitect.transit.types.hexFor = function(a, b, c) {
		  var d = "";
		  c = c || b + 1;
		  for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e);b < c;b++, e -= 8, f = f.shiftRightUnsigned(8)) {
		    var g = a.and(f).shiftRightUnsigned(e).toString(16);
		    1 == g.length && (g = "0" + g);
		    d += g;
		  }
		  return d;
		};
		com.cognitect.transit.types.UUID = function(a, b) {
		  this.high = a;
		  this.low = b;
		  this.hashCode = -1;
		};
		com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {
		  return this.low;
		};
		com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {
		  return this.high;
		};
		com.cognitect.transit.types.UUID.prototype.toString = function() {
		  var a, b = this.high, c = this.low;
		  a = "" + (com.cognitect.transit.types.hexFor(b, 0, 4) + "-");
		  a += com.cognitect.transit.types.hexFor(b, 4, 6) + "-";
		  a += com.cognitect.transit.types.hexFor(b, 6, 8) + "-";
		  a += com.cognitect.transit.types.hexFor(c, 0, 2) + "-";
		  return a += com.cognitect.transit.types.hexFor(c, 2, 8);
		};
		com.cognitect.transit.types.UUID.prototype.equiv = function(a) {
		  return com.cognitect.transit.eq.equals(this, a);
		};
		com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
		com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);
		};
		com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
		  return this.hashCode;
		};
		com.cognitect.transit.types.UUIDfromString = function(a) {
		  a = a.replace(/-/g, "");
		  for (var b = null, c = null, d = c = 0, e = 24, f = 0, f = c = 0, e = 24;8 > f;f += 2, e -= 8) {
		    c |= parseInt(a.substring(f, f + 2), 16) << e;
		  }
		  d = 0;
		  f = 8;
		  for (e = 24;16 > f;f += 2, e -= 8) {
		    d |= parseInt(a.substring(f, f + 2), 16) << e;
		  }
		  b = goog.math.Long.fromBits(d, c);
		  c = 0;
		  f = 16;
		  for (e = 24;24 > f;f += 2, e -= 8) {
		    c |= parseInt(a.substring(f, f + 2), 16) << e;
		  }
		  d = 0;
		  for (e = f = 24;32 > f;f += 2, e -= 8) {
		    d |= parseInt(a.substring(f, f + 2), 16) << e;
		  }
		  c = goog.math.Long.fromBits(d, c);
		  return new com.cognitect.transit.types.UUID(b, c);
		};
		com.cognitect.transit.types.uuid = function(a) {
		  return com.cognitect.transit.types.UUIDfromString(a);
		};
		com.cognitect.transit.types.isUUID = function(a) {
		  return a instanceof com.cognitect.transit.types.UUID;
		};
		com.cognitect.transit.types.date = function(a) {
		  a = "number" === typeof a ? a : parseInt(a, 10);
		  return new Date(a);
		};
		com.cognitect.transit.types.verboseDate = function(a) {
		  return new Date(a);
		};
		Date.prototype.com$cognitect$transit$equals = function(a) {
		  return a instanceof Date ? this.valueOf() === a.valueOf() : !1;
		};
		Date.prototype.com$cognitect$transit$hashCode = function() {
		  return this.valueOf();
		};
		com.cognitect.transit.types.binary = function(a, b) {
		  return b && !1 === b.preferBuffers || "undefined" == typeof Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue("b", a) : new Buffer(a, "base64");
		};
		com.cognitect.transit.types.isBinary = function(a) {
		  return "undefined" != typeof Buffer && a instanceof Buffer ? !0 : "undefined" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && "b" === a.tag;
		};
		com.cognitect.transit.types.uri = function(a) {
		  return com.cognitect.transit.types.taggedValue("r", a);
		};
		com.cognitect.transit.types.isURI = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "r" === a.tag;
		};
		com.cognitect.transit.types.KEYS = 0;
		com.cognitect.transit.types.VALUES = 1;
		com.cognitect.transit.types.ENTRIES = 2;
		com.cognitect.transit.types.TransitArrayMapIterator = function(a, b) {
		  this.entries = a;
		  this.type = b || com.cognitect.transit.types.KEYS;
		  this.idx = 0;
		};
		com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {
		  if (this.idx < this.entries.length) {
		    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], a = {value:a, done:!1};
		    this.idx += 2;
		    return a;
		  }
		  return {value:null, done:!0};
		};
		com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
		com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
		  return this;
		};
		com.cognitect.transit.types.TransitMapIterator = function(a, b) {
		  this.map = a;
		  this.type = b || com.cognitect.transit.types.KEYS;
		  this.keys = this.map.getKeys();
		  this.idx = 0;
		  this.bucket = null;
		  this.bucketIdx = 0;
		};
		com.cognitect.transit.types.TransitMapIterator.prototype.next = function() {
		  if (this.idx < this.map.size) {
		    null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
		    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], a = {value:a, done:!1};
		    this.idx++;
		    this.bucketIdx += 2;
		    return a;
		  }
		  return {value:null, done:!0};
		};
		com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
		com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
		  return this;
		};
		com.cognitect.transit.types.mapEquals = function(a, b) {
		  if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {
		    if (a.size !== b.size) {
		      return !1;
		    }
		    for (var c in a.map) {
		      for (var d = a.map[c], e = 0;e < d.length;e += 2) {
		        if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {
		          return !1;
		        }
		      }
		    }
		    return !0;
		  }
		  if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {
		    if (a.size !== b.size) {
		      return !1;
		    }
		    c = a._entries;
		    for (e = 0;e < c.length;e += 2) {
		      if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {
		        return !1;
		      }
		    }
		    return !0;
		  }
		  if (null != b && "object" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {
		    for (d = 0;d < c;d++) {
		      var f = e[d];
		      if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {
		        return !1;
		      }
		    }
		    return !0;
		  }
		  return !1;
		};
		com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
		com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
		com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
		com.cognitect.transit.types.print = function(a) {
		  return null == a ? "null" : goog.isArray(a) ? "[" + a.toString() + "]" : goog.isString(a) ? '"' + a + '"' : a.toString();
		};
		com.cognitect.transit.types.printMap = function(a) {
		  var b = 0, c = "TransitMap {";
		  a.forEach(function(d, e) {
		    c += com.cognitect.transit.types.print(e) + " => " + com.cognitect.transit.types.print(d);
		    b < a.size - 1 && (c += ", ");
		    b++;
		  });
		  return c + "}";
		};
		com.cognitect.transit.types.printSet = function(a) {
		  var b = 0, c = "TransitSet {";
		  a.forEach(function(d) {
		    c += com.cognitect.transit.types.print(d);
		    b < a.size - 1 && (c += ", ");
		    b++;
		  });
		  return c + "}";
		};
		com.cognitect.transit.types.TransitArrayMap = function(a) {
		  this._entries = a;
		  this.backingMap = null;
		  this.hashCode = -1;
		  this.size = a.length / 2;
		  this.accesses = 0;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {
		  return com.cognitect.transit.types.printMap(this);
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {
		  return this.toString();
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {
		  if (this.backingMap) {
		    throw Error("Invalid operation, already converted");
		  }
		  if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
		    return !1;
		  }
		  this.accesses++;
		  return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {
		  this.hashCode = -1;
		  this.backingMap ? this.backingMap.clear() : this._entries = [];
		  this.size = 0;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
		com.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {
		  return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
		com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {
		  if (this.backingMap) {
		    return this.backingMap.keySet();
		  }
		  for (var a = [], b = 0, c = 0;c < this._entries.length;b++, c += 2) {
		    a[b] = this._entries[c];
		  }
		  return a;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
		com.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {
		  return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
		com.cognitect.transit.types.TransitArrayMap.prototype.values = function() {
		  return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
		com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a) {
		  if (this.backingMap) {
		    this.backingMap.forEach(a);
		  } else {
		    for (var b = 0;b < this._entries.length;b += 2) {
		      a(this._entries[b + 1], this._entries[b]);
		    }
		  }
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
		com.cognitect.transit.types.TransitArrayMap.prototype.get = function(a, b) {
		  if (this.backingMap) {
		    return this.backingMap.get(a);
		  }
		  if (this.convert()) {
		    return this.get(a);
		  }
		  for (var c = 0;c < this._entries.length;c += 2) {
		    if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
		      return this._entries[c + 1];
		    }
		  }
		  return b;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
		com.cognitect.transit.types.TransitArrayMap.prototype.has = function(a) {
		  if (this.backingMap) {
		    return this.backingMap.has(a);
		  }
		  if (this.convert()) {
		    return this.has(a);
		  }
		  for (var b = 0;b < this._entries.length;b += 2) {
		    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
		      return !0;
		    }
		  }
		  return !1;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
		com.cognitect.transit.types.TransitArrayMap.prototype.set = function(a, b) {
		  this.hashCode = -1;
		  if (this.backingMap) {
		    this.backingMap.set(a, b), this.size = this.backingMap.size;
		  } else {
		    for (var c = 0;c < this._entries.length;c += 2) {
		      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
		        this._entries[c + 1] = b;
		        return;
		      }
		    }
		    this._entries.push(a);
		    this._entries.push(b);
		    this.size++;
		    this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);
		  }
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
		com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function(a) {
		  this.hashCode = -1;
		  if (this.backingMap) {
		    return a = this.backingMap["delete"](a), this.size = this.backingMap.size, a;
		  }
		  for (var b = 0;b < this._entries.length;b += 2) {
		    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
		      return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;
		    }
		  }
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {
		  var a = com.cognitect.transit.types.map();
		  this.forEach(function(b, c) {
		    a.set(c, b);
		  });
		  return a;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
		com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
		  return this.entries();
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {
		  if (this.backingMap) {
		    return this.backingMap.com$cognitect$transit$hashCode();
		  }
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
		  return this.hashCode;
		};
		com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a) {
		  return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);
		};
		com.cognitect.transit.types.TransitMap = function(a, b, c) {
		  this.map = b || {};
		  this._keys = a || [];
		  this.size = c || 0;
		  this.hashCode = -1;
		};
		com.cognitect.transit.types.TransitMap.prototype.toString = function() {
		  return com.cognitect.transit.types.printMap(this);
		};
		com.cognitect.transit.types.TransitMap.prototype.inspect = function() {
		  return this.toString();
		};
		com.cognitect.transit.types.TransitMap.prototype.clear = function() {
		  this.hashCode = -1;
		  this.map = {};
		  this._keys = [];
		  this.size = 0;
		};
		com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
		com.cognitect.transit.types.TransitMap.prototype.getKeys = function() {
		  return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
		};
		com.cognitect.transit.types.TransitMap.prototype["delete"] = function(a) {
		  this.hashCode = -1;
		  this._keys = null;
		  for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0;d < c.length;d += 2) {
		    if (com.cognitect.transit.eq.equals(a, c[d])) {
		      return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;
		    }
		  }
		};
		com.cognitect.transit.types.TransitMap.prototype.entries = function() {
		  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
		};
		com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
		com.cognitect.transit.types.TransitMap.prototype.forEach = function(a) {
		  for (var b = this.getKeys(), c = 0;c < b.length;c++) {
		    for (var d = this.map[b[c]], e = 0;e < d.length;e += 2) {
		      a(d[e + 1], d[e], this);
		    }
		  }
		};
		com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
		com.cognitect.transit.types.TransitMap.prototype.get = function(a, b) {
		  var c = com.cognitect.transit.eq.hashCode(a), c = this.map[c];
		  if (null != c) {
		    for (var d = 0;d < c.length;d += 2) {
		      if (com.cognitect.transit.eq.equals(a, c[d])) {
		        return c[d + 1];
		      }
		    }
		  } else {
		    return b;
		  }
		};
		com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
		com.cognitect.transit.types.TransitMap.prototype.has = function(a) {
		  var b = com.cognitect.transit.eq.hashCode(a), b = this.map[b];
		  if (null != b) {
		    for (var c = 0;c < b.length;c += 2) {
		      if (com.cognitect.transit.eq.equals(a, b[c])) {
		        return !0;
		      }
		    }
		  }
		  return !1;
		};
		com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
		com.cognitect.transit.types.TransitMap.prototype.keys = function() {
		  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
		};
		com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
		com.cognitect.transit.types.TransitMap.prototype.keySet = function() {
		  for (var a = this.getKeys(), b = [], c = 0;c < a.length;c++) {
		    for (var d = this.map[a[c]], e = 0;e < d.length;e += 2) {
		      b.push(d[e]);
		    }
		  }
		  return b;
		};
		com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
		com.cognitect.transit.types.TransitMap.prototype.set = function(a, b) {
		  this.hashCode = -1;
		  var c = com.cognitect.transit.eq.hashCode(a), d = this.map[c];
		  if (null == d) {
		    this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;
		  } else {
		    for (var c = !0, e = 0;e < d.length;e += 2) {
		      if (com.cognitect.transit.eq.equals(b, d[e])) {
		        c = !1;
		        d[e] = b;
		        break;
		      }
		    }
		    c && (d.push(a), d.push(b), this.size++);
		  }
		};
		com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
		com.cognitect.transit.types.TransitMap.prototype.values = function() {
		  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
		};
		com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
		com.cognitect.transit.types.TransitMap.prototype.clone = function() {
		  var a = com.cognitect.transit.types.map();
		  this.forEach(function(b, c) {
		    a.set(c, b);
		  });
		  return a;
		};
		com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
		com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
		  return this.entries();
		};
		com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {
		  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
		  return this.hashCode;
		};
		com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a) {
		  return com.cognitect.transit.types.mapEquals(this, a);
		};
		com.cognitect.transit.types.map = function(a, b, c) {
		  a = a || [];
		  b = !1 === b ? b : !0;
		  if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
		    if (b) {
		      var d = a;
		      a = [];
		      for (b = 0;b < d.length;b += 2) {
		        var e = !1;
		        for (c = 0;c < a.length;c += 2) {
		          if (com.cognitect.transit.eq.equals(a[c], d[b])) {
		            a[c + 1] = d[b + 1];
		            e = !0;
		            break;
		          }
		        }
		        e || (a.push(d[b]), a.push(d[b + 1]));
		      }
		    }
		    return new com.cognitect.transit.types.TransitArrayMap(a);
		  }
		  var d = {}, e = [], f = 0;
		  for (b = 0;b < a.length;b += 2) {
		    c = com.cognitect.transit.eq.hashCode(a[b]);
		    var g = d[c];
		    if (null == g) {
		      e.push(c), d[c] = [a[b], a[b + 1]], f++;
		    } else {
		      var h = !0;
		      for (c = 0;c < g.length;c += 2) {
		        if (com.cognitect.transit.eq.equals(g[c], a[b])) {
		          g[c + 1] = a[b + 1];
		          h = !1;
		          break;
		        }
		      }
		      h && (g.push(a[b]), g.push(a[b + 1]), f++);
		    }
		  }
		  return new com.cognitect.transit.types.TransitMap(e, d, f);
		};
		com.cognitect.transit.types.isArrayMap = function(a) {
		  return a instanceof com.cognitect.transit.types.TransitArrayMap;
		};
		com.cognitect.transit.types.isMap = function(a) {
		  return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;
		};
		com.cognitect.transit.types.TransitSet = function(a) {
		  this.map = a;
		  this.size = a.size;
		};
		com.cognitect.transit.types.TransitSet.prototype.toString = function() {
		  return com.cognitect.transit.types.printSet(this);
		};
		com.cognitect.transit.types.TransitSet.prototype.inspect = function() {
		  return this.toString();
		};
		com.cognitect.transit.types.TransitSet.prototype.add = function(a) {
		  this.map.set(a, a);
		  this.size = this.map.size;
		};
		com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
		com.cognitect.transit.types.TransitSet.prototype.clear = function() {
		  this.map = new com.cognitect.transit.types.TransitMap;
		  this.size = 0;
		};
		com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
		com.cognitect.transit.types.TransitSet.prototype["delete"] = function(a) {
		  a = this.map["delete"](a);
		  this.size = this.map.size;
		  return a;
		};
		com.cognitect.transit.types.TransitSet.prototype.entries = function() {
		  return this.map.entries();
		};
		com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
		com.cognitect.transit.types.TransitSet.prototype.forEach = function(a, b) {
		  var c = this;
		  this.map.forEach(function(b, e, f) {
		    a(e, c);
		  });
		};
		com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
		com.cognitect.transit.types.TransitSet.prototype.has = function(a) {
		  return this.map.has(a);
		};
		com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
		com.cognitect.transit.types.TransitSet.prototype.keys = function() {
		  return this.map.keys();
		};
		com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
		com.cognitect.transit.types.TransitSet.prototype.keySet = function() {
		  return this.map.keySet();
		};
		com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
		com.cognitect.transit.types.TransitSet.prototype.values = function() {
		  return this.map.values();
		};
		com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
		com.cognitect.transit.types.TransitSet.prototype.clone = function() {
		  var a = com.cognitect.transit.types.set();
		  this.forEach(function(b) {
		    a.add(b);
		  });
		  return a;
		};
		com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
		com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {
		  return this.values();
		};
		com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a) {
		  if (a instanceof com.cognitect.transit.types.TransitSet) {
		    if (this.size === a.size) {
		      return com.cognitect.transit.eq.equals(this.map, a.map);
		    }
		  } else {
		    return !1;
		  }
		};
		com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a) {
		  return com.cognitect.transit.eq.hashCode(this.map);
		};
		com.cognitect.transit.types.set = function(a) {
		  a = a || [];
		  for (var b = {}, c = [], d = 0, e = 0;e < a.length;e++) {
		    var f = com.cognitect.transit.eq.hashCode(a[e]), g = b[f];
		    if (null == g) {
		      c.push(f), b[f] = [a[e], a[e]], d++;
		    } else {
		      for (var f = !0, h = 0;h < g.length;h += 2) {
		        if (com.cognitect.transit.eq.equals(g[h], a[e])) {
		          f = !1;
		          break;
		        }
		      }
		      f && (g.push(a[e]), g.push(a[e]), d++);
		    }
		  }
		  return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));
		};
		com.cognitect.transit.types.isSet = function(a) {
		  return a instanceof com.cognitect.transit.types.TransitSet;
		};
		com.cognitect.transit.types.quoted = function(a) {
		  return com.cognitect.transit.types.taggedValue("'", a);
		};
		com.cognitect.transit.types.isQuoted = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "'" === a.tag;
		};
		com.cognitect.transit.types.list = function(a) {
		  return com.cognitect.transit.types.taggedValue("list", a);
		};
		com.cognitect.transit.types.isList = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "list" === a.tag;
		};
		com.cognitect.transit.types.link = function(a) {
		  return com.cognitect.transit.types.taggedValue("link", a);
		};
		com.cognitect.transit.types.isLink = function(a) {
		  return a instanceof com.cognitect.transit.types.TaggedValue && "link" === a.tag;
		};
		com.cognitect.transit.types.specialDouble = function(a) {
		  switch(a) {
		    case "-INF":
		      return -Infinity;
		    case "INF":
		      return Infinity;
		    case "NaN":
		      return NaN;
		    default:
		      throw Error("Invalid special double value " + a);;
		  }
		};
		com.cognitect.transit.handlers = {};
		com.cognitect.transit.handlers.ctorGuid = 0;
		com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
		com.cognitect.transit.handlers.typeTag = function(a) {
		  if (null == a) {
		    return "null";
		  }
		  if (a === String) {
		    return "string";
		  }
		  if (a === Boolean) {
		    return "boolean";
		  }
		  if (a === Number) {
		    return "number";
		  }
		  if (a === Array) {
		    return "array";
		  }
		  if (a === Object) {
		    return "map";
		  }
		  var b = a[com.cognitect.transit.handlers.ctorGuidProperty];
		  null == b && ("undefined" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, {value:b, enumerable:!1})) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);
		  return b;
		};
		com.cognitect.transit.handlers.constructor = function(a) {
		  return null == a ? null : a.constructor;
		};
		com.cognitect.transit.handlers.padZeros = function(a, b) {
		  for (var c = a.toString(), d = c.length;d < b;d++) {
		    c = "0" + c;
		  }
		  return c;
		};
		com.cognitect.transit.handlers.stringableKeys = function(a) {
		  a = com.cognitect.transit.util.objectKeys(a);
		  for (var b = 0;b < a.length;b++) {
		  }
		  return !0;
		};
		com.cognitect.transit.handlers.NilHandler = function() {
		};
		com.cognitect.transit.handlers.NilHandler.prototype.tag = function(a) {
		  return "_";
		};
		com.cognitect.transit.handlers.NilHandler.prototype.rep = function(a) {
		  return null;
		};
		com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a) {
		  return "null";
		};
		com.cognitect.transit.handlers.StringHandler = function() {
		};
		com.cognitect.transit.handlers.StringHandler.prototype.tag = function(a) {
		  return "s";
		};
		com.cognitect.transit.handlers.StringHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.NumberHandler = function() {
		};
		com.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a) {
		  return "i";
		};
		com.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.IntegerHandler = function() {
		};
		com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a) {
		  return "i";
		};
		com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.BooleanHandler = function() {
		};
		com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a) {
		  return "?";
		};
		com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.ArrayHandler = function() {
		};
		com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a) {
		  return "array";
		};
		com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a) {
		  return null;
		};
		com.cognitect.transit.handlers.MapHandler = function() {
		};
		com.cognitect.transit.handlers.MapHandler.prototype.tag = function(a) {
		  return "map";
		};
		com.cognitect.transit.handlers.MapHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a) {
		  return null;
		};
		com.cognitect.transit.handlers.VerboseDateHandler = function() {
		};
		com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a) {
		  return "t";
		};
		com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a) {
		  return a.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + "Z";
		};
		com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a, b) {
		  return b.rep(a);
		};
		com.cognitect.transit.handlers.DateHandler = function() {
		};
		com.cognitect.transit.handlers.DateHandler.prototype.tag = function(a) {
		  return "m";
		};
		com.cognitect.transit.handlers.DateHandler.prototype.rep = function(a) {
		  return a.valueOf();
		};
		com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a) {
		  return a.valueOf().toString();
		};
		com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a) {
		  return new com.cognitect.transit.handlers.VerboseDateHandler;
		};
		com.cognitect.transit.handlers.UUIDHandler = function() {
		};
		com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a) {
		  return "u";
		};
		com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a) {
		  return a.toString();
		};
		com.cognitect.transit.handlers.KeywordHandler = function() {
		};
		com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a) {
		  return ":";
		};
		com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a) {
		  return a._name;
		};
		com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a, b) {
		  return b.rep(a);
		};
		com.cognitect.transit.handlers.SymbolHandler = function() {
		};
		com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a) {
		  return "$";
		};
		com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a) {
		  return a._name;
		};
		com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a, b) {
		  return b.rep(a);
		};
		com.cognitect.transit.handlers.TaggedHandler = function() {
		};
		com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a) {
		  return a.tag;
		};
		com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a) {
		  return a.rep;
		};
		com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.TransitSetHandler = function() {
		};
		com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a) {
		  return "set";
		};
		com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a) {
		  var b = [];
		  a.forEach(function(a, d) {
		    b.push(a);
		  });
		  return com.cognitect.transit.types.taggedValue("array", b);
		};
		com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.TransitArrayMapHandler = function() {
		};
		com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a) {
		  return "map";
		};
		com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.TransitMapHandler = function() {
		};
		com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a) {
		  return "map";
		};
		com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a) {
		  return a;
		};
		com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.BufferHandler = function() {
		};
		com.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a) {
		  return "b";
		};
		com.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a) {
		  return a.toString("base64");
		};
		com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.Uint8ArrayHandler = function() {
		};
		com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a) {
		  return "b";
		};
		com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a) {
		  return com.cognitect.transit.util.Uint8ToBase64(a);
		};
		com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a, b) {
		  return null;
		};
		com.cognitect.transit.handlers.defaultHandlers = function(a) {
		  a.set(null, new com.cognitect.transit.handlers.NilHandler);
		  a.set(String, new com.cognitect.transit.handlers.StringHandler);
		  a.set(Number, new com.cognitect.transit.handlers.NumberHandler);
		  a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler);
		  a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler);
		  a.set(Array, new com.cognitect.transit.handlers.ArrayHandler);
		  a.set(Object, new com.cognitect.transit.handlers.MapHandler);
		  a.set(Date, new com.cognitect.transit.handlers.DateHandler);
		  a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler);
		  a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler);
		  a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler);
		  a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler);
		  a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler);
		  a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler);
		  a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler);
		  "undefined" != typeof Buffer && a.set(Buffer, new com.cognitect.transit.handlers.BufferHandler);
		  "undefined" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler);
		  return a;
		};
		com.cognitect.transit.handlers.Handlers = function() {
		  this.handlers = {};
		  com.cognitect.transit.handlers.defaultHandlers(this);
		};
		com.cognitect.transit.handlers.Handlers.prototype.get = function(a) {
		  var b = null, b = "string" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];
		  return null != b ? b : this.handlers["default"];
		};
		com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
		com.cognitect.transit.handlers.validTag = function(a) {
		  switch(a) {
		    case "null":
		    ;
		    case "string":
		    ;
		    case "boolean":
		    ;
		    case "number":
		    ;
		    case "array":
		    ;
		    case "map":
		      return !1;
		  }
		  return !0;
		};
		com.cognitect.transit.handlers.Handlers.prototype.set = function(a, b) {
		  "string" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;
		};
		com.cognitect.transit.impl = {};
		com.cognitect.transit.impl.decoder = {};
		com.cognitect.transit.impl.decoder.Tag = function(a) {
		  this.str = a;
		};
		com.cognitect.transit.impl.decoder.tag = function(a) {
		  return new com.cognitect.transit.impl.decoder.Tag(a);
		};
		com.cognitect.transit.impl.decoder.isTag = function(a) {
		  return a && a instanceof com.cognitect.transit.impl.decoder.Tag;
		};
		com.cognitect.transit.impl.decoder.isGroundHandler = function(a) {
		  switch(a) {
		    case "_":
		    ;
		    case "s":
		    ;
		    case "?":
		    ;
		    case "i":
		    ;
		    case "d":
		    ;
		    case "b":
		    ;
		    case "'":
		    ;
		    case "array":
		    ;
		    case "map":
		      return !0;
		  }
		  return !1;
		};
		com.cognitect.transit.impl.decoder.Decoder = function(a) {
		  this.options = a || {};
		  this.handlers = {};
		  for (var b in this.defaults.handlers) {
		    this.handlers[b] = this.defaults.handlers[b];
		  }
		  for (b in this.options.handlers) {
		    if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {
		      throw Error('Cannot override handler for ground type "' + b + '"');
		    }
		    this.handlers[b] = this.options.handlers[b];
		  }
		  this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
		  this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
		  this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
		  this.mapBuilder = this.options.mapBuilder;
		  this.arrayBuilder = this.options.arrayBuilder;
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = {handlers:{_:function(a, b) {
		  return com.cognitect.transit.types.nullValue();
		}, "?":function(a, b) {
		  return com.cognitect.transit.types.boolValue(a);
		}, b:function(a, b) {
		  return com.cognitect.transit.types.binary(a, b);
		}, i:function(a, b) {
		  return com.cognitect.transit.types.intValue(a);
		}, n:function(a, b) {
		  return com.cognitect.transit.types.bigInteger(a);
		}, d:function(a, b) {
		  return com.cognitect.transit.types.floatValue(a);
		}, f:function(a, b) {
		  return com.cognitect.transit.types.bigDecimalValue(a);
		}, c:function(a, b) {
		  return com.cognitect.transit.types.charValue(a);
		}, ":":function(a, b) {
		  return com.cognitect.transit.types.keyword(a);
		}, $:function(a, b) {
		  return com.cognitect.transit.types.symbol(a);
		}, r:function(a, b) {
		  return com.cognitect.transit.types.uri(a);
		}, z:function(a, b) {
		  return com.cognitect.transit.types.specialDouble(a);
		}, "'":function(a, b) {
		  return a;
		}, m:function(a, b) {
		  return com.cognitect.transit.types.date(a);
		}, t:function(a, b) {
		  return com.cognitect.transit.types.verboseDate(a);
		}, u:function(a, b) {
		  return com.cognitect.transit.types.uuid(a);
		}, set:function(a, b) {
		  return com.cognitect.transit.types.set(a);
		}, list:function(a, b) {
		  return com.cognitect.transit.types.list(a);
		}, link:function(a, b) {
		  return com.cognitect.transit.types.link(a);
		}, cmap:function(a, b) {
		  return com.cognitect.transit.types.map(a, !1);
		}}, defaultHandler:function(a, b) {
		  return com.cognitect.transit.types.taggedValue(a, b);
		}, preferStrings:!0, preferBuffers:!0};
		com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a, b, c, d) {
		  if (null == a) {
		    return null;
		  }
		  switch(typeof a) {
		    case "string":
		      return this.decodeString(a, b, c, d);
		    case "object":
		      return com.cognitect.transit.util.isArray(a) ? "^ " === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);
		  }
		  return a;
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
		com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a, b, c, d) {
		  return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a, b, c, d) {
		  c = com.cognitect.transit.util.objectKeys(a);
		  var e = c[0];
		  d = 1 == c.length ? this.decode(e, b, !1, !1) : null;
		  if (com.cognitect.transit.impl.decoder.isTag(d)) {
		    return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));
		  }
		  if (this.mapBuilder) {
		    if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
		      var f = [];
		      for (d = 0;d < c.length;d++) {
		        e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
		      }
		      return this.mapBuilder.fromArray(f, a);
		    }
		    f = this.mapBuilder.init(a);
		    for (d = 0;d < c.length;d++) {
		      e = c[d], f = this.mapBuilder.add(f, this.decode(e, b, !0, !1), this.decode(a[e], b, !1, !1), a);
		    }
		    return this.mapBuilder.finalize(f, a);
		  }
		  f = [];
		  for (d = 0;d < c.length;d++) {
		    e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
		  }
		  return com.cognitect.transit.types.map(f, !1);
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a, b, c, d) {
		  if (this.mapBuilder) {
		    if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
		      d = [];
		      for (c = 1;c < a.length;c += 2) {
		        d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
		      }
		      return this.mapBuilder.fromArray(d, a);
		    }
		    d = this.mapBuilder.init(a);
		    for (c = 1;c < a.length;c += 2) {
		      d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);
		    }
		    return this.mapBuilder.finalize(d, a);
		  }
		  d = [];
		  for (c = 1;c < a.length;c += 2) {
		    d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
		  }
		  return com.cognitect.transit.types.map(d, !1);
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a, b, c, d) {
		  if (d) {
		    var e = [];
		    for (d = 0;d < a.length;d++) {
		      e.push(this.decode(a[d], b, c, !1));
		    }
		    return e;
		  }
		  e = b && b.idx;
		  if (2 === a.length && "string" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {
		    return a = a[1], e = this.handlers[d.str], null != e ? e = e(this.decode(a, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, c, !1));
		  }
		  b && e != b.idx && (b.idx = e);
		  if (this.arrayBuilder) {
		    if (32 >= a.length && this.arrayBuilder.fromArray) {
		      e = [];
		      for (d = 0;d < a.length;d++) {
		        e.push(this.decode(a[d], b, c, !1));
		      }
		      return this.arrayBuilder.fromArray(e, a);
		    }
		    e = this.arrayBuilder.init(a);
		    for (d = 0;d < a.length;d++) {
		      e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);
		    }
		    return this.arrayBuilder.finalize(e, a);
		  }
		  e = [];
		  for (d = 0;d < a.length;d++) {
		    e.push(this.decode(a[d], b, c, !1));
		  }
		  return e;
		};
		com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a, b, c) {
		  if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {
		    b = a.charAt(1);
		    if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {
		      return a.substring(1);
		    }
		    if (b === com.cognitect.transit.delimiters.TAG) {
		      return com.cognitect.transit.impl.decoder.tag(a.substring(2));
		    }
		    c = this.handlers[b];
		    return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);
		  }
		  return a;
		};
		com.cognitect.transit.impl.decoder.decoder = function(a) {
		  return new com.cognitect.transit.impl.decoder.Decoder(a);
		};
		com.cognitect.transit.impl.reader = {};
		com.cognitect.transit.impl.reader.JSONUnmarshaller = function(a) {
		  this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);
		};
		com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a, b) {
		  return this.decoder.decode(JSON.parse(a), b);
		};
		com.cognitect.transit.impl.reader.Reader = function(a, b) {
		  this.unmarshaller = a;
		  this.options = b || {};
		  this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache;
		};
		com.cognitect.transit.impl.reader.Reader.prototype.read = function(a) {
		  a = this.unmarshaller.unmarshal(a, this.cache);
		  this.cache.clear();
		  return a;
		};
		com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
		com.cognitect.transit.impl.writer = {};
		com.cognitect.transit.impl.writer.escape = function(a) {
		  if (0 < a.length) {
		    var b = a.charAt(0);
		    return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;
		  }
		  return a;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller = function(a) {
		  this.opts = a || {};
		  this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;
		  this.objectBuilder = this.opts.objectBuilder || null;
		  this.handlers = new com.cognitect.transit.handlers.Handlers;
		  if (a = this.opts.handlers) {
		    if (com.cognitect.transit.util.isArray(a) || !a.forEach) {
		      throw Error('transit writer "handlers" option must be a map');
		    }
		    var b = this;
		    a.forEach(function(a, d) {
		      if (void 0 !== d) {
		        b.handlers.set(d, a);
		      } else {
		        throw Error("Cannot create handler for JavaScript undefined");
		      }
		    });
		  }
		  this.handlerForForeign = this.opts.handlerForForeign;
		  this.unpack = this.opts.unpack || function(a) {
		    return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;
		  };
		  this.verbose = this.opts && this.opts.verbose || !1;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a) {
		  var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));
		  return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a, b) {
		  this.handlers.set(a, b);
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a, b) {
		  return a ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a, b) : null;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a, b, c, d, e) {
		  a = a + b + c;
		  return e ? e.write(a, d) : a;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a, b, c) {
		  return b ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a.toString()[0], b, c) : a;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a, b, c) {
		  return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b, c) : b || "string" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a.toString(), b, c) : a;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a, b, c) {
		  return b ? this.emitString(a.ESC, "d", a, b, c) : a;
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a, b, c) {
		  return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a, b, c);
		};
		com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a, b, c) {
		  if (a.verbose) {
		    a = {};
		    var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c);
		    a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);
		    return a;
		  }
		  return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];
		};
		com.cognitect.transit.impl.writer.emitObjects = function(a, b, c) {
		  var d = [];
		  if (com.cognitect.transit.util.isArray(b)) {
		    for (var e = 0;e < b.length;e++) {
		      d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));
		    }
		  } else {
		    b.forEach(function(b, e) {
		      d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));
		    });
		  }
		  return d;
		};
		com.cognitect.transit.impl.writer.emitArray = function(a, b, c, d) {
		  return com.cognitect.transit.impl.writer.emitObjects(a, b, d);
		};
		com.cognitect.transit.impl.writer.isStringableKey = function(a, b) {
		  if ("string" !== typeof b) {
		    var c = a.handler(b);
		    return c && 1 === c.tag(b).length;
		  }
		  return !0;
		};
		com.cognitect.transit.impl.writer.stringableKeys = function(a, b) {
		  var c = a.unpack(b), d = !0;
		  if (c) {
		    for (var e = 0;e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d);e += 2) {
		    }
		    return d;
		  }
		  if (b.keys && (c = b.keys(), e = null, c.next)) {
		    for (e = c.next();!e.done;) {
		      d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);
		      if (!d) {
		        break;
		      }
		      e = c.next();
		    }
		    return d;
		  }
		  if (b.forEach) {
		    return b.forEach(function(b, c) {
		      d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);
		    }), d;
		  }
		  throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b).name);
		};
		com.cognitect.transit.impl.writer.isForeignObject = function(a) {
		  if (a.constructor.transit$isObject) {
		    return !0;
		  }
		  var b = a.constructor.toString(), b = b.substr(9), b = b.substr(0, b.indexOf("("));
		  isObject = "Object" == b;
		  "undefined" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, "transit$isObject", {value:isObject, enumerable:!1}) : a.constructor.transit$isObject = isObject;
		  return isObject;
		};
		com.cognitect.transit.impl.writer.emitMap = function(a, b, c, d) {
		  var e = null, f = null, g = null, e = null;
		  c = 0;
		  if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {
		    if (a.verbose) {
		      if (null != b.forEach) {
		        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
		          var h = {};
		          b.forEach(function(b, c) {
		            h[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
		          });
		        } else {
		          e = a.unpack(b);
		          f = [];
		          g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
		          if (e) {
		            for (;c < e.length;c += 2) {
		              f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, !1)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
		            }
		          } else {
		            b.forEach(function(b, c) {
		              f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, !1));
		              f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
		            });
		          }
		          h = {};
		          h[g] = f;
		        }
		      } else {
		        for (e = com.cognitect.transit.util.objectKeys(b), h = {};c < e.length;c++) {
		          h[com.cognitect.transit.impl.writer.marshal(a, e[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d);
		        }
		      }
		      return h;
		    }
		    if (null != b.forEach) {
		      if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
		        e = a.unpack(b);
		        h = ["^ "];
		        if (e) {
		          for (;c < e.length;c += 2) {
		            h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
		          }
		        } else {
		          b.forEach(function(b, c) {
		            h.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
		            h.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
		          });
		        }
		        return h;
		      }
		      e = a.unpack(b);
		      f = [];
		      g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
		      if (e) {
		        for (;c < e.length;c += 2) {
		          f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, d)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
		        }
		      } else {
		        b.forEach(function(b, c) {
		          f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, d));
		          f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
		        });
		      }
		      return [g, f];
		    }
		    h = ["^ "];
		    for (e = com.cognitect.transit.util.objectKeys(b);c < e.length;c++) {
		      h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d));
		    }
		    return h;
		  }
		  if (null != a.objectBuilder) {
		    return a.objectBuilder(b, function(b) {
		      return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);
		    }, function(b) {
		      return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
		    });
		  }
		  c = com.cognitect.transit.handlers.constructor(b).name;
		  e = Error("Cannot write " + c);
		  e.data = {obj:b, type:c};
		  throw e;
		};
		com.cognitect.transit.impl.writer.emitTaggedMap = function(a, b, c, d, e) {
		  return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];
		};
		com.cognitect.transit.impl.writer.emitEncoded = function(a, b, c, d, e, f, g) {
		  if (1 === c.length) {
		    if ("string" === typeof d) {
		      return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
		    }
		    if (f || a.preferStrings) {
		      (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);
		      if (null !== d) {
		        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
		      }
		      a = Error('Tag "' + c + '" cannot be encoded as string');
		      a.data = {tag:c, rep:d, obj:e};
		      throw a;
		    }
		  }
		  return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);
		};
		com.cognitect.transit.impl.writer.marshal = function(a, b, c, d) {
		  var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null), f = e ? e.tag(b) : null, g = e ? e.rep(b) : null;
		  if (null != e && null != f) {
		    switch(f) {
		      case "_":
		        return a.emitNil(c, d);
		      case "s":
		        return a.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c, d);
		      case "?":
		        return a.emitBoolean(g, c, d);
		      case "i":
		        return a.emitInteger(g, c, d);
		      case "d":
		        return a.emitDouble(g, c, d);
		      case "b":
		        return a.emitBinary(g, c, d);
		      case "'":
		        return a.emitQuoted(a, g, d);
		      case "array":
		        return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);
		      case "map":
		        return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);
		      default:
		        return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);
		    }
		  } else {
		    throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error("Cannot write " + a), c.data = {obj:b, type:a}, c;
		  }
		};
		com.cognitect.transit.impl.writer.maybeQuoted = function(a, b) {
		  var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);
		  if (null != c) {
		    return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;
		  }
		  var c = com.cognitect.transit.handlers.constructor(b).name, d = Error("Cannot write " + c);
		  d.data = {obj:b, type:c};
		  throw d;
		};
		com.cognitect.transit.impl.writer.marshalTop = function(a, b, c, d) {
		  return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));
		};
		com.cognitect.transit.impl.writer.Writer = function(a, b) {
		  this._marshaller = a;
		  this.options = b || {};
		  this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache;
		};
		com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {
		  return this._marshaller;
		};
		com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
		com.cognitect.transit.impl.writer.Writer.prototype.write = function(a, b) {
		  var c = null, c = b || {}, d = c.asMapKey || !1, e = this._marshaller.verbose ? !1 : this.cache, c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);
		  null != this.cache && this.cache.clear();
		  return c;
		};
		com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
		com.cognitect.transit.impl.writer.Writer.prototype.register = function(a, b) {
		  this._marshaller.registerHandler(a, b);
		};
		com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
		var TRANSIT_DEV = !0, TRANSIT_NODE_TARGET = !0, TRANSIT_BROWSER_TARGET = !1, TRANSIT_BROWSER_AMD_TARGET = !1;
		com.cognitect.transit.reader = function(a, b) {
		  if ("json" === a || "json-verbose" === a || null == a) {
		    var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);
		    return new com.cognitect.transit.impl.reader.Reader(c, b);
		  }
		  throw Error("Cannot create reader of type " + a);
		};
		com.cognitect.transit.writer = function(a, b) {
		  if ("json" === a || "json-verbose" === a || null == a) {
		    "json-verbose" === a && (null == b && (b = {}), b.verbose = !0);
		    var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);
		    return new com.cognitect.transit.impl.writer.Writer(c, b);
		  }
		  c = Error('Type must be "json"');
		  c.data = {type:a};
		  throw c;
		};
		com.cognitect.transit.makeWriteHandler = function(a) {
		  var b = function() {
		  };
		  b.prototype.tag = a.tag;
		  b.prototype.rep = a.rep;
		  b.prototype.stringRep = a.stringRep;
		  b.prototype.getVerboseHandler = a.getVerboseHandler;
		  return new b;
		};
		com.cognitect.transit.makeBuilder = function(a) {
		  var b = function() {
		  };
		  b.prototype.init = a.init;
		  b.prototype.add = a.add;
		  b.prototype.finalize = a.finalize;
		  b.prototype.fromArray = a.fromArray;
		  return new b;
		};
		com.cognitect.transit.date = com.cognitect.transit.types.date;
		com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
		com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
		com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
		com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
		com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
		com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
		com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
		com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
		com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
		com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
		com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
		com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
		com.cognitect.transit.binary = com.cognitect.transit.types.binary;
		com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
		com.cognitect.transit.uri = com.cognitect.transit.types.uri;
		com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
		com.cognitect.transit.map = com.cognitect.transit.types.map;
		com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
		com.cognitect.transit.set = com.cognitect.transit.types.set;
		com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
		com.cognitect.transit.list = com.cognitect.transit.types.list;
		com.cognitect.transit.isList = com.cognitect.transit.types.isList;
		com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
		com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
		com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
		com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
		com.cognitect.transit.link = com.cognitect.transit.types.link;
		com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
		com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
		com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
		com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
		com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
		com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
		com.cognitect.transit.mapToObject = function(a) {
		  var b = {};
		  a.forEach(function(a, d) {
		    if ("string" !== typeof d) {
		      throw Error("Cannot convert map with non-string keys");
		    }
		    b[d] = a;
		  });
		  return b;
		};
		com.cognitect.transit.objectToMap = function(a) {
		  var b = com.cognitect.transit.map(), c;
		  for (c in a) {
		    a.hasOwnProperty(c) && b.set(c, a[c]);
		  }
		  return b;
		};
		com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
		com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
		com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
		com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
		com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
		com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
		TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol("transit.isInteger", 
		com.cognitect.transit.types.isInteger), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), 
		goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), 
		goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol("transit.quoted", 
		com.cognitect.transit.types.quoted), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol("transit.hashMapLike", 
		com.cognitect.transit.eq.hashMapLike), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), 
		goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
		TRANSIT_NODE_TARGET && (module.exports = {reader:com.cognitect.transit.reader, writer:com.cognitect.transit.writer, makeBuilder:com.cognitect.transit.makeBuilder, makeWriteHandler:com.cognitect.transit.makeWriteHandler, date:com.cognitect.transit.types.date, integer:com.cognitect.transit.types.intValue, isInteger:com.cognitect.transit.types.isInteger, uuid:com.cognitect.transit.types.uuid, isUUID:com.cognitect.transit.types.isUUID, bigInt:com.cognitect.transit.types.bigInteger, isBigInt:com.cognitect.transit.types.isBigInteger, 
		bigDec:com.cognitect.transit.types.bigDecimalValue, isBigDec:com.cognitect.transit.types.isBigDecimal, keyword:com.cognitect.transit.types.keyword, isKeyword:com.cognitect.transit.types.isKeyword, symbol:com.cognitect.transit.types.symbol, isSymbol:com.cognitect.transit.types.isSymbol, binary:com.cognitect.transit.types.binary, isBinary:com.cognitect.transit.types.isBinary, uri:com.cognitect.transit.types.uri, isURI:com.cognitect.transit.types.isURI, map:com.cognitect.transit.types.map, isMap:com.cognitect.transit.types.isMap, 
		set:com.cognitect.transit.types.set, isSet:com.cognitect.transit.types.isSet, list:com.cognitect.transit.types.list, isList:com.cognitect.transit.types.isList, quoted:com.cognitect.transit.types.quoted, isQuoted:com.cognitect.transit.types.isQuoted, tagged:com.cognitect.transit.types.taggedValue, isTaggedValue:com.cognitect.transit.types.isTaggedValue, link:com.cognitect.transit.types.link, isLink:com.cognitect.transit.types.isLink, hash:com.cognitect.transit.eq.hashCode, hashArrayLike:com.cognitect.transit.eq.hashArrayLike, 
		hashMapLike:com.cognitect.transit.eq.hashMapLike, equals:com.cognitect.transit.eq.equals, extendToEQ:com.cognitect.transit.eq.extendToEQ, mapToObject:com.cognitect.transit.mapToObject, objectToMap:com.cognitect.transit.objectToMap, decoder:com.cognitect.transit.impl.decoder.decoder, UUIDfromString:com.cognitect.transit.types.UUIDfromString, randomUUID:com.cognitect.transit.util.randomUUID, stringableKeys:com.cognitect.transit.impl.writer.stringableKeys, readCache:com.cognitect.transit.caching.readCache, 
		writeCache:com.cognitect.transit.caching.writeCache});


		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56).Buffer))

	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * @license  MIT
		 */
		/* eslint-disable no-proto */

		'use strict'

		var base64 = __webpack_require__(57)
		var ieee754 = __webpack_require__(58)
		var isArray = __webpack_require__(59)

		exports.Buffer = Buffer
		exports.SlowBuffer = SlowBuffer
		exports.INSPECT_MAX_BYTES = 50
		Buffer.poolSize = 8192 // not used by this implementation

		var rootParent = {}

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Use Object implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * Due to various browser bugs, sometimes the Object implementation will be used even
		 * when the browser supports typed arrays.
		 *
		 * Note:
		 *
		 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
		 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
		 *
		 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
		 *     on objects.
		 *
		 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
		 *
		 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
		 *     incorrect length in some situations.

		 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
		 * get the Object implementation, which is slower but behaves correctly.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
		  ? global.TYPED_ARRAY_SUPPORT
		  : typedArraySupport()

		function typedArraySupport () {
		  function Bar () {}
		  try {
		    var arr = new Uint8Array(1)
		    arr.foo = function () { return 42 }
		    arr.constructor = Bar
		    return arr.foo() === 42 && // typed array instances can be augmented
		        arr.constructor === Bar && // constructor can be set
		        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
		        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
		  } catch (e) {
		    return false
		  }
		}

		function kMaxLength () {
		  return Buffer.TYPED_ARRAY_SUPPORT
		    ? 0x7fffffff
		    : 0x3fffffff
		}

		/**
		 * Class: Buffer
		 * =============
		 *
		 * The Buffer constructor returns instances of `Uint8Array` that are augmented
		 * with function properties for all the node `Buffer` API functions. We use
		 * `Uint8Array` so that square bracket notation works as expected -- it returns
		 * a single octet.
		 *
		 * By augmenting the instances, we can avoid modifying the `Uint8Array`
		 * prototype.
		 */
		function Buffer (arg) {
		  if (!(this instanceof Buffer)) {
		    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
		    if (arguments.length > 1) return new Buffer(arg, arguments[1])
		    return new Buffer(arg)
		  }

		  if (!Buffer.TYPED_ARRAY_SUPPORT) {
		    this.length = 0
		    this.parent = undefined
		  }

		  // Common case.
		  if (typeof arg === 'number') {
		    return fromNumber(this, arg)
		  }

		  // Slightly less common case.
		  if (typeof arg === 'string') {
		    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
		  }

		  // Unusual.
		  return fromObject(this, arg)
		}

		function fromNumber (that, length) {
		  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) {
		    for (var i = 0; i < length; i++) {
		      that[i] = 0
		    }
		  }
		  return that
		}

		function fromString (that, string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

		  // Assumption: byteLength() return value is always < kMaxLength.
		  var length = byteLength(string, encoding) | 0
		  that = allocate(that, length)

		  that.write(string, encoding)
		  return that
		}

		function fromObject (that, object) {
		  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

		  if (isArray(object)) return fromArray(that, object)

		  if (object == null) {
		    throw new TypeError('must start with number, buffer, array or string')
		  }

		  if (typeof ArrayBuffer !== 'undefined') {
		    if (object.buffer instanceof ArrayBuffer) {
		      return fromTypedArray(that, object)
		    }
		    if (object instanceof ArrayBuffer) {
		      return fromArrayBuffer(that, object)
		    }
		  }

		  if (object.length) return fromArrayLike(that, object)

		  return fromJsonObject(that, object)
		}

		function fromBuffer (that, buffer) {
		  var length = checked(buffer.length) | 0
		  that = allocate(that, length)
		  buffer.copy(that, 0, 0, length)
		  return that
		}

		function fromArray (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		// Duplicate of fromArray() to keep fromArray() monomorphic.
		function fromTypedArray (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  // Truncating the elements is probably not what people expect from typed
		  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
		  // of the old Buffer constructor.
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		function fromArrayBuffer (that, array) {
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    array.byteLength
		    that = Buffer._augment(new Uint8Array(array))
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that = fromTypedArray(that, new Uint8Array(array))
		  }
		  return that
		}

		function fromArrayLike (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
		// Returns a zero-length buffer for inputs that don't conform to the spec.
		function fromJsonObject (that, object) {
		  var array
		  var length = 0

		  if (object.type === 'Buffer' && isArray(object.data)) {
		    array = object.data
		    length = checked(array.length) | 0
		  }
		  that = allocate(that, length)

		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		if (Buffer.TYPED_ARRAY_SUPPORT) {
		  Buffer.prototype.__proto__ = Uint8Array.prototype
		  Buffer.__proto__ = Uint8Array
		} else {
		  // pre-set for values that may exist in the future
		  Buffer.prototype.length = undefined
		  Buffer.prototype.parent = undefined
		}

		function allocate (that, length) {
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = Buffer._augment(new Uint8Array(length))
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that.length = length
		    that._isBuffer = true
		  }

		  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
		  if (fromPool) that.parent = rootParent

		  return that
		}

		function checked (length) {
		  // Note: cannot use `length < kMaxLength` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= kMaxLength()) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (subject, encoding) {
		  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

		  var buf = new Buffer(subject, encoding)
		  delete buf.parent
		  return buf
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return !!(b != null && b._isBuffer)
		}

		Buffer.compare = function compare (a, b) {
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError('Arguments must be Buffers')
		  }

		  if (a === b) return 0

		  var x = a.length
		  var y = b.length

		  var i = 0
		  var len = Math.min(x, y)
		  while (i < len) {
		    if (a[i] !== b[i]) break

		    ++i
		  }

		  if (i !== len) {
		    x = a[i]
		    y = b[i]
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'binary':
		    case 'base64':
		    case 'raw':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		}

		Buffer.concat = function concat (list, length) {
		  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

		  if (list.length === 0) {
		    return new Buffer(0)
		  }

		  var i
		  if (length === undefined) {
		    length = 0
		    for (i = 0; i < list.length; i++) {
		      length += list[i].length
		    }
		  }

		  var buf = new Buffer(length)
		  var pos = 0
		  for (i = 0; i < list.length; i++) {
		    var item = list[i]
		    item.copy(buf, pos)
		    pos += item.length
		  }
		  return buf
		}

		function byteLength (string, encoding) {
		  if (typeof string !== 'string') string = '' + string

		  var len = string.length
		  if (len === 0) return 0

		  // Use a for loop to avoid recursion
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'binary':
		      // Deprecated
		      case 'raw':
		      case 'raws':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) return utf8ToBytes(string).length // assume utf8
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		Buffer.byteLength = byteLength

		function slowToString (encoding, start, end) {
		  var loweredCase = false

		  start = start | 0
		  end = end === undefined || end === Infinity ? this.length : end | 0

		  if (!encoding) encoding = 'utf8'
		  if (start < 0) start = 0
		  if (end > this.length) end = this.length
		  if (end <= start) return ''

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'binary':
		        return binarySlice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase()
		        loweredCase = true
		    }
		  }
		}

		Buffer.prototype.toString = function toString () {
		  var length = this.length | 0
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		}

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		}

		Buffer.prototype.inspect = function inspect () {
		  var str = ''
		  var max = exports.INSPECT_MAX_BYTES
		  if (this.length > 0) {
		    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
		    if (this.length > max) str += ' ... '
		  }
		  return '<Buffer ' + str + '>'
		}

		Buffer.prototype.compare = function compare (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return 0
		  return Buffer.compare(this, b)
		}

		Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
		  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
		  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
		  byteOffset >>= 0

		  if (this.length === 0) return -1
		  if (byteOffset >= this.length) return -1

		  // Negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

		  if (typeof val === 'string') {
		    if (val.length === 0) return -1 // special case: looking for empty string always fails
		    return String.prototype.indexOf.call(this, val, byteOffset)
		  }
		  if (Buffer.isBuffer(val)) {
		    return arrayIndexOf(this, val, byteOffset)
		  }
		  if (typeof val === 'number') {
		    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
		      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
		    }
		    return arrayIndexOf(this, [ val ], byteOffset)
		  }

		  function arrayIndexOf (arr, val, byteOffset) {
		    var foundIndex = -1
		    for (var i = 0; byteOffset + i < arr.length; i++) {
		      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
		        if (foundIndex === -1) foundIndex = i
		        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
		      } else {
		        foundIndex = -1
		      }
		    }
		    return -1
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		// `get` is deprecated
		Buffer.prototype.get = function get (offset) {
		  console.log('.get() is deprecated. Access using array indexes instead.')
		  return this.readUInt8(offset)
		}

		// `set` is deprecated
		Buffer.prototype.set = function set (v, offset) {
		  console.log('.set() is deprecated. Access using array indexes instead.')
		  return this.writeUInt8(v, offset)
		}

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0
		  var remaining = buf.length - offset
		  if (!length) {
		    length = remaining
		  } else {
		    length = Number(length)
		    if (length > remaining) {
		      length = remaining
		    }
		  }

		  // must be an even number of digits
		  var strLen = string.length
		  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

		  if (length > strLen / 2) {
		    length = strLen / 2
		  }
		  for (var i = 0; i < length; i++) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16)
		    if (isNaN(parsed)) throw new Error('Invalid hex string')
		    buf[offset + i] = parsed
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function binaryWrite (buf, string, offset, length) {
		  return asciiWrite(buf, string, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8'
		    length = this.length
		    offset = 0
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset
		    length = this.length
		    offset = 0
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset | 0
		    if (isFinite(length)) {
		      length = length | 0
		      if (encoding === undefined) encoding = 'utf8'
		    } else {
		      encoding = length
		      length = undefined
		    }
		  // legacy write(string, encoding, offset, length) - remove in v0.13
		  } else {
		    var swap = encoding
		    encoding = offset
		    offset = length | 0
		    length = swap
		  }

		  var remaining = this.length - offset
		  if (length === undefined || length > remaining) length = remaining

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8'

		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		        return asciiWrite(this, string, offset, length)

		      case 'binary':
		        return binaryWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		}

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end)
		  var res = []

		  var i = start
		  while (i < end) {
		    var firstByte = buf[i]
		    var codePoint = null
		    var bytesPerSequence = (firstByte > 0xEF) ? 4
		      : (firstByte > 0xDF) ? 3
		      : (firstByte > 0xBF) ? 2
		      : 1

		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1]
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          fourthByte = buf[i + 3]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD
		      bytesPerSequence = 1
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
		      codePoint = 0xDC00 | codePoint & 0x3FF
		    }

		    res.push(codePoint)
		    i += bytesPerSequence
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000

		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = ''
		  var i = 0
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    )
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)

		  for (var i = start; i < end; i++) {
		    ret += String.fromCharCode(buf[i] & 0x7F)
		  }
		  return ret
		}

		function binarySlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)

		  for (var i = start; i < end; i++) {
		    ret += String.fromCharCode(buf[i])
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  var len = buf.length

		  if (!start || start < 0) start = 0
		  if (!end || end < 0 || end > len) end = len

		  var out = ''
		  for (var i = start; i < end; i++) {
		    out += toHex(buf[i])
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end)
		  var res = ''
		  for (var i = 0; i < bytes.length; i += 2) {
		    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length
		  start = ~~start
		  end = end === undefined ? len : ~~end

		  if (start < 0) {
		    start += len
		    if (start < 0) start = 0
		  } else if (start > len) {
		    start = len
		  }

		  if (end < 0) {
		    end += len
		    if (end < 0) end = 0
		  } else if (end > len) {
		    end = len
		  }

		  if (end < start) end = start

		  var newBuf
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    newBuf = Buffer._augment(this.subarray(start, end))
		  } else {
		    var sliceLen = end - start
		    newBuf = new Buffer(sliceLen, undefined)
		    for (var i = 0; i < sliceLen; i++) {
		      newBuf[i] = this[i + start]
		    }
		  }

		  if (newBuf.length) newBuf.parent = this.parent || this

		  return newBuf
		}

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }

		  return val
		}

		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length)
		  }

		  var val = this[offset + --byteLength]
		  var mul = 1
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul
		  }

		  return val
		}

		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  return this[offset]
		}

		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return this[offset] | (this[offset + 1] << 8)
		}

		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return (this[offset] << 8) | this[offset + 1]
		}

		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		}

		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		}

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
		  mul *= 0x80

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

		  return val
		}

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var i = byteLength
		  var mul = 1
		  var val = this[offset + --i]
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul
		  }
		  mul *= 0x80

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

		  return val
		}

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		}

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset] | (this[offset + 1] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset + 1] | (this[offset] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		}

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		}

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, true, 23, 4)
		}

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, false, 23, 4)
		}

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, true, 52, 8)
		}

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, false, 52, 8)
		}

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('value is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('index out of range')
		}

		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

		  var mul = 1
		  var i = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

		  var i = byteLength - 1
		  var mul = 1
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  this[offset] = (value & 0xff)
		  return offset + 1
		}

		function objectWriteUInt16 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
		    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
		      (littleEndian ? i : 1 - i) * 8
		  }
		}

		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}

		function objectWriteUInt32 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffffffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
		    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
		  }
		}

		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset + 3] = (value >>> 24)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 1] = (value >>> 8)
		    this[offset] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)

		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }

		  var i = 0
		  var mul = 1
		  var sub = value < 0 ? 1 : 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)

		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }

		  var i = byteLength - 1
		  var mul = 1
		  var sub = value < 0 ? 1 : 0
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  if (value < 0) value = 0xff + value + 1
		  this[offset] = (value & 0xff)
		  return offset + 1
		}

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 3] = (value >>> 24)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (value < 0) value = 0xffffffff + value + 1
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (value > max || value < min) throw new RangeError('value is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('index out of range')
		  if (offset < 0) throw new RangeError('index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4)
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		}

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		}

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8)
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		}

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		}

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!start) start = 0
		  if (!end && end !== 0) end = this.length
		  if (targetStart >= target.length) targetStart = target.length
		  if (!targetStart) targetStart = 0
		  if (end > 0 && end < start) end = start

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start
		  }

		  var len = end - start
		  var i

		  if (this === target && start < targetStart && targetStart < end) {
		    // descending copy from end
		    for (i = len - 1; i >= 0; i--) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
		    // ascending copy from start
		    for (i = 0; i < len; i++) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else {
		    target._set(this.subarray(start, start + len), targetStart)
		  }

		  return len
		}

		// fill(value, start=0, end=buffer.length)
		Buffer.prototype.fill = function fill (value, start, end) {
		  if (!value) value = 0
		  if (!start) start = 0
		  if (!end) end = this.length

		  if (end < start) throw new RangeError('end < start')

		  // Fill 0 bytes; we're done
		  if (end === start) return
		  if (this.length === 0) return

		  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
		  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

		  var i
		  if (typeof value === 'number') {
		    for (i = start; i < end; i++) {
		      this[i] = value
		    }
		  } else {
		    var bytes = utf8ToBytes(value.toString())
		    var len = bytes.length
		    for (i = start; i < end; i++) {
		      this[i] = bytes[i % len]
		    }
		  }

		  return this
		}

		/**
		 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
		 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
		 */
		Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
		  if (typeof Uint8Array !== 'undefined') {
		    if (Buffer.TYPED_ARRAY_SUPPORT) {
		      return (new Buffer(this)).buffer
		    } else {
		      var buf = new Uint8Array(this.length)
		      for (var i = 0, len = buf.length; i < len; i += 1) {
		        buf[i] = this[i]
		      }
		      return buf.buffer
		    }
		  } else {
		    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
		  }
		}

		// HELPER FUNCTIONS
		// ================

		var BP = Buffer.prototype

		/**
		 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
		 */
		Buffer._augment = function _augment (arr) {
		  arr.constructor = Buffer
		  arr._isBuffer = true

		  // save reference to original Uint8Array set method before overwriting
		  arr._set = arr.set

		  // deprecated
		  arr.get = BP.get
		  arr.set = BP.set

		  arr.write = BP.write
		  arr.toString = BP.toString
		  arr.toLocaleString = BP.toString
		  arr.toJSON = BP.toJSON
		  arr.equals = BP.equals
		  arr.compare = BP.compare
		  arr.indexOf = BP.indexOf
		  arr.copy = BP.copy
		  arr.slice = BP.slice
		  arr.readUIntLE = BP.readUIntLE
		  arr.readUIntBE = BP.readUIntBE
		  arr.readUInt8 = BP.readUInt8
		  arr.readUInt16LE = BP.readUInt16LE
		  arr.readUInt16BE = BP.readUInt16BE
		  arr.readUInt32LE = BP.readUInt32LE
		  arr.readUInt32BE = BP.readUInt32BE
		  arr.readIntLE = BP.readIntLE
		  arr.readIntBE = BP.readIntBE
		  arr.readInt8 = BP.readInt8
		  arr.readInt16LE = BP.readInt16LE
		  arr.readInt16BE = BP.readInt16BE
		  arr.readInt32LE = BP.readInt32LE
		  arr.readInt32BE = BP.readInt32BE
		  arr.readFloatLE = BP.readFloatLE
		  arr.readFloatBE = BP.readFloatBE
		  arr.readDoubleLE = BP.readDoubleLE
		  arr.readDoubleBE = BP.readDoubleBE
		  arr.writeUInt8 = BP.writeUInt8
		  arr.writeUIntLE = BP.writeUIntLE
		  arr.writeUIntBE = BP.writeUIntBE
		  arr.writeUInt16LE = BP.writeUInt16LE
		  arr.writeUInt16BE = BP.writeUInt16BE
		  arr.writeUInt32LE = BP.writeUInt32LE
		  arr.writeUInt32BE = BP.writeUInt32BE
		  arr.writeIntLE = BP.writeIntLE
		  arr.writeIntBE = BP.writeIntBE
		  arr.writeInt8 = BP.writeInt8
		  arr.writeInt16LE = BP.writeInt16LE
		  arr.writeInt16BE = BP.writeInt16BE
		  arr.writeInt32LE = BP.writeInt32LE
		  arr.writeInt32BE = BP.writeInt32BE
		  arr.writeFloatLE = BP.writeFloatLE
		  arr.writeFloatBE = BP.writeFloatBE
		  arr.writeDoubleLE = BP.writeDoubleLE
		  arr.writeDoubleBE = BP.writeDoubleBE
		  arr.fill = BP.fill
		  arr.inspect = BP.inspect
		  arr.toArrayBuffer = BP.toArrayBuffer

		  return arr
		}

		var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

		function base64clean (str) {
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '='
		  }
		  return str
		}

		function stringtrim (str) {
		  if (str.trim) return str.trim()
		  return str.replace(/^\s+|\s+$/g, '')
		}

		function toHex (n) {
		  if (n < 16) return '0' + n.toString(16)
		  return n.toString(16)
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity
		  var codePoint
		  var length = string.length
		  var leadSurrogate = null
		  var bytes = []

		  for (var i = 0; i < length; i++) {
		    codePoint = string.charCodeAt(i)

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		        leadSurrogate = codePoint
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		    }

		    leadSurrogate = null

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint)
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  var byteArray = []
		  for (var i = 0; i < str.length; i++) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF)
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  var c, hi, lo
		  var byteArray = []
		  for (var i = 0; i < str.length; i++) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i)
		    hi = c >> 8
		    lo = c % 256
		    byteArray.push(lo)
		    byteArray.push(hi)
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; i++) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i]
		  }
		  return i
		}

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56).Buffer, (function() { return this; }())))

	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {

		var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

		;(function (exports) {
			'use strict';

		  var Arr = (typeof Uint8Array !== 'undefined')
		    ? Uint8Array
		    : Array

			var PLUS   = '+'.charCodeAt(0)
			var SLASH  = '/'.charCodeAt(0)
			var NUMBER = '0'.charCodeAt(0)
			var LOWER  = 'a'.charCodeAt(0)
			var UPPER  = 'A'.charCodeAt(0)
			var PLUS_URL_SAFE = '-'.charCodeAt(0)
			var SLASH_URL_SAFE = '_'.charCodeAt(0)

			function decode (elt) {
				var code = elt.charCodeAt(0)
				if (code === PLUS ||
				    code === PLUS_URL_SAFE)
					return 62 // '+'
				if (code === SLASH ||
				    code === SLASH_URL_SAFE)
					return 63 // '/'
				if (code < NUMBER)
					return -1 //no match
				if (code < NUMBER + 10)
					return code - NUMBER + 26 + 26
				if (code < UPPER + 26)
					return code - UPPER
				if (code < LOWER + 26)
					return code - LOWER + 26
			}

			function b64ToByteArray (b64) {
				var i, j, l, tmp, placeHolders, arr

				if (b64.length % 4 > 0) {
					throw new Error('Invalid string. Length must be a multiple of 4')
				}

				// the number of equal signs (place holders)
				// if there are two placeholders, than the two characters before it
				// represent one byte
				// if there is only one, then the three characters before it represent 2 bytes
				// this is just a cheap hack to not do indexOf twice
				var len = b64.length
				placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

				// base64 is 4/3 + up to two characters of the original data
				arr = new Arr(b64.length * 3 / 4 - placeHolders)

				// if there are placeholders, only get up to the last complete 4 chars
				l = placeHolders > 0 ? b64.length - 4 : b64.length

				var L = 0

				function push (v) {
					arr[L++] = v
				}

				for (i = 0, j = 0; i < l; i += 4, j += 3) {
					tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
					push((tmp & 0xFF0000) >> 16)
					push((tmp & 0xFF00) >> 8)
					push(tmp & 0xFF)
				}

				if (placeHolders === 2) {
					tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
					push(tmp & 0xFF)
				} else if (placeHolders === 1) {
					tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
					push((tmp >> 8) & 0xFF)
					push(tmp & 0xFF)
				}

				return arr
			}

			function uint8ToBase64 (uint8) {
				var i,
					extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
					output = "",
					temp, length

				function encode (num) {
					return lookup.charAt(num)
				}

				function tripletToBase64 (num) {
					return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
				}

				// go through the array every three bytes, we'll deal with trailing stuff later
				for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
					temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
					output += tripletToBase64(temp)
				}

				// pad the end with zeros, but make sure to not forget the extra bytes
				switch (extraBytes) {
					case 1:
						temp = uint8[uint8.length - 1]
						output += encode(temp >> 2)
						output += encode((temp << 4) & 0x3F)
						output += '=='
						break
					case 2:
						temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
						output += encode(temp >> 10)
						output += encode((temp >> 4) & 0x3F)
						output += encode((temp << 2) & 0x3F)
						output += '='
						break
				}

				return output
			}

			exports.toByteArray = b64ToByteArray
			exports.fromByteArray = uint8ToBase64
		}( false ? (this.base64js = {}) : exports))


	/***/ },
	/* 58 */
	/***/ function(module, exports) {

		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var nBits = -7
		  var i = isLE ? (nBytes - 1) : 0
		  var d = isLE ? -1 : 1
		  var s = buffer[offset + i]

		  i += d

		  e = s & ((1 << (-nBits)) - 1)
		  s >>= (-nBits)
		  nBits += eLen
		  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

		  m = e & ((1 << (-nBits)) - 1)
		  e >>= (-nBits)
		  nBits += mLen
		  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

		  if (e === 0) {
		    e = 1 - eBias
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen)
		    e = e - eBias
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		}

		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
		  var i = isLE ? 0 : (nBytes - 1)
		  var d = isLE ? 1 : -1
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

		  value = Math.abs(value)

		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0
		    e = eMax
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2)
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--
		      c *= 2
		    }
		    if (e + eBias >= 1) {
		      value += rt / c
		    } else {
		      value += rt * Math.pow(2, 1 - eBias)
		    }
		    if (value * c >= 2) {
		      e++
		      c /= 2
		    }

		    if (e + eBias >= eMax) {
		      m = 0
		      e = eMax
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen)
		      e = e + eBias
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
		      e = 0
		    }
		  }

		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

		  e = (e << mLen) | m
		  eLen += mLen
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

		  buffer[offset + i - d] |= s * 128
		}


	/***/ },
	/* 59 */
	/***/ function(module, exports) {

		var toString = {}.toString;

		module.exports = Array.isArray || function (arr) {
		  return toString.call(arr) == '[object Array]';
		};


	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.replaceTemplate = exports.processTemplate = undefined;

		var _immutable = __webpack_require__(9);

		var _ramdaFantasy = __webpack_require__(13);

		var _ramda = __webpack_require__(25);

		var _ramda2 = _interopRequireDefault(_ramda);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _errors = __webpack_require__(11);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const isDolar_903 = s_914 => s_914 && s_914 instanceof _syntax2.default && s_914.match("identifier") && s_914.val() === "$";
		const isDelimiter_904 = s_915 => s_915 && typeof s_915.match === "function" && s_915.match("delimiter");
		const isBraces_905 = s_916 => s_916 && typeof s_916.match === "function" && s_916.match("braces");
		const isParens_906 = s_917 => s_917 && typeof s_917.match === "function" && s_917.match("parens");
		const isBrackets_907 = s_918 => s_918 && typeof s_918.match === "function" && s_918.match("brackets");
		const insertIntoDelimiter_908 = _ramda2.default.cond([[isBraces_905, (s_919, r_920) => _syntax2.default.from("braces", r_920, s_919)], [isParens_906, (s_921, r_922) => _syntax2.default.from("parens", r_922, s_921)], [isBrackets_907, (s_923, r_924) => _syntax2.default.from("brackets", r_924, s_923)]]);
		const process_909 = (acc_925, s_926) => {
		  if (isBraces_905(s_926) && isDolar_903(acc_925.template.last())) {
		    return { template: acc_925.template.push(_syntax2.default.from("braces", _immutable.List.of(_syntax2.default.from("number", acc_925.interp.size)), s_926)), interp: acc_925.interp.push(s_926.inner()) };
		  } else if (isDelimiter_904(s_926)) {
		    let innerResult = processTemplate_912(s_926.inner(), acc_925.interp);
		    return { template: acc_925.template.push(insertIntoDelimiter_908(s_926, innerResult.template)), interp: innerResult.interp };
		  } else {
		    return { template: acc_925.template.push(s_926), interp: acc_925.interp };
		  }
		};
		function cloneLineNumber_910(to_927, from_928) {
		  if (from_928 && to_927 && typeof to_927.setLineNumber === "function") {
		    return to_927.setLineNumber(from_928.lineNumber());
		  }
		  return to_927;
		}
		const replace_911 = (acc_929, s_930) => {
		  let last_931 = acc_929.template.get(-1);
		  let beforeLast_932 = acc_929.template.get(-2);
		  if (isBraces_905(s_930) && isDolar_903(last_931)) {
		    let index = s_930.inner().first().val();
		    (0, _errors.assert)(acc_929.rep.size > index, "unknown replacement value");
		    let replacement = cloneLineNumber_910(acc_929.rep.get(index), beforeLast_932);
		    return { template: acc_929.template.pop().concat(replacement), rep: acc_929.rep };
		  } else if (isDelimiter_904(s_930)) {
		    let innerResult = replaceTemplate_913(s_930.inner(), acc_929.rep);
		    return { template: acc_929.template.push(insertIntoDelimiter_908(s_930, innerResult)), rep: acc_929.rep };
		  } else {
		    return { template: acc_929.template.push(s_930), rep: acc_929.rep };
		  }
		};
		function processTemplate_912(temp_933) {
		  let interp_934 = arguments.length <= 1 || arguments[1] === undefined ? (0, _immutable.List)() : arguments[1];

		  return temp_933.reduce(process_909, { template: (0, _immutable.List)(), interp: interp_934 });
		}
		function replaceTemplate_913(temp_935, rep_936) {
		  return temp_935.reduce(replace_911, { template: (0, _immutable.List)(), rep: rep_936 }).template;
		}
		exports.processTemplate = processTemplate_912;
		exports.replaceTemplate = replaceTemplate_913;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L3RlbXBsYXRlLXByb2Nlc3Nvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0EsTUFBTSxjQUFjLFNBQVMsU0FBUyxpQ0FBVCxJQUFvQyxNQUFNLEtBQU4sQ0FBWSxZQUFaLENBQXBDLElBQWlFLE1BQU0sR0FBTixPQUFnQixHQUE5RztBQUNBLE1BQU0sa0JBQWtCLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxXQUFaLENBQS9FO0FBQ0EsTUFBTSxlQUFlLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxRQUFaLENBQTVFO0FBQ0EsTUFBTSxlQUFlLFNBQVMsU0FBUyxPQUFPLE1BQU0sS0FBYixLQUF1QixVQUFoQyxJQUE4QyxNQUFNLEtBQU4sQ0FBWSxRQUFaLENBQTVFO0FBQ0EsTUFBTSxpQkFBaUIsU0FBUyxTQUFTLE9BQU8sTUFBTSxLQUFiLEtBQXVCLFVBQWhDLElBQThDLE1BQU0sS0FBTixDQUFZLFVBQVosQ0FBOUU7QUFDQSxNQUFNLDBCQUEwQixnQkFBRSxJQUFGLENBQU8sQ0FBQyxDQUFDLFlBQUQsRUFBZSxDQUFDLEtBQUQsRUFBUSxLQUFSLEtBQWtCLGlCQUFPLElBQVAsQ0FBWSxRQUFaLEVBQXNCLEtBQXRCLEVBQTZCLEtBQTdCLENBQWpDLENBQUQsRUFBd0UsQ0FBQyxZQUFELEVBQWUsQ0FBQyxLQUFELEVBQVEsS0FBUixLQUFrQixpQkFBTyxJQUFQLENBQVksUUFBWixFQUFzQixLQUF0QixFQUE2QixLQUE3QixDQUFqQyxDQUF4RSxFQUErSSxDQUFDLGNBQUQsRUFBaUIsQ0FBQyxLQUFELEVBQVEsS0FBUixLQUFrQixpQkFBTyxJQUFQLENBQVksVUFBWixFQUF3QixLQUF4QixFQUErQixLQUEvQixDQUFuQyxDQUEvSSxD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aEIsRUFBNkIsRUFBQyxVQUFVLHNCQUFYLEVBQW1CLFFBQVEsVUFBM0IsRUFBN0IsQ0FBUDtBQUNEO0FBQ0QsU0FBUyxtQkFBVCxDQUE2QixRQUE3QixFQUF1QyxPQUF2QyxFQUFnRDtBQUM5QyxTQUFPLFNBQVMsTUFBVCxDQUFnQixXQUFoQixFQUE2QixFQUFDLFVBQVUsc0JBQVgsRUFBbUIsS0FBSyxPQUF4QixFQUE3QixFQUErRCxRQUF0RTtBQUNEO1FBQzhCLGUsR0FBdkIsbUI7UUFDdUIsZSxHQUF2QixtQiIsImZpbGUiOiJ0ZW1wbGF0ZS1wcm9jZXNzb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCB7TWF5YmV9IGZyb20gXCJyYW1kYS1mYW50YXN5XCI7XG5pbXBvcnQgXyBmcm9tIFwicmFtZGFcIjtcbmltcG9ydCBTeW50YXggZnJvbSBcIi4vc3ludGF4XCI7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5jb25zdCBpc0RvbGFyXzkwMyA9IHNfOTE0ID0+IHNfOTE0ICYmIHNfOTE0IGluc3RhbmNlb2YgU3ludGF4ICYmIHNfOTE0Lm1hdGNoKFwiaWRlbnRpZmllclwiKSAmJiBzXzkxNC52YWwoKSA9PT0gXCIkXCI7XG5jb25zdCBpc0RlbGltaXRlcl85MDQgPSBzXzkxNSA9PiBzXzkxNSAmJiB0eXBlb2Ygc185MTUubWF0Y2ggPT09IFwiZnVuY3Rpb25cIiAmJiBzXzkxNS5tYXRjaChcImRlbGltaXRlclwiKTtcbmNvbnN0IGlzQnJhY2VzXzkwNSA9IHNfOTE2ID0+IHNfOTE2ICYmIHR5cGVvZiBzXzkxNi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIHNfOTE2Lm1hdGNoKFwiYnJhY2VzXCIpO1xuY29uc3QgaXNQYXJlbnNfOTA2ID0gc185MTcgPT4gc185MTcgJiYgdHlwZW9mIHNfOTE3Lm1hdGNoID09PSBcImZ1bmN0aW9uXCIgJiYgc185MTcubWF0Y2goXCJwYXJlbnNcIik7XG5jb25zdCBpc0JyYWNrZXRzXzkwNyA9IHNfOTE4ID0+IHNfOTE4ICYmIHR5cGVvZiBzXzkxOC5tYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIHNfOTE4Lm1hdGNoKFwiYnJhY2tldHNcIik7XG5jb25zdCBpbnNlcnRJbnRvRGVsaW1pdGVyXzkwOCA9IF8uY29uZChbW2lzQnJhY2VzXzkwNSwgKHNfOTE5LCByXzkyMCkgPT4gU3ludGF4LmZyb20oXCJicmFjZXNcIiwgcl85MjAsIHNfOTE5KV0sIFtpc1BhcmVuc185MDYsIChzXzkyMSwgcl85MjIpID0+IFN5bnRheC5mcm9tKFwicGFyZW5zXCIsIHJfOTIyLCBzXzkyMSldLCBbaXNCcmFja2V0c185MDcsIChzXzkyMywgcl85MjQpID0+IFN5bnRheC5mcm9tKFwiYnJhY2tldHNcIiwgcl85MjQsIHNfOTIzKV1dKTtcbmNvbnN0IHByb2Nlc3NfOTA5ID0gKGFjY185MjUsIHNfOTI2KSA9PiB7XG4gIGlmIChpc0JyYWNlc185MDUoc185MjYpICYmIGlzRG9sYXJfOTAzKGFjY185MjUudGVtcGxhdGUubGFzdCgpKSkge1xuICAgIHJldHVybiB7dGVtcGxhdGU6IGFjY185MjUudGVtcGxhdGUucHVzaChTeW50YXguZnJvbShcImJyYWNlc1wiLCBMaXN0Lm9mKFN5bnRheC5mcm9tKFwibnVtYmVyXCIsIGFjY185MjUuaW50ZXJwLnNpemUpKSwgc185MjYpKSwgaW50ZXJwOiBhY2NfOTI1LmludGVycC5wdXNoKHNfOTI2LmlubmVyKCkpfTtcbiAgfSBlbHNlIGlmIChpc0RlbGltaXRlcl85MDQoc185MjYpKSB7XG4gICAgbGV0IGlubmVyUmVzdWx0ID0gcHJvY2Vzc1RlbXBsYXRlXzkxMihzXzkyNi5pbm5lcigpLCBhY2NfOTI1LmludGVycCk7XG4gICAgcmV0dXJuIHt0ZW1wbGF0ZTogYWNjXzkyNS50ZW1wbGF0ZS5wdXNoKGluc2VydEludG9EZWxpbWl0ZXJfOTA4KHNfOTI2LCBpbm5lclJlc3VsdC50ZW1wbGF0ZSkpLCBpbnRlcnA6IGlubmVyUmVzdWx0LmludGVycH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt0ZW1wbGF0ZTogYWNjXzkyNS50ZW1wbGF0ZS5wdXNoKHNfOTI2KSwgaW50ZXJwOiBhY2NfOTI1LmludGVycH07XG4gIH1cbn07XG5mdW5jdGlvbiBjbG9uZUxpbmVOdW1iZXJfOTEwKHRvXzkyNywgZnJvbV85MjgpIHtcbiAgaWYgKGZyb21fOTI4ICYmIHRvXzkyNyAmJiB0eXBlb2YgdG9fOTI3LnNldExpbmVOdW1iZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0b185Mjcuc2V0TGluZU51bWJlcihmcm9tXzkyOC5saW5lTnVtYmVyKCkpO1xuICB9XG4gIHJldHVybiB0b185Mjc7XG59XG5jb25zdCByZXBsYWNlXzkxMSA9IChhY2NfOTI5LCBzXzkzMCkgPT4ge1xuICBsZXQgbGFzdF85MzEgPSBhY2NfOTI5LnRlbXBsYXRlLmdldCgtMSk7XG4gIGxldCBiZWZvcmVMYXN0XzkzMiA9IGFjY185MjkudGVtcGxhdGUuZ2V0KC0yKTtcbiAgaWYgKGlzQnJhY2VzXzkwNShzXzkzMCkgJiYgaXNEb2xhcl85MDMobGFzdF85MzEpKSB7XG4gICAgbGV0IGluZGV4ID0gc185MzAuaW5uZXIoKS5maXJzdCgpLnZhbCgpO1xuICAgIGFzc2VydChhY2NfOTI5LnJlcC5zaXplID4gaW5kZXgsIFwidW5rbm93biByZXBsYWNlbWVudCB2YWx1ZVwiKTtcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSBjbG9uZUxpbmVOdW1iZXJfOTEwKGFjY185MjkucmVwLmdldChpbmRleCksIGJlZm9yZUxhc3RfOTMyKTtcbiAgICByZXR1cm4ge3RlbXBsYXRlOiBhY2NfOTI5LnRlbXBsYXRlLnBvcCgpLmNvbmNhdChyZXBsYWNlbWVudCksIHJlcDogYWNjXzkyOS5yZXB9O1xuICB9IGVsc2UgaWYgKGlzRGVsaW1pdGVyXzkwNChzXzkzMCkpIHtcbiAgICBsZXQgaW5uZXJSZXN1bHQgPSByZXBsYWNlVGVtcGxhdGVfOTEzKHNfOTMwLmlubmVyKCksIGFjY185MjkucmVwKTtcbiAgICByZXR1cm4ge3RlbXBsYXRlOiBhY2NfOTI5LnRlbXBsYXRlLnB1c2goaW5zZXJ0SW50b0RlbGltaXRlcl85MDgoc185MzAsIGlubmVyUmVzdWx0KSksIHJlcDogYWNjXzkyOS5yZXB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7dGVtcGxhdGU6IGFjY185MjkudGVtcGxhdGUucHVzaChzXzkzMCksIHJlcDogYWNjXzkyOS5yZXB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlXzkxMih0ZW1wXzkzMywgaW50ZXJwXzkzNCA9IExpc3QoKSkge1xuICByZXR1cm4gdGVtcF85MzMucmVkdWNlKHByb2Nlc3NfOTA5LCB7dGVtcGxhdGU6IExpc3QoKSwgaW50ZXJwOiBpbnRlcnBfOTM0fSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGVfOTEzKHRlbXBfOTM1LCByZXBfOTM2KSB7XG4gIHJldHVybiB0ZW1wXzkzNS5yZWR1Y2UocmVwbGFjZV85MTEsIHt0ZW1wbGF0ZTogTGlzdCgpLCByZXA6IHJlcF85MzZ9KS50ZW1wbGF0ZTtcbn1cbmV4cG9ydCB7cHJvY2Vzc1RlbXBsYXRlXzkxMiBhcyBwcm9jZXNzVGVtcGxhdGV9O1xuZXhwb3J0IHtyZXBsYWNlVGVtcGxhdGVfOTEzIGFzIHJlcGxhY2VUZW1wbGF0ZX0iXX0=

	/***/ },
	/* 61 */
	/***/ function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		class ASTDispatcher {
		  constructor(prefix_16, errorIfMissing_17) {
		    this.errorIfMissing = errorIfMissing_17;
		    this.prefix = prefix_16;
		  }
		  dispatch(term_18) {
		    let field_19 = this.prefix + term_18.type;
		    if (typeof this[field_19] === "function") {
		      return this[field_19](term_18);
		    } else if (!this.errorIfMissing) {
		      return term_18;
		    }
		    throw new Error(`Missing implementation for: ${ field_19 }`);
		  }
		}
		exports.default = ASTDispatcher;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2FzdC1kaXNwYXRjaGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWUsTUFBTSxhQUFOLENBQW9CO0FBQ2pDLGNBQVksU0FBWixFQUF1QixpQkFBdkIsRUFBMEM7QUFDeEMsU0FBSyxjQUFMLEdBQXNCLGlCQUF0QjtBQUNBLFNBQUssTUFBTCxHQUFjLFNBQWQ7QUFDRDtBQUNELFdBQVMsT0FBVCxFQUFrQjtBQUNoQixRQUFJLFdBQVcsS0FBSyxNQUFMLEdBQWMsUUFBUSxJQUFyQztBQUNBLFFBQUksT0FBTyxLQUFLLFFBQUwsQ0FBUCxLQUEwQixVQUE5QixFQUEwQztBQUN4QyxhQUFPLEtBQUssUUFBTCxFQUFlLE9BQWYsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsS0FBSyxjQUFWLEVBQTBCO0FBQy9CLGFBQU8sT0FBUDtBQUNEO0FBQ0QsVUFBTSxJQUFJLEtBQUosQ0FBVSxDQUFDLDRCQUFELEdBQStCLFFBQS9CLEVBQXdDLEFBQXhDLENBQVYsQ0FBTjtBQUNEO0FBYmdDO2tCQUFkLGEiLCJmaWxlIjoiYXN0LWRpc3BhdGNoZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBBU1REaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IocHJlZml4XzE2LCBlcnJvcklmTWlzc2luZ18xNykge1xuICAgIHRoaXMuZXJyb3JJZk1pc3NpbmcgPSBlcnJvcklmTWlzc2luZ18xNztcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeF8xNjtcbiAgfVxuICBkaXNwYXRjaCh0ZXJtXzE4KSB7XG4gICAgbGV0IGZpZWxkXzE5ID0gdGhpcy5wcmVmaXggKyB0ZXJtXzE4LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXzE5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpc1tmaWVsZF8xOV0odGVybV8xOCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5lcnJvcklmTWlzc2luZykge1xuICAgICAgcmV0dXJuIHRlcm1fMTg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBpbXBsZW1lbnRhdGlvbiBmb3I6ICR7ZmllbGRfMTl9YCk7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.unwrap = exports.SyntaxOrTermWrapper = undefined;

		var _mapSyntaxReducer = __webpack_require__(63);

		var _mapSyntaxReducer2 = _interopRequireDefault(_mapSyntaxReducer);

		var _shiftReducer = __webpack_require__(30);

		var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

		var _immutable = __webpack_require__(9);

		var _enforester = __webpack_require__(48);

		var _syntax = __webpack_require__(10);

		var _syntax2 = _interopRequireDefault(_syntax);

		var _ramdaFantasy = __webpack_require__(13);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const Just_375 = _ramdaFantasy.Maybe.Just;
		const Nothing_376 = _ramdaFantasy.Maybe.Nothing;
		const symWrap_377 = Symbol("wrapper");
		const symName_378 = Symbol("name");
		const getLineNumber_379 = t_383 => {
		  if (t_383 instanceof _syntax2.default) {
		    return t_383.lineNumber();
		  }
		  throw new Error("Line numbers on terms not implemented yet");
		};
		const getVal_380 = t_384 => {
		  if (t_384.match("delimiter")) {
		    return null;
		  }
		  if (t_384 instanceof _syntax2.default) {
		    return t_384.val();
		  }
		  return null;
		};
		class SyntaxOrTermWrapper_381 {
		  constructor(s_385) {
		    let context_386 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    this[symWrap_377] = s_385;
		    this.context = context_386;
		  }
		  match(type_387, value_388) {
		    let stx_389 = this[symWrap_377];
		    if (stx_389 instanceof _syntax2.default) {
		      return stx_389.match(type_387, value_388);
		    }
		  }
		  isIdentifier(value_390) {
		    return this.match("identifier", value_390);
		  }
		  isAssign(value_391) {
		    return this.match("assign", value_391);
		  }
		  isBooleanLiteral(value_392) {
		    return this.match("boolean", value_392);
		  }
		  isKeyword(value_393) {
		    return this.match("keyword", value_393);
		  }
		  isNullLiteral(value_394) {
		    return this.match("null", value_394);
		  }
		  isNumericLiteral(value_395) {
		    return this.match("number", value_395);
		  }
		  isPunctuator(value_396) {
		    return this.match("punctuator", value_396);
		  }
		  isStringLiteral(value_397) {
		    return this.match("string", value_397);
		  }
		  isRegularExpression(value_398) {
		    return this.match("regularExpression", value_398);
		  }
		  isTemplate(value_399) {
		    return this.match("template", value_399);
		  }
		  isDelimiter(value_400) {
		    return this.match("delimiter", value_400);
		  }
		  isParens(value_401) {
		    return this.match("parens", value_401);
		  }
		  isBraces(value_402) {
		    return this.match("braces", value_402);
		  }
		  isBrackets(value_403) {
		    return this.match("brackets", value_403);
		  }
		  isSyntaxTemplate(value_404) {
		    return this.match("syntaxTemplate", value_404);
		  }
		  isEOF(value_405) {
		    return this.match("eof", value_405);
		  }
		  lineNumber() {
		    return getLineNumber_379(this[symWrap_377]);
		  }
		  val() {
		    return getVal_380(this[symWrap_377]);
		  }
		  inner() {
		    let stx_406 = this[symWrap_377];
		    if (!stx_406.match("delimiter")) {
		      throw new Error("Can only get inner syntax on a delimiter");
		    }
		    let enf_407 = new _enforester.Enforester(stx_406.inner(), (0, _immutable.List)(), this.context);
		    return new MacroContext(enf_407, "inner", this.context);
		  }
		}
		function unwrap_382(x_408) {
		  if (x_408 instanceof SyntaxOrTermWrapper_381) {
		    return x_408[symWrap_377];
		  }
		  return x_408;
		}
		class MacroContext {
		  constructor(enf_409, name_410, context_411, useScope_412, introducedScope_413) {
		    this._enf = enf_409;
		    this[symName_378] = name_410;
		    this.context = context_411;
		    if (useScope_412 && introducedScope_413) {
		      this.noScopes = false;
		      this.useScope = useScope_412;
		      this.introducedScope = introducedScope_413;
		    } else {
		      this.noScopes = true;
		    }
		    this[Symbol.iterator] = () => this;
		  }
		  name() {
		    return new SyntaxOrTermWrapper_381(this[symName_378], this.context);
		  }
		  next() {
		    let type_414 = arguments.length <= 0 || arguments[0] === undefined ? "Syntax" : arguments[0];

		    if (this._enf.rest.size === 0) {
		      return { done: true, value: null };
		    }
		    let value_415;
		    switch (type_414) {
		      case "AssignmentExpression":
		      case "expr":
		        value_415 = this._enf.enforestExpressionLoop();
		        break;
		      case "Expression":
		        value_415 = this._enf.enforestExpression();
		        break;
		      case "Syntax":
		        value_415 = this._enf.advance();
		        if (!this.noScopes) {
		          value_415 = value_415.addScope(this.useScope, this.context.bindings, _syntax.ALL_PHASES).addScope(this.introducedScope, this.context.bindings, _syntax.ALL_PHASES, { flip: true });
		        }
		        break;
		      default:
		        throw new Error("Unknown term type: " + type_414);
		    }
		    return { done: false, value: new SyntaxOrTermWrapper_381(value_415, this.context) };
		  }
		}
		exports.default = MacroContext;
		exports.SyntaxOrTermWrapper = SyntaxOrTermWrapper_381;
		exports.unwrap = unwrap_382;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L21hY3JvLWNvbnRleHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztJQUFhLEM7Ozs7OztBQUNiLE1BQU0sV0FBVyxvQkFBTSxJQUF2QjtBQUNBLE1BQU0sY0FBYyxvQkFBTSxPQUExQjtBQUNBLE1BQU0sY0FBYyxPQUFPLFNBQVAsQ0FBcEI7QUFDQSxNQUFNLGNBQWMsT0FBTyxNQUFQLENBQXBCO0FBQ0EsTUFBTSxvQkFBb0IsU0FBUztBQUNqQyxNQUFJLGlDQUFKLEVBQTZCO0FBQzNCLFdBQU8sTUFBTSxVQUFOLEVBQVA7QUFDRDtBQUNELFFBQU0sSUFBSSxLQUFKLENBQVUsMkNBQVYsQ0FBTjtBQUNELENBTEQ7QUFNQSxNQUFNLGFBQWEsU0FBUztBQUMxQixNQUFJLE1BQU0sS0FBTixDQUFZLFdBQVosQ0FBSixFQUE4QjtBQUM1QixXQUFPLElBQVA7QUFDRDtBQUNELE1BQUksaUNBQUosRUFBNkI7QUFDM0IsV0FBTyxNQUFNLEdBQU4sRUFBUDtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQ0FSRDtBQVNBLE1BQU0sdUJBQU4sQ0FBOEI7QUFDNUIsY0FBWSxLQUFaLEVBQXFDO0FBQUEsUUFBbEIsV0FBa0IseURBQUosRUFBSTs7QUFDbkMsU0FBSyxXQUFMLElBQW9CLEtBQXBCO0FBQ0EsU0FBSyxPQUFMLEdBQWUsV0FBZjtBQUNEO0FBQ0QsUUFBTSxRQUFOLEVBQWdCLFNBQWhCLEVBQTJCO0FBQ3pCLFFBQUksVUFBVSxLQUFLLFdBQUwsQ0FBZDtBQUNBLFFBQUksbUNBQUosRUFBK0I7QUFDN0IsYUFBTyxRQUFRLEtBQVIsQ0FBYyxRQUFkLEVBQXdCLFNBQXhCLENBQVA7QUFDRDtBQUNGO0FBQ0QsZUFBYSxTQUFiLEVBQXdCO0FBQ3RCLFdBQU8sS0FBSyxLQUFMLENBQVcsWUFBWCxFQUF5QixTQUF6QixDQUFQO0FBQ0Q7QUFDRCxXQUFTLFNBQVQsRUFBb0I7QUFDbEIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLFNBQXJCLENBQVA7QUFDRDtBQUNELG1CQUFpQixTQUFqQixFQUE0QjtBQUMxQixXQUFPLEtBQUssS0FBTCxDQUFXLFNBQVgsRUFBc0IsU0FBdEIsQ0FBUDtBQUNEO0FBQ0QsWUFBVSxTQUFWLEVBQXFCO0FBQ25CLFdBQU8sS0FBSyxLQUFMLENBQVcsU0FBWCxFQUFzQixTQUF0QixDQUFQO0FBQ0Q7QUFDRCxnQkFBYyxTQUFkLEVBQXlCO0FBQ3ZCLFdBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxFQUFtQixTQUFuQixDQUFQO0FBQ0Q7QUFDRCxtQkFBaUIsU0FBakIsRUFBNEI7QUFDMUIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLFNBQXJCLENBQVA7QUFDRDtBQUNELGVBQWEsU0FBYixFQUF3QjtBQUN0QixXQUFPLEtBQUssS0FBTCxDQUFXLFlBQVgsRUFBeUIsU0FBekIsQ0FBUDtBQUNEO0FBQ0Qsa0JBQWdCLFNBQWhCLEVBQTJCO0FBQ3pCLFdBQU8sS0FBSyxLQUFMLENBQVcsUUFBWCxFQUFxQixTQUFyQixDQUFQO0FBQ0Q7QUFDRCxzQkFBb0IsU0FBcEIsRUFBK0I7QUFDN0IsV0FBTyxLQUFLLEtBQUwsQ0FBVyxtQkFBWCxFQUFnQyxTQUFoQyxDQUFQO0FBQ0Q7QUFDRCxhQUFXLFNBQVgsRUFBc0I7QUFDcEIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxVQUFYLEVBQXVCLFNBQXZCLENBQVA7QUFDRDtBQUNELGNBQVksU0FBWixFQUF1QjtBQUNyQixXQUFPLEtBQUssS0FBTCxDQUFXLFdBQVgsRUFBd0IsU0FBeEIsQ0FBUDtBQUNEO0FBQ0QsV0FBUyxTQUFULEVBQW9CO0FBQ2xCLFdBQU8sS0FBSyxLQUFMLENBQVcsUUFBWCxFQUFxQixTQUFyQixDQUFQO0FBQ0Q7QUFDRCxXQUFTLFNBQVQsRUFBb0I7QUFDbEIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLFNBQXJCLENBQVA7QUFDRDtBQUNELGFBQVcsU0FBWCxFQUFzQjtBQUNwQixXQUFPLEtBQUssS0FBTCxDQUFXLFVBQVgsRUFBdUIsU0FBdkIsQ0FBUDtBQUNEO0FBQ0QsbUJBQWlCLFNBQWpCLEVBQTRCO0FBQzFCLFdBQU8sS0FBSyxLQUFMLENBQVcsZ0JBQVgsRUFBNkIsU0FBN0IsQ0FBUDtBQUNEO0FBQ0QsUUFBTSxTQUFOLEVBQWlCO0FBQ2YsV0FBTyxLQUFLLEtBQUwsQ0FBVyxLQUFYLEVBQWtCLFNBQWxCLENBQVA7QUFDRDtBQUNELGVBQWE7QUFDWCxXQUFPLGtCQUFrQixLQUFLLFdBQUwsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsUUFBTTtBQUNKLFdBQU8sV0FBVyxLQUFLLFdBQUwsQ0FBWCxDQUFQO0FBQ0Q7QUFDRCxVQUFRO0FBQ04sUUFBSSxVQUFVLEtBQUssV0FBTCxDQUFkO0FBQ0EsUUFBSSxDQUFDLFFBQVEsS0FBUixDQUFjLFdBQWQsQ0FBTCxFQUFpQztBQUMvQixZQUFNLElBQUksS0FBSixDQUFVLDBDQUFWLENBQU47QUFDRDtBQUNELFFBQUksVUFBVSwyQkFBZSxRQUFRLEtBQVIsRUFBZixFQUFnQyxzQkFBaEMsRUFBd0MsS0FBSyxPQUE3QyxDQUFkO0FBQ0EsV0FBTyxJQUFJLFlBQUosQ0FBaUIsT0FBakIsRUFBMEIsT0FBMUIsRUFBbUMsS0FBSyxPQUF4QyxDQUFQO0FBQ0Q7QUF4RTJCO0FBMEU5QixTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMkI7QUFDekIsTUFBSSxpQkFBaUIsdUJBQXJCLEVBQThDO0FBQzVDLFdBQU8sTUFBTSxXQUFOLENBQVA7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNEO0FBQ2MsTUFBTSxZQUFOLENBQW1CO0FBQ2hDLGNBQVksT0FBWixFQUFxQixRQUFyQixFQUErQixXQUEvQixFQUE0QyxZQUE1QyxFQUEwRCxtQkFBMUQsRUFBK0U7QUFDN0UsU0FBSyxJQUFMLEdBQVksT0FBWjtBQUNBLFNBQUssV0FBTCxJQUFvQixRQUFwQjtBQUNBLFNBQUssT0FBTCxHQUFlLFdBQWY7QUFDQSxRQUFJLGdCQUFnQixtQkFBcEIsRUFBeUM7QUFDdkMsV0FBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsV0FBSyxRQUFMLEdBQWdCLFlBQWhCO0FBQ0EsV0FBSyxlQUFMLEdBQXVCLG1CQUF2QjtBQUNELEtBSkQsTUFJTztBQUNMLFdBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNEO0FBQ0QsU0FBSyxPQUFPLFFBQVosSUFBd0IsTUFBTSxJQUE5QjtBQUNEO0FBQ0QsU0FBTztBQUNMLFdBQU8sSUFBSSx1QkFBSixDQUE0QixLQUFLLFdBQUwsQ0FBNUIsRUFBK0MsS0FBSyxPQUFwRCxDQUFQO0FBQ0Q7QUFDRCxTQUEwQjtBQUFBLFFBQXJCLFFBQXFCLHlEQUFWLFFBQVU7O0FBQ3hCLFFBQUksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLElBQWYsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0IsYUFBTyxFQUFDLE1BQU0sSUFBUCxFQUFhLE9BQU8sSUFBcEIsRUFBUDtBQUNEO0FBQ0QsUUFBSSxTQUFKO0FBQ0EsWUFBUSxRQUFSO0FBQ0UsV0FBSyxzQkFBTDtBQUNBLFdBQUssTUFBTDtBQUNFLG9CQUFZLEtBQUssSUFBTCxDQUFVLHNCQUFWLEVBQVo7QUFDQTtBQUNGLFdBQUssWUFBTDtBQUNFLG9CQUFZLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQVo7QUFDQTtBQUNGLFdBQUssUUFBTDtBQUNFLG9CQUFZLEtBQUssSUFBTCxDQUFVLE9BQVYsRUFBWjtBQUNBLFlBQUksQ0FBQyxLQUFLLFFBQVYsRUFBb0I7QUFDbEIsc0JBQVksVUFBVSxRQUFWLENBQW1CLEtBQUssUUFBeEIsRUFBa0MsS0FBSyxPQUFMLENBQWEsUUFBL0Msc0JBQXFFLFFBQXJFLENBQThFLEtBQUssZUFBbkYsRUFBb0csS0FBSyxPQUFMLENBQWEsUUFBakgsc0JBQXVJLEVBQUMsTUFBTSxJQUFQLEVBQXZJLENBQVo7QUFDRDtBQUNEO0FBQ0Y7QUFDRSxjQUFNLElBQUksS0FBSixDQUFVLHdCQUF3QixRQUFsQyxDQUFOO0FBZko7QUFpQkEsV0FBTyxFQUFDLE1BQU0sS0FBUCxFQUFjLE9BQU8sSUFBSSx1QkFBSixDQUE0QixTQUE1QixFQUF1QyxLQUFLLE9BQTVDLENBQXJCLEVBQVA7QUFDRDtBQXhDK0I7a0JBQWIsWTtRQTBDYyxtQixHQUEzQix1QjtRQUNjLE0sR0FBZCxVIiwiZmlsZSI6Im1hY3JvLWNvbnRleHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFwU3ludGF4UmVkdWNlciBmcm9tIFwiLi9tYXAtc3ludGF4LXJlZHVjZXJcIjtcbmltcG9ydCByZWR1Y2VyIGZyb20gXCJzaGlmdC1yZWR1Y2VyXCI7XG5pbXBvcnQge0xpc3R9IGZyb20gXCJpbW11dGFibGVcIjtcbmltcG9ydCB7RW5mb3Jlc3Rlcn0gZnJvbSBcIi4vZW5mb3Jlc3RlclwiO1xuaW1wb3J0IFN5bnRheCwge0FMTF9QSEFTRVN9IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0IHtNYXliZX0gZnJvbSBcInJhbWRhLWZhbnRhc3lcIjtcbmltcG9ydCAgKiBhcyBfIGZyb20gXCJyYW1kYVwiO1xuY29uc3QgSnVzdF8zNzUgPSBNYXliZS5KdXN0O1xuY29uc3QgTm90aGluZ18zNzYgPSBNYXliZS5Ob3RoaW5nO1xuY29uc3Qgc3ltV3JhcF8zNzcgPSBTeW1ib2woXCJ3cmFwcGVyXCIpO1xuY29uc3Qgc3ltTmFtZV8zNzggPSBTeW1ib2woXCJuYW1lXCIpO1xuY29uc3QgZ2V0TGluZU51bWJlcl8zNzkgPSB0XzM4MyA9PiB7XG4gIGlmICh0XzM4MyBpbnN0YW5jZW9mIFN5bnRheCkge1xuICAgIHJldHVybiB0XzM4My5saW5lTnVtYmVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTGluZSBudW1iZXJzIG9uIHRlcm1zIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG59O1xuY29uc3QgZ2V0VmFsXzM4MCA9IHRfMzg0ID0+IHtcbiAgaWYgKHRfMzg0Lm1hdGNoKFwiZGVsaW1pdGVyXCIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRfMzg0IGluc3RhbmNlb2YgU3ludGF4KSB7XG4gICAgcmV0dXJuIHRfMzg0LnZhbCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNsYXNzIFN5bnRheE9yVGVybVdyYXBwZXJfMzgxIHtcbiAgY29uc3RydWN0b3Ioc18zODUsIGNvbnRleHRfMzg2ID0ge30pIHtcbiAgICB0aGlzW3N5bVdyYXBfMzc3XSA9IHNfMzg1O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRfMzg2O1xuICB9XG4gIG1hdGNoKHR5cGVfMzg3LCB2YWx1ZV8zODgpIHtcbiAgICBsZXQgc3R4XzM4OSA9IHRoaXNbc3ltV3JhcF8zNzddO1xuICAgIGlmIChzdHhfMzg5IGluc3RhbmNlb2YgU3ludGF4KSB7XG4gICAgICByZXR1cm4gc3R4XzM4OS5tYXRjaCh0eXBlXzM4NywgdmFsdWVfMzg4KTtcbiAgICB9XG4gIH1cbiAgaXNJZGVudGlmaWVyKHZhbHVlXzM5MCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiaWRlbnRpZmllclwiLCB2YWx1ZV8zOTApO1xuICB9XG4gIGlzQXNzaWduKHZhbHVlXzM5MSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiYXNzaWduXCIsIHZhbHVlXzM5MSk7XG4gIH1cbiAgaXNCb29sZWFuTGl0ZXJhbCh2YWx1ZV8zOTIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJvb2xlYW5cIiwgdmFsdWVfMzkyKTtcbiAgfVxuICBpc0tleXdvcmQodmFsdWVfMzkzKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJrZXl3b3JkXCIsIHZhbHVlXzM5Myk7XG4gIH1cbiAgaXNOdWxsTGl0ZXJhbCh2YWx1ZV8zOTQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcIm51bGxcIiwgdmFsdWVfMzk0KTtcbiAgfVxuICBpc051bWVyaWNMaXRlcmFsKHZhbHVlXzM5NSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwibnVtYmVyXCIsIHZhbHVlXzM5NSk7XG4gIH1cbiAgaXNQdW5jdHVhdG9yKHZhbHVlXzM5Nikge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwicHVuY3R1YXRvclwiLCB2YWx1ZV8zOTYpO1xuICB9XG4gIGlzU3RyaW5nTGl0ZXJhbCh2YWx1ZV8zOTcpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcInN0cmluZ1wiLCB2YWx1ZV8zOTcpO1xuICB9XG4gIGlzUmVndWxhckV4cHJlc3Npb24odmFsdWVfMzk4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJyZWd1bGFyRXhwcmVzc2lvblwiLCB2YWx1ZV8zOTgpO1xuICB9XG4gIGlzVGVtcGxhdGUodmFsdWVfMzk5KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJ0ZW1wbGF0ZVwiLCB2YWx1ZV8zOTkpO1xuICB9XG4gIGlzRGVsaW1pdGVyKHZhbHVlXzQwMCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZGVsaW1pdGVyXCIsIHZhbHVlXzQwMCk7XG4gIH1cbiAgaXNQYXJlbnModmFsdWVfNDAxKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJwYXJlbnNcIiwgdmFsdWVfNDAxKTtcbiAgfVxuICBpc0JyYWNlcyh2YWx1ZV80MDIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaChcImJyYWNlc1wiLCB2YWx1ZV80MDIpO1xuICB9XG4gIGlzQnJhY2tldHModmFsdWVfNDAzKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJicmFja2V0c1wiLCB2YWx1ZV80MDMpO1xuICB9XG4gIGlzU3ludGF4VGVtcGxhdGUodmFsdWVfNDA0KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goXCJzeW50YXhUZW1wbGF0ZVwiLCB2YWx1ZV80MDQpO1xuICB9XG4gIGlzRU9GKHZhbHVlXzQwNSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKFwiZW9mXCIsIHZhbHVlXzQwNSk7XG4gIH1cbiAgbGluZU51bWJlcigpIHtcbiAgICByZXR1cm4gZ2V0TGluZU51bWJlcl8zNzkodGhpc1tzeW1XcmFwXzM3N10pO1xuICB9XG4gIHZhbCgpIHtcbiAgICByZXR1cm4gZ2V0VmFsXzM4MCh0aGlzW3N5bVdyYXBfMzc3XSk7XG4gIH1cbiAgaW5uZXIoKSB7XG4gICAgbGV0IHN0eF80MDYgPSB0aGlzW3N5bVdyYXBfMzc3XTtcbiAgICBpZiAoIXN0eF80MDYubWF0Y2goXCJkZWxpbWl0ZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGdldCBpbm5lciBzeW50YXggb24gYSBkZWxpbWl0ZXJcIik7XG4gICAgfVxuICAgIGxldCBlbmZfNDA3ID0gbmV3IEVuZm9yZXN0ZXIoc3R4XzQwNi5pbm5lcigpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgcmV0dXJuIG5ldyBNYWNyb0NvbnRleHQoZW5mXzQwNywgXCJpbm5lclwiLCB0aGlzLmNvbnRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB1bndyYXBfMzgyKHhfNDA4KSB7XG4gIGlmICh4XzQwOCBpbnN0YW5jZW9mIFN5bnRheE9yVGVybVdyYXBwZXJfMzgxKSB7XG4gICAgcmV0dXJuIHhfNDA4W3N5bVdyYXBfMzc3XTtcbiAgfVxuICByZXR1cm4geF80MDg7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWNyb0NvbnRleHQge1xuICBjb25zdHJ1Y3RvcihlbmZfNDA5LCBuYW1lXzQxMCwgY29udGV4dF80MTEsIHVzZVNjb3BlXzQxMiwgaW50cm9kdWNlZFNjb3BlXzQxMykge1xuICAgIHRoaXMuX2VuZiA9IGVuZl80MDk7XG4gICAgdGhpc1tzeW1OYW1lXzM3OF0gPSBuYW1lXzQxMDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XzQxMTtcbiAgICBpZiAodXNlU2NvcGVfNDEyICYmIGludHJvZHVjZWRTY29wZV80MTMpIHtcbiAgICAgIHRoaXMubm9TY29wZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMudXNlU2NvcGUgPSB1c2VTY29wZV80MTI7XG4gICAgICB0aGlzLmludHJvZHVjZWRTY29wZSA9IGludHJvZHVjZWRTY29wZV80MTM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9TY29wZXMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSAoKSA9PiB0aGlzO1xuICB9XG4gIG5hbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXhPclRlcm1XcmFwcGVyXzM4MSh0aGlzW3N5bU5hbWVfMzc4XSwgdGhpcy5jb250ZXh0KTtcbiAgfVxuICBuZXh0KHR5cGVfNDE0ID0gXCJTeW50YXhcIikge1xuICAgIGlmICh0aGlzLl9lbmYucmVzdC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IHRydWUsIHZhbHVlOiBudWxsfTtcbiAgICB9XG4gICAgbGV0IHZhbHVlXzQxNTtcbiAgICBzd2l0Y2ggKHR5cGVfNDE0KSB7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgIHZhbHVlXzQxNSA9IHRoaXMuX2VuZi5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkV4cHJlc3Npb25cIjpcbiAgICAgICAgdmFsdWVfNDE1ID0gdGhpcy5fZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTeW50YXhcIjpcbiAgICAgICAgdmFsdWVfNDE1ID0gdGhpcy5fZW5mLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLm5vU2NvcGVzKSB7XG4gICAgICAgICAgdmFsdWVfNDE1ID0gdmFsdWVfNDE1LmFkZFNjb3BlKHRoaXMudXNlU2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUykuYWRkU2NvcGUodGhpcy5pbnRyb2R1Y2VkU2NvcGUsIHRoaXMuY29udGV4dC5iaW5kaW5ncywgQUxMX1BIQVNFUywge2ZsaXA6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGVybSB0eXBlOiBcIiArIHR5cGVfNDE0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtkb25lOiBmYWxzZSwgdmFsdWU6IG5ldyBTeW50YXhPclRlcm1XcmFwcGVyXzM4MSh2YWx1ZV80MTUsIHRoaXMuY29udGV4dCl9O1xuICB9XG59XG5leHBvcnQge1N5bnRheE9yVGVybVdyYXBwZXJfMzgxIGFzIFN5bnRheE9yVGVybVdyYXBwZXJ9O1xuZXhwb3J0IHt1bndyYXBfMzgyIGFzIHVud3JhcH0iXX0=

	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _shiftReducer = __webpack_require__(30);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class MapSyntaxReducer extends _shiftReducer.CloneReducer {
		  constructor(fn_416) {
		    super();
		    this.fn = fn_416;
		  }
		  reduceBindingIdentifier(node_417, state_418) {
		    let name_419 = this.fn(node_417.name);
		    return new _terms2.default("BindingIdentifier", { name: name_419 });
		  }
		  reduceIdentifierExpression(node_420, state_421) {
		    let name_422 = this.fn(node_420.name);
		    return new _terms2.default("IdentifierExpression", { name: name_422 });
		  }
		}
		exports.default = MapSyntaxReducer;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L21hcC1zeW50YXgtcmVkdWNlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ2UsTUFBTSxnQkFBTixvQ0FBNEM7QUFDekQsY0FBWSxNQUFaLEVBQW9CO0FBQ2xCO0FBQ0EsU0FBSyxFQUFMLEdBQVUsTUFBVjtBQUNEO0FBQ0QsMEJBQXdCLFFBQXhCLEVBQWtDLFNBQWxDLEVBQTZDO0FBQzNDLFFBQUksV0FBVyxLQUFLLEVBQUwsQ0FBUSxTQUFTLElBQWpCLENBQWY7QUFDQSxXQUFPLG9CQUFTLG1CQUFULEVBQThCLEVBQUMsTUFBTSxRQUFQLEVBQTlCLENBQVA7QUFDRDtBQUNELDZCQUEyQixRQUEzQixFQUFxQyxTQUFyQyxFQUFnRDtBQUM5QyxRQUFJLFdBQVcsS0FBSyxFQUFMLENBQVEsU0FBUyxJQUFqQixDQUFmO0FBQ0EsV0FBTyxvQkFBUyxzQkFBVCxFQUFpQyxFQUFDLE1BQU0sUUFBUCxFQUFqQyxDQUFQO0FBQ0Q7QUFad0Q7a0JBQXRDLGdCIiwiZmlsZSI6Im1hcC1zeW50YXgtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtIGZyb20gXCIuL3Rlcm1zXCI7XG5pbXBvcnQge0Nsb25lUmVkdWNlcn0gZnJvbSBcInNoaWZ0LXJlZHVjZXJcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcFN5bnRheFJlZHVjZXIgZXh0ZW5kcyBDbG9uZVJlZHVjZXIge1xuICBjb25zdHJ1Y3Rvcihmbl80MTYpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm4gPSBmbl80MTY7XG4gIH1cbiAgcmVkdWNlQmluZGluZ0lkZW50aWZpZXIobm9kZV80MTcsIHN0YXRlXzQxOCkge1xuICAgIGxldCBuYW1lXzQxOSA9IHRoaXMuZm4obm9kZV80MTcubmFtZSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiQmluZGluZ0lkZW50aWZpZXJcIiwge25hbWU6IG5hbWVfNDE5fSk7XG4gIH1cbiAgcmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24obm9kZV80MjAsIHN0YXRlXzQyMSkge1xuICAgIGxldCBuYW1lXzQyMiA9IHRoaXMuZm4obm9kZV80MjAubmFtZSk7XG4gICAgcmV0dXJuIG5ldyBUZXJtKFwiSWRlbnRpZmllckV4cHJlc3Npb25cIiwge25hbWU6IG5hbWVfNDIyfSk7XG4gIH1cbn1cbiJdfQ==

	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.collectBindings = exports.CollectBindingSyntax = undefined;

		var _symbol = __webpack_require__(42);

		var _transforms = __webpack_require__(29);

		var _errors = __webpack_require__(11);

		var _terms = __webpack_require__(26);

		var _terms2 = _interopRequireDefault(_terms);

		var _immutable = __webpack_require__(9);

		var _astDispatcher = __webpack_require__(61);

		var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

		var _ramda = __webpack_require__(25);

		var _ = _interopRequireWildcard(_ramda);

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		class CollectBindingSyntax_325 extends _astDispatcher2.default {
		  constructor() {
		    super("collect", true);
		    this.names = (0, _immutable.List)();
		  }
		  collect(term_327) {
		    return this.dispatch(term_327);
		  }
		  collectBindingIdentifier(term_328) {
		    return this.names.concat(term_328.name);
		  }
		  collectBindingPropertyIdentifier(term_329) {
		    return this.collect(term_329.binding);
		  }
		  collectBindingPropertyProperty(term_330) {
		    return this.collect(term_330.binding);
		  }
		  collectArrayBinding(term_331) {
		    let restElement_332 = null;
		    if (term_331.restElement != null) {
		      restElement_332 = this.collect(term_331.restElement);
		    }
		    return this.names.concat(restElement_332).concat(term_331.elements.filter(el_333 => el_333 != null).flatMap(el_334 => this.collect(el_334)));
		  }
		  collectObjectBinding(term_335) {
		    return (0, _immutable.List)();
		  }
		}
		function collectBindings_326(term_336) {
		  return new CollectBindingSyntax_325().collect(term_336);
		}
		exports.CollectBindingSyntax = CollectBindingSyntax_325;
		exports.collectBindings = collectBindings_326;
		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3N3ZWV0L2h5Z2llbmUtdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBYSxDOzs7Ozs7QUFDYixNQUFNLHdCQUFOLGlDQUFxRDtBQUNuRCxnQkFBYztBQUNaLFVBQU0sU0FBTixFQUFpQixJQUFqQjtBQUNBLFNBQUssS0FBTCxHQUFhLHNCQUFiO0FBQ0Q7QUFDRCxVQUFRLFFBQVIsRUFBa0I7QUFDaEIsV0FBTyxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQVA7QUFDRDtBQUNELDJCQUF5QixRQUF6QixFQUFtQztBQUNqQyxXQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsU0FBUyxJQUEzQixDQUFQO0FBQ0Q7QUFDRCxtQ0FBaUMsUUFBakMsRUFBMkM7QUFDekMsV0FBTyxLQUFLLE9BQUwsQ0FBYSxTQUFTLE9BQXRCLENBQVA7QUFDRDtBQUNELGlDQUErQixRQUEvQixFQUF5QztBQUN2QyxXQUFPLEtBQUssT0FBTCxDQUFhLFNBQVMsT0FBdEIsQ0FBUDtBQUNEO0FBQ0Qsc0JBQW9CLFFBQXBCLEVBQThCO0FBQzVCLFFBQUksa0JBQWtCLElBQXRCO0FBQ0EsUUFBSSxTQUFTLFdBQVQsSUFBd0IsSUFBNUIsRUFBa0M7QUFDaEMsd0JBQWtCLEtBQUssT0FBTCxDQUFhLFNBQVMsV0FBdEIsQ0FBbEI7QUFDRDtBQUNELFdBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixlQUFsQixFQUFtQyxNQUFuQyxDQUEwQyxTQUFTLFFBQVQsQ0FBa0IsTUFBbEIsQ0FBeUIsVUFBVSxVQUFVLElBQTdDLEVBQW1ELE9BQW5ELENBQTJELFVBQVUsS0FBSyxPQUFMLENBQWEsTUFBYixDQUFyRSxDQUExQyxDQUFQO0FBQ0Q7QUFDRCx1QkFBcUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBTyxzQkFBUDtBQUNEO0FBMUJrRDtBQTRCckQsU0FBUyxtQkFBVCxDQUE2QixRQUE3QixFQUF1QztBQUNyQyxTQUFRLElBQUksd0JBQUosRUFBRCxDQUErQixPQUEvQixDQUF1QyxRQUF2QyxDQUFQO0FBQ0Q7UUFDbUMsb0IsR0FBNUIsd0I7UUFDdUIsZSxHQUF2QixtQiIsImZpbGUiOiJoeWdpZW5lLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZW5zeW19IGZyb20gXCIuL3N5bWJvbFwiO1xuaW1wb3J0IHtWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3Jtc1wiO1xuaW1wb3J0IHtleHBlY3QsIGFzc2VydH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgVGVybSwge2lzRU9GLCBpc0JpbmRpbmdJZGVudGlmaWVyLCBpc0JpbmRpbmdQcm9wZXJ0eVByb3BlcnR5LCBpc0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIsIGlzT2JqZWN0QmluZGluZywgaXNBcnJheUJpbmRpbmcsIGlzRnVuY3Rpb25EZWNsYXJhdGlvbiwgaXNGdW5jdGlvbkV4cHJlc3Npb24sIGlzRnVuY3Rpb25UZXJtLCBpc0Z1bmN0aW9uV2l0aE5hbWUsIGlzU3ludGF4RGVjbGFyYXRpb24sIGlzU3ludGF4cmVjRGVjbGFyYXRpb24sIGlzVmFyaWFibGVEZWNsYXJhdGlvbiwgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50LCBpc0ltcG9ydCwgaXNFeHBvcnQsIGlzUHJhZ21hLCBpc0V4cG9ydFN5bnRheH0gZnJvbSBcIi4vdGVybXNcIjtcbmltcG9ydCB7TGlzdH0gZnJvbSBcImltbXV0YWJsZVwiO1xuaW1wb3J0IEFTVERpc3BhdGNoZXIgZnJvbSBcIi4vYXN0LWRpc3BhdGNoZXJcIjtcbmltcG9ydCAgKiBhcyBfIGZyb20gXCJyYW1kYVwiO1xuY2xhc3MgQ29sbGVjdEJpbmRpbmdTeW50YXhfMzI1IGV4dGVuZHMgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiY29sbGVjdFwiLCB0cnVlKTtcbiAgICB0aGlzLm5hbWVzID0gTGlzdCgpO1xuICB9XG4gIGNvbGxlY3QodGVybV8zMjcpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0ZXJtXzMyNyk7XG4gIH1cbiAgY29sbGVjdEJpbmRpbmdJZGVudGlmaWVyKHRlcm1fMzI4KSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuY29uY2F0KHRlcm1fMzI4Lm5hbWUpO1xuICB9XG4gIGNvbGxlY3RCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyKHRlcm1fMzI5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCh0ZXJtXzMyOS5iaW5kaW5nKTtcbiAgfVxuICBjb2xsZWN0QmluZGluZ1Byb3BlcnR5UHJvcGVydHkodGVybV8zMzApIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KHRlcm1fMzMwLmJpbmRpbmcpO1xuICB9XG4gIGNvbGxlY3RBcnJheUJpbmRpbmcodGVybV8zMzEpIHtcbiAgICBsZXQgcmVzdEVsZW1lbnRfMzMyID0gbnVsbDtcbiAgICBpZiAodGVybV8zMzEucmVzdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgcmVzdEVsZW1lbnRfMzMyID0gdGhpcy5jb2xsZWN0KHRlcm1fMzMxLnJlc3RFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuY29uY2F0KHJlc3RFbGVtZW50XzMzMikuY29uY2F0KHRlcm1fMzMxLmVsZW1lbnRzLmZpbHRlcihlbF8zMzMgPT4gZWxfMzMzICE9IG51bGwpLmZsYXRNYXAoZWxfMzM0ID0+IHRoaXMuY29sbGVjdChlbF8zMzQpKSk7XG4gIH1cbiAgY29sbGVjdE9iamVjdEJpbmRpbmcodGVybV8zMzUpIHtcbiAgICByZXR1cm4gTGlzdCgpO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0QmluZGluZ3NfMzI2KHRlcm1fMzM2KSB7XG4gIHJldHVybiAobmV3IENvbGxlY3RCaW5kaW5nU3ludGF4XzMyNSkuY29sbGVjdCh0ZXJtXzMzNik7XG59XG5leHBvcnQge0NvbGxlY3RCaW5kaW5nU3ludGF4XzMyNSBhcyBDb2xsZWN0QmluZGluZ1N5bnRheH07XG5leHBvcnQge2NvbGxlY3RCaW5kaW5nc18zMjYgYXMgY29sbGVjdEJpbmRpbmdzfSJdfQ==

	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		// MODULES //

		var isString = __webpack_require__( 66 ),
			re = __webpack_require__( 67 );


		// DIRNAME //

		/**
		* FUNCTION: dirname( path )
		*	Returns a path dirname.
		*
		* @param {String} path - path
		* @returns {String} directory name
		*/
		function dirname( path ) {
			if ( !isString( path ) ) {
				throw new TypeError( 'invalid input argument. Path must be a primitive string. Value: `' + path + '`.' );
			}
			return re.exec( path )[ 1 ];
		} // end FUNCTION dirname()


		// EXPORTS //

		module.exports = dirname;


	/***/ },
	/* 66 */
	/***/ function(module, exports) {

		/**
		*
		*	VALIDATE: string-primitive
		*
		*
		*	DESCRIPTION:
		*		- Validates if a value is a string primitive.
		*
		*
		*	NOTES:
		*		[1]
		*
		*
		*	TODO:
		*		[1]
		*
		*
		*	LICENSE:
		*		MIT
		*
		*	Copyright (c) 2015. Athan Reines.
		*
		*
		*	AUTHOR:
		*		Athan Reines. kgryte@gmail.com. 2015.
		*
		*/

		'use strict';

		/**
		* FUNCTION: isString( value )
		*	Validates if a value is a string primitive.
		*
		* @param {*} value - value to be validated
		* @returns {Boolean} boolean indicating if a value is a string primitive
		*/
		function isString( value ) {
			return typeof value === 'string';
		} // end FUNCTION isString()


		// EXPORTS //

		module.exports = isString;


	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		// MODULES //

		var isWindows = __webpack_require__( 68 );


		// REGEX //

		var posix,
			win32,
			re;

		posix = __webpack_require__( 71 );
		win32 = __webpack_require__( 72 );

		if ( isWindows ) {
			re = win32;
		} else {
			re = posix;
		}


		// EXPORTS //

		module.exports = re;
		module.exports.posix = posix;
		module.exports.win32 = win32;


	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		// MODULES //

		var platform = __webpack_require__( 69 );


		// EXPORTS //

		module.exports = ( platform === 'win32' );


	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {'use strict';

		// EXPORTS //

		module.exports = process.platform;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)))

	/***/ },
	/* 70 */
	/***/ function(module, exports) {

		// shim for using process in browser

		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}

		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = setTimeout(cleanUpNextTick);
		    draining = true;

		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    clearTimeout(timeout);
		}

		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        setTimeout(drainQueue, 0);
		    }
		};

		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};

		function noop() {}

		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;

		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};

		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };


	/***/ },
	/* 71 */
	/***/ function(module, exports) {

		'use strict';

		/**
		* REGEX: /^((?:\.(?![^\/]))|(?:(?:\/?|)(?:[\s\S]*?)))(?:\/+?|)(?:(?:\.{1,2}|[^\/]+?|)(?:\.[^.\/]*|))(?:[\/]*)$/
		*	Captures a POSIX path dirname. Modified from Node.js [source]{@link https://github.com/nodejs/node/blob/1a3b295d0f46b2189bd853800b1e63ab4d106b66/lib/path.js#L406}.
		*
		*	\^
		*		-	match any string which begins with
		*	()
		*		-	capture (includes root and dirname)
		*	(?:)
		*		-	capture but do not remember (handles '.' and './' cases)
		*	\.(?![^\/])
		*		-	a . literal if the . literal is NOT followed by something other than a / literal
		*	|
		*		-	OR
		*	(?:)
		*		-	capture but do not remember (handles root+dirname case)
		*	(?:)
		*		-	capture but do not remember (root)
		*	\/?
		*		-	match a / literal 0 or 1 time
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (directory)
		*	[\s\S]
		*		-	any space or non-space character
		*	*?
		*		-	zero or more times, but non-greedily (shortest possible match)
		*	(?:)
		*		-	capture but do not remember (slash)
		*	\/+?
		*		-	a / literal 1 or more times, but do so non-greedily
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (basename)
		*	\.{1,2}
		*		-	match a . literal 1 or 2 times
		*	|
		*		-	OR
		*	[^\/]+?
		*		-	match anything which is not a / literal 1 or more times, but do so non-greedily
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (extname)
		*	\.
		*		-	match a . literal
		*	[^.\/]
		*		-	match anything which is not a . or / literal
		*	*
		*		-	zero or more times
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (trailing slash)
		*	[\/]
		*		-	match a / literal
		*	*
		*		-	zero or more times
		*	$
		*		-	end of string
		*/
		var re = /^((?:\.(?![^\/]))|(?:(?:\/?|)(?:[\s\S]*?)))(?:\/+?|)(?:(?:\.{1,2}|[^\/]+?|)(?:\.[^.\/]*|))(?:[\/]*)$/;


		// EXPORTS //

		module.exports = re;


	/***/ },
	/* 72 */
	/***/ function(module, exports) {

		'use strict';

		/**
		* REGEX: /^((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+|)(?:[\\\/]|)(?:[\s\S]*?))(?:[\\\/]+?|)(?:(?:\.{1,2}|[^\\\/]+?|)(?:\.[^.\/\\]*|))(?:[\\\/]*)$/
		*	Capture a Windows path dirname. Modified from Node.js [source]{@link https://github.com/nodejs/node/blob/1a3b295d0f46b2189bd853800b1e63ab4d106b66/lib/path.js#L65}.
		*
		*	^
		*		-	match any string which begins with
		*	()
		*		-	capture (includes the device, slash, and dirname)
		*	(?:)
		*		-	capture but do not remember (device)
		*	[a-zA-Z]:
		*		-	match any upper or lowercase letter and a : literal
		*	|
		*		-	OR
		*	[\\\/]
		*		-	match a \ or / literal character
		*	{2}
		*		-	exactly 2 times
		*	[^\\\/]+
		*		-	match anything but a \ or / literal one or more times
		*	[\\\/]+
		*		-	match a \ or / literal one or more times
		*	[^\\\/]+
		*		-	match anything but a \ or / literal one or more times
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (slash)
		*	[\\\/]
		*		-	match a \ or / literal
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (dirname)
		*	[\s\S]
		*		-	match any space or non-space character
		*	*?
		*		-	zero or more times but do so non-greedily
		*	(?:)
		*		-	capture but do not remember (slash before basename)
		*	[\\\/]+?
		*		-	match a \ or / literal one or more times, but do so non-greedily
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (basename)
		*	(?:)
		*		-	capture but do not remember
		*	\.{1,2}
		*		-	match a . literal one or two times
		*	|
		*		-	OR
		*	[^\\\/]+?
		*		-	match anything but a \ or / literal one or more times, but do so non-greedily
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (extname)
		*	\.
		*		-	match a . literal
		*	[^.\/\\]*
		*		-	match anything but a ., /, or \ literal zero or more times
		*	|)
		*		-	OR capture nothing
		*	(?:)
		*		-	capture but do not remember (trailing slash)
		*	[\\\/]*
		*		-	match a \ or / literal zero or more times
		*	$
		*		-	end of string
		*/
		var re = /^((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+|)(?:[\\\/]|)(?:[\s\S]*?))(?:[\\\/]+?|)(?:(?:\.{1,2}|[^\\\/]+?|)(?:\.[^.\/\\]*|))(?:[\\\/]*)$/;


		// EXPORTS //

		module.exports = re;


	/***/ }
	/******/ ])}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));;

/***/ }
/******/ ])});;